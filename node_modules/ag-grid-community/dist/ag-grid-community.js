(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["agGrid"] = factory();
	else
		root["agGrid"] = factory();
})(self, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 52974:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(36758);
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40935);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20062);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(82487), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_1___ = new URL(/* asset import */ __webpack_require__(31244), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_2___ = new URL(/* asset import */ __webpack_require__(50542), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_3___ = new URL(/* asset import */ __webpack_require__(18791), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
var ___CSS_LOADER_URL_REPLACEMENT_1___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_1___);
var ___CSS_LOADER_URL_REPLACEMENT_2___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_2___);
var ___CSS_LOADER_URL_REPLACEMENT_3___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_3___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".ag-filter-panel-buttons {\n  display: flex;\n  justify-content: flex-end;\n  overflow: hidden;\n  padding: var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding) 0;\n  flex-wrap: wrap;\n  gap: var(--ag-widget-vertical-spacing) var(--ag-widget-horizontal-spacing);\n}\n\n.ag-filter-panel-buttons-button {\n  line-height: 1.5;\n}\n\n.ag-filter-panel .ag-standard-button.ag-filter-panel-buttons-apply-button {\n  color: var(--ag-filter-panel-apply-button-color);\n  background-color: var(--ag-filter-panel-apply-button-background-color);\n}\n\n.ag-filter-panel > *:where(:last-child) {\n  padding-bottom: var(--ag-widget-container-vertical-padding);\n}\n\n.ag-row.ag-row-pinned-source {\n  color: var(--ag-pinned-source-row-text-color);\n  background-color: var(--ag-pinned-source-row-background-color);\n  font-weight: var(--ag-pinned-source-row-font-weight);\n}\n\n.ag-row.ag-row-pinned {\n  color: var(--ag-pinned-row-text-color);\n  background-color: var(--ag-pinned-row-background-color);\n  font-weight: var(--ag-pinned-row-font-weight);\n}\n\n.ag-floating-top-viewport {\n  border-bottom: var(--ag-pinned-row-border);\n}\n\n.ag-floating-bottom-viewport {\n  border-top: var(--ag-pinned-row-border);\n}\n\n.ag-measurement-container {\n  --ag-legacy-styles-loaded: \"true\";\n}\n\n.ag-icon {\n  font-family: var(--ag-icon-font-family);\n  font-weight: var(--ag-icon-font-weight);\n  color: var(--ag-icon-font-color);\n  font-size: var(--ag-icon-size);\n  line-height: var(--ag-icon-size);\n  font-style: normal;\n  font-variant: normal;\n  text-transform: none;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  width: var(--ag-icon-size);\n  height: var(--ag-icon-size);\n  position: relative;\n}\n.ag-icon::before {\n  content: \"\";\n  font-family: inherit;\n}\n.ag-icon::after {\n  background: transparent var(--ag-icon-image, none) center/contain no-repeat;\n  display: var(--ag-icon-image-display);\n  opacity: var(--ag-icon-image-opacity, 0.9);\n  position: absolute;\n  inset: 0;\n  content: \"\";\n}\n\n.ag-icon-aggregation {\n  font-family: var(--ag-icon-font-family-aggregation, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-aggregation, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-aggregation, var(--ag-icon-font-color));\n}\n\n.ag-icon-aggregation::before {\n  content: var(--ag-icon-font-code-aggregation, \"\\f101\");\n  display: var(--ag-icon-font-display-aggregation, var(--ag-icon-font-display));\n}\n\n.ag-icon-aggregation::after {\n  background-image: var(--ag-icon-image-aggregation, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-aggregation, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-aggregation, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-arrows {\n  font-family: var(--ag-icon-font-family-arrows, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-arrows, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-arrows, var(--ag-icon-font-color));\n}\n\n.ag-icon-arrows::before {\n  content: var(--ag-icon-font-code-arrows, \"\\f102\");\n  display: var(--ag-icon-font-display-arrows, var(--ag-icon-font-display));\n}\n\n.ag-icon-arrows::after {\n  background-image: var(--ag-icon-image-arrows, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-arrows, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-arrows, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-asc {\n  font-family: var(--ag-icon-font-family-asc, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-asc, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-asc, var(--ag-icon-font-color));\n}\n\n.ag-icon-asc::before {\n  content: var(--ag-icon-font-code-asc, \"\\f103\");\n  display: var(--ag-icon-font-display-asc, var(--ag-icon-font-display));\n}\n\n.ag-icon-asc::after {\n  background-image: var(--ag-icon-image-asc, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-asc, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-asc, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-cancel {\n  font-family: var(--ag-icon-font-family-cancel, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-cancel, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-cancel, var(--ag-icon-font-color));\n}\n\n.ag-icon-cancel::before {\n  content: var(--ag-icon-font-code-cancel, \"\\f104\");\n  display: var(--ag-icon-font-display-cancel, var(--ag-icon-font-display));\n}\n\n.ag-icon-cancel::after {\n  background-image: var(--ag-icon-image-cancel, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-cancel, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-cancel, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-chart {\n  font-family: var(--ag-icon-font-family-chart, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-chart, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-chart, var(--ag-icon-font-color));\n}\n\n.ag-icon-chart::before {\n  content: var(--ag-icon-font-code-chart, \"\\f105\");\n  display: var(--ag-icon-font-display-chart, var(--ag-icon-font-display));\n}\n\n.ag-icon-chart::after {\n  background-image: var(--ag-icon-image-chart, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-chart, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-chart, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-checkbox-checked {\n  font-family: var(--ag-icon-font-family-checkbox-checked, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-checkbox-checked, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-checkbox-checked, var(--ag-icon-font-color));\n}\n\n.ag-icon-checkbox-checked::before {\n  content: var(--ag-icon-font-code-checkbox-checked, \"\\f106\");\n  display: var(--ag-icon-font-display-checkbox-checked, var(--ag-icon-font-display));\n}\n\n.ag-icon-checkbox-checked::after {\n  background-image: var(--ag-icon-image-checkbox-checked, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-checkbox-checked, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-checkbox-checked, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-checkbox-indeterminate {\n  font-family: var(--ag-icon-font-family-checkbox-indeterminate, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-checkbox-indeterminate, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-checkbox-indeterminate, var(--ag-icon-font-color));\n}\n\n.ag-icon-checkbox-indeterminate::before {\n  content: var(--ag-icon-font-code-checkbox-indeterminate, \"\\f107\");\n  display: var(--ag-icon-font-display-checkbox-indeterminate, var(--ag-icon-font-display));\n}\n\n.ag-icon-checkbox-indeterminate::after {\n  background-image: var(--ag-icon-image-checkbox-indeterminate, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-checkbox-indeterminate, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-checkbox-indeterminate, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-checkbox-unchecked {\n  font-family: var(--ag-icon-font-family-checkbox-unchecked, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-checkbox-unchecked, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-checkbox-unchecked, var(--ag-icon-font-color));\n}\n\n.ag-icon-checkbox-unchecked::before {\n  content: var(--ag-icon-font-code-checkbox-unchecked, \"\\f108\");\n  display: var(--ag-icon-font-display-checkbox-unchecked, var(--ag-icon-font-display));\n}\n\n.ag-icon-checkbox-unchecked::after {\n  background-image: var(--ag-icon-image-checkbox-unchecked, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-checkbox-unchecked, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-checkbox-unchecked, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-color-picker {\n  font-family: var(--ag-icon-font-family-color-picker, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-color-picker, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-color-picker, var(--ag-icon-font-color));\n}\n\n.ag-icon-color-picker::before {\n  content: var(--ag-icon-font-code-color-picker, \"\\f109\");\n  display: var(--ag-icon-font-display-color-picker, var(--ag-icon-font-display));\n}\n\n.ag-icon-color-picker::after {\n  background-image: var(--ag-icon-image-color-picker, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-color-picker, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-color-picker, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-columns {\n  font-family: var(--ag-icon-font-family-columns, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-columns, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-columns, var(--ag-icon-font-color));\n}\n\n.ag-icon-columns::before {\n  content: var(--ag-icon-font-code-columns, \"\\f10a\");\n  display: var(--ag-icon-font-display-columns, var(--ag-icon-font-display));\n}\n\n.ag-icon-columns::after {\n  background-image: var(--ag-icon-image-columns, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-columns, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-columns, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-contracted {\n  font-family: var(--ag-icon-font-family-contracted, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-contracted, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-contracted, var(--ag-icon-font-color));\n}\n\n.ag-icon-contracted::before {\n  content: var(--ag-icon-font-code-contracted, \"\\f10b\");\n  display: var(--ag-icon-font-display-contracted, var(--ag-icon-font-display));\n}\n\n.ag-icon-contracted::after {\n  background-image: var(--ag-icon-image-contracted, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-contracted, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-contracted, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-copy {\n  font-family: var(--ag-icon-font-family-copy, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-copy, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-copy, var(--ag-icon-font-color));\n}\n\n.ag-icon-copy::before {\n  content: var(--ag-icon-font-code-copy, \"\\f10c\");\n  display: var(--ag-icon-font-display-copy, var(--ag-icon-font-display));\n}\n\n.ag-icon-copy::after {\n  background-image: var(--ag-icon-image-copy, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-copy, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-copy, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-cross {\n  font-family: var(--ag-icon-font-family-cross, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-cross, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-cross, var(--ag-icon-font-color));\n}\n\n.ag-icon-cross::before {\n  content: var(--ag-icon-font-code-cross, \"\\f10d\");\n  display: var(--ag-icon-font-display-cross, var(--ag-icon-font-display));\n}\n\n.ag-icon-cross::after {\n  background-image: var(--ag-icon-image-cross, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-cross, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-cross, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-csv {\n  font-family: var(--ag-icon-font-family-csv, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-csv, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-csv, var(--ag-icon-font-color));\n}\n\n.ag-icon-csv::before {\n  content: var(--ag-icon-font-code-csv, \"\\f10e\");\n  display: var(--ag-icon-font-display-csv, var(--ag-icon-font-display));\n}\n\n.ag-icon-csv::after {\n  background-image: var(--ag-icon-image-csv, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-csv, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-csv, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-cut {\n  font-family: var(--ag-icon-font-family-cut, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-cut, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-cut, var(--ag-icon-font-color));\n}\n\n.ag-icon-cut::before {\n  content: var(--ag-icon-font-code-cut, \"\\f10f\");\n  display: var(--ag-icon-font-display-cut, var(--ag-icon-font-display));\n}\n\n.ag-icon-cut::after {\n  background-image: var(--ag-icon-image-cut, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-cut, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-cut, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-desc {\n  font-family: var(--ag-icon-font-family-desc, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-desc, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-desc, var(--ag-icon-font-color));\n}\n\n.ag-icon-desc::before {\n  content: var(--ag-icon-font-code-desc, \"\\f110\");\n  display: var(--ag-icon-font-display-desc, var(--ag-icon-font-display));\n}\n\n.ag-icon-desc::after {\n  background-image: var(--ag-icon-image-desc, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-desc, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-desc, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-excel {\n  font-family: var(--ag-icon-font-family-excel, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-excel, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-excel, var(--ag-icon-font-color));\n}\n\n.ag-icon-excel::before {\n  content: var(--ag-icon-font-code-excel, \"\\f111\");\n  display: var(--ag-icon-font-display-excel, var(--ag-icon-font-display));\n}\n\n.ag-icon-excel::after {\n  background-image: var(--ag-icon-image-excel, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-excel, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-excel, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-expanded {\n  font-family: var(--ag-icon-font-family-expanded, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-expanded, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-expanded, var(--ag-icon-font-color));\n}\n\n.ag-icon-expanded::before {\n  content: var(--ag-icon-font-code-expanded, \"\\f112\");\n  display: var(--ag-icon-font-display-expanded, var(--ag-icon-font-display));\n}\n\n.ag-icon-expanded::after {\n  background-image: var(--ag-icon-image-expanded, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-expanded, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-expanded, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-eye-slash {\n  font-family: var(--ag-icon-font-family-eye-slash, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-eye-slash, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-eye-slash, var(--ag-icon-font-color));\n}\n\n.ag-icon-eye-slash::before {\n  content: var(--ag-icon-font-code-eye-slash, \"\\f113\");\n  display: var(--ag-icon-font-display-eye-slash, var(--ag-icon-font-display));\n}\n\n.ag-icon-eye-slash::after {\n  background-image: var(--ag-icon-image-eye-slash, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-eye-slash, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-eye-slash, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-eye {\n  font-family: var(--ag-icon-font-family-eye, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-eye, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-eye, var(--ag-icon-font-color));\n}\n\n.ag-icon-eye::before {\n  content: var(--ag-icon-font-code-eye, \"\\f114\");\n  display: var(--ag-icon-font-display-eye, var(--ag-icon-font-display));\n}\n\n.ag-icon-eye::after {\n  background-image: var(--ag-icon-image-eye, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-eye, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-eye, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-filter {\n  font-family: var(--ag-icon-font-family-filter, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-filter, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-filter, var(--ag-icon-font-color));\n}\n\n.ag-icon-filter::before {\n  content: var(--ag-icon-font-code-filter, \"\\f115\");\n  display: var(--ag-icon-font-display-filter, var(--ag-icon-font-display));\n}\n\n.ag-icon-filter::after {\n  background-image: var(--ag-icon-image-filter, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-filter, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-filter, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-first {\n  font-family: var(--ag-icon-font-family-first, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-first, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-first, var(--ag-icon-font-color));\n}\n\n.ag-icon-first::before {\n  content: var(--ag-icon-font-code-first, \"\\f116\");\n  display: var(--ag-icon-font-display-first, var(--ag-icon-font-display));\n}\n\n.ag-icon-first::after {\n  background-image: var(--ag-icon-image-first, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-first, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-first, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-grip {\n  font-family: var(--ag-icon-font-family-grip, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-grip, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-grip, var(--ag-icon-font-color));\n}\n\n.ag-icon-grip::before {\n  content: var(--ag-icon-font-code-grip, \"\\f117\");\n  display: var(--ag-icon-font-display-grip, var(--ag-icon-font-display));\n}\n\n.ag-icon-grip::after {\n  background-image: var(--ag-icon-image-grip, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-grip, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-grip, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-group {\n  font-family: var(--ag-icon-font-family-group, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-group, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-group, var(--ag-icon-font-color));\n}\n\n.ag-icon-group::before {\n  content: var(--ag-icon-font-code-group, \"\\f118\");\n  display: var(--ag-icon-font-display-group, var(--ag-icon-font-display));\n}\n\n.ag-icon-group::after {\n  background-image: var(--ag-icon-image-group, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-group, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-group, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-last {\n  font-family: var(--ag-icon-font-family-last, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-last, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-last, var(--ag-icon-font-color));\n}\n\n.ag-icon-last::before {\n  content: var(--ag-icon-font-code-last, \"\\f119\");\n  display: var(--ag-icon-font-display-last, var(--ag-icon-font-display));\n}\n\n.ag-icon-last::after {\n  background-image: var(--ag-icon-image-last, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-last, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-last, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-left {\n  font-family: var(--ag-icon-font-family-left, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-left, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-left, var(--ag-icon-font-color));\n}\n\n.ag-icon-left::before {\n  content: var(--ag-icon-font-code-left, \"\\f11a\");\n  display: var(--ag-icon-font-display-left, var(--ag-icon-font-display));\n}\n\n.ag-icon-left::after {\n  background-image: var(--ag-icon-image-left, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-left, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-left, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-linked {\n  font-family: var(--ag-icon-font-family-linked, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-linked, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-linked, var(--ag-icon-font-color));\n}\n\n.ag-icon-linked::before {\n  content: var(--ag-icon-font-code-linked, \"\\f11b\");\n  display: var(--ag-icon-font-display-linked, var(--ag-icon-font-display));\n}\n\n.ag-icon-linked::after {\n  background-image: var(--ag-icon-image-linked, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-linked, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-linked, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-loading {\n  font-family: var(--ag-icon-font-family-loading, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-loading, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-loading, var(--ag-icon-font-color));\n}\n\n.ag-icon-loading::before {\n  content: var(--ag-icon-font-code-loading, \"\\f11c\");\n  display: var(--ag-icon-font-display-loading, var(--ag-icon-font-display));\n}\n\n.ag-icon-loading::after {\n  background-image: var(--ag-icon-image-loading, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-loading, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-loading, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-maximize {\n  font-family: var(--ag-icon-font-family-maximize, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-maximize, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-maximize, var(--ag-icon-font-color));\n}\n\n.ag-icon-maximize::before {\n  content: var(--ag-icon-font-code-maximize, \"\\f11d\");\n  display: var(--ag-icon-font-display-maximize, var(--ag-icon-font-display));\n}\n\n.ag-icon-maximize::after {\n  background-image: var(--ag-icon-image-maximize, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-maximize, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-maximize, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-menu {\n  font-family: var(--ag-icon-font-family-menu, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-menu, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-menu, var(--ag-icon-font-color));\n}\n\n.ag-icon-menu::before {\n  content: var(--ag-icon-font-code-menu, \"\\f11e\");\n  display: var(--ag-icon-font-display-menu, var(--ag-icon-font-display));\n}\n\n.ag-icon-menu::after {\n  background-image: var(--ag-icon-image-menu, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-menu, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-menu, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-minimize {\n  font-family: var(--ag-icon-font-family-minimize, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-minimize, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-minimize, var(--ag-icon-font-color));\n}\n\n.ag-icon-minimize::before {\n  content: var(--ag-icon-font-code-minimize, \"\\f11f\");\n  display: var(--ag-icon-font-display-minimize, var(--ag-icon-font-display));\n}\n\n.ag-icon-minimize::after {\n  background-image: var(--ag-icon-image-minimize, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-minimize, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-minimize, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-next {\n  font-family: var(--ag-icon-font-family-next, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-next, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-next, var(--ag-icon-font-color));\n}\n\n.ag-icon-next::before {\n  content: var(--ag-icon-font-code-next, \"\\f120\");\n  display: var(--ag-icon-font-display-next, var(--ag-icon-font-display));\n}\n\n.ag-icon-next::after {\n  background-image: var(--ag-icon-image-next, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-next, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-next, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-none {\n  font-family: var(--ag-icon-font-family-none, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-none, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-none, var(--ag-icon-font-color));\n}\n\n.ag-icon-none::before {\n  content: var(--ag-icon-font-code-none, \"\\f121\");\n  display: var(--ag-icon-font-display-none, var(--ag-icon-font-display));\n}\n\n.ag-icon-none::after {\n  background-image: var(--ag-icon-image-none, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-none, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-none, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-not-allowed {\n  font-family: var(--ag-icon-font-family-not-allowed, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-not-allowed, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-not-allowed, var(--ag-icon-font-color));\n}\n\n.ag-icon-not-allowed::before {\n  content: var(--ag-icon-font-code-not-allowed, \"\\f122\");\n  display: var(--ag-icon-font-display-not-allowed, var(--ag-icon-font-display));\n}\n\n.ag-icon-not-allowed::after {\n  background-image: var(--ag-icon-image-not-allowed, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-not-allowed, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-not-allowed, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-paste {\n  font-family: var(--ag-icon-font-family-paste, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-paste, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-paste, var(--ag-icon-font-color));\n}\n\n.ag-icon-paste::before {\n  content: var(--ag-icon-font-code-paste, \"\\f123\");\n  display: var(--ag-icon-font-display-paste, var(--ag-icon-font-display));\n}\n\n.ag-icon-paste::after {\n  background-image: var(--ag-icon-image-paste, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-paste, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-paste, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-pin {\n  font-family: var(--ag-icon-font-family-pin, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-pin, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-pin, var(--ag-icon-font-color));\n}\n\n.ag-icon-pin::before {\n  content: var(--ag-icon-font-code-pin, \"\\f124\");\n  display: var(--ag-icon-font-display-pin, var(--ag-icon-font-display));\n}\n\n.ag-icon-pin::after {\n  background-image: var(--ag-icon-image-pin, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-pin, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-pin, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-pivot {\n  font-family: var(--ag-icon-font-family-pivot, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-pivot, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-pivot, var(--ag-icon-font-color));\n}\n\n.ag-icon-pivot::before {\n  content: var(--ag-icon-font-code-pivot, \"\\f125\");\n  display: var(--ag-icon-font-display-pivot, var(--ag-icon-font-display));\n}\n\n.ag-icon-pivot::after {\n  background-image: var(--ag-icon-image-pivot, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-pivot, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-pivot, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-previous {\n  font-family: var(--ag-icon-font-family-previous, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-previous, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-previous, var(--ag-icon-font-color));\n}\n\n.ag-icon-previous::before {\n  content: var(--ag-icon-font-code-previous, \"\\f126\");\n  display: var(--ag-icon-font-display-previous, var(--ag-icon-font-display));\n}\n\n.ag-icon-previous::after {\n  background-image: var(--ag-icon-image-previous, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-previous, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-previous, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-radio-button-off {\n  font-family: var(--ag-icon-font-family-radio-button-off, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-radio-button-off, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-radio-button-off, var(--ag-icon-font-color));\n}\n\n.ag-icon-radio-button-off::before {\n  content: var(--ag-icon-font-code-radio-button-off, \"\\f127\");\n  display: var(--ag-icon-font-display-radio-button-off, var(--ag-icon-font-display));\n}\n\n.ag-icon-radio-button-off::after {\n  background-image: var(--ag-icon-image-radio-button-off, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-radio-button-off, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-radio-button-off, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-radio-button-on {\n  font-family: var(--ag-icon-font-family-radio-button-on, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-radio-button-on, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-radio-button-on, var(--ag-icon-font-color));\n}\n\n.ag-icon-radio-button-on::before {\n  content: var(--ag-icon-font-code-radio-button-on, \"\\f128\");\n  display: var(--ag-icon-font-display-radio-button-on, var(--ag-icon-font-display));\n}\n\n.ag-icon-radio-button-on::after {\n  background-image: var(--ag-icon-image-radio-button-on, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-radio-button-on, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-radio-button-on, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-right {\n  font-family: var(--ag-icon-font-family-right, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-right, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-right, var(--ag-icon-font-color));\n}\n\n.ag-icon-right::before {\n  content: var(--ag-icon-font-code-right, \"\\f129\");\n  display: var(--ag-icon-font-display-right, var(--ag-icon-font-display));\n}\n\n.ag-icon-right::after {\n  background-image: var(--ag-icon-image-right, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-right, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-right, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-save {\n  font-family: var(--ag-icon-font-family-save, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-save, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-save, var(--ag-icon-font-color));\n}\n\n.ag-icon-save::before {\n  content: var(--ag-icon-font-code-save, \"\\f12a\");\n  display: var(--ag-icon-font-display-save, var(--ag-icon-font-display));\n}\n\n.ag-icon-save::after {\n  background-image: var(--ag-icon-image-save, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-save, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-save, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-small-down {\n  font-family: var(--ag-icon-font-family-small-down, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-small-down, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-small-down, var(--ag-icon-font-color));\n}\n\n.ag-icon-small-down::before {\n  content: var(--ag-icon-font-code-small-down, \"\\f12b\");\n  display: var(--ag-icon-font-display-small-down, var(--ag-icon-font-display));\n}\n\n.ag-icon-small-down::after {\n  background-image: var(--ag-icon-image-small-down, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-small-down, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-small-down, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-small-left {\n  font-family: var(--ag-icon-font-family-small-left, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-small-left, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-small-left, var(--ag-icon-font-color));\n}\n\n.ag-icon-small-left::before {\n  content: var(--ag-icon-font-code-small-left, \"\\f12c\");\n  display: var(--ag-icon-font-display-small-left, var(--ag-icon-font-display));\n}\n\n.ag-icon-small-left::after {\n  background-image: var(--ag-icon-image-small-left, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-small-left, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-small-left, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-small-right {\n  font-family: var(--ag-icon-font-family-small-right, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-small-right, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-small-right, var(--ag-icon-font-color));\n}\n\n.ag-icon-small-right::before {\n  content: var(--ag-icon-font-code-small-right, \"\\f12d\");\n  display: var(--ag-icon-font-display-small-right, var(--ag-icon-font-display));\n}\n\n.ag-icon-small-right::after {\n  background-image: var(--ag-icon-image-small-right, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-small-right, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-small-right, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-small-up {\n  font-family: var(--ag-icon-font-family-small-up, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-small-up, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-small-up, var(--ag-icon-font-color));\n}\n\n.ag-icon-small-up::before {\n  content: var(--ag-icon-font-code-small-up, \"\\f12e\");\n  display: var(--ag-icon-font-display-small-up, var(--ag-icon-font-display));\n}\n\n.ag-icon-small-up::after {\n  background-image: var(--ag-icon-image-small-up, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-small-up, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-small-up, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-tick {\n  font-family: var(--ag-icon-font-family-tick, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-tick, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-tick, var(--ag-icon-font-color));\n}\n\n.ag-icon-tick::before {\n  content: var(--ag-icon-font-code-tick, \"\\f12f\");\n  display: var(--ag-icon-font-display-tick, var(--ag-icon-font-display));\n}\n\n.ag-icon-tick::after {\n  background-image: var(--ag-icon-image-tick, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-tick, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-tick, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-tree-closed {\n  font-family: var(--ag-icon-font-family-tree-closed, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-tree-closed, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-tree-closed, var(--ag-icon-font-color));\n}\n\n.ag-icon-tree-closed::before {\n  content: var(--ag-icon-font-code-tree-closed, \"\\f130\");\n  display: var(--ag-icon-font-display-tree-closed, var(--ag-icon-font-display));\n}\n\n.ag-icon-tree-closed::after {\n  background-image: var(--ag-icon-image-tree-closed, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-tree-closed, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-tree-closed, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-tree-indeterminate {\n  font-family: var(--ag-icon-font-family-tree-indeterminate, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-tree-indeterminate, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-tree-indeterminate, var(--ag-icon-font-color));\n}\n\n.ag-icon-tree-indeterminate::before {\n  content: var(--ag-icon-font-code-tree-indeterminate, \"\\f131\");\n  display: var(--ag-icon-font-display-tree-indeterminate, var(--ag-icon-font-display));\n}\n\n.ag-icon-tree-indeterminate::after {\n  background-image: var(--ag-icon-image-tree-indeterminate, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-tree-indeterminate, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-tree-indeterminate, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-tree-open {\n  font-family: var(--ag-icon-font-family-tree-open, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-tree-open, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-tree-open, var(--ag-icon-font-color));\n}\n\n.ag-icon-tree-open::before {\n  content: var(--ag-icon-font-code-tree-open, \"\\f132\");\n  display: var(--ag-icon-font-display-tree-open, var(--ag-icon-font-display));\n}\n\n.ag-icon-tree-open::after {\n  background-image: var(--ag-icon-image-tree-open, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-tree-open, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-tree-open, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-unlinked {\n  font-family: var(--ag-icon-font-family-unlinked, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-unlinked, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-unlinked, var(--ag-icon-font-color));\n}\n\n.ag-icon-unlinked::before {\n  content: var(--ag-icon-font-code-unlinked, \"\\f133\");\n  display: var(--ag-icon-font-display-unlinked, var(--ag-icon-font-display));\n}\n\n.ag-icon-unlinked::after {\n  background-image: var(--ag-icon-image-unlinked, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-unlinked, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-unlinked, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-up {\n  font-family: var(--ag-icon-font-family-up, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-up, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-up, var(--ag-icon-font-color));\n}\n\n.ag-icon-up::before {\n  content: var(--ag-icon-font-code-up, \"\\f134\");\n  display: var(--ag-icon-font-display-up, var(--ag-icon-font-display));\n}\n\n.ag-icon-up::after {\n  background-image: var(--ag-icon-image-up, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-up, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-up, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-down {\n  font-family: var(--ag-icon-font-family-down, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-down, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-down, var(--ag-icon-font-color));\n}\n\n.ag-icon-down::before {\n  content: var(--ag-icon-font-code-down, \"\\f135\");\n  display: var(--ag-icon-font-display-down, var(--ag-icon-font-display));\n}\n\n.ag-icon-down::after {\n  background-image: var(--ag-icon-image-down, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-down, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-down, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-plus {\n  font-family: var(--ag-icon-font-family-plus, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-plus, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-plus, var(--ag-icon-font-color));\n}\n\n.ag-icon-plus::before {\n  content: var(--ag-icon-font-code-plus, \"\\f136\");\n  display: var(--ag-icon-font-display-plus, var(--ag-icon-font-display));\n}\n\n.ag-icon-plus::after {\n  background-image: var(--ag-icon-image-plus, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-plus, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-plus, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-minus {\n  font-family: var(--ag-icon-font-family-minus, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-minus, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-minus, var(--ag-icon-font-color));\n}\n\n.ag-icon-minus::before {\n  content: var(--ag-icon-font-code-minus, \"\\f137\");\n  display: var(--ag-icon-font-display-minus, var(--ag-icon-font-display));\n}\n\n.ag-icon-minus::after {\n  background-image: var(--ag-icon-image-minus, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-minus, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-minus, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-menu-alt {\n  font-family: var(--ag-icon-font-family-menu-alt, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-menu-alt, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-menu-alt, var(--ag-icon-font-color));\n}\n\n.ag-icon-menu-alt::before {\n  content: var(--ag-icon-font-code-menu-alt, \"\\f138\");\n  display: var(--ag-icon-font-display-menu-alt, var(--ag-icon-font-display));\n}\n\n.ag-icon-menu-alt::after {\n  background-image: var(--ag-icon-image-menu-alt, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-menu-alt, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-menu-alt, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-settings {\n  font-family: var(--ag-icon-font-family-settings, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-settings, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-settings, var(--ag-icon-font-color));\n}\n\n.ag-icon-settings::before {\n  content: var(--ag-icon-font-code-settings, \"\\f139\");\n  display: var(--ag-icon-font-display-settings, var(--ag-icon-font-display));\n}\n\n.ag-icon-settings::after {\n  background-image: var(--ag-icon-image-settings, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-settings, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-settings, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-column-arrow {\n  font-family: var(--ag-icon-font-family-column-arrow, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-column-arrow, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-column-arrow, var(--ag-icon-font-color));\n}\n\n.ag-icon-column-arrow::before {\n  content: var(--ag-icon-font-code-column-arrow, \"\\f13a\");\n  display: var(--ag-icon-font-display-column-arrow, var(--ag-icon-font-display));\n}\n\n.ag-icon-column-arrow::after {\n  background-image: var(--ag-icon-image-column-arrow, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-column-arrow, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-column-arrow, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-un-pin {\n  font-family: var(--ag-icon-font-family-un-pin, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-un-pin, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-un-pin, var(--ag-icon-font-color));\n}\n\n.ag-icon-un-pin::before {\n  content: var(--ag-icon-font-code-un-pin, \"\\f13b\");\n  display: var(--ag-icon-font-display-un-pin, var(--ag-icon-font-display));\n}\n\n.ag-icon-un-pin::after {\n  background-image: var(--ag-icon-image-un-pin, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-un-pin, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-un-pin, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-pinned-bottom {\n  font-family: var(--ag-icon-font-family-pinned-bottom, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-pinned-bottom, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-pinned-bottom, var(--ag-icon-font-color));\n}\n\n.ag-icon-pinned-bottom::before {\n  content: var(--ag-icon-font-code-pinned-bottom, \"\\f13e\");\n  display: var(--ag-icon-font-display-pinned-bottom, var(--ag-icon-font-display));\n}\n\n.ag-icon-pinned-bottom::after {\n  background-image: var(--ag-icon-image-pinned-bottom, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-pinned-bottom, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-pinned-bottom, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-pinned-top {\n  font-family: var(--ag-icon-font-family-pinned-top, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-pinned-top, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-pinned-top, var(--ag-icon-font-color));\n}\n\n.ag-icon-pinned-top::before {\n  content: var(--ag-icon-font-code-pinned-top, \"\\f13f\");\n  display: var(--ag-icon-font-display-pinned-top, var(--ag-icon-font-display));\n}\n\n.ag-icon-pinned-top::after {\n  background-image: var(--ag-icon-image-pinned-top, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-pinned-top, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-pinned-top, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-chevron-up {\n  font-family: var(--ag-icon-font-family-chevron-up, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-chevron-up, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-chevron-up, var(--ag-icon-font-color));\n}\n\n.ag-icon-chevron-up::before {\n  content: var(--ag-icon-font-code-chevron-up, \"\\f140\");\n  display: var(--ag-icon-font-display-chevron-up, var(--ag-icon-font-display));\n}\n\n.ag-icon-chevron-up::after {\n  background-image: var(--ag-icon-image-chevron-up, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-chevron-up, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-chevron-up, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-chevron-down {\n  font-family: var(--ag-icon-font-family-chevron-down, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-chevron-down, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-chevron-down, var(--ag-icon-font-color));\n}\n\n.ag-icon-chevron-down::before {\n  content: var(--ag-icon-font-code-chevron-down, \"\\f141\");\n  display: var(--ag-icon-font-display-chevron-down, var(--ag-icon-font-display));\n}\n\n.ag-icon-chevron-down::after {\n  background-image: var(--ag-icon-image-chevron-down, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-chevron-down, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-chevron-down, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-chevron-left {\n  font-family: var(--ag-icon-font-family-chevron-left, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-chevron-left, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-chevron-left, var(--ag-icon-font-color));\n}\n\n.ag-icon-chevron-left::before {\n  content: var(--ag-icon-font-code-chevron-left, \"\\f142\");\n  display: var(--ag-icon-font-display-chevron-left, var(--ag-icon-font-display));\n}\n\n.ag-icon-chevron-left::after {\n  background-image: var(--ag-icon-image-chevron-left, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-chevron-left, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-chevron-left, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-chevron-right {\n  font-family: var(--ag-icon-font-family-chevron-right, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-chevron-right, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-chevron-right, var(--ag-icon-font-color));\n}\n\n.ag-icon-chevron-right::before {\n  content: var(--ag-icon-font-code-chevron-right, \"\\f143\");\n  display: var(--ag-icon-font-display-chevron-right, var(--ag-icon-font-display));\n}\n\n.ag-icon-chevron-right::after {\n  background-image: var(--ag-icon-image-chevron-right, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-chevron-right, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-chevron-right, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-filter-add {\n  font-family: var(--ag-icon-font-family-filter-add, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-filter-add, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-filter-add, var(--ag-icon-font-color));\n}\n\n.ag-icon-filter-add::before {\n  content: var(--ag-icon-font-code-filter-add, \"\\f144\");\n  display: var(--ag-icon-font-display-filter-add, var(--ag-icon-font-display));\n}\n\n.ag-icon-filter-add::after {\n  background-image: var(--ag-icon-image-filter-add, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-filter-add, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-filter-add, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-edit {\n  font-family: var(--ag-icon-font-family-edit, var(--ag-icon-font-family));\n  font-weight: var(--ag-icon-font-weight-edit, var(--ag-icon-font-weight));\n  color: var(--ag-icon-font-color-edit, var(--ag-icon-font-color));\n}\n\n.ag-icon-edit::before {\n  content: var(--ag-icon-font-code-edit, \"\\f145\");\n  display: var(--ag-icon-font-display-edit, var(--ag-icon-font-display));\n}\n\n.ag-icon-edit::after {\n  background-image: var(--ag-icon-image-edit, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-edit, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-edit, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-icon-row-drag::before {\n  content: var(--ag-icon-font-code-grip);\n}\n\n.ag-left-arrow::before {\n  content: var(--ag-icon-font-code-left);\n}\n\n.ag-right-arrow::before {\n  content: var(--ag-icon-font-code-right);\n}\n\n[class*=ag-theme-] {\n  --ag-foreground-color: #000;\n  --ag-data-color: var(--ag-foreground-color);\n  --ag-secondary-foreground-color: var(--ag-foreground-color);\n  --ag-header-foreground-color: var(--ag-secondary-foreground-color);\n  --ag-disabled-foreground-color: rgba(0, 0, 0, 0.5);\n  --ag-background-color: #fff;\n  --ag-header-background-color: transparent;\n  --ag-tooltip-background-color: transparent;\n  --ag-tooltip-error-background-color: color-mix(\n      in srgb,\n      var(--ag-background-color),\n      var(--ag-invalid-color) 10%\n  );\n  --ag-tooltip-error-text-color: var(--ag-invalid-color);\n  --ag-tooltip-error-border-color: color-mix(in srgb, var(--ag-background-color), var(--ag-invalid-color) 25%);\n  --ag-subheader-background-color: transparent;\n  --ag-subheader-toolbar-background-color: transparent;\n  --ag-control-panel-background-color: transparent;\n  --ag-side-button-selected-background-color: var(--ag-control-panel-background-color);\n  --ag-selected-row-background-color: #bbb;\n  --ag-odd-row-background-color: var(--ag-background-color);\n  --ag-modal-overlay-background-color: rgba(255, 255, 255, 0.66);\n  --ag-menu-background-color: var(--ag-background-color);\n  --ag-menu-border-color: var(--ag-border-color);\n  --ag-panel-background-color: var(--ag-background-color);\n  --ag-panel-border-color: var(--ag-border-color);\n  --ag-row-hover-color: transparent;\n  --ag-column-hover-color: transparent;\n  --ag-range-selection-border-color: var(--ag-foreground-color);\n  --ag-range-selection-border-style: solid;\n  --ag-range-selection-background-color: rgba(0, 0, 0, 0.2);\n  --ag-range-selection-background-color-2: var(--ag-range-selection-background-color);\n  --ag-range-selection-background-color-3: var(--ag-range-selection-background-color);\n  --ag-range-selection-background-color-4: var(--ag-range-selection-background-color);\n  --ag-range-selection-highlight-color: var(--ag-range-selection-border-color);\n  --ag-range-header-highlight-color: color-mix(\n      in srgb,\n      var(--ag-header-background-color),\n      var(--ag-foreground-color) 8%\n  );\n  --ag-selected-tab-underline-color: var(--ag-range-selection-border-color);\n  --ag-selected-tab-underline-width: 0;\n  --ag-selected-tab-underline-transition-speed: 0s;\n  --ag-range-selection-chart-category-background-color: rgba(0, 255, 132, 0.1);\n  --ag-range-selection-chart-background-color: rgba(0, 88, 255, 0.1);\n  --ag-header-cell-hover-background-color: transparent;\n  --ag-header-cell-moving-background-color: var(--ag-background-color);\n  --ag-value-change-value-highlight-background-color: rgba(22, 160, 133, 0.5);\n  --ag-value-change-delta-up-color: #43a047;\n  --ag-value-change-delta-down-color: #e53935;\n  --ag-row-loading-skeleton-effect-color: rgba(66, 66, 66, 0.2);\n  --ag-chip-background-color: transparent;\n  --ag-chip-border-color: var(--ag-chip-background-color);\n  --ag-borders: solid 1px;\n  --ag-border-color: rgba(0, 0, 0, 0.25);\n  --ag-borders-critical: var(--ag-borders);\n  --ag-borders-secondary: var(--ag-borders);\n  --ag-secondary-border-color: var(--ag-border-color);\n  --ag-row-border-style: solid;\n  --ag-row-border-color: var(--ag-secondary-border-color);\n  --ag-row-border-width: 1px;\n  --ag-cell-horizontal-border: solid transparent;\n  --ag-borders-input: var(--ag-borders-secondary);\n  --ag-input-border-color: var(--ag-secondary-border-color);\n  --ag-borders-input-invalid: solid 2px;\n  --ag-input-border-color-invalid: var(--ag-invalid-color);\n  --ag-full-row-invalid-background-color: color-mix(\n      in srgb,\n      var(--ag-background-color),\n      var(--ag-invalid-color) 25%\n  );\n  --ag-borders-side-button: var(--ag-borders);\n  --ag-border-radius: 0px;\n  --ag-wrapper-border-radius: var(--ag-border-radius);\n  --ag-row-border-color: var(--ag-secondary-border-color);\n  --ag-header-column-separator-display: none;\n  --ag-header-column-separator-height: 100%;\n  --ag-header-column-separator-width: 1px;\n  --ag-header-column-separator-color: var(--ag-secondary-border-color);\n  --ag-header-column-resize-handle-display: none;\n  --ag-header-column-resize-handle-height: 50%;\n  --ag-header-column-resize-handle-width: 1px;\n  --ag-header-column-resize-handle-color: var(--ag-secondary-border-color);\n  --ag-invalid-color: red;\n  --ag-input-disabled-border-color: var(--ag-input-border-color);\n  --ag-input-disabled-background-color: transparent;\n  --ag-checkbox-background-color: transparent;\n  --ag-checkbox-border-radius: var(--ag-border-radius);\n  --ag-checkbox-checked-color: var(--ag-foreground-color);\n  --ag-checkbox-unchecked-color: var(--ag-foreground-color);\n  --ag-checkbox-indeterminate-color: var(--ag-checkbox-unchecked-color);\n  --ag-toggle-button-off-border-color: var(--ag-checkbox-unchecked-color);\n  --ag-toggle-button-off-background-color: var(--ag-checkbox-unchecked-color);\n  --ag-toggle-button-on-border-color: var(--ag-checkbox-checked-color);\n  --ag-toggle-button-on-background-color: var(--ag-checkbox-checked-color);\n  --ag-toggle-button-switch-background-color: var(--ag-background-color);\n  --ag-toggle-button-switch-border-color: var(--ag-toggle-button-off-border-color);\n  --ag-toggle-button-border-width: 1px;\n  --ag-toggle-button-height: var(--ag-icon-size);\n  --ag-toggle-button-width: calc(var(--ag-toggle-button-height) * 2);\n  --ag-input-focus-box-shadow: none;\n  --ag-input-error-focus-box-shadow: none;\n  --ag-input-focus-border-color: none;\n  --ag-minichart-selected-chart-color: var(--ag-checkbox-checked-color);\n  --ag-minichart-selected-page-color: var(--ag-checkbox-checked-color);\n  --ag-grid-size: 4px;\n  --ag-icon-size: 12px;\n  --ag-icon-font-weight: normal;\n  --ag-icon-font-color: var(--ag-foreground-color);\n  --ag-icon-image-display: block;\n  --ag-widget-container-horizontal-padding: calc(var(--ag-grid-size) * 1.5);\n  --ag-widget-container-vertical-padding: calc(var(--ag-grid-size) * 1.5);\n  --ag-widget-horizontal-spacing: calc(var(--ag-grid-size) * 2);\n  --ag-widget-vertical-spacing: var(--ag-grid-size);\n  --ag-cell-horizontal-padding: calc(var(--ag-grid-size) * 3);\n  --ag-cell-widget-spacing: var(--ag-cell-horizontal-padding);\n  --ag-row-height: calc(var(--ag-grid-size) * 6 + 1px);\n  --ag-header-height: var(--ag-row-height);\n  --ag-pagination-panel-height: var(--ag-header-height);\n  --ag-list-item-height: calc(var(--ag-grid-size) * 5);\n  --ag-column-select-indent-size: calc(var(--ag-grid-size) + var(--ag-icon-size));\n  --ag-set-filter-indent-size: calc(var(--ag-grid-size) + var(--ag-icon-size));\n  --ag-advanced-filter-builder-indent-size: calc(var(--ag-grid-size) * 2 + var(--ag-icon-size));\n  --ag-row-group-indent-size: calc(var(--ag-cell-widget-spacing) + var(--ag-icon-size));\n  --ag-row-numbers-selected-color: #bbb;\n  --ag-filter-tool-panel-group-indent: 16px;\n  --ag-tab-min-width: 220px;\n  --ag-chart-menu-panel-width: var(--ag-tab-min-width);\n  --ag-menu-min-width: 181px;\n  --ag-side-bar-panel-width: 200px;\n  --ag-font-family: \"Helvetica Neue\", sans-serif;\n  --ag-font-size: 14px;\n  --ag-card-radius: var(--ag-border-radius);\n  --ag-card-shadow: none;\n  --ag-popup-shadow: 5px 5px 10px rgba(0, 0, 0, 0.3);\n  --ag-advanced-filter-join-pill-color: #f08e8d;\n  --ag-advanced-filter-column-pill-color: #a6e194;\n  --ag-advanced-filter-option-pill-color: #f3c08b;\n  --ag-advanced-filter-value-pill-color: #85c0e4;\n  --ag-find-match-color: var(--ag-foreground-color);\n  --ag-find-active-match-color: var(--ag-foreground-color);\n  --ag-find-match-background-color: #ffff00;\n  --ag-find-active-match-background-color: #ffa500;\n  --ag-cell-batch-edit-background-color: rgb(220 181 139 / 16%);\n  --ag-cell-batch-edit-text-color: #422f00;\n  --ag-row-batch-edit-background-color: var(--ag-cell-batch-edit-background-color);\n  --ag-row-batch-edit-text-color: var(--ag-cell-batch-edit-text-color);\n  --ag-filter-panel-apply-button-color: var(--ag-foreground-color);\n  --ag-filter-panel-apply-button-background-color: var(--ag-background-color);\n  --ag-filter-panel-card-subtle-color: var(--ag-foreground-color);\n  --ag-filter-panel-card-subtle-hover-color: var(--ag-foreground-color);\n}\n\n.ag-root-wrapper,\n.ag-sticky-top,\n.ag-sticky-bottom,\n.ag-dnd-ghost {\n  background-color: var(--ag-background-color);\n}\n\n.ag-sticky-bottom {\n  border-top: var(--ag-row-border-style) var(--ag-row-border-color) var(--ag-row-border-width);\n}\n\n.ag-root-wrapper,\n.ag-popup {\n  --ag-indentation-level: 0;\n}\n\n[class*=ag-theme-] {\n  -webkit-font-smoothing: antialiased;\n  font-family: var(--ag-font-family);\n  font-size: var(--ag-font-size);\n  line-height: normal;\n  color: var(--ag-foreground-color);\n}\n\nag-grid,\nag-grid-angular,\nag-grid-ng2,\nag-grid-polymer,\nag-grid-aurelia {\n  display: block;\n}\n\n.ag-aria-description-container {\n  z-index: 9999;\n  border: 0px;\n  clip: rect(1px, 1px, 1px, 1px);\n  height: 1px;\n  width: 1px;\n  position: absolute;\n  overflow: hidden;\n  padding: 0px;\n  white-space: nowrap;\n}\n\n.ag-hidden {\n  display: none !important;\n}\n\n.ag-invisible {\n  visibility: hidden !important;\n}\n\n.ag-drag-handle {\n  cursor: grab;\n}\n\n.ag-column-drop-wrapper {\n  display: flex;\n}\n\n.ag-column-drop-horizontal-half-width {\n  display: inline-block;\n  width: 50% !important;\n}\n\n.ag-unselectable {\n  -moz-user-select: none;\n  -webkit-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.ag-selectable {\n  -moz-user-select: text;\n  -webkit-user-select: text;\n  -ms-user-select: text;\n  user-select: text;\n}\n\n.ag-tab {\n  position: relative;\n}\n\n.ag-tab-guard {\n  position: absolute;\n  width: 0;\n  height: 0;\n  display: block;\n}\n\n.ag-virtual-list-viewport .ag-tab-guard {\n  position: sticky;\n}\n\n.ag-tab-guard-top {\n  top: 1px;\n}\n\n.ag-tab-guard-bottom {\n  bottom: 1px;\n}\n\n.ag-select-agg-func-popup {\n  position: absolute;\n}\n\n.ag-input-wrapper,\n.ag-picker-field-wrapper {\n  display: flex;\n  flex: 1 1 auto;\n  align-items: center;\n  line-height: normal;\n  position: relative;\n}\n\n.ag-shake-left-to-right {\n  animation-direction: alternate;\n  animation-duration: 0.2s;\n  animation-iteration-count: infinite;\n  animation-name: ag-shake-left-to-right;\n}\n\n@keyframes ag-shake-left-to-right {\n  from {\n    padding-left: 6px;\n    padding-right: 2px;\n  }\n  to {\n    padding-left: 2px;\n    padding-right: 6px;\n  }\n}\n.ag-root-wrapper {\n  cursor: default;\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  white-space: normal;\n}\n.ag-root-wrapper.ag-layout-normal {\n  height: 100%;\n}\n\n.ag-watermark {\n  position: absolute;\n  bottom: 20px;\n  right: 25px;\n  opacity: 0.7;\n  transition: opacity 1s ease-out 3s;\n  color: #9b9b9b;\n}\n.ag-watermark::before {\n  content: \"\";\n  background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ");\n  background-repeat: no-repeat;\n  background-size: 170px 40px;\n  display: block;\n  height: 40px;\n  width: 170px;\n}\n\n.ag-watermark-text {\n  opacity: 0.5;\n  font-weight: bold;\n  font-family: Impact, sans-serif;\n  font-size: 19px;\n  padding-left: 0.7rem;\n}\n\n.ag-root-wrapper-body {\n  display: flex;\n  flex-direction: row;\n}\n.ag-root-wrapper-body.ag-layout-normal {\n  flex: 1 1 auto;\n  height: 0;\n  min-height: 0;\n}\n\n.ag-root {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n}\n.ag-root.ag-layout-normal, .ag-root.ag-layout-auto-height {\n  overflow: hidden;\n  flex: 1 1 auto;\n  width: 0;\n}\n.ag-root.ag-layout-normal {\n  height: 100%;\n}\n\n.ag-header-viewport,\n.ag-floating-top-viewport,\n.ag-body-viewport,\n.ag-center-cols-viewport,\n.ag-floating-bottom-viewport,\n.ag-body-horizontal-scroll-viewport,\n.ag-body-vertical-scroll-viewport,\n.ag-virtual-list-viewport,\n.ag-sticky-top-viewport,\n.ag-sticky-bottom-viewport {\n  position: relative;\n  height: 100%;\n  min-width: 0px;\n  overflow: hidden;\n  flex: 1 1 auto;\n}\n\n.ag-body-viewport,\n.ag-center-cols-viewport,\n.ag-header-viewport,\n.ag-floating-top-viewport,\n.ag-floating-bottom-viewport,\n.ag-sticky-top-viewport,\n.ag-sticky-bottom-viewport {\n  overflow-x: auto;\n  -ms-overflow-style: none !important;\n  scrollbar-width: none !important;\n}\n.ag-body-viewport::-webkit-scrollbar,\n.ag-center-cols-viewport::-webkit-scrollbar,\n.ag-header-viewport::-webkit-scrollbar,\n.ag-floating-top-viewport::-webkit-scrollbar,\n.ag-floating-bottom-viewport::-webkit-scrollbar,\n.ag-sticky-top-viewport::-webkit-scrollbar,\n.ag-sticky-bottom-viewport::-webkit-scrollbar {\n  display: none !important;\n}\n\n.ag-body-viewport {\n  display: flex;\n  overflow-x: hidden;\n}\n.ag-body-viewport.ag-layout-normal {\n  overflow-y: auto;\n  -webkit-overflow-scrolling: touch;\n}\n\n.ag-viewport {\n  position: relative;\n}\n\n.ag-spanning-container {\n  position: absolute;\n  top: 0;\n  z-index: 1;\n}\n\n.ag-sticky-top-container,\n.ag-sticky-bottom-container,\n.ag-floating-top-container,\n.ag-floating-bottom-container {\n  min-height: 1px;\n}\n\n.ag-sticky-top,\n.ag-sticky-bottom {\n  z-index: 1;\n}\n\n.ag-center-cols-viewport {\n  min-height: 100%;\n  width: 100%;\n}\n\n.ag-body-horizontal-scroll-viewport {\n  overflow-x: scroll;\n}\n\n.ag-body-vertical-scroll-viewport {\n  overflow-y: scroll;\n}\n\n.ag-virtual-list-viewport {\n  overflow: auto;\n  width: 100%;\n}\n\n.ag-header-container,\n.ag-floating-top-container,\n.ag-body-container,\n.ag-pinned-right-cols-container,\n.ag-center-cols-container,\n.ag-pinned-left-cols-container,\n.ag-floating-bottom-container,\n.ag-body-horizontal-scroll-container,\n.ag-body-vertical-scroll-container,\n.ag-full-width-container,\n.ag-floating-bottom-full-width-container,\n.ag-virtual-list-container,\n.ag-sticky-top-container,\n.ag-sticky-bottom-container {\n  position: relative;\n}\n\n.ag-header-container,\n.ag-floating-top-container,\n.ag-pinned-left-floating-top,\n.ag-pinned-right-floating-top,\n.ag-floating-bottom-container,\n.ag-pinned-left-floating-bottom,\n.ag-pinned-right-floating-bottom,\n.ag-sticky-top-container,\n.ag-sticky-bottom-container {\n  height: 100%;\n  white-space: nowrap;\n}\n\n.ag-center-cols-container {\n  display: block;\n}\n\n.ag-pinned-right-cols-container {\n  display: block;\n}\n\n.ag-body-horizontal-scroll-container {\n  height: 100%;\n}\n\n.ag-body-vertical-scroll-container {\n  width: 100%;\n}\n\n.ag-full-width-container,\n.ag-floating-top-full-width-container,\n.ag-floating-bottom-full-width-container,\n.ag-sticky-top-full-width-container,\n.ag-sticky-bottom-full-width-container {\n  position: absolute;\n  top: 0px;\n  pointer-events: none;\n}\n.ag-ltr .ag-full-width-container,\n.ag-ltr .ag-floating-top-full-width-container,\n.ag-ltr .ag-floating-bottom-full-width-container,\n.ag-ltr .ag-sticky-top-full-width-container,\n.ag-ltr .ag-sticky-bottom-full-width-container {\n  left: 0;\n}\n.ag-rtl .ag-full-width-container,\n.ag-rtl .ag-floating-top-full-width-container,\n.ag-rtl .ag-floating-bottom-full-width-container,\n.ag-rtl .ag-sticky-top-full-width-container,\n.ag-rtl .ag-sticky-bottom-full-width-container {\n  right: 0;\n}\n\n.ag-full-width-container {\n  width: 100%;\n}\n\n.ag-floating-bottom-full-width-container,\n.ag-floating-top-full-width-container {\n  display: inline-block;\n  overflow: hidden;\n  height: 100%;\n  width: 100%;\n}\n\n.ag-virtual-list-container {\n  overflow: hidden;\n}\n\n.ag-body {\n  position: relative;\n  display: flex;\n  flex: 1 1 auto;\n  flex-direction: row !important;\n  min-height: 0;\n}\n\n.ag-body-horizontal-scroll,\n.ag-body-vertical-scroll {\n  min-height: 0;\n  min-width: 0;\n  display: flex;\n  position: relative;\n}\n.ag-body-horizontal-scroll.ag-scrollbar-invisible,\n.ag-body-vertical-scroll.ag-scrollbar-invisible {\n  position: absolute;\n  bottom: 0;\n}\n.ag-body-horizontal-scroll.ag-scrollbar-invisible.ag-apple-scrollbar,\n.ag-body-vertical-scroll.ag-scrollbar-invisible.ag-apple-scrollbar {\n  opacity: 0;\n  transition: opacity 400ms;\n  visibility: hidden;\n}\n.ag-body-horizontal-scroll.ag-scrollbar-invisible.ag-apple-scrollbar.ag-scrollbar-scrolling, .ag-body-horizontal-scroll.ag-scrollbar-invisible.ag-apple-scrollbar.ag-scrollbar-active,\n.ag-body-vertical-scroll.ag-scrollbar-invisible.ag-apple-scrollbar.ag-scrollbar-scrolling,\n.ag-body-vertical-scroll.ag-scrollbar-invisible.ag-apple-scrollbar.ag-scrollbar-active {\n  visibility: visible;\n  opacity: 1;\n}\n\n.ag-body-horizontal-scroll {\n  width: 100%;\n}\n.ag-body-horizontal-scroll.ag-scrollbar-invisible {\n  left: 0;\n  right: 0;\n}\n\n.ag-body-vertical-scroll {\n  height: 100%;\n}\n.ag-body-vertical-scroll.ag-scrollbar-invisible {\n  top: 0;\n  z-index: 10;\n}\n.ag-ltr .ag-body-vertical-scroll.ag-scrollbar-invisible {\n  right: 0;\n}\n.ag-rtl .ag-body-vertical-scroll.ag-scrollbar-invisible {\n  left: 0;\n}\n\n.ag-force-vertical-scroll {\n  overflow-y: scroll !important;\n}\n\n.ag-horizontal-left-spacer,\n.ag-horizontal-right-spacer {\n  height: 100%;\n  min-width: 0;\n  overflow-x: scroll;\n}\n.ag-horizontal-left-spacer.ag-scroller-corner,\n.ag-horizontal-right-spacer.ag-scroller-corner {\n  overflow-x: hidden;\n}\n\n.ag-header,\n.ag-pinned-left-header,\n.ag-pinned-right-header {\n  display: inline-block;\n  overflow: hidden;\n  position: relative;\n}\n\n.ag-header-cell-sortable .ag-header-cell-label {\n  cursor: pointer;\n}\n\n.ag-header {\n  display: flex;\n  width: 100%;\n  white-space: nowrap;\n}\n\n.ag-pinned-left-header {\n  height: 100%;\n}\n\n.ag-pinned-right-header {\n  height: 100%;\n}\n\n.ag-header-row {\n  position: absolute;\n}\n\n.ag-header-row:not(.ag-header-row-column-group) {\n  overflow: hidden;\n}\n\n.ag-header.ag-header-allow-overflow .ag-header-row {\n  overflow: visible;\n}\n\n.ag-header-cell {\n  display: inline-flex;\n  align-items: center;\n  position: absolute;\n  height: 100%;\n  overflow: hidden;\n}\n\n.ag-header-cell.ag-header-active .ag-header-cell-menu-button,\n.ag-header-cell-filter-button {\n  opacity: 1;\n}\n\n.ag-header-cell-menu-button:not(.ag-header-menu-always-show) {\n  transition: opacity 0.2s;\n  opacity: 0;\n}\n\n.ag-header-group-cell-label,\n.ag-header-cell-label {\n  display: flex;\n  flex: 1 1 auto;\n  align-self: stretch;\n  align-items: center;\n  overflow: hidden;\n}\n\n.ag-header-cell-label {\n  text-overflow: ellipsis;\n}\n\n.ag-header-group-cell-label.ag-sticky-label {\n  position: sticky;\n  flex: none;\n  max-width: 100%;\n  overflow: visible;\n}\n\n.ag-header-group-text {\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n.ag-header-cell-text {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  word-break: break-word;\n}\n\n.ag-header-group-cell .ag-header-cell-comp-wrapper {\n  display: flex;\n}\n\n.ag-header-cell:not(.ag-header-cell-auto-height) .ag-header-cell-comp-wrapper {\n  height: 100%;\n  display: flex;\n  align-items: center;\n}\n\n.ag-header-cell-comp-wrapper {\n  width: 100%;\n}\n\n.ag-header-cell-wrap-text .ag-header-cell-comp-wrapper {\n  white-space: normal;\n}\n\n.ag-header-cell-comp-wrapper-limited-height > div {\n  overflow: hidden;\n}\n\n.ag-right-aligned-header .ag-header-cell-label {\n  flex-direction: row-reverse;\n}\n\n.ag-header-cell-resize {\n  position: absolute;\n  z-index: 2;\n  height: 100%;\n  width: 8px;\n  top: 0;\n  cursor: ew-resize;\n}\n.ag-ltr .ag-header-cell-resize {\n  right: -3px;\n}\n.ag-rtl .ag-header-cell-resize {\n  left: -3px;\n}\n\n.ag-pinned-left-header .ag-header-cell-resize {\n  right: -3px;\n}\n\n.ag-pinned-right-header .ag-header-cell-resize {\n  left: -3px;\n}\n\n.ag-header-select-all {\n  display: flex;\n}\n\n.ag-header-cell-menu-button,\n.ag-header-cell-filter-button,\n.ag-side-button-button,\n.ag-panel-title-bar-button,\n.ag-floating-filter-button-button {\n  cursor: pointer;\n}\n\n.ag-column-moving .ag-cell {\n  transition: left 0.2s;\n}\n.ag-column-moving .ag-header-cell {\n  transition: left 0.2s;\n}\n.ag-column-moving .ag-spanned-cell-wrapper {\n  transition: left 0.2s;\n}\n.ag-column-moving .ag-header-group-cell {\n  transition: left 0.2s, width 0.2s;\n}\n\n.ag-column-panel {\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  flex: 1 1 auto;\n}\n\n.ag-column-select {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  flex: 3 1 0px;\n}\n\n.ag-column-select-header {\n  position: relative;\n  display: flex;\n  flex: none;\n}\n\n.ag-column-select-header-icon {\n  position: relative;\n}\n\n.ag-column-select-header-filter-wrapper {\n  flex: 1 1 auto;\n}\n\n.ag-column-select-header-filter {\n  width: 100%;\n}\n\n.ag-column-select-list {\n  flex: 1 1 0px;\n  overflow: hidden;\n}\n\n.ag-column-drop {\n  position: relative;\n  display: inline-flex;\n  align-items: center;\n  overflow: auto;\n  width: 100%;\n}\n\n.ag-column-drop-list {\n  display: flex;\n  align-items: center;\n}\n\n.ag-column-drop-cell {\n  position: relative;\n  display: flex;\n  align-items: center;\n}\n\n.ag-column-drop-cell-text {\n  overflow: hidden;\n  flex: 1 1 auto;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n\n.ag-column-drop-vertical {\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  align-items: stretch;\n  flex: 1 1 0px;\n}\n\n.ag-column-drop-vertical-title-bar {\n  display: flex;\n  align-items: center;\n  flex: none;\n}\n\n.ag-column-drop-vertical-list {\n  position: relative;\n  align-items: stretch;\n  flex-grow: 1;\n  flex-direction: column;\n  overflow-x: auto;\n}\n.ag-column-drop-vertical-list > * {\n  flex: none;\n}\n\n.ag-column-drop-empty .ag-column-drop-vertical-list {\n  overflow: hidden;\n}\n\n.ag-column-drop-vertical-empty-message {\n  display: block;\n}\n\n.ag-column-drop.ag-column-drop-horizontal {\n  white-space: nowrap;\n  overflow: hidden;\n}\n\n.ag-column-drop-cell-button {\n  cursor: pointer;\n}\n\n.ag-filter-toolpanel {\n  flex: 1 1 0px;\n  min-width: 0;\n}\n\n.ag-filter-toolpanel-header {\n  position: relative;\n}\n\n.ag-filter-toolpanel-header,\n.ag-filter-toolpanel-search {\n  display: flex;\n  align-items: center;\n}\n.ag-filter-toolpanel-header > *,\n.ag-filter-toolpanel-search > * {\n  display: flex;\n  align-items: center;\n}\n\n.ag-filter-apply-panel {\n  display: flex;\n  justify-content: flex-end;\n  overflow: hidden;\n}\n\n.ag-row-animation .ag-row {\n  transition: transform 0.4s, top 0.4s, opacity 0.2s;\n}\n\n.ag-row-animation .ag-row.ag-after-created {\n  transition: transform 0.4s, top 0.4s, height 0.4s, opacity 0.2s;\n}\n\n.ag-row-animation.ag-prevent-animation .ag-row,\n.ag-row-animation.ag-prevent-animation .ag-row.ag-after-created {\n  transition: none !important;\n}\n\n.ag-row-no-animation .ag-row {\n  transition: none;\n}\n\n.ag-row {\n  white-space: nowrap;\n  width: 100%;\n}\n\n.ag-row-loading {\n  display: flex;\n  align-items: center;\n}\n\n.ag-row-position-absolute {\n  position: absolute;\n}\n\n.ag-row-position-relative {\n  position: relative;\n}\n\n.ag-full-width-row {\n  overflow: hidden;\n  pointer-events: all;\n}\n\n.ag-row-inline-editing {\n  z-index: 1;\n}\n\n.ag-row-dragging {\n  z-index: 2;\n}\n\n.ag-stub-cell {\n  display: flex;\n  align-items: center;\n}\n\n.ag-cell {\n  display: inline-block;\n  position: absolute;\n  white-space: nowrap;\n  height: 100%;\n}\n\n.ag-cell-value {\n  flex: 1 1 auto;\n}\n\n.ag-cell-value,\n.ag-group-value {\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n.ag-cell-wrapper {\n  display: flex;\n  align-items: center;\n}\n.ag-cell-wrapper.ag-row-group {\n  align-items: flex-start;\n}\n\n.ag-cell-wrap-text {\n  white-space: normal;\n  word-break: break-word;\n}\n\n.ag-cell-wrap-text:not(.ag-cell-auto-height) .ag-cell-wrapper {\n  align-items: normal;\n  height: 100%;\n}\n.ag-cell-wrap-text:not(.ag-cell-auto-height) .ag-cell-wrapper .ag-cell-value {\n  height: 100%;\n}\n\n.ag-sparkline-wrapper {\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  top: 0;\n  line-height: initial;\n}\n\n.ag-full-width-row .ag-cell-wrapper.ag-row-group {\n  height: 100%;\n  align-items: center;\n}\n\n.ag-cell-inline-editing {\n  z-index: 1;\n}\n.ag-cell-inline-editing .ag-cell-wrapper,\n.ag-cell-inline-editing .ag-cell-edit-wrapper,\n.ag-cell-inline-editing .ag-cell-editor,\n.ag-cell-inline-editing .ag-cell-editor .ag-wrapper,\n.ag-cell-inline-editing .ag-cell-editor.ag-cell-editor.ag-cell-editor input {\n  height: 100%;\n  min-height: 100%;\n  width: 100%;\n  line-height: normal;\n}\n\n.ag-row.ag-row-editing-invalid .ag-cell-inline-editing {\n  opacity: 0.8;\n}\n\n.ag-cell .ag-icon {\n  display: inline-block;\n  vertical-align: middle;\n}\n\n.ag-set-filter-item {\n  display: flex;\n  align-items: center;\n  height: 100%;\n}\n\n.ag-set-filter-item-checkbox {\n  display: flex;\n  width: 100%;\n  height: 100%;\n}\n\n.ag-set-filter-group-icons {\n  display: block;\n}\n.ag-set-filter-group-icons > * {\n  cursor: pointer;\n}\n\n.ag-filter-body-wrapper {\n  display: flex;\n  flex-direction: column;\n}\n\n.ag-filter-filter {\n  flex: 1 1 0px;\n}\n\n.ag-filter-condition {\n  display: flex;\n  justify-content: center;\n}\n\n.ag-floating-filter-body {\n  position: relative;\n  display: flex;\n  flex: 1 1 auto;\n  height: 100%;\n}\n\n.ag-floating-filter-full-body {\n  display: flex;\n  flex: 1 1 auto;\n  height: 100%;\n  width: 100%;\n  align-items: center;\n  overflow: hidden;\n}\n\n.ag-floating-filter-full-body > div {\n  flex: 1 1 auto;\n}\n\n.ag-floating-filter-input {\n  align-items: center;\n  display: flex;\n  width: 100%;\n}\n.ag-floating-filter-input > * {\n  flex: 1 1 auto;\n}\n\n.ag-floating-filter-button {\n  display: flex;\n  flex: none;\n}\n\n.ag-date-floating-filter-wrapper {\n  display: flex;\n}\n\n.ag-set-floating-filter-input input[disabled] {\n  pointer-events: none;\n}\n\n.ag-dnd-ghost {\n  display: inline-flex;\n  align-items: center;\n  cursor: move;\n  white-space: nowrap;\n}\n\n.ag-overlay {\n  height: 100%;\n  left: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 0;\n  width: 100%;\n  z-index: 2;\n}\n\n.ag-overlay-panel {\n  display: flex;\n  height: 100%;\n  width: 100%;\n}\n\n.ag-overlay-wrapper {\n  display: flex;\n  flex: none;\n  width: 100%;\n  height: 100%;\n  align-items: center;\n  justify-content: center;\n  text-align: center;\n}\n\n.ag-overlay-loading-wrapper {\n  pointer-events: all;\n}\n\n.ag-popup-child {\n  z-index: 5;\n  top: 0;\n}\n\n.ag-popup-editor {\n  position: absolute;\n  -moz-user-select: none;\n  -webkit-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.ag-large-text-input {\n  display: block;\n}\n\n.ag-virtual-list-item {\n  position: absolute;\n  width: 100%;\n}\n\n.ag-floating-top,\n.ag-floating-bottom {\n  overflow: hidden;\n  white-space: nowrap;\n  width: 100%;\n  position: relative;\n  display: flex;\n}\n\n.ag-pinned-left-floating-top,\n.ag-pinned-right-floating-top,\n.ag-pinned-left-floating-bottom,\n.ag-pinned-right-floating-bottom {\n  overflow: hidden;\n  position: relative;\n  min-width: 0px;\n}\n\n.ag-sticky-top,\n.ag-sticky-bottom {\n  position: absolute;\n  display: flex;\n  width: 100%;\n  overflow: hidden;\n  height: 0px;\n}\n\n.ag-sticky-bottom {\n  box-sizing: content-box !important;\n}\n\n.ag-pinned-left-sticky-top,\n.ag-pinned-right-sticky-top {\n  position: relative;\n  height: 100%;\n  overflow: hidden;\n}\n\n.ag-sticky-top-full-width-container,\n.ag-sticky-bottom-full-width-container {\n  overflow: hidden;\n  width: 100%;\n  height: 100%;\n}\n\n.ag-dialog,\n.ag-panel {\n  display: flex;\n  flex-direction: column;\n  position: relative;\n  overflow: hidden;\n}\n\n.ag-panel-title-bar {\n  display: flex;\n  flex: none;\n  align-items: center;\n  cursor: default;\n}\n\n.ag-panel-title-bar-title {\n  flex: 1 1 auto;\n}\n\n.ag-panel-title-bar-buttons {\n  display: flex;\n}\n\n.ag-panel-title-bar-button {\n  cursor: pointer;\n}\n\n.ag-panel-content-wrapper {\n  display: flex;\n  flex: 1 1 auto;\n  position: relative;\n  overflow: hidden;\n}\n\n.ag-dialog {\n  position: absolute;\n}\n\n.ag-resizer {\n  position: absolute;\n  pointer-events: none;\n  z-index: 1;\n  -moz-user-select: none;\n  -webkit-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n.ag-resizer.ag-resizer-topLeft {\n  top: 0;\n  left: 0;\n  height: 5px;\n  width: 5px;\n  cursor: nwse-resize;\n}\n.ag-resizer.ag-resizer-top {\n  top: 0;\n  left: 5px;\n  right: 5px;\n  height: 5px;\n  cursor: ns-resize;\n}\n.ag-resizer.ag-resizer-topRight {\n  top: 0;\n  right: 0;\n  height: 5px;\n  width: 5px;\n  cursor: nesw-resize;\n}\n.ag-resizer.ag-resizer-right {\n  top: 5px;\n  right: 0;\n  bottom: 5px;\n  width: 5px;\n  cursor: ew-resize;\n}\n.ag-resizer.ag-resizer-bottomRight {\n  bottom: 0;\n  right: 0;\n  height: 5px;\n  width: 5px;\n  cursor: nwse-resize;\n}\n.ag-resizer.ag-resizer-bottom {\n  bottom: 0;\n  left: 5px;\n  right: 5px;\n  height: 5px;\n  cursor: ns-resize;\n}\n.ag-resizer.ag-resizer-bottomLeft {\n  bottom: 0;\n  left: 0;\n  height: 5px;\n  width: 5px;\n  cursor: nesw-resize;\n}\n.ag-resizer.ag-resizer-left {\n  left: 0;\n  top: 5px;\n  bottom: 5px;\n  width: 5px;\n  cursor: ew-resize;\n}\n\n.ag-tooltip {\n  position: absolute;\n  z-index: 99999;\n}\n\n.ag-tooltip-custom {\n  position: absolute;\n  z-index: 99999;\n}\n\n.ag-tooltip:not(.ag-tooltip-interactive),\n.ag-tooltip-custom:not(.ag-tooltip-interactive) {\n  pointer-events: none;\n}\n\n.ag-value-slide-out {\n  margin-right: 5px;\n  opacity: 1;\n  transition: opacity 3s, margin-right 3s;\n  transition-timing-function: linear;\n}\n\n.ag-value-slide-out-end {\n  margin-right: 10px;\n  opacity: 0;\n}\n\n.ag-opacity-zero {\n  opacity: 0 !important;\n}\n\n.ag-menu {\n  max-height: 100%;\n  overflow-y: auto;\n  position: absolute;\n  -moz-user-select: none;\n  -webkit-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.ag-menu-column-select-wrapper {\n  height: 265px;\n  overflow: auto;\n}\n.ag-menu-column-select-wrapper .ag-column-select {\n  height: 100%;\n}\n\n.ag-dialog .ag-panel-content-wrapper .ag-column-select {\n  user-select: none;\n}\n\n.ag-menu-list {\n  display: table;\n  width: 100%;\n}\n\n.ag-menu-option,\n.ag-menu-separator {\n  display: table-row;\n}\n\n.ag-menu-option-part,\n.ag-menu-separator-part {\n  display: table-cell;\n  vertical-align: middle;\n}\n\n.ag-menu-option-text {\n  white-space: nowrap;\n}\n\n.ag-menu-option-custom {\n  display: contents;\n}\n\n.ag-compact-menu-option {\n  width: 100%;\n  display: flex;\n  flex-wrap: nowrap;\n}\n\n.ag-compact-menu-option-text {\n  white-space: nowrap;\n  flex: 1 1 auto;\n}\n\n.ag-context-menu-loading-icon {\n  position: absolute;\n  pointer-events: none;\n}\n\n.ag-pill-container {\n  display: flex;\n  gap: 0.25rem;\n  flex-wrap: nowrap;\n}\n\n.ag-pill {\n  display: flex;\n  white-space: nowrap;\n  padding: 0 0.25rem;\n  align-items: center;\n}\n\n.ag-pill .ag-pill-button {\n  border: none;\n  padding: 0;\n}\n\n.ag-rich-select {\n  cursor: default;\n  outline: none;\n  height: 100%;\n}\n\n.ag-rich-select-value {\n  display: flex;\n  align-items: center;\n  height: 100%;\n}\n.ag-rich-select-value .ag-picker-field-display {\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.ag-rich-select-value .ag-picker-field-display.ag-display-as-placeholder {\n  opacity: 0.5;\n}\n\n.ag-rich-select-list {\n  position: relative;\n}\n.ag-rich-select-list .ag-loading-text {\n  min-height: 2rem;\n}\n\n.ag-rich-select-row {\n  display: flex;\n  flex: 1 1 auto;\n  align-items: center;\n  white-space: nowrap;\n  overflow: hidden;\n  height: 100%;\n}\n\n.ag-rich-select-field-input {\n  flex: 1 1 auto;\n}\n.ag-rich-select-field-input .ag-input-field-input {\n  padding: 0 !important;\n  border: none !important;\n  box-shadow: none !important;\n  text-overflow: ellipsis;\n}\n.ag-rich-select-field-input .ag-input-field-input::placeholder {\n  opacity: 0.8;\n}\n\n.ag-autocomplete {\n  align-items: center;\n  display: flex;\n}\n.ag-autocomplete > * {\n  flex: 1 1 auto;\n}\n\n.ag-autocomplete-list-popup {\n  position: absolute;\n  -moz-user-select: none;\n  -webkit-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.ag-autocomplete-list {\n  position: relative;\n}\n\n.ag-autocomplete-virtual-list-item {\n  display: flex;\n}\n\n.ag-autocomplete-row {\n  display: flex;\n  flex: 1 1 auto;\n  align-items: center;\n  overflow: hidden;\n}\n\n.ag-autocomplete-row-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n.ag-paging-panel {\n  align-items: center;\n  display: flex;\n  justify-content: flex-end;\n}\n\n.ag-paging-page-summary-panel {\n  display: flex;\n  align-items: center;\n}\n\n.ag-paging-button {\n  position: relative;\n}\n\n.ag-disabled .ag-paging-page-summary-panel {\n  pointer-events: none;\n}\n\n.ag-tool-panel-wrapper {\n  display: flex;\n  overflow-y: auto;\n  overflow-x: hidden;\n  cursor: default;\n  -moz-user-select: none;\n  -webkit-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.ag-column-select-column,\n.ag-column-select-column-group,\n.ag-select-agg-func-item {\n  position: relative;\n  align-items: center;\n  display: flex;\n  flex-direction: row;\n  flex-wrap: nowrap;\n  height: 100%;\n}\n.ag-column-select-column > *,\n.ag-column-select-column-group > *,\n.ag-select-agg-func-item > * {\n  flex: none;\n}\n\n.ag-select-agg-func-item,\n.ag-column-select-column-label {\n  flex: 1 1 auto;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n\n.ag-column-select-checkbox {\n  display: flex;\n}\n\n.ag-tool-panel-horizontal-resize {\n  cursor: ew-resize;\n  height: 100%;\n  position: absolute;\n  top: 0;\n  width: 5px;\n  z-index: 1;\n}\n\n.ag-ltr .ag-side-bar-left .ag-tool-panel-horizontal-resize {\n  right: -3px;\n}\n.ag-rtl .ag-side-bar-left .ag-tool-panel-horizontal-resize {\n  left: -3px;\n}\n\n.ag-ltr .ag-side-bar-right .ag-tool-panel-horizontal-resize {\n  left: -3px;\n}\n.ag-rtl .ag-side-bar-right .ag-tool-panel-horizontal-resize {\n  right: -3px;\n}\n\n.ag-details-row {\n  width: 100%;\n}\n\n.ag-details-row-fixed-height {\n  height: 100%;\n}\n\n.ag-details-grid {\n  width: 100%;\n}\n\n.ag-details-grid-fixed-height {\n  height: 100%;\n}\n\n.ag-header-group-cell {\n  display: flex;\n  align-items: center;\n  height: 100%;\n  position: absolute;\n  contain: paint;\n}\n\n.ag-header-group-cell-no-group.ag-header-span-height {\n  display: none;\n}\n\n.ag-cell-label-container {\n  display: flex;\n  justify-content: space-between;\n  flex-direction: row-reverse;\n  align-items: center;\n  height: 100%;\n  width: 100%;\n}\n\n.ag-header-group-cell-label,\n.ag-cell-label-container {\n  padding: 5px 0px;\n}\n\n.ag-right-aligned-header .ag-cell-label-container {\n  flex-direction: row;\n}\n.ag-right-aligned-header .ag-header-cell-text {\n  text-align: end;\n}\n\n.ag-side-bar {\n  display: flex;\n  flex-direction: row-reverse;\n}\n\n.ag-side-bar-left {\n  order: -1;\n  flex-direction: row;\n}\n\n.ag-side-button-button {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  flex-wrap: nowrap;\n  white-space: nowrap;\n  outline: none;\n  cursor: pointer;\n}\n\n.ag-side-button-label {\n  writing-mode: vertical-lr;\n}\n\n.ag-status-bar {\n  display: flex;\n  justify-content: space-between;\n  overflow: hidden;\n}\n\n.ag-status-panel,\n.ag-status-panel.ag-status-panel-aggregations .ag-status-name-value {\n  display: inline-flex;\n}\n\n.ag-status-name-value {\n  white-space: nowrap;\n}\n\n.ag-status-bar-left {\n  display: inline-flex;\n}\n\n.ag-status-bar-center {\n  display: inline-flex;\n}\n\n.ag-status-bar-right {\n  display: inline-flex;\n}\n\n.ag-row-number-cell {\n  width: 100%;\n  white-space: nowrap;\n  overflow: hidden;\n  user-select: none;\n}\n.ag-ltr .ag-row-number-cell {\n  text-align: right;\n}\n.ag-rtl .ag-row-number-cell {\n  text-align: left;\n}\n\n.ag-row-numbers-resizer {\n  position: absolute;\n  bottom: -2px;\n  left: 0;\n  height: 4px;\n  width: 100%;\n  cursor: ns-resize;\n}\n\n.ag-icon {\n  display: block;\n  speak: none;\n}\n\n.ag-group {\n  position: relative;\n  width: 100%;\n}\n\n.ag-group-title-bar {\n  display: flex;\n  align-items: center;\n}\n\n.ag-group-title {\n  display: inline;\n  min-width: 0;\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n}\n\n.ag-group-title-bar .ag-group-title {\n  cursor: default;\n}\n\n.ag-group-toolbar {\n  display: flex;\n  align-items: center;\n}\n\n.ag-group-container {\n  display: flex;\n}\n\n.ag-disabled .ag-group-container {\n  pointer-events: none;\n}\n\n.ag-group-container-horizontal {\n  flex-direction: row;\n  flex-wrap: wrap;\n}\n\n.ag-group-container-vertical {\n  flex-direction: column;\n}\n\n.ag-column-group-icons {\n  display: block;\n}\n.ag-column-group-icons > * {\n  cursor: pointer;\n}\n\n.ag-group-item-alignment-stretch .ag-group-item {\n  align-items: stretch;\n}\n\n.ag-group-item-alignment-start .ag-group-item {\n  align-items: flex-start;\n}\n\n.ag-group-item-alignment-end .ag-group-item {\n  align-items: flex-end;\n}\n\n.ag-toggle-button-icon {\n  transition: right 0.3s;\n  position: absolute;\n  top: -1px;\n}\n\n.ag-input-field,\n.ag-select {\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n}\n\n.ag-input-field-input {\n  flex: 1 1 auto;\n}\n\n.ag-floating-filter-input .ag-input-field-input[type=date],\n.ag-floating-filter-input .ag-input-field-input[type=datetime-local] {\n  width: 1px;\n}\n\n.ag-range-field {\n  display: flex;\n  align-items: center;\n}\n\n.ag-angle-select {\n  display: flex;\n  align-items: center;\n}\n\n.ag-angle-select-wrapper {\n  display: flex;\n}\n\n.ag-angle-select-parent-circle {\n  display: block;\n  position: relative;\n}\n\n.ag-angle-select-child-circle {\n  position: absolute;\n}\n\n.ag-slider-wrapper {\n  display: flex;\n}\n.ag-slider-wrapper .ag-input-field {\n  flex: 1 1 auto;\n}\n\n.ag-picker-field-display {\n  flex: 1 1 auto;\n}\n\n.ag-picker-field {\n  display: flex;\n  align-items: center;\n}\n\n.ag-picker-field-icon {\n  display: flex;\n  border: 0;\n  padding: 0;\n  margin: 0;\n  cursor: pointer;\n}\n\n.ag-picker-field-wrapper {\n  overflow: hidden;\n}\n\n.ag-label-align-right .ag-label {\n  order: 1;\n}\n.ag-label-align-right > * {\n  flex: none;\n}\n\n.ag-label-align-top {\n  flex-direction: column;\n  align-items: flex-start;\n}\n.ag-label-align-top > * {\n  align-self: stretch;\n}\n\n.ag-label-ellipsis {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  flex: 1;\n}\n\n.ag-color-panel {\n  width: 100%;\n  display: flex;\n  flex-direction: column;\n  text-align: center;\n}\n\n.ag-spectrum-color {\n  flex: 1 1 auto;\n  position: relative;\n  overflow: visible;\n  cursor: default;\n}\n\n.ag-spectrum-fill {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n}\n\n.ag-spectrum-val {\n  cursor: pointer;\n}\n\n.ag-spectrum-dragger {\n  position: absolute;\n  pointer-events: none;\n  cursor: pointer;\n}\n\n.ag-spectrum-hue,\n.ag-spectrum-alpha {\n  cursor: default;\n}\n\n.ag-spectrum-hue-background {\n  background: linear-gradient(to left, #ff0000 3%, #ffff00 17%, #00ff00 33%, #00ffff 50%, #0000ff 67%, #ff00ff 83%, #ff0000 100%);\n  width: 100%;\n  height: 100%;\n}\n\n.ag-spectrum-alpha {\n  --ag-spectrum-alpha-background-checked: url(" + ___CSS_LOADER_URL_REPLACEMENT_1___ + ");\n}\n\n.ag-spectrum-alpha-background {\n  background: linear-gradient(to right, var(--ag-internal-spectrum-alpha-color-from), var(--ag-internal-spectrum-alpha-color-to)), var(--ag-spectrum-alpha-background-checked) top left/4px 4px;\n  width: 100%;\n  height: 100%;\n}\n\n.ag-spectrum-tool {\n  cursor: pointer;\n  position: relative;\n}\n\n.ag-spectrum-slider {\n  position: absolute;\n  pointer-events: none;\n}\n\n.ag-spectrum-alpha .ag-spectrum-slider {\n  background: linear-gradient(to bottom, var(--ag-internal-spectrum-alpha-color), var(--ag-internal-spectrum-alpha-color)) white;\n}\n\n.ag-recent-colors {\n  display: flex;\n}\n\n.ag-recent-color {\n  cursor: pointer;\n}\n\n.ag-pill-select {\n  display: flex;\n  flex-direction: column;\n}\n.ag-pill-select .ag-column-drop {\n  flex: unset;\n}\n\n.ag-ltr {\n  direction: ltr;\n}\n.ag-ltr .ag-body,\n.ag-ltr .ag-floating-top,\n.ag-ltr .ag-floating-bottom,\n.ag-ltr .ag-header,\n.ag-ltr .ag-sticky-top,\n.ag-ltr .ag-sticky-bottom,\n.ag-ltr .ag-body-viewport,\n.ag-ltr .ag-body-horizontal-scroll {\n  flex-direction: row;\n}\n\n.ag-rtl {\n  direction: rtl;\n}\n.ag-rtl .ag-body,\n.ag-rtl .ag-floating-top,\n.ag-rtl .ag-floating-bottom,\n.ag-rtl .ag-header,\n.ag-rtl .ag-sticky-top,\n.ag-rtl .ag-sticky-bottom,\n.ag-rtl .ag-body-viewport,\n.ag-rtl .ag-body-horizontal-scroll {\n  flex-direction: row-reverse;\n}\n.ag-rtl .ag-icon-contracted,\n.ag-rtl .ag-icon-expanded,\n.ag-rtl .ag-icon-tree-closed {\n  display: block;\n  transform: rotate(180deg);\n}\n\n.ag-body .ag-body-viewport {\n  -webkit-overflow-scrolling: touch;\n}\n\n.ag-measurement-container {\n  width: 0;\n  overflow: hidden;\n  visibility: hidden;\n}\n.ag-measurement-container div {\n  position: absolute;\n}\n\n.ag-layout-print.ag-body {\n  display: block;\n  height: unset;\n}\n.ag-layout-print.ag-root-wrapper {\n  display: inline-block;\n}\n.ag-layout-print .ag-body-vertical-scroll {\n  display: none;\n}\n.ag-layout-print .ag-body-horizontal-scroll {\n  display: none;\n}\n.ag-layout-print.ag-force-vertical-scroll {\n  overflow-y: visible !important;\n}\n\n@media print {\n  .ag-root-wrapper.ag-layout-print {\n    display: table;\n  }\n  .ag-root-wrapper.ag-layout-print .ag-root-wrapper-body,\n  .ag-root-wrapper.ag-layout-print .ag-root,\n  .ag-root-wrapper.ag-layout-print .ag-body-viewport,\n  .ag-root-wrapper.ag-layout-print .ag-center-cols-container,\n  .ag-root-wrapper.ag-layout-print .ag-center-cols-viewport,\n  .ag-root-wrapper.ag-layout-print .ag-body-horizontal-scroll-viewport,\n  .ag-root-wrapper.ag-layout-print .ag-virtual-list-viewport {\n    height: auto !important;\n    overflow: hidden !important;\n    display: block !important;\n  }\n  .ag-root-wrapper.ag-layout-print .ag-row,\n  .ag-root-wrapper.ag-layout-print .ag-cell {\n    break-inside: avoid;\n  }\n}\n[class^=ag-],\n[class^=ag-]:focus,\n[class^=ag-]:after,\n[class^=ag-]:before {\n  box-sizing: border-box;\n  outline: none;\n}\n\n[class^=ag-]::-ms-clear {\n  display: none;\n}\n\n.ag-checkbox .ag-input-wrapper,\n.ag-radio-button .ag-input-wrapper {\n  overflow: visible;\n}\n\n.ag-range-field .ag-input-wrapper {\n  height: 100%;\n}\n\n.ag-toggle-button {\n  flex: none;\n  width: unset;\n  min-width: unset;\n}\n\n.ag-button {\n  border-radius: 0px;\n  color: var(--ag-foreground-color);\n}\n\n.ag-button:hover {\n  background-color: transparent;\n}\n\n.ag-ltr .ag-label-align-right .ag-label {\n  margin-left: var(--ag-grid-size);\n}\n.ag-rtl .ag-label-align-right .ag-label {\n  margin-right: var(--ag-grid-size);\n}\n\ninput[class^=ag-] {\n  margin: 0;\n  background-color: var(--ag-background-color);\n}\n\ntextarea[class^=ag-],\nselect[class^=ag-] {\n  background-color: var(--ag-background-color);\n}\n\ninput[class^=ag-]:not([type]),\ninput[class^=ag-][type=text],\ninput[class^=ag-][type=number],\ninput[class^=ag-][type=tel],\ninput[class^=ag-][type=date],\ninput[class^=ag-][type=datetime-local],\ntextarea[class^=ag-] {\n  font-size: inherit;\n  line-height: inherit;\n  color: inherit;\n  font-family: inherit;\n  border: var(--ag-borders-input) var(--ag-input-border-color);\n}\ninput[class^=ag-]:not([type]):disabled,\ninput[class^=ag-][type=text]:disabled,\ninput[class^=ag-][type=number]:disabled,\ninput[class^=ag-][type=tel]:disabled,\ninput[class^=ag-][type=date]:disabled,\ninput[class^=ag-][type=datetime-local]:disabled,\ntextarea[class^=ag-]:disabled {\n  color: var(--ag-disabled-foreground-color);\n  background-color: var(--ag-input-disabled-background-color);\n  border-color: var(--ag-input-disabled-border-color);\n}\ninput[class^=ag-]:not([type]):focus,\ninput[class^=ag-][type=text]:focus,\ninput[class^=ag-][type=number]:focus,\ninput[class^=ag-][type=tel]:focus,\ninput[class^=ag-][type=date]:focus,\ninput[class^=ag-][type=datetime-local]:focus,\ntextarea[class^=ag-]:focus {\n  outline: none;\n  box-shadow: var(--ag-input-focus-box-shadow);\n  border-color: var(--ag-input-focus-border-color);\n}\ninput[class^=ag-]:not([type]):focus.invalid, input[class^=ag-]:not([type]):focus:invalid,\ninput[class^=ag-][type=text]:focus.invalid,\ninput[class^=ag-][type=text]:focus:invalid,\ninput[class^=ag-][type=number]:focus.invalid,\ninput[class^=ag-][type=number]:focus:invalid,\ninput[class^=ag-][type=tel]:focus.invalid,\ninput[class^=ag-][type=tel]:focus:invalid,\ninput[class^=ag-][type=date]:focus.invalid,\ninput[class^=ag-][type=date]:focus:invalid,\ninput[class^=ag-][type=datetime-local]:focus.invalid,\ninput[class^=ag-][type=datetime-local]:focus:invalid,\ntextarea[class^=ag-]:focus.invalid,\ntextarea[class^=ag-]:focus:invalid {\n  box-shadow: var(--ag-input-error-focus-box-shadow);\n  border-color: var(--ag-invalid-color);\n}\ninput[class^=ag-]:not([type]):invalid,\ninput[class^=ag-][type=text]:invalid,\ninput[class^=ag-][type=number]:invalid,\ninput[class^=ag-][type=tel]:invalid,\ninput[class^=ag-][type=date]:invalid,\ninput[class^=ag-][type=datetime-local]:invalid,\ntextarea[class^=ag-]:invalid {\n  border: var(--ag-borders-input-invalid) var(--ag-input-border-color-invalid);\n}\n\ninput[class^=ag-][type=number]:not(.ag-number-field-input-stepper) {\n  -moz-appearance: textfield;\n}\ninput[class^=ag-][type=number]:not(.ag-number-field-input-stepper)::-webkit-outer-spin-button, input[class^=ag-][type=number]:not(.ag-number-field-input-stepper)::-webkit-inner-spin-button {\n  -webkit-appearance: none;\n  margin: 0;\n}\n\ninput[class^=ag-][type=range] {\n  padding: 0;\n}\n\ninput[class^=ag-][type=button]:focus,\nbutton[class^=ag-]:focus {\n  box-shadow: var(--ag-input-focus-box-shadow);\n}\ninput[class^=ag-][type=button]:focus:invalid, input[class^=ag-][type=button]:focus.invalid,\nbutton[class^=ag-]:focus:invalid,\nbutton[class^=ag-]:focus.invalid {\n  box-shadow: var(--ag-input-error-focus-box-shadow);\n}\n\n.ag-drag-handle {\n  color: var(--ag-secondary-foreground-color);\n}\n\n.ag-list-item,\n.ag-virtual-list-item {\n  height: var(--ag-list-item-height);\n}\n\n.ag-virtual-list-item:focus-visible {\n  outline: none;\n}\n.ag-virtual-list-item:focus-visible::after {\n  content: \"\";\n  position: absolute;\n  background-color: transparent;\n  pointer-events: none;\n  top: 4px;\n  left: 4px;\n  display: block;\n  width: calc(100% - 8px);\n  height: calc(100% - 8px);\n  border: 1px solid;\n  border-color: var(--ag-input-focus-border-color);\n}\n\n.ag-select-list {\n  background-color: var(--ag-background-color);\n  overflow-y: auto;\n  overflow-x: hidden;\n  border-radius: var(--ag-border-radius);\n  border: var(--ag-borders) var(--ag-border-color);\n}\n\n.ag-list-item {\n  display: flex;\n  align-items: center;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.ag-list-item.ag-active-item {\n  background-color: var(--ag-row-hover-color);\n}\n\n.ag-select-list-item {\n  -moz-user-select: none;\n  -webkit-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  cursor: default;\n}\n.ag-ltr .ag-select-list-item {\n  padding-left: calc(var(--ag-cell-horizontal-padding) / 2);\n}\n.ag-rtl .ag-select-list-item {\n  padding-right: calc(var(--ag-cell-horizontal-padding) / 2);\n}\n.ag-select-list-item span {\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  overflow: hidden;\n}\n\n.ag-row-drag,\n.ag-selection-checkbox,\n.ag-group-expanded,\n.ag-group-contracted {\n  color: var(--ag-secondary-foreground-color);\n}\n.ag-ltr .ag-row-drag,\n.ag-ltr .ag-selection-checkbox,\n.ag-ltr .ag-group-expanded,\n.ag-ltr .ag-group-contracted {\n  margin-right: var(--ag-cell-widget-spacing);\n}\n.ag-rtl .ag-row-drag,\n.ag-rtl .ag-selection-checkbox,\n.ag-rtl .ag-group-expanded,\n.ag-rtl .ag-group-contracted {\n  margin-left: var(--ag-cell-widget-spacing);\n}\n\n.ag-cell-wrapper > *:not(.ag-cell-value):not(.ag-group-value) {\n  --ag-internal-calculated-line-height: var(\n      --ag-line-height,\n      calc(var(--ag-row-height) - var(--ag-row-border-width))\n  );\n  --ag-internal-padded-row-height: calc(var(--ag-row-height) - var(--ag-row-border-width) - 2px);\n  height: min(var(--ag-internal-calculated-line-height), var(--ag-internal-padded-row-height));\n  display: flex;\n  align-items: center;\n  flex: none;\n}\n\n.ag-group-expanded,\n.ag-group-contracted {\n  cursor: pointer;\n}\n\n.ag-group-title-bar-icon {\n  cursor: pointer;\n  flex: none;\n  color: var(--ag-secondary-foreground-color);\n}\n\n.ag-ltr .ag-group-child-count {\n  margin-left: 2px;\n}\n.ag-rtl .ag-group-child-count {\n  margin-right: 2px;\n}\n\n.ag-group-title-bar {\n  background-color: var(--ag-subheader-background-color);\n  padding: var(--ag-grid-size);\n}\n\n.ag-group-toolbar {\n  padding: var(--ag-grid-size);\n  background-color: var(--ag-subheader-toolbar-background-color);\n}\n\n.ag-disabled-group-title-bar,\n.ag-disabled-group-container {\n  opacity: 0.5;\n}\n\n.group-item {\n  margin: calc(var(--ag-grid-size) * 0.5) 0;\n}\n\n.ag-label {\n  white-space: nowrap;\n}\n.ag-ltr .ag-label {\n  margin-right: var(--ag-grid-size);\n}\n.ag-rtl .ag-label {\n  margin-left: var(--ag-grid-size);\n}\n\n.ag-label-align-top .ag-label {\n  margin-bottom: calc(var(--ag-grid-size) * 0.5);\n}\n\n.ag-angle-select[disabled] {\n  color: var(--ag-disabled-foreground-color);\n  pointer-events: none;\n}\n.ag-angle-select[disabled] .ag-angle-select-field {\n  opacity: 0.4;\n}\n\n.ag-ltr .ag-slider-field,\n.ag-ltr .ag-angle-select-field {\n  margin-right: calc(var(--ag-grid-size) * 2);\n}\n.ag-rtl .ag-slider-field,\n.ag-rtl .ag-angle-select-field {\n  margin-left: calc(var(--ag-grid-size) * 2);\n}\n\n.ag-angle-select-parent-circle {\n  width: 24px;\n  height: 24px;\n  border-radius: 12px;\n  border: solid 1px;\n  border-color: var(--ag-border-color);\n  background-color: var(--ag-background-color);\n}\n\n.ag-angle-select-child-circle {\n  top: 4px;\n  left: 12px;\n  width: 6px;\n  height: 6px;\n  margin-left: -3px;\n  margin-top: -4px;\n  border-radius: 3px;\n  background-color: var(--ag-secondary-foreground-color);\n}\n\n.ag-picker-field-wrapper {\n  border: var(--ag-borders);\n  border-color: var(--ag-border-color);\n  border-radius: 5px;\n  background-color: var(--ag-background-color);\n}\n.ag-picker-field-wrapper.invalid {\n  border: var(--ag-borders-input-invalid) var(--ag-input-border-color-invalid);\n}\n.ag-picker-field-wrapper:disabled {\n  color: var(--ag-disabled-foreground-color);\n  background-color: var(--ag-input-disabled-background-color);\n  border-color: var(--ag-input-disabled-border-color);\n}\n.ag-picker-field-wrapper.ag-picker-has-focus:not(.invalid), .ag-picker-field-wrapper:focus-within:not(.invalid) {\n  outline: none;\n  box-shadow: var(--ag-input-focus-box-shadow);\n  border-color: var(--ag-input-focus-border-color);\n}\n\n.ag-picker-field-button {\n  background-color: var(--ag-background-color);\n  color: var(--ag-secondary-foreground-color);\n}\n\n.ag-dialog.ag-color-dialog {\n  border-radius: 5px;\n}\n\n.ag-color-picker .ag-picker-field-wrapper {\n  padding-left: var(--ag-grid-size);\n  padding-right: var(--ag-grid-size);\n}\n.ag-color-picker .ag-picker-field-display {\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  min-height: var(--ag-list-item-height);\n}\n\n.ag-ltr .ag-color-picker-color,\n.ag-ltr .ag-color-picker-value {\n  margin-right: var(--ag-grid-size);\n}\n.ag-rtl .ag-color-picker-color,\n.ag-rtl .ag-color-picker-value {\n  margin-left: var(--ag-grid-size);\n}\n\n.ag-color-panel {\n  padding: var(--ag-grid-size);\n}\n\n.ag-spectrum-color {\n  background-color: rgb(255, 0, 0);\n  border-radius: 2px;\n}\n\n.ag-spectrum-tools {\n  padding: 10px;\n}\n\n.ag-spectrum-sat {\n  background-image: linear-gradient(to right, white, rgba(204, 154, 129, 0));\n}\n\n.ag-spectrum-val {\n  background-image: linear-gradient(to top, black, rgba(204, 154, 129, 0));\n}\n\n.ag-spectrum-dragger {\n  border-radius: 12px;\n  height: 12px;\n  width: 12px;\n  border: 2px solid white;\n  background: black;\n  box-shadow: 0 0 2px 0px rgba(0, 0, 0, 0.24);\n}\n\n.ag-spectrum-hue-background {\n  border-radius: 2px;\n}\n\n.ag-spectrum-alpha-background {\n  border-radius: 2px;\n}\n\n.ag-spectrum-tool {\n  margin-bottom: 10px;\n  height: 11px;\n  border-radius: 2px;\n}\n\n.ag-spectrum-slider {\n  margin-top: -12px;\n  width: 13px;\n  height: 13px;\n  border-radius: 13px;\n  border: 2px solid white;\n  box-shadow: 0 1px 4px 0 rgba(0, 0, 0, 0.37);\n}\n\n.ag-recent-colors {\n  margin-top: 10px;\n}\n\n.ag-recent-color {\n  margin: 0 3px;\n}\n.ag-recent-color:first-child {\n  margin-left: 0;\n}\n.ag-recent-color:last-child {\n  margin-right: 0;\n}\n\n.ag-spectrum-color:focus-visible:not(:disabled):not([readonly]),\n.ag-spectrum-slider:focus-visible:not(:disabled):not([readonly]),\n.ag-recent-color:focus-visible:not(:disabled):not([readonly]) {\n  box-shadow: var(--ag-input-focus-box-shadow);\n}\n\n.ag-ltr .ag-color-input input[class^=ag-][type=text].ag-input-field-input {\n  padding-left: calc(var(--ag-icon-size) + var(--ag-grid-size) * 2);\n}\n.ag-rtl .ag-color-input input[class^=ag-][type=text].ag-input-field-input {\n  padding-right: calc(var(--ag-icon-size) + var(--ag-grid-size) * 2);\n}\n.ag-color-input .ag-color-input-color {\n  position: absolute;\n}\n.ag-ltr .ag-color-input .ag-color-input-color {\n  margin-left: var(--ag-grid-size);\n}\n.ag-rtl .ag-color-input .ag-color-input-color {\n  margin-right: var(--ag-grid-size);\n}\n\n.ag-color-picker-color,\n.ag-color-input-color {\n  width: var(--ag-icon-size);\n  height: var(--ag-icon-size);\n  border: var(--ag-borders-secondary) var(--ag-secondary-border-color);\n  border-radius: 2px;\n}\n\n.ag-dnd-ghost {\n  border: var(--ag-borders) var(--ag-border-color);\n  background: var(--ag-background-color);\n  border-radius: var(--ag-card-radius);\n  box-shadow: var(--ag-card-shadow);\n  padding: var(--ag-grid-size);\n  overflow: hidden;\n  text-overflow: ellipsis;\n  border: var(--ag-borders-secondary) var(--ag-secondary-border-color);\n  color: var(--ag-secondary-foreground-color);\n  height: var(--ag-header-height);\n  line-height: var(--ag-header-height);\n  margin: 0;\n  padding: 0 calc(var(--ag-grid-size) * 2);\n  transform: translateY(calc(var(--ag-grid-size) * 2));\n}\n\n.ag-dnd-ghost-icon {\n  margin-right: var(--ag-grid-size);\n  color: var(--ag-foreground-color);\n}\n\n.ag-popup-child:not(.ag-tooltip-custom) {\n  box-shadow: var(--ag-popup-shadow);\n}\n\n.ag-select .ag-picker-field-wrapper {\n  min-height: var(--ag-list-item-height);\n  cursor: default;\n}\n.ag-ltr .ag-select .ag-picker-field-wrapper {\n  padding-left: calc(var(--ag-cell-horizontal-padding) / 2);\n}\n.ag-rtl .ag-select .ag-picker-field-wrapper {\n  padding-right: calc(var(--ag-cell-horizontal-padding) / 2);\n}\n.ag-ltr .ag-select .ag-picker-field-wrapper {\n  padding-right: var(--ag-grid-size);\n}\n.ag-rtl .ag-select .ag-picker-field-wrapper {\n  padding-left: var(--ag-grid-size);\n}\n.ag-select.ag-disabled .ag-picker-field-wrapper:focus {\n  box-shadow: none;\n}\n.ag-select:not(.ag-cell-editor, .ag-label-align-top) {\n  min-height: var(--ag-list-item-height);\n}\n.ag-select .ag-picker-field-display {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.ag-select .ag-picker-field-icon {\n  display: flex;\n  align-items: center;\n}\n.ag-select.ag-disabled {\n  opacity: 0.5;\n}\n\n.ag-rich-select-value,\n.ag-rich-select-list {\n  background-color: var(--ag-background-color);\n}\n\n.ag-rich-select-list {\n  width: 100%;\n  height: auto;\n  border-radius: var(--ag-border-radius);\n  border: var(--ag-borders) var(--ag-border-color);\n}\n.ag-rich-select-list .ag-loading-text {\n  padding: var(--ag-widget-vertical-spacing) var(--ag-widget-horizontal-spacing);\n}\n\n.ag-rich-select-value {\n  border-bottom: var(--ag-borders-secondary) var(--ag-secondary-border-color);\n  padding-top: 0;\n  padding-bottom: 0;\n}\n.ag-ltr .ag-rich-select-value {\n  padding-left: calc(var(--ag-cell-horizontal-padding) / 2);\n}\n.ag-rtl .ag-rich-select-value {\n  padding-right: calc(var(--ag-cell-horizontal-padding) / 2);\n}\n.ag-ltr .ag-rich-select-value {\n  padding-right: var(--ag-grid-size);\n}\n.ag-rtl .ag-rich-select-value {\n  padding-left: var(--ag-grid-size);\n}\n\n.ag-ltr .ag-rich-select-field-input {\n  left: calc(var(--ag-cell-horizontal-padding));\n}\n.ag-rtl .ag-rich-select-field-input {\n  right: calc(var(--ag-cell-horizontal-padding));\n}\n\n.ag-popup-editor .ag-rich-select-value {\n  height: var(--ag-row-height);\n  min-width: 200px;\n}\n\n.ag-rich-select-virtual-list-item {\n  cursor: default;\n  height: var(--ag-list-item-height);\n}\n.ag-rich-select-virtual-list-item:focus-visible::after {\n  content: none;\n}\n\n.ag-ltr .ag-rich-select-row {\n  padding-left: calc(var(--ag-cell-horizontal-padding) / 2);\n}\n.ag-rtl .ag-rich-select-row {\n  padding-right: calc(var(--ag-cell-horizontal-padding) / 2);\n}\n\n.ag-rich-select-row-selected {\n  background-color: var(--ag-selected-row-background-color);\n}\n\n.ag-rich-select-row:hover,\n.ag-rich-select-row-highlighted {\n  background-image: linear-gradient(var(--ag-row-hover-color), var(--ag-row-hover-color));\n}\n\n.ag-rich-select-row-text-highlight {\n  font-weight: bold;\n}\n\n.ag-autocomplete {\n  width: 100%;\n}\n\n.ag-autocomplete-list {\n  width: 100%;\n  min-width: 200px;\n  height: calc(var(--ag-row-height) * 6.5);\n}\n\n.ag-autocomplete-virtual-list-item {\n  cursor: default;\n  height: var(--ag-list-item-height);\n}\n.ag-autocomplete-virtual-list-item:focus-visible::after {\n  content: none;\n}\n.ag-autocomplete-virtual-list-item:hover {\n  background-color: var(--ag-row-hover-color);\n}\n\n.ag-autocomplete-row-label {\n  margin: 0px var(--ag-widget-container-horizontal-padding);\n}\n\n.ag-autocomplete-row-selected {\n  background-color: var(--ag-selected-row-background-color);\n}\n\n.ag-pill {\n  border: 1px solid var(--ag-chip-border-color);\n  border-radius: var(--ag-border-radius);\n  background-color: var(--ag-chip-background-color);\n}\n\n.ag-ltr .ag-pill .ag-pill-button {\n  margin-left: var(--ag-grid-size);\n}\n.ag-rtl .ag-pill .ag-pill-button {\n  margin-right: var(--ag-grid-size);\n}\n\n.ag-pill:focus-visible {\n  border-color: var(--ag-input-focus-border-color);\n}\n\n.ag-pill .ag-pill-button:hover {\n  cursor: pointer;\n}\n\n.ag-dragging-range-handle .ag-dialog,\n.ag-dragging-fill-handle .ag-dialog {\n  opacity: 0.7;\n  pointer-events: none;\n}\n\n.ag-dialog {\n  border-radius: var(--ag-border-radius);\n  border: var(--ag-borders) var(--ag-border-color);\n  box-shadow: var(--ag-popup-shadow);\n}\n\n.ag-panel {\n  background-color: var(--ag-panel-background-color);\n  border-color: var(--ag-panel-border-color);\n}\n\n.ag-panel-title-bar {\n  color: var(--ag-header-foreground-color);\n  height: var(--ag-header-height);\n  padding: var(--ag-grid-size) var(--ag-cell-horizontal-padding);\n  border-bottom: var(--ag-borders) var(--ag-border-color);\n}\n\n.ag-ltr .ag-panel-title-bar-button {\n  margin-left: var(--ag-grid-size);\n}\n.ag-rtl .ag-panel-title-bar-button {\n  margin-right: var(--ag-grid-size);\n}\n\n.ag-tooltip {\n  background-color: var(--ag-tooltip-background-color);\n  color: var(--ag-foreground-color);\n  padding: var(--ag-grid-size);\n  border: var(--ag-borders) var(--ag-border-color);\n  border-radius: var(--ag-card-radius);\n  white-space: normal;\n}\n.ag-tooltip.ag-cell-editor-tooltip {\n  background-color: var(--ag-tooltip-error-background-color);\n  color: var(--ag-tooltip-error-text-color);\n  border: var(--ag-borders) var(--ag-tooltip-error-border-color);\n  font-weight: 500;\n}\n\n.ag-tooltip.ag-tooltip-animate,\n.ag-tooltip-custom.ag-tooltip-animate {\n  transition: opacity 1s;\n}\n.ag-tooltip.ag-tooltip-animate.ag-tooltip-hiding,\n.ag-tooltip-custom.ag-tooltip-animate.ag-tooltip-hiding {\n  opacity: 0;\n}\n\n.ag-ltr .ag-column-select-column,\n.ag-ltr .ag-column-select-column-group {\n  padding-left: calc(var(--ag-indentation-level) * var(--ag-column-select-indent-size));\n}\n.ag-rtl .ag-column-select-column,\n.ag-rtl .ag-column-select-column-group {\n  padding-right: calc(var(--ag-indentation-level) * var(--ag-column-select-indent-size));\n}\n\n.ag-column-select-header-icon {\n  cursor: pointer;\n}\n\n.ag-column-select-header-icon:focus-visible {\n  outline: none;\n}\n.ag-column-select-header-icon:focus-visible::after {\n  content: \"\";\n  position: absolute;\n  background-color: transparent;\n  pointer-events: none;\n  top: 0px;\n  left: 0px;\n  display: block;\n  width: calc(100% - 0px);\n  height: calc(100% - 0px);\n  border: 1px solid;\n  border-color: var(--ag-input-focus-border-color);\n}\n\n.ag-ltr .ag-column-group-icons:not(:last-child),\n.ag-ltr .ag-column-select-header-icon:not(:last-child),\n.ag-ltr .ag-column-select-header-checkbox:not(:last-child),\n.ag-ltr .ag-column-select-header-filter-wrapper:not(:last-child),\n.ag-ltr .ag-column-select-checkbox:not(:last-child),\n.ag-ltr .ag-column-select-column-drag-handle:not(:last-child),\n.ag-ltr .ag-column-select-column-group-drag-handle:not(:last-child),\n.ag-ltr .ag-column-select-column-label:not(:last-child) {\n  margin-right: var(--ag-widget-horizontal-spacing);\n}\n.ag-rtl .ag-column-group-icons:not(:last-child),\n.ag-rtl .ag-column-select-header-icon:not(:last-child),\n.ag-rtl .ag-column-select-header-checkbox:not(:last-child),\n.ag-rtl .ag-column-select-header-filter-wrapper:not(:last-child),\n.ag-rtl .ag-column-select-checkbox:not(:last-child),\n.ag-rtl .ag-column-select-column-drag-handle:not(:last-child),\n.ag-rtl .ag-column-select-column-group-drag-handle:not(:last-child),\n.ag-rtl .ag-column-select-column-label:not(:last-child) {\n  margin-left: var(--ag-widget-horizontal-spacing);\n}\n\n.ag-column-select-virtual-list-item:focus-visible {\n  outline: none;\n}\n.ag-column-select-virtual-list-item:focus-visible::after {\n  content: \"\";\n  position: absolute;\n  background-color: transparent;\n  pointer-events: none;\n  top: 1px;\n  left: 1px;\n  display: block;\n  width: calc(100% - 2px);\n  height: calc(100% - 2px);\n  border: 1px solid;\n  border-color: var(--ag-input-focus-border-color);\n}\n\n.ag-column-select-column-group:not(:last-child),\n.ag-column-select-column:not(:last-child) {\n  margin-bottom: var(--ag-widget-vertical-spacing);\n}\n\n.ag-column-select-column-readonly,\n.ag-column-select-column-group-readonly {\n  color: var(--ag-disabled-foreground-color);\n  pointer-events: none;\n}\n\n.ag-ltr .ag-column-select-add-group-indent {\n  margin-left: calc(var(--ag-icon-size) + var(--ag-grid-size) * 2);\n}\n.ag-rtl .ag-column-select-add-group-indent {\n  margin-right: calc(var(--ag-icon-size) + var(--ag-grid-size) * 2);\n}\n\n.ag-column-select-virtual-list-viewport {\n  padding: calc(var(--ag-widget-container-vertical-padding) * 0.5) 0px;\n}\n\n.ag-column-select-virtual-list-item {\n  padding: 0 var(--ag-widget-container-horizontal-padding);\n}\n\n.ag-checkbox-edit {\n  padding-left: var(--ag-cell-horizontal-padding);\n  padding-right: var(--ag-cell-horizontal-padding);\n}\n\n.ag-pill-select .ag-column-drop {\n  border-bottom: 0;\n  min-height: unset;\n}\n.ag-pill-select .ag-column-drop-list {\n  padding: 0;\n}\n.ag-pill-select .ag-select {\n  padding-top: var(--ag-grid-size);\n}\n.ag-pill-select .ag-picker-field-wrapper {\n  background-color: transparent;\n  border: 0;\n}\n.ag-pill-select .ag-picker-field-display {\n  cursor: pointer;\n}\n\n.ag-rtl {\n  text-align: right;\n}\n\n.ag-root-wrapper {\n  border-radius: var(--ag-wrapper-border-radius);\n  border: var(--ag-borders) var(--ag-border-color);\n}\n\n.ag-row > .ag-cell-wrapper.ag-row-group {\n  padding-left: calc(var(--ag-cell-horizontal-padding) + var(--ag-row-group-indent-size) * var(--ag-indentation-level));\n}\n\n.ag-cell-wrapper.ag-row-group,\n.ag-cell-wrapper.ag-row-group-leaf-indent,\n.ag-cell-wrapper.ag-pivot-leaf-group {\n  padding-left: calc(var(--ag-indentation-level) * var(--ag-row-group-indent-size));\n}\n\n.ag-cell-wrapper > .ag-group-checkbox-spacing {\n  width: var(--ag-icon-size);\n  margin-right: var(--ag-cell-widget-spacing);\n}\n\n.ag-ltr .ag-row-group-leaf-indent {\n  margin-left: var(--ag-row-group-indent-size);\n}\n.ag-rtl .ag-row-group-leaf-indent {\n  margin-right: var(--ag-row-group-indent-size);\n}\n\n.ag-row:not(.ag-row-level-0) .ag-pivot-leaf-group {\n  margin-left: var(--ag-row-group-indent-size);\n}\n\n.ag-value-change-delta {\n  padding-right: 2px;\n}\n\n.ag-value-change-delta-up {\n  color: var(--ag-value-change-delta-up-color);\n}\n\n.ag-value-change-delta-down {\n  color: var(--ag-value-change-delta-down-color);\n}\n\n.ag-value-change-value {\n  background-color: transparent;\n  border-radius: 1px;\n  padding-left: 1px;\n  padding-right: 1px;\n  transition: background-color 1s;\n}\n\n.ag-value-change-value-highlight {\n  background-color: var(--ag-value-change-value-highlight-background-color);\n  transition: background-color 0.1s;\n}\n\n.ag-cell-data-changed {\n  background-color: var(--ag-value-change-value-highlight-background-color) !important;\n}\n\n.ag-cell-data-changed-animation {\n  background-color: transparent;\n}\n\n.ag-cell-highlight {\n  background-color: var(--ag-range-selection-highlight-color) !important;\n}\n\n.ag-row,\n.ag-spanned-row {\n  color: var(--ag-data-color);\n}\n\n.ag-row {\n  height: var(--ag-row-height);\n  background-color: var(--ag-background-color);\n  border-bottom: var(--ag-row-border-style) var(--ag-row-border-color) var(--ag-row-border-width);\n}\n.ag-row.ag-row-editing-invalid {\n  background-color: var(--ag-full-row-invalid-background-color);\n}\n\n.ag-spanned-cell-wrapper {\n  background-color: var(--ag-background-color);\n  position: absolute;\n}\n\n.ag-spanned-cell-wrapper > .ag-spanned-cell {\n  display: block;\n  position: relative;\n}\n\n.ag-row-highlight-above::after,\n.ag-row-highlight-inside::after,\n.ag-row-highlight-below::after {\n  content: \"\";\n  position: absolute;\n  width: calc(100% - 1px);\n  height: 1px;\n  background-color: var(--ag-range-selection-border-color);\n  left: 1px;\n  pointer-events: none;\n}\n\n.ag-row-highlight-above::after {\n  top: 0;\n}\n\n.ag-row-highlight-below::after {\n  bottom: 0;\n}\n\n.ag-row-highlight-indent::after {\n  display: block;\n  width: auto;\n  left: calc(2 * (var(--ag-cell-widget-spacing) + var(--ag-icon-size)) + var(--ag-cell-horizontal-padding) + var(--ag-row-highlight-level) * var(--ag-row-group-indent-size));\n  right: 1px;\n}\n\n.ag-row-highlight-inside::after {\n  display: block;\n  width: auto;\n  height: auto;\n  inset: 0;\n  background-color: var(--ag-selected-row-background-color);\n  border: 1px solid var(--ag-range-selection-border-color);\n}\n\n.ag-row-odd {\n  background-color: var(--ag-odd-row-background-color);\n}\n\n.ag-body-horizontal-scroll:not(.ag-scrollbar-invisible) .ag-horizontal-left-spacer:not(.ag-scroller-corner) {\n  border-right: var(--ag-borders-critical) var(--ag-border-color);\n}\n.ag-body-horizontal-scroll:not(.ag-scrollbar-invisible) .ag-horizontal-right-spacer:not(.ag-scroller-corner) {\n  border-left: var(--ag-borders-critical) var(--ag-border-color);\n}\n\n.ag-row-selected::before {\n  content: \"\";\n  background-color: var(--ag-selected-row-background-color);\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n}\n\n.ag-row-hover:not(.ag-full-width-row)::before,\n.ag-row-hover.ag-full-width-row.ag-row-group::before {\n  content: \"\";\n  background-color: var(--ag-row-hover-color);\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  pointer-events: none;\n}\n\n.ag-row.ag-full-width-row.ag-row-group > * {\n  position: relative;\n}\n\n.ag-row-hover.ag-row-selected::before {\n  background-color: var(--ag-row-hover-color);\n  background-image: linear-gradient(var(--ag-selected-row-background-color), var(--ag-selected-row-background-color));\n}\n\n.ag-column-hover {\n  background-color: var(--ag-column-hover-color);\n}\n\n.ag-header-range-highlight {\n  background-color: var(--ag-range-header-highlight-color);\n}\n\n.ag-ltr .ag-right-aligned-cell {\n  text-align: right;\n}\n.ag-rtl .ag-right-aligned-cell {\n  text-align: left;\n}\n\n.ag-ltr .ag-right-aligned-cell .ag-cell-value,\n.ag-ltr .ag-right-aligned-cell .ag-group-value {\n  margin-left: auto;\n}\n.ag-rtl .ag-right-aligned-cell .ag-cell-value,\n.ag-rtl .ag-right-aligned-cell .ag-group-value {\n  margin-right: auto;\n}\n\n.ag-ltr .ag-right-aligned-cell .ag-skeleton-effect {\n  margin-left: auto;\n}\n.ag-rtl .ag-right-aligned-cell .ag-skeleton-effect {\n  margin-right: auto;\n}\n\n.ag-cell,\n.ag-full-width-row .ag-cell-wrapper.ag-row-group {\n  --ag-internal-calculated-line-height: var(\n      --ag-line-height,\n      calc(var(--ag-row-height) - var(--ag-row-border-width))\n  );\n  --ag-internal-padded-row-height: calc(var(--ag-row-height) - var(--ag-row-border-width) - 2px);\n  border: 1px solid transparent;\n  line-height: min(var(--ag-internal-calculated-line-height), var(--ag-internal-padded-row-height));\n  padding-left: calc(var(--ag-cell-horizontal-padding) - 1px + var(--ag-row-group-indent-size) * var(--ag-indentation-level));\n  padding-right: calc(var(--ag-cell-horizontal-padding) - 1px);\n  -webkit-font-smoothing: subpixel-antialiased;\n}\n\n.ag-row > .ag-cell-wrapper {\n  padding-left: calc(var(--ag-cell-horizontal-padding) - 1px);\n  padding-right: calc(var(--ag-cell-horizontal-padding) - 1px);\n}\n\n.ag-row-dragging {\n  cursor: move;\n  opacity: 0.5;\n}\n\n.ag-cell-inline-editing {\n  border: 1px solid var(--ag-border-color);\n  border-radius: var(--ag-card-radius);\n  box-shadow: var(--ag-card-shadow);\n  padding: 0;\n  background-color: var(--ag-control-panel-background-color);\n}\n\n.ag-popup-editor .ag-large-text,\n.ag-autocomplete-list-popup {\n  border: var(--ag-borders) var(--ag-border-color);\n  background: var(--ag-background-color);\n  border-radius: var(--ag-card-radius);\n  box-shadow: var(--ag-card-shadow);\n  padding: var(--ag-grid-size);\n  background-color: var(--ag-control-panel-background-color);\n  padding: 0;\n}\n\n.ag-large-text-input {\n  height: auto;\n  padding: var(--ag-cell-horizontal-padding);\n}\n\n.ag-rtl .ag-large-text-input textarea {\n  resize: none;\n}\n\n.ag-details-row {\n  padding: calc(var(--ag-grid-size) * 5);\n  background-color: var(--ag-background-color);\n}\n\n.ag-layout-auto-height .ag-center-cols-viewport,\n.ag-layout-auto-height .ag-center-cols-container,\n.ag-layout-print .ag-center-cols-viewport,\n.ag-layout-print .ag-center-cols-container {\n  min-height: 50px;\n}\n\n.ag-overlay-loading-wrapper {\n  background-color: var(--ag-modal-overlay-background-color);\n}\n\n.ag-overlay-loading-center {\n  border: var(--ag-borders) var(--ag-border-color);\n  background: var(--ag-background-color);\n  border-radius: var(--ag-card-radius);\n  box-shadow: var(--ag-card-shadow);\n  padding: var(--ag-grid-size);\n}\n\n.ag-skeleton-container {\n  width: 100%;\n  height: 100%;\n  align-content: center;\n}\n\n.ag-skeleton-effect {\n  background-color: var(--ag-row-loading-skeleton-effect-color);\n  width: 100%;\n  height: 1em;\n  border-radius: 0.25rem;\n  animation: ag-skeleton-loading 1.5s ease-in-out 0.5s infinite;\n}\n\n@keyframes ag-skeleton-loading {\n  0% {\n    opacity: 1;\n  }\n  50% {\n    opacity: 0.4;\n  }\n  100% {\n    opacity: 1;\n  }\n}\n.ag-loading {\n  display: flex;\n  height: 100%;\n  align-items: center;\n}\n.ag-ltr .ag-loading {\n  padding-left: var(--ag-cell-horizontal-padding);\n}\n.ag-rtl .ag-loading {\n  padding-right: var(--ag-cell-horizontal-padding);\n}\n\n.ag-ltr .ag-loading-icon {\n  padding-right: var(--ag-cell-widget-spacing);\n}\n.ag-rtl .ag-loading-icon {\n  padding-left: var(--ag-cell-widget-spacing);\n}\n\n.ag-icon-loading {\n  animation-name: spin;\n  animation-duration: 1000ms;\n  animation-iteration-count: infinite;\n  animation-timing-function: linear;\n}\n\n@keyframes spin {\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n}\n.ag-floating-top:not(.ag-invisible) {\n  border-bottom: var(--ag-borders-critical) var(--ag-border-color);\n}\n\n.ag-floating-bottom:not(.ag-invisible) {\n  border-top: var(--ag-borders-critical) var(--ag-border-color);\n}\n\n.ag-find-cell {\n  display: block;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n.ag-find-match {\n  color: var(--ag-find-match-color);\n  background-color: var(--ag-find-match-background-color);\n}\n\n.ag-find-active-match {\n  color: var(--ag-find-active-match-color);\n  background-color: var(--ag-find-active-match-background-color);\n}\n\n.ag-ltr .ag-cell {\n  border-right: var(--ag-cell-horizontal-border);\n}\n.ag-rtl .ag-cell {\n  border-left: var(--ag-cell-horizontal-border);\n}\n.ag-ltr .ag-cell {\n  border-right-width: 1px;\n}\n.ag-rtl .ag-cell {\n  border-left-width: 1px;\n}\n\n.ag-cell.ag-cell-first-right-pinned:not(.ag-cell-range-left):not(.ag-cell-range-single-cell) {\n  border-left: var(--ag-borders-critical) var(--ag-border-color);\n}\n\n.ag-cell.ag-cell-last-left-pinned:not(.ag-cell-range-right):not(.ag-cell-range-single-cell) {\n  border-right: var(--ag-borders-critical) var(--ag-border-color);\n}\n\n.ag-cell-range-selected:not(.ag-cell-focus),\n.ag-cell-range-selected.ag-cell-range-chart,\n.ag-body-viewport:not(.ag-has-focus) .ag-cell-range-single-cell:not(.ag-cell-inline-editing) {\n  background-color: var(--ag-range-selection-background-color);\n}\n.ag-cell-range-selected:not(.ag-cell-focus).ag-cell-range-chart,\n.ag-cell-range-selected.ag-cell-range-chart.ag-cell-range-chart,\n.ag-body-viewport:not(.ag-has-focus) .ag-cell-range-single-cell:not(.ag-cell-inline-editing).ag-cell-range-chart {\n  background-color: var(--ag-range-selection-chart-background-color) !important;\n}\n.ag-cell-range-selected:not(.ag-cell-focus).ag-cell-range-chart.ag-cell-range-chart-category,\n.ag-cell-range-selected.ag-cell-range-chart.ag-cell-range-chart.ag-cell-range-chart-category,\n.ag-body-viewport:not(.ag-has-focus) .ag-cell-range-single-cell:not(.ag-cell-inline-editing).ag-cell-range-chart.ag-cell-range-chart-category {\n  background-color: var(--ag-range-selection-chart-category-background-color) !important;\n}\n\n.ag-cell-range-selected-1:not(.ag-cell-focus),\n.ag-cell-range-selected-1.ag-cell-range-chart,\n.ag-root:not(.ag-context-menu-open) .ag-body-viewport:not(.ag-has-focus) .ag-cell-range-selected-1:not(.ag-cell-inline-editing) {\n  background-color: var(--ag-range-selection-background-color);\n}\n\n.ag-cell-range-selected-2:not(.ag-cell-focus),\n.ag-cell-range-selected-2.ag-cell-range-chart,\n.ag-body-viewport:not(.ag-has-focus) .ag-cell-range-selected-2 {\n  background-color: var(--ag-range-selection-background-color-2);\n}\n\n.ag-cell-range-selected-3:not(.ag-cell-focus),\n.ag-cell-range-selected-3.ag-cell-range-chart,\n.ag-body-viewport:not(.ag-has-focus) .ag-cell-range-selected-3 {\n  background-color: var(--ag-range-selection-background-color-3);\n}\n\n.ag-cell-range-selected-4:not(.ag-cell-focus),\n.ag-cell-range-selected-4.ag-cell-range-chart,\n.ag-body-viewport:not(.ag-has-focus) .ag-cell-range-selected-4 {\n  background-color: var(--ag-range-selection-background-color-4);\n}\n\n.ag-cell.ag-cell-range-selected:not(.ag-cell-range-single-cell).ag-cell-range-top {\n  border-top-color: var(--ag-range-selection-border-color);\n  border-top-style: var(--ag-range-selection-border-style);\n}\n.ag-cell.ag-cell-range-selected:not(.ag-cell-range-single-cell).ag-cell-range-right {\n  border-right-color: var(--ag-range-selection-border-color);\n  border-right-style: var(--ag-range-selection-border-style);\n}\n.ag-cell.ag-cell-range-selected:not(.ag-cell-range-single-cell).ag-cell-range-bottom {\n  border-bottom-color: var(--ag-range-selection-border-color);\n  border-bottom-style: var(--ag-range-selection-border-style);\n}\n.ag-cell.ag-cell-range-selected:not(.ag-cell-range-single-cell).ag-cell-range-left {\n  border-left-color: var(--ag-range-selection-border-color);\n  border-left-style: var(--ag-range-selection-border-style);\n}\n\n.ag-ltr .ag-cell-focus:not(.ag-cell-range-selected):focus-within,\n.ag-ltr .ag-context-menu-open .ag-cell-focus:not(.ag-cell-range-selected),\n.ag-ltr .ag-full-width-row.ag-row-focus:focus .ag-cell-wrapper.ag-row-group,\n.ag-ltr .ag-cell-range-single-cell,\n.ag-ltr .ag-cell-range-single-cell.ag-cell-range-handle,\n.ag-rtl .ag-cell-focus:not(.ag-cell-range-selected):focus-within,\n.ag-rtl .ag-context-menu-open .ag-cell-focus:not(.ag-cell-range-selected),\n.ag-rtl .ag-full-width-row.ag-row-focus:focus .ag-cell-wrapper.ag-row-group,\n.ag-rtl .ag-cell-range-single-cell,\n.ag-rtl .ag-cell-range-single-cell.ag-cell-range-handle {\n  border: 1px solid;\n  border-color: var(--ag-range-selection-border-color);\n  border-style: var(--ag-range-selection-border-style);\n  outline: initial;\n}\n\n.ag-cell.ag-selection-fill-top,\n.ag-cell.ag-selection-fill-top.ag-cell-range-selected {\n  border-top: 1px dashed;\n  border-top-color: var(--ag-range-selection-border-color);\n}\n\n.ag-ltr .ag-cell.ag-selection-fill-right,\n.ag-ltr .ag-cell.ag-selection-fill-right.ag-cell-range-selected {\n  border-right: 1px dashed var(--ag-range-selection-border-color) !important;\n}\n.ag-rtl .ag-cell.ag-selection-fill-right,\n.ag-rtl .ag-cell.ag-selection-fill-right.ag-cell-range-selected {\n  border-left: 1px dashed var(--ag-range-selection-border-color) !important;\n}\n\n.ag-cell.ag-selection-fill-bottom,\n.ag-cell.ag-selection-fill-bottom.ag-cell-range-selected {\n  border-bottom: 1px dashed;\n  border-bottom-color: var(--ag-range-selection-border-color);\n}\n\n.ag-ltr .ag-cell.ag-selection-fill-left,\n.ag-ltr .ag-cell.ag-selection-fill-left.ag-cell-range-selected {\n  border-left: 1px dashed var(--ag-range-selection-border-color) !important;\n}\n.ag-rtl .ag-cell.ag-selection-fill-left,\n.ag-rtl .ag-cell.ag-selection-fill-left.ag-cell-range-selected {\n  border-right: 1px dashed var(--ag-range-selection-border-color) !important;\n}\n\n.ag-fill-handle,\n.ag-range-handle {\n  position: absolute;\n  width: 6px;\n  height: 6px;\n  bottom: -1px;\n  background-color: var(--ag-range-selection-border-color);\n}\n.ag-ltr .ag-fill-handle,\n.ag-ltr .ag-range-handle {\n  right: -1px;\n}\n.ag-rtl .ag-fill-handle,\n.ag-rtl .ag-range-handle {\n  left: -1px;\n}\n\n.ag-fill-handle {\n  cursor: cell;\n}\n\n.ag-range-handle {\n  cursor: nwse-resize;\n}\n\n.ag-cell-inline-editing {\n  border-color: var(--ag-input-focus-border-color) !important;\n}\n.ag-cell-inline-editing.ag-cell-editing-error {\n  border-color: var(--ag-invalid-color) !important;\n}\n\n.ag-menu {\n  border: var(--ag-borders) var(--ag-border-color);\n  background: var(--ag-background-color);\n  border-radius: var(--ag-card-radius);\n  box-shadow: var(--ag-card-shadow);\n  padding: var(--ag-grid-size);\n  background-color: var(--ag-menu-background-color);\n  border-color: var(--ag-menu-border-color);\n  padding: 0;\n}\n\n.ag-menu.ag-tabs {\n  min-width: var(--ag-tab-min-width);\n}\n\n.ag-menu-list {\n  cursor: default;\n  padding: var(--ag-grid-size) 0;\n}\n\n.ag-menu-separator {\n  height: calc(var(--ag-grid-size) * 2 + 1px);\n}\n\n.ag-menu-separator-part::after {\n  content: \"\";\n  display: block;\n  border-top: var(--ag-borders-critical) var(--ag-border-color);\n}\n\n.ag-menu-option {\n  position: relative;\n}\n\n.ag-menu-option:focus-visible {\n  outline: none;\n}\n.ag-menu-option:focus-visible::after {\n  content: \"\";\n  position: absolute;\n  background-color: transparent;\n  pointer-events: none;\n  top: 1px;\n  left: 1px;\n  display: block;\n  width: calc(100% - 2px);\n  height: calc(100% - 2px);\n  border: 1px solid;\n  border-color: var(--ag-input-focus-border-color);\n}\n\n.ag-menu-option-active,\n.ag-compact-menu-option-active {\n  background-color: var(--ag-row-hover-color);\n}\n\n.ag-menu-option-part,\n.ag-compact-menu-option-part {\n  line-height: var(--ag-icon-size);\n  padding: calc(var(--ag-grid-size) + 2px) 0;\n}\n\n.ag-menu-option-disabled,\n.ag-compact-menu-option-disabled {\n  opacity: 0.5;\n}\n\n.ag-menu-option-icon,\n.ag-compact-menu-option-icon {\n  width: var(--ag-icon-size);\n}\n.ag-ltr .ag-menu-option-icon,\n.ag-ltr .ag-compact-menu-option-icon {\n  padding-left: calc(var(--ag-grid-size) * 2);\n}\n.ag-rtl .ag-menu-option-icon,\n.ag-rtl .ag-compact-menu-option-icon {\n  padding-right: calc(var(--ag-grid-size) * 2);\n}\n\n.ag-menu-option-text,\n.ag-compact-menu-option-text {\n  padding-left: calc(var(--ag-grid-size) * 2);\n  padding-right: calc(var(--ag-grid-size) * 2);\n}\n\n.ag-ltr .ag-menu-option-shortcut,\n.ag-ltr .ag-compact-menu-option-shortcut {\n  padding-right: var(--ag-grid-size);\n}\n.ag-rtl .ag-menu-option-shortcut,\n.ag-rtl .ag-compact-menu-option-shortcut {\n  padding-left: var(--ag-grid-size);\n}\n\n.ag-ltr .ag-menu-option-popup-pointer,\n.ag-ltr .ag-compact-menu-option-popup-pointer {\n  padding-right: var(--ag-grid-size);\n}\n.ag-rtl .ag-menu-option-popup-pointer,\n.ag-rtl .ag-compact-menu-option-popup-pointer {\n  padding-left: var(--ag-grid-size);\n}\n\n.ag-tabs-header {\n  display: flex;\n}\n\n.ag-tabs-header-wrapper {\n  display: flex;\n}\n.ag-tabs-header-wrapper .ag-tabs-header {\n  flex: 1;\n}\n\n.ag-tabs-close-button-wrapper {\n  border: 0;\n  border-right: var(--ag-borders) var(--ag-border-color);\n  padding: var(--ag-grid-size);\n}\n\n.ag-tabs-close-button {\n  border: 0;\n  background-color: unset;\n  cursor: pointer;\n  padding: 0;\n}\n\n.ag-tab {\n  border-bottom: var(--ag-selected-tab-underline-width) solid transparent;\n  transition: border-bottom var(--ag-selected-tab-underline-transition-speed);\n  display: flex;\n  flex: none;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n}\n\n.ag-tab:focus-visible {\n  outline: none;\n}\n.ag-tab:focus-visible::after {\n  content: \"\";\n  position: absolute;\n  background-color: transparent;\n  pointer-events: none;\n  top: 4px;\n  left: 4px;\n  display: block;\n  width: calc(100% - 8px);\n  height: calc(100% - 8px);\n  border: 1px solid;\n  border-color: var(--ag-input-focus-border-color);\n}\n\n.ag-tab-selected {\n  border-bottom-color: var(--ag-selected-tab-underline-color);\n}\n\n.ag-menu-header {\n  color: var(--ag-secondary-foreground-color);\n}\n\n.ag-filter-separator {\n  border-top: var(--ag-borders-critical) var(--ag-border-color);\n}\n\n.ag-filter-select .ag-picker-field-wrapper {\n  width: 0;\n}\n\n.ag-filter-condition-operator {\n  height: 17px;\n}\n\n.ag-ltr .ag-filter-condition-operator-or {\n  margin-left: calc(var(--ag-grid-size) * 2);\n}\n.ag-rtl .ag-filter-condition-operator-or {\n  margin-right: calc(var(--ag-grid-size) * 2);\n}\n\n.ag-set-filter-select-all {\n  padding-top: var(--ag-widget-container-vertical-padding);\n}\n\n.ag-set-filter-list,\n.ag-filter-no-matches {\n  height: calc(var(--ag-list-item-height) * 6);\n}\n\n.ag-set-filter-tree-list {\n  height: calc(var(--ag-list-item-height) * 10);\n}\n\n.ag-set-filter-filter {\n  margin-top: var(--ag-widget-container-vertical-padding);\n  margin-left: var(--ag-widget-container-horizontal-padding);\n  margin-right: var(--ag-widget-container-horizontal-padding);\n}\n\n.ag-filter-to {\n  margin-top: var(--ag-widget-vertical-spacing);\n}\n\n.ag-mini-filter {\n  margin: var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding);\n}\n\n.ag-set-filter {\n  --ag-indentation-level: 0;\n}\n\n.ag-ltr .ag-set-filter-item {\n  padding-left: calc(var(--ag-widget-container-horizontal-padding) + var(--ag-indentation-level) * var(--ag-set-filter-indent-size));\n}\n.ag-rtl .ag-set-filter-item {\n  padding-right: calc(var(--ag-widget-container-horizontal-padding) + var(--ag-indentation-level) * var(--ag-set-filter-indent-size));\n}\n\n.ag-ltr .ag-set-filter-add-group-indent {\n  margin-left: calc(var(--ag-icon-size) + var(--ag-widget-container-horizontal-padding));\n}\n.ag-rtl .ag-set-filter-add-group-indent {\n  margin-right: calc(var(--ag-icon-size) + var(--ag-widget-container-horizontal-padding));\n}\n\n.ag-ltr .ag-set-filter-group-icons {\n  margin-right: var(--ag-widget-container-horizontal-padding);\n}\n.ag-rtl .ag-set-filter-group-icons {\n  margin-left: var(--ag-widget-container-horizontal-padding);\n}\n\n.ag-filter-menu .ag-set-filter-list {\n  min-width: 200px;\n}\n\n.ag-filter-virtual-list-item:focus-visible {\n  outline: none;\n}\n.ag-filter-virtual-list-item:focus-visible::after {\n  content: \"\";\n  position: absolute;\n  background-color: transparent;\n  pointer-events: none;\n  top: 1px;\n  left: 1px;\n  display: block;\n  width: calc(100% - 2px);\n  height: calc(100% - 2px);\n  border: 1px solid;\n  border-color: var(--ag-input-focus-border-color);\n}\n\n.ag-filter-apply-panel {\n  padding: var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding);\n  border-top: var(--ag-borders-secondary) var(--ag-secondary-border-color);\n}\n\n.ag-filter-apply-panel-button {\n  line-height: 1.5;\n}\n.ag-ltr .ag-filter-apply-panel-button {\n  margin-left: calc(var(--ag-grid-size) * 2);\n}\n.ag-rtl .ag-filter-apply-panel-button {\n  margin-right: calc(var(--ag-grid-size) * 2);\n}\n\n.ag-simple-filter-body-wrapper {\n  padding: var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding);\n  padding-bottom: calc(var(--ag-widget-container-vertical-padding) - var(--ag-widget-vertical-spacing));\n  overflow-y: auto;\n  min-height: calc(var(--ag-list-item-height) + var(--ag-widget-container-vertical-padding) + var(--ag-widget-vertical-spacing));\n}\n.ag-simple-filter-body-wrapper > * {\n  margin-bottom: var(--ag-widget-vertical-spacing);\n}\n.ag-simple-filter-body-wrapper .ag-resizer-wrapper {\n  margin: 0;\n}\n\n.ag-menu:not(.ag-tabs) .ag-filter .ag-filter-body-wrapper,\n.ag-menu:not(.ag-tabs) .ag-filter > *:not(.ag-filter-wrapper) {\n  min-width: calc(var(--ag-menu-min-width) - 2px);\n}\n\n.ag-filter-no-matches {\n  padding: var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding);\n}\n\n.ag-multi-filter-menu-item {\n  margin: var(--ag-grid-size) 0;\n}\n\n.ag-multi-filter-group-title-bar {\n  padding: calc(var(--ag-grid-size) * 2) var(--ag-grid-size);\n  background-color: transparent;\n}\n\n.ag-group-filter-field-select-wrapper {\n  padding: var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding);\n  padding-bottom: calc(var(--ag-widget-container-vertical-padding) - var(--ag-widget-vertical-spacing));\n}\n.ag-group-filter-field-select-wrapper > * {\n  margin-bottom: var(--ag-widget-vertical-spacing);\n}\n\n.ag-multi-filter-group-title-bar:focus-visible {\n  outline: none;\n}\n.ag-multi-filter-group-title-bar:focus-visible::after {\n  content: \"\";\n  position: absolute;\n  background-color: transparent;\n  pointer-events: none;\n  top: 4px;\n  left: 4px;\n  display: block;\n  width: calc(100% - 8px);\n  height: calc(100% - 8px);\n  border: 1px solid;\n  border-color: var(--ag-input-focus-border-color);\n}\n\n.ag-side-bar {\n  position: relative;\n}\n\n.ag-tool-panel-wrapper {\n  width: var(--ag-side-bar-panel-width);\n  background-color: var(--ag-control-panel-background-color);\n}\n\n.ag-side-buttons {\n  padding-top: calc(var(--ag-grid-size) * 4);\n  width: calc(var(--ag-icon-size) + 4px);\n  position: relative;\n  overflow: hidden;\n}\n\nbutton.ag-side-button-button {\n  color: inherit;\n  font-family: inherit;\n  font-size: inherit;\n  font-weight: inherit;\n  line-height: inherit;\n  background: transparent;\n  padding: calc(var(--ag-grid-size) * 2) 0 calc(var(--ag-grid-size) * 2) 0;\n  width: 100%;\n  margin: 0;\n  min-height: calc(var(--ag-grid-size) * 18);\n  background-position-y: center;\n  background-position-x: center;\n  background-repeat: no-repeat;\n  border: none;\n  border-top: var(--ag-borders-side-button) var(--ag-border-color);\n  border-bottom: var(--ag-borders-side-button) var(--ag-border-color);\n}\nbutton.ag-side-button-button:focus {\n  box-shadow: none;\n}\n\n.ag-side-button-button:focus-visible {\n  outline: none;\n}\n.ag-side-button-button:focus-visible::after {\n  content: \"\";\n  position: absolute;\n  background-color: transparent;\n  pointer-events: none;\n  top: 4px;\n  left: 4px;\n  display: block;\n  width: calc(100% - 8px);\n  height: calc(100% - 8px);\n  border: 1px solid;\n  border-color: var(--ag-input-focus-border-color);\n}\n\n.ag-selected button.ag-side-button-button {\n  background-color: var(--ag-side-button-selected-background-color);\n}\n\n.ag-side-button-icon-wrapper {\n  margin-bottom: 3px;\n}\n\n.ag-ltr .ag-side-bar-left,\n.ag-rtl .ag-side-bar-right {\n  border-right: var(--ag-borders) var(--ag-border-color);\n}\n.ag-ltr .ag-side-bar-left .ag-tool-panel-wrapper,\n.ag-rtl .ag-side-bar-right .ag-tool-panel-wrapper {\n  border-left: var(--ag-borders) var(--ag-border-color);\n}\n.ag-ltr .ag-side-bar-left .ag-side-button-button,\n.ag-rtl .ag-side-bar-right .ag-side-button-button {\n  border-right: var(--ag-selected-tab-underline-width) solid transparent;\n  transition: border-right var(--ag-selected-tab-underline-transition-speed);\n}\n.ag-ltr .ag-side-bar-left .ag-selected .ag-side-button-button,\n.ag-rtl .ag-side-bar-right .ag-selected .ag-side-button-button {\n  border-right-color: var(--ag-selected-tab-underline-color);\n}\n\n.ag-rtl .ag-side-bar-left,\n.ag-ltr .ag-side-bar-right {\n  border-left: var(--ag-borders) var(--ag-border-color);\n}\n.ag-rtl .ag-side-bar-left .ag-tool-panel-wrapper,\n.ag-ltr .ag-side-bar-right .ag-tool-panel-wrapper {\n  border-right: var(--ag-borders) var(--ag-border-color);\n}\n.ag-rtl .ag-side-bar-left .ag-side-button-button,\n.ag-ltr .ag-side-bar-right .ag-side-button-button {\n  border-left: var(--ag-selected-tab-underline-width) solid transparent;\n  transition: border-left var(--ag-selected-tab-underline-transition-speed);\n}\n.ag-rtl .ag-side-bar-left .ag-selected .ag-side-button-button,\n.ag-ltr .ag-side-bar-right .ag-selected .ag-side-button-button {\n  border-left-color: var(--ag-selected-tab-underline-color);\n}\n\n.ag-filter-toolpanel-header {\n  height: calc(var(--ag-grid-size) * 6);\n}\n\n.ag-filter-toolpanel-header,\n.ag-filter-toolpanel-search {\n  padding: 0 var(--ag-grid-size);\n}\n\n.ag-filter-toolpanel-header:focus-visible {\n  outline: none;\n}\n.ag-filter-toolpanel-header:focus-visible::after {\n  content: \"\";\n  position: absolute;\n  background-color: transparent;\n  pointer-events: none;\n  top: 4px;\n  left: 4px;\n  display: block;\n  width: calc(100% - 8px);\n  height: calc(100% - 8px);\n  border: 1px solid;\n  border-color: var(--ag-input-focus-border-color);\n}\n\n.ag-filter-toolpanel-group:not(.ag-has-filter) > .ag-group-title-bar .ag-filter-toolpanel-group-instance-header-icon {\n  display: none;\n}\n\n.ag-filter-toolpanel-group-level-0-header {\n  height: calc(var(--ag-grid-size) * 8);\n}\n\n.ag-filter-toolpanel-group-item {\n  margin-top: calc(var(--ag-grid-size) * 0.5);\n  margin-bottom: calc(var(--ag-grid-size) * 0.5);\n}\n\n.ag-filter-toolpanel-search {\n  height: var(--ag-header-height);\n}\n\n.ag-filter-toolpanel-search-input {\n  flex-grow: 1;\n  height: calc(var(--ag-grid-size) * 4);\n}\n.ag-ltr .ag-filter-toolpanel-search-input {\n  margin-right: var(--ag-grid-size);\n}\n.ag-rtl .ag-filter-toolpanel-search-input {\n  margin-left: var(--ag-grid-size);\n}\n\n.ag-filter-toolpanel-group-level-0 {\n  border-top: var(--ag-borders-secondary) var(--ag-secondary-border-color);\n}\n\n.ag-ltr .ag-filter-toolpanel-expand,\n.ag-ltr .ag-filter-toolpanel-group-title-bar-icon {\n  margin-right: var(--ag-grid-size);\n}\n.ag-rtl .ag-filter-toolpanel-expand,\n.ag-rtl .ag-filter-toolpanel-group-title-bar-icon {\n  margin-left: var(--ag-grid-size);\n}\n\n.ag-filter-toolpanel-group-title-bar {\n  background-color: transparent;\n}\n\n.ag-ltr .ag-filter-toolpanel-header {\n  padding-left: calc(var(--ag-filter-tool-panel-group-indent) * var(--ag-indentation-level, 0) + var(--ag-grid-size));\n}\n.ag-rtl .ag-filter-toolpanel-header {\n  padding-right: calc(var(--ag-filter-tool-panel-group-indent) * var(--ag-indentation-level, 0) + var(--ag-grid-size));\n}\n\n.ag-filter-toolpanel-instance-filter {\n  border-bottom: var(--ag-borders) var(--ag-border-color);\n  border-top: var(--ag-borders) var(--ag-border-color);\n  margin-top: var(--ag-grid-size);\n}\n\n.ag-ltr .ag-filter-toolpanel-group-instance-header-icon,\n.ag-ltr .ag-filter-toolpanel-instance-header-icon {\n  margin-left: var(--ag-grid-size);\n}\n.ag-rtl .ag-filter-toolpanel-group-instance-header-icon,\n.ag-rtl .ag-filter-toolpanel-instance-header-icon {\n  margin-right: var(--ag-grid-size);\n}\n\n.ag-set-filter-group-icons {\n  color: var(--ag-secondary-foreground-color);\n}\n\n.ag-filter-panel {\n  display: flex;\n  flex-direction: column;\n  width: 100%;\n}\n.ag-filter-panel .ag-simple-filter-body-wrapper {\n  padding: var(--ag-widget-vertical-spacing) var(--ag-widget-container-horizontal-padding) 0;\n}\n.ag-filter-panel .ag-mini-filter {\n  margin-top: var(--ag-widget-vertical-spacing);\n  margin-left: var(--ag-widget-container-horizontal-padding);\n  margin-right: var(--ag-widget-container-horizontal-padding);\n}\n.ag-filter-panel .ag-standard-button {\n  transition: background-color 0.25s ease-in-out, color 0.25s ease-in-out;\n}\n.ag-filter-panel .ag-simple-filter-body-wrapper > *:last-child,\n.ag-filter-panel .ag-set-filter-body-wrapper {\n  margin-bottom: var(--ag-widget-container-vertical-padding);\n}\n\n.ag-filter-panel-container {\n  flex: 1;\n  overflow: auto;\n  padding: var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding) 0;\n}\n\n.ag-filter-panel-container > *:not(:last-child) {\n  margin-bottom: var(--ag-widget-container-vertical-padding);\n}\n\n.ag-filter-card {\n  border: 1px solid var(--ag-border-color);\n  border-radius: var(--ag-border-radius);\n  background-color: var(--ag-background-color);\n}\n.ag-ltr .ag-filter-card .ag-set-filter-item {\n  padding-left: calc(var(--ag-widget-container-horizontal-padding) + var(--ag-indentation-level) * var(--ag-set-filter-indent-size));\n  padding-right: var(--ag-widget-container-horizontal-padding);\n}\n.ag-rtl .ag-filter-card .ag-set-filter-item {\n  padding-right: calc(var(--ag-widget-container-horizontal-padding) + var(--ag-indentation-level) * var(--ag-set-filter-indent-size));\n  padding-left: var(--ag-widget-container-horizontal-padding);\n}\n\n.ag-filter-card-header {\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  padding-top: var(--ag-widget-vertical-spacing);\n}\n.ag-ltr .ag-filter-card-header > *:not(:last-child) {\n  padding-right: var(--ag-grid-size);\n}\n.ag-rtl .ag-filter-card-header > *:not(:last-child) {\n  padding-left: var(--ag-grid-size);\n}\n\n.ag-filter-card-heading {\n  flex: 1;\n  overflow: hidden;\n  padding-top: calc(var(--ag-widget-container-vertical-padding) - var(--ag-widget-vertical-spacing));\n  padding-bottom: calc(var(--ag-widget-container-vertical-padding) - var(--ag-widget-vertical-spacing));\n}\n.ag-ltr .ag-filter-card-heading {\n  padding-left: var(--ag-widget-horizontal-spacing);\n}\n.ag-rtl .ag-filter-card-heading {\n  padding-right: var(--ag-widget-horizontal-spacing);\n}\n\n.ag-filter-card-expand {\n  display: flex;\n  flex-direction: row;\n  width: 100%;\n  justify-content: space-between;\n  align-items: center;\n}\n\n.ag-filter-card-title {\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n.ag-filter-card-expand-icon {\n  display: flex;\n  flex: 1;\n  justify-content: end;\n}\n\n.ag-filter-card-editing-icon {\n  margin: 0 var(--ag-grid-size);\n}\n\n.ag-filter-card-summary,\n.ag-filter-card-expand-icon .ag-icon,\n.ag-filter-card-delete-icon .ag-icon,\n.ag-filter-card-editing-icon .ag-icon {\n  color: var(--ag-filter-panel-card-subtle-color);\n}\n\n.ag-filter-card-expand-icon .ag-icon,\n.ag-filter-card-delete-icon .ag-icon {\n  transition: color 0.25s ease-in-out;\n}\n\n.ag-filter-card-expand-icon:hover .ag-icon,\n.ag-filter-card-delete-icon:hover .ag-icon {\n  color: var(--ag-filter-panel-card-subtle-hover-color);\n}\n\n.ag-filter-card-heading:hover .ag-filter-card-expand-icon .ag-icon {\n  color: var(--ag-filter-panel-card-subtle-hover-color);\n}\n\n.ag-filter-card-expand,\n.ag-filter-card-delete {\n  border-radius: var(--ag-button-border-radius);\n  background: none;\n  border: none;\n  cursor: pointer;\n  padding: 0;\n}\n\n.ag-filter-panel .ag-standard-button {\n  cursor: pointer;\n}\n\n.ag-filter-card-summary,\n.ag-filter-type-select {\n  margin-left: var(--ag-widget-container-horizontal-padding);\n  margin-right: var(--ag-widget-container-horizontal-padding);\n}\n\n.ag-ltr .ag-filter-card-delete {\n  margin-right: var(--ag-widget-horizontal-spacing);\n}\n.ag-rtl .ag-filter-card-delete {\n  margin-left: var(--ag-widget-horizontal-spacing);\n}\n\n.ag-filter-card-summary {\n  margin-bottom: var(--ag-widget-container-vertical-padding);\n}\n\n.ag-filter-type-select {\n  padding-top: var(--ag-widget-vertical-spacing);\n}\n\n.ag-filter-card-add {\n  padding: 0;\n  border: 0;\n}\n\n.ag-filter-add-button {\n  display: flex;\n  flex-direction: row;\n  width: 100%;\n  align-items: center;\n  line-height: 1.5;\n}\n\n.ag-ltr .ag-filter-add-button-label {\n  margin-left: var(--ag-grid-size);\n}\n.ag-rtl .ag-filter-add-button-label {\n  margin-right: var(--ag-grid-size);\n}\n\n.ag-filter-add-select {\n  border: 0;\n}\n.ag-ltr .ag-filter-add-select .ag-text-field-input {\n  padding-left: calc(var(--ag-grid-size) * 1.5 + 12px) !important;\n}\n.ag-rtl .ag-filter-add-select .ag-text-field-input {\n  padding-right: calc(var(--ag-grid-size) * 1.5 + 12px) !important;\n}\n.ag-filter-add-select .ag-rich-select-value {\n  padding: calc((1.5 * var(--ag-font-size) + 4 * var(--ag-grid-size) - var(--ag-input-height)) / 2) var(--ag-grid-size);\n  border: 0;\n}\n\n.ag-pivot-mode-panel {\n  min-height: var(--ag-header-height);\n  height: var(--ag-header-height);\n  display: flex;\n}\n\n.ag-pivot-mode-select {\n  display: flex;\n  align-items: center;\n}\n.ag-ltr .ag-pivot-mode-select {\n  margin-left: var(--ag-widget-container-horizontal-padding);\n}\n.ag-rtl .ag-pivot-mode-select {\n  margin-right: var(--ag-widget-container-horizontal-padding);\n}\n\n.ag-column-select-header:focus-visible {\n  outline: none;\n}\n.ag-column-select-header:focus-visible::after {\n  content: \"\";\n  position: absolute;\n  background-color: transparent;\n  pointer-events: none;\n  top: 4px;\n  left: 4px;\n  display: block;\n  width: calc(100% - 8px);\n  height: calc(100% - 8px);\n  border: 1px solid;\n  border-color: var(--ag-input-focus-border-color);\n}\n\n.ag-column-select-header {\n  height: var(--ag-header-height);\n  align-items: center;\n  padding: 0 var(--ag-widget-container-horizontal-padding);\n  border-bottom: var(--ag-borders-secondary) var(--ag-secondary-border-color);\n}\n\n.ag-column-panel-column-select {\n  border-bottom: var(--ag-borders-secondary) var(--ag-secondary-border-color);\n  border-top: var(--ag-borders-secondary) var(--ag-secondary-border-color);\n}\n\n.ag-column-group-icons,\n.ag-column-select-header-icon {\n  color: var(--ag-secondary-foreground-color);\n}\n\n.ag-column-select-list .ag-list-item-hovered::after {\n  content: \"\";\n  position: absolute;\n  left: 0;\n  right: 0;\n  height: 1px;\n}\n.ag-column-select-list .ag-item-highlight-top::after {\n  top: 0;\n}\n.ag-column-select-list .ag-item-highlight-bottom::after {\n  bottom: 0;\n}\n\n.ag-header,\n.ag-advanced-filter-header {\n  background-color: var(--ag-header-background-color);\n  border-bottom: var(--ag-borders-critical) var(--ag-border-color);\n}\n\n.ag-header-row {\n  color: var(--ag-header-foreground-color);\n  height: var(--ag-header-height);\n}\n\n.ag-pinned-right-header {\n  border-left: var(--ag-borders-critical) var(--ag-border-color);\n}\n\n.ag-pinned-left-header {\n  border-right: var(--ag-borders-critical) var(--ag-border-color);\n}\n\n.ag-ltr .ag-header-cell:not(.ag-right-aligned-header) .ag-header-label-icon,\n.ag-ltr .ag-header-cell:not(.ag-right-aligned-header) .ag-header-menu-icon {\n  margin-left: var(--ag-grid-size);\n}\n.ag-rtl .ag-header-cell:not(.ag-right-aligned-header) .ag-header-label-icon,\n.ag-rtl .ag-header-cell:not(.ag-right-aligned-header) .ag-header-menu-icon {\n  margin-right: var(--ag-grid-size);\n}\n\n.ag-ltr .ag-header-cell.ag-right-aligned-header .ag-header-label-icon,\n.ag-ltr .ag-header-cell.ag-right-aligned-header .ag-header-menu-icon {\n  margin-right: var(--ag-grid-size);\n}\n.ag-rtl .ag-header-cell.ag-right-aligned-header .ag-header-label-icon,\n.ag-rtl .ag-header-cell.ag-right-aligned-header .ag-header-menu-icon {\n  margin-left: var(--ag-grid-size);\n}\n\n.ag-header-cell,\n.ag-header-group-cell {\n  padding-left: var(--ag-cell-horizontal-padding);\n  padding-right: var(--ag-cell-horizontal-padding);\n}\n.ag-header-cell.ag-header-cell-moving,\n.ag-header-group-cell.ag-header-cell-moving {\n  background-color: var(--ag-header-cell-moving-background-color);\n}\n\n.ag-ltr .ag-header-group-cell-label.ag-sticky-label {\n  left: var(--ag-cell-horizontal-padding);\n}\n.ag-rtl .ag-header-group-cell-label.ag-sticky-label {\n  right: var(--ag-cell-horizontal-padding);\n}\n\n.ag-header-cell:focus-visible {\n  outline: none;\n}\n.ag-header-cell:focus-visible::after {\n  content: \"\";\n  position: absolute;\n  background-color: transparent;\n  pointer-events: none;\n  top: 4px;\n  left: 4px;\n  display: block;\n  width: calc(100% - 8px);\n  height: calc(100% - 8px);\n  border: 1px solid;\n  border-color: var(--ag-input-focus-border-color);\n}\n\n.ag-header-group-cell:focus-visible {\n  outline: none;\n}\n.ag-header-group-cell:focus-visible::after {\n  content: \"\";\n  position: absolute;\n  background-color: transparent;\n  pointer-events: none;\n  top: 4px;\n  left: 4px;\n  display: block;\n  width: calc(100% - 8px);\n  height: calc(100% - 8px);\n  border: 1px solid;\n  border-color: var(--ag-input-focus-border-color);\n}\n\n.ag-advanced-filter-header-cell:focus-visible {\n  outline: none;\n}\n.ag-advanced-filter-header-cell:focus-visible::after {\n  content: \"\";\n  position: absolute;\n  background-color: transparent;\n  pointer-events: none;\n  top: 4px;\n  left: 4px;\n  display: block;\n  width: calc(100% - 8px);\n  height: calc(100% - 8px);\n  border: 1px solid;\n  border-color: var(--ag-input-focus-border-color);\n}\n\n.ag-header-icon {\n  color: var(--ag-secondary-foreground-color);\n}\n\n.ag-header-expand-icon {\n  cursor: pointer;\n}\n.ag-ltr .ag-header-expand-icon {\n  margin-left: 4px;\n}\n.ag-rtl .ag-header-expand-icon {\n  margin-right: 4px;\n}\n\n.ag-header-row:not(:first-child) .ag-header-cell:not(.ag-header-span-height.ag-header-span-total, .ag-header-parent-hidden),\n.ag-header-row:not(:first-child) .ag-header-group-cell.ag-header-group-cell-with-group {\n  border-top: var(--ag-borders-critical) var(--ag-border-color);\n}\n\n.ag-header-group-cell:not(.ag-column-resizing) + .ag-header-group-cell:not(.ag-column-hover):not(.ag-header-cell-moving):hover, .ag-header-group-cell:not(.ag-column-resizing) + .ag-header-group-cell:not(.ag-column-hover).ag-column-resizing,\n.ag-header-cell:not(.ag-column-resizing) + .ag-header-cell:not(.ag-column-hover):not(.ag-header-cell-moving):hover,\n.ag-header-cell:not(.ag-column-resizing) + .ag-header-cell:not(.ag-column-hover).ag-column-resizing,\n.ag-header-group-cell:first-of-type:not(.ag-header-cell-moving):hover,\n.ag-header-group-cell:first-of-type.ag-column-resizing,\n.ag-header-cell:not(.ag-column-hover):first-of-type:not(.ag-header-cell-moving):hover,\n.ag-header-cell:not(.ag-column-hover):first-of-type.ag-column-resizing {\n  background-color: var(--ag-header-cell-hover-background-color);\n}\n\n.ag-header-cell::before,\n.ag-header-group-cell:not(.ag-header-span-height.ag-header-group-cell-no-group)::before {\n  content: \"\";\n  position: absolute;\n  z-index: 1;\n  display: var(--ag-header-column-separator-display);\n  width: var(--ag-header-column-separator-width);\n  height: var(--ag-header-column-separator-height);\n  top: calc(50% - var(--ag-header-column-separator-height) * 0.5);\n  background-color: var(--ag-header-column-separator-color);\n}\n.ag-ltr .ag-header-cell::before,\n.ag-ltr .ag-header-group-cell:not(.ag-header-span-height.ag-header-group-cell-no-group)::before {\n  right: 0;\n}\n.ag-rtl .ag-header-cell::before,\n.ag-rtl .ag-header-group-cell:not(.ag-header-span-height.ag-header-group-cell-no-group)::before {\n  left: 0;\n}\n\n.ag-header-highlight-before::after,\n.ag-header-highlight-after::after {\n  content: \"\";\n  position: absolute;\n  height: 100%;\n  width: 1px;\n}\n\n.ag-header-highlight-before::after {\n  left: 0px;\n}\n\n.ag-header-highlight-after::after {\n  right: 0px;\n}\n\n.ag-pinned-left-header .ag-header-highlight-after::after {\n  right: 1px;\n}\n\n.ag-header-cell-resize {\n  display: flex;\n  align-items: center;\n}\n\n.ag-header-cell-resize::after {\n  content: \"\";\n  position: absolute;\n  z-index: 1;\n  display: var(--ag-header-column-resize-handle-display);\n  width: var(--ag-header-column-resize-handle-width);\n  height: var(--ag-header-column-resize-handle-height);\n  top: calc(50% - var(--ag-header-column-resize-handle-height) * 0.5);\n  background-color: var(--ag-header-column-resize-handle-color);\n}\n.ag-header-cell.ag-header-span-height .ag-header-cell-resize::after {\n  height: calc(100% - var(--ag-grid-size) * 4);\n  top: calc(var(--ag-grid-size) * 2);\n}\n\n.ag-ltr .ag-header-viewport .ag-header-cell-resize::after {\n  left: calc(50% - var(--ag-header-column-resize-handle-width));\n}\n.ag-rtl .ag-header-viewport .ag-header-cell-resize::after {\n  right: calc(50% - var(--ag-header-column-resize-handle-width));\n}\n\n.ag-pinned-left-header .ag-header-cell-resize::after {\n  left: calc(50% - var(--ag-header-column-resize-handle-width));\n}\n\n.ag-pinned-right-header .ag-header-cell-resize::after {\n  left: 50%;\n}\n\n.ag-ltr .ag-header-select-all {\n  margin-right: var(--ag-cell-horizontal-padding);\n}\n.ag-rtl .ag-header-select-all {\n  margin-left: var(--ag-cell-horizontal-padding);\n}\n\n.ag-ltr .ag-floating-filter-button {\n  margin-left: var(--ag-cell-widget-spacing);\n}\n.ag-rtl .ag-floating-filter-button {\n  margin-right: var(--ag-cell-widget-spacing);\n}\n\n.ag-floating-filter-button-button {\n  color: inherit;\n  font-family: inherit;\n  font-size: inherit;\n  font-weight: inherit;\n  line-height: inherit;\n  appearance: none;\n  background: transparent;\n  border: none;\n  height: var(--ag-icon-size);\n  padding: 0;\n  width: var(--ag-icon-size);\n}\n\n.ag-filter-loading {\n  background-color: var(--ag-control-panel-background-color);\n  height: 100%;\n  padding: var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding);\n  position: absolute;\n  width: 100%;\n  z-index: 1;\n  align-items: unset;\n}\n\n.ag-paging-panel {\n  border-top: 1px solid;\n  border-top-color: var(--ag-border-color);\n  color: var(--ag-secondary-foreground-color);\n  height: var(--ag-pagination-panel-height);\n}\n.ag-paging-panel > * {\n  margin: 0 var(--ag-cell-horizontal-padding);\n}\n.ag-paging-panel > .ag-paging-page-size .ag-wrapper {\n  min-width: calc(var(--ag-grid-size) * 10);\n}\n\n.ag-paging-button {\n  cursor: pointer;\n}\n\n.ag-paging-button.ag-disabled {\n  cursor: default;\n  color: var(--ag-disabled-foreground-color);\n}\n\n.ag-paging-button:focus-visible {\n  outline: none;\n}\n.ag-paging-button:focus-visible::after {\n  content: \"\";\n  position: absolute;\n  background-color: transparent;\n  pointer-events: none;\n  top: 0px;\n  left: 0px;\n  display: block;\n  width: calc(100% - 0px);\n  height: calc(100% - 0px);\n  border: 1px solid;\n  border-color: var(--ag-input-focus-border-color);\n}\n\n.ag-paging-button,\n.ag-paging-description {\n  margin: 0 var(--ag-grid-size);\n}\n\n.ag-status-bar {\n  border-top: var(--ag-borders) var(--ag-border-color);\n  color: var(--ag-disabled-foreground-color);\n  padding-right: calc(var(--ag-grid-size) * 4);\n  padding-left: calc(var(--ag-grid-size) * 4);\n  line-height: 1.5;\n}\n\n.ag-status-name-value-value {\n  color: var(--ag-foreground-color);\n}\n\n.ag-status-bar-center {\n  text-align: center;\n}\n\n.ag-status-name-value {\n  margin-left: var(--ag-grid-size);\n  margin-right: var(--ag-grid-size);\n  padding-top: calc(var(--ag-grid-size) * 2);\n  padding-bottom: calc(var(--ag-grid-size) * 2);\n}\n\n.ag-column-drop-cell {\n  background: var(--ag-chip-background-color);\n  border-radius: calc(var(--ag-grid-size) * 4);\n  height: calc(var(--ag-grid-size) * 4);\n  padding: 0 calc(var(--ag-grid-size) * 0.5);\n  border: 1px solid var(--ag-chip-border-color);\n}\n\n.ag-column-drop-cell:focus-visible {\n  outline: none;\n}\n.ag-column-drop-cell:focus-visible::after {\n  content: \"\";\n  position: absolute;\n  background-color: transparent;\n  pointer-events: none;\n  top: 2px;\n  left: 2px;\n  display: block;\n  width: calc(100% - 4px);\n  height: calc(100% - 4px);\n  border: 1px solid;\n  border-color: var(--ag-input-focus-border-color);\n}\n\n.ag-column-drop-cell-text {\n  margin: 0 var(--ag-grid-size);\n}\n\n.ag-column-drop-cell-button {\n  min-width: calc(var(--ag-grid-size) * 4);\n  margin: 0 calc(var(--ag-grid-size) * 0.5);\n  color: var(--ag-secondary-foreground-color);\n}\n\n.ag-column-drop-cell-drag-handle {\n  margin-left: calc(var(--ag-grid-size) * 2);\n}\n\n.ag-column-drop-cell-ghost {\n  opacity: 0.5;\n}\n\n.ag-column-drop-horizontal {\n  background-color: var(--ag-header-background-color);\n  color: var(--ag-secondary-foreground-color);\n  height: var(--ag-header-height);\n  border-bottom: var(--ag-borders) var(--ag-border-color);\n}\n.ag-ltr .ag-column-drop-horizontal {\n  padding-left: var(--ag-cell-horizontal-padding);\n}\n.ag-rtl .ag-column-drop-horizontal {\n  padding-right: var(--ag-cell-horizontal-padding);\n}\n\n.ag-ltr .ag-column-drop-horizontal-half-width:not(:last-child) {\n  border-right: var(--ag-borders) var(--ag-border-color);\n}\n.ag-rtl .ag-column-drop-horizontal-half-width:not(:last-child) {\n  border-left: var(--ag-borders) var(--ag-border-color);\n}\n\n.ag-column-drop-horizontal-cell-separator {\n  margin: 0 var(--ag-grid-size);\n  color: var(--ag-secondary-foreground-color);\n}\n\n.ag-column-drop-horizontal-empty-message {\n  color: var(--ag-disabled-foreground-color);\n}\n\n.ag-ltr .ag-column-drop-horizontal-icon {\n  margin-right: var(--ag-cell-horizontal-padding);\n}\n.ag-rtl .ag-column-drop-horizontal-icon {\n  margin-left: var(--ag-cell-horizontal-padding);\n}\n\n.ag-column-drop-vertical-list {\n  padding-bottom: var(--ag-grid-size);\n  padding-right: var(--ag-grid-size);\n  padding-left: var(--ag-grid-size);\n}\n\n.ag-column-drop-vertical-cell {\n  margin-top: var(--ag-grid-size);\n}\n\n.ag-column-drop-vertical {\n  min-height: 50px;\n  border-bottom: var(--ag-borders-secondary) var(--ag-secondary-border-color);\n}\n.ag-column-drop-vertical.ag-last-column-drop {\n  border-bottom: none;\n}\n\n.ag-column-drop-vertical-icon {\n  margin-left: var(--ag-grid-size);\n  margin-right: var(--ag-grid-size);\n}\n\n.ag-column-drop-vertical-empty-message {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  overflow: hidden;\n  color: var(--ag-disabled-foreground-color);\n  margin-top: var(--ag-grid-size);\n}\n\n.ag-select-agg-func-popup {\n  border: var(--ag-borders) var(--ag-border-color);\n  background: var(--ag-background-color);\n  border-radius: var(--ag-card-radius);\n  box-shadow: var(--ag-card-shadow);\n  padding: var(--ag-grid-size);\n  background: var(--ag-background-color);\n  height: calc(var(--ag-grid-size) * 5 * 3.5);\n  padding: 0;\n}\n\n.ag-select-agg-func-virtual-list-item {\n  cursor: default;\n}\n.ag-ltr .ag-select-agg-func-virtual-list-item {\n  padding-left: calc(var(--ag-grid-size) * 2);\n}\n.ag-rtl .ag-select-agg-func-virtual-list-item {\n  padding-right: calc(var(--ag-grid-size) * 2);\n}\n.ag-select-agg-func-virtual-list-item:hover {\n  background-color: var(--ag-selected-row-background-color);\n}\n\n.ag-select-agg-func-virtual-list-item:focus-visible {\n  outline: none;\n}\n.ag-select-agg-func-virtual-list-item:focus-visible::after {\n  content: \"\";\n  position: absolute;\n  background-color: transparent;\n  pointer-events: none;\n  top: 1px;\n  left: 1px;\n  display: block;\n  width: calc(100% - 2px);\n  height: calc(100% - 2px);\n  border: 1px solid;\n  border-color: var(--ag-input-focus-border-color);\n}\n\n.ag-sort-indicator-container {\n  display: flex;\n}\n\n.ag-ltr .ag-sort-indicator-icon {\n  padding-left: var(--ag-grid-size);\n}\n.ag-rtl .ag-sort-indicator-icon {\n  padding-right: var(--ag-grid-size);\n}\n\n.ag-chart {\n  position: relative;\n  display: flex;\n  width: 100%;\n  height: 100%;\n}\n\n.ag-chart-components-wrapper {\n  position: relative;\n  display: flex;\n  flex: 1 1 auto;\n}\n\n.ag-chart-canvas-wrapper {\n  position: relative;\n  flex: 1 1 auto;\n}\n\n.ag-chart-menu {\n  position: absolute;\n  top: 16px;\n  display: flex;\n  flex-direction: column;\n}\n.ag-ltr .ag-chart-menu {\n  right: 20px;\n}\n.ag-rtl .ag-chart-menu {\n  left: 20px;\n}\n\n.ag-chart-docked-container {\n  position: relative;\n  min-width: var(--ag-chart-menu-panel-width);\n}\n\n.ag-chart-menu-hidden ~ .ag-chart-docked-container {\n  display: none;\n}\n\n.ag-chart-tabbed-menu {\n  width: 100%;\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n}\n\n.ag-chart-tabbed-menu-header {\n  flex: none;\n  -moz-user-select: none;\n  -webkit-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  cursor: default;\n}\n\n.ag-chart-tabbed-menu-body {\n  display: flex;\n  flex: 1 1 auto;\n  align-items: stretch;\n  overflow: hidden;\n}\n\n.ag-chart-tab {\n  width: 100%;\n  overflow: hidden;\n  overflow-y: auto;\n}\n\n.ag-chart-settings {\n  overflow-x: hidden;\n}\n\n.ag-chart-settings-wrapper {\n  position: relative;\n  flex-direction: column;\n  width: 100%;\n  height: 100%;\n  display: flex;\n  overflow: hidden;\n}\n\n.ag-chart-settings-nav-bar {\n  display: flex;\n  align-items: center;\n  width: 100%;\n  height: 30px;\n  padding: 0 10px;\n  -moz-user-select: none;\n  -webkit-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.ag-chart-settings-card-selector {\n  display: flex;\n  align-items: center;\n  justify-content: space-around;\n  flex: 1 1 auto;\n  height: 100%;\n  padding: 0 10px;\n}\n\n.ag-chart-settings-card-item {\n  cursor: pointer;\n  width: 10px;\n  height: 10px;\n  background-color: #000;\n  position: relative;\n}\n.ag-chart-settings-card-item.ag-not-selected {\n  opacity: 0.2;\n}\n.ag-chart-settings-card-item::before {\n  content: \" \";\n  display: block;\n  position: absolute;\n  background-color: transparent;\n  left: 50%;\n  top: 50%;\n  margin-left: -10px;\n  margin-top: -10px;\n  width: 20px;\n  height: 20px;\n}\n\n.ag-chart-settings-prev,\n.ag-chart-settings-next {\n  position: relative;\n  flex: none;\n}\n.ag-chart-settings-prev:focus-within,\n.ag-chart-settings-next:focus-within {\n  box-shadow: var(--ag-input-focus-box-shadow);\n  border-radius: 1px;\n}\n\n.ag-chart-settings-prev-button,\n.ag-chart-settings-next-button {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  cursor: pointer;\n  opacity: 0;\n}\n\n.ag-chart-settings-mini-charts-container {\n  position: relative;\n  flex: 1 1 auto;\n  overflow-x: hidden;\n  overflow-y: auto;\n}\n\n.ag-chart-settings-mini-wrapper {\n  position: absolute;\n  top: 0;\n  left: 0;\n  display: flex;\n  flex-direction: column;\n  width: 100%;\n  min-height: 100%;\n  overflow: hidden;\n}\n.ag-chart-settings-mini-wrapper.ag-animating {\n  transition: left 0.3s;\n  transition-timing-function: ease-in-out;\n}\n\n.ag-chart-mini-thumbnail {\n  cursor: pointer;\n}\n\n.ag-chart-mini-thumbnail-canvas {\n  display: block;\n}\n\n.ag-chart-data-wrapper,\n.ag-chart-format-wrapper,\n.ag-chart-advanced-settings-wrapper {\n  display: flex;\n  flex-direction: column;\n  position: relative;\n  -moz-user-select: none;\n  -webkit-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  padding-bottom: 16px;\n}\n\n.ag-chart-data-wrapper,\n.ag-chart-advanced-settings-wrapper {\n  height: 100%;\n  overflow-y: auto;\n}\n\n.ag-chart-advanced-settings {\n  background-color: var(--ag-control-panel-background-color);\n}\n\n.ag-chart-advanced-settings-wrapper,\n.ag-chart-advanced-settings {\n  width: 100%;\n}\n\n.ag-chart-advanced-settings-wrapper {\n  padding-bottom: 0;\n}\n\n.ag-chart-data-section,\n.ag-chart-format-section,\n.ag-chart-advanced-settings-section {\n  display: flex;\n  margin: 0;\n}\n\n.ag-chart-advanced-settings-section {\n  padding-top: var(--ag-grid-size);\n  padding-bottom: var(--ag-grid-size);\n}\n.ag-chart-advanced-settings-section:not(:last-child) {\n  border-bottom: 1px solid var(--ag-secondary-border-color);\n}\n\n.ag-chart-empty-text {\n  display: flex;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  align-items: center;\n  justify-content: center;\n  background-color: var(--ag-background-color);\n}\n\n.ag-chart .ag-chart-menu-wrapper .ag-chart-menu {\n  display: flex;\n  flex-direction: row;\n  top: 8px;\n  gap: 20px;\n  width: auto;\n}\n.ag-ltr .ag-chart .ag-chart-menu-wrapper .ag-chart-menu {\n  right: calc(var(--ag-cell-horizontal-padding) + var(--ag-grid-size) - 4px);\n  justify-content: right;\n}\n.ag-rtl .ag-chart .ag-chart-menu-wrapper .ag-chart-menu {\n  left: calc(var(--ag-cell-horizontal-padding) + var(--ag-grid-size) - 4px);\n  justify-content: left;\n}\n\n.ag-charts-font-size-color {\n  display: flex;\n  align-self: stretch;\n  justify-content: space-between;\n}\n\n.ag-charts-data-group-item {\n  position: relative;\n}\n\n.ag-charts-data-group-item:not(:last-child) {\n  margin-bottom: var(--ag-grid-size);\n}\n\n.ag-chart-menu {\n  border-radius: var(--ag-card-radius);\n  background: var(--ag-background-color);\n}\n\n.ag-chart-menu-icon {\n  opacity: 0.5;\n  margin: 2px 0;\n  cursor: pointer;\n  border-radius: var(--ag-card-radius);\n  color: var(--ag-secondary-foreground-color);\n}\n.ag-chart-menu-icon:hover {\n  opacity: 1;\n}\n\n.ag-chart-menu-toolbar-button {\n  border: 0;\n  background-color: unset;\n  padding: 0 2px;\n  border-radius: 1px;\n}\n\n.ag-chart-mini-thumbnail {\n  border: 1px solid var(--ag-secondary-border-color);\n  border-radius: 5px;\n  padding: 1px;\n}\n.ag-chart-mini-thumbnail.ag-selected {\n  border-color: var(--ag-minichart-selected-chart-color);\n  border-width: 2px;\n  padding: unset;\n}\n.ag-chart-mini-thumbnail:focus-visible {\n  outline: none;\n  border-color: var(--ag-minichart-selected-chart-color);\n  box-shadow: var(--ag-input-focus-box-shadow);\n}\n\n.ag-chart-settings-card-item {\n  background: var(--ag-foreground-color);\n  width: 8px;\n  height: 8px;\n  border-radius: 4px;\n}\n.ag-chart-settings-card-item.ag-selected {\n  background-color: var(--ag-minichart-selected-page-color);\n}\n\n.ag-chart-data-column-drag-handle {\n  margin-left: var(--ag-grid-size);\n}\n\n.ag-charts-settings-group-title-bar,\n.ag-charts-data-group-title-bar,\n.ag-charts-format-top-level-group-title-bar {\n  border-top: var(--ag-borders-secondary) var(--ag-secondary-border-color);\n  position: relative;\n}\n\n.ag-charts-advanced-settings-top-level-group-title-bar {\n  position: relative;\n  background-color: unset;\n}\n\n.ag-charts-data-group-title-bar:focus-visible {\n  outline: none;\n}\n.ag-charts-data-group-title-bar:focus-visible::after {\n  content: \"\";\n  position: absolute;\n  background-color: transparent;\n  pointer-events: none;\n  top: 4px;\n  left: 4px;\n  display: block;\n  width: calc(100% - 8px);\n  height: calc(100% - 8px);\n  border: 1px solid;\n  border-color: var(--ag-input-focus-border-color);\n}\n\n.ag-charts-format-top-level-group-title-bar:focus-visible {\n  outline: none;\n}\n.ag-charts-format-top-level-group-title-bar:focus-visible::after {\n  content: \"\";\n  position: absolute;\n  background-color: transparent;\n  pointer-events: none;\n  top: 4px;\n  left: 4px;\n  display: block;\n  width: calc(100% - 8px);\n  height: calc(100% - 8px);\n  border: 1px solid;\n  border-color: var(--ag-input-focus-border-color);\n}\n\n.ag-charts-data-group-title-bar .ag-charts-data-group-title,\n.ag-charts-format-top-level-group-title-bar .ag-charts-format-top-level-group-title {\n  cursor: pointer;\n}\n\n.ag-charts-data-group-container {\n  padding: calc(var(--ag-widget-container-vertical-padding) * 0.5) var(--ag-widget-container-horizontal-padding);\n}\n.ag-charts-data-group-container .ag-charts-data-group-item:not(.ag-charts-format-sub-level-group):not(.ag-pill-select):not(.ag-select) {\n  height: var(--ag-list-item-height);\n}\n.ag-charts-data-group-container .ag-charts-data-group-item.ag-picker-field {\n  margin-top: var(--ag-grid-size);\n}\n.ag-charts-data-group-container .ag-list-item-hovered::after {\n  content: \"\";\n  position: absolute;\n  left: 0;\n  right: 0;\n  height: 1px;\n}\n.ag-charts-data-group-container .ag-item-highlight-top::after {\n  top: 0;\n}\n.ag-charts-data-group-container .ag-item-highlight-bottom::after {\n  bottom: 0;\n}\n\n.ag-charts-format-top-level-group-container,\n.ag-charts-advanced-settings-top-level-group-container {\n  padding: var(--ag-grid-size);\n}\n.ag-ltr .ag-charts-format-top-level-group-container,\n.ag-ltr .ag-charts-advanced-settings-top-level-group-container {\n  margin-left: calc(var(--ag-grid-size) * 2);\n}\n.ag-rtl .ag-charts-format-top-level-group-container,\n.ag-rtl .ag-charts-advanced-settings-top-level-group-container {\n  margin-right: calc(var(--ag-grid-size) * 2);\n}\n\n.ag-charts-format-top-level-group-item,\n.ag-charts-advanced-settings-top-level-group-item {\n  margin: var(--ag-grid-size) 0;\n}\n\n.ag-charts-format-sub-level-group-container {\n  padding: var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding);\n  padding-bottom: calc(var(--ag-widget-container-vertical-padding) - var(--ag-widget-vertical-spacing));\n}\n.ag-charts-format-sub-level-group-container > * {\n  margin-bottom: var(--ag-widget-vertical-spacing);\n}\n\n.ag-charts-format-sub-level-no-header-group-container > * {\n  margin-bottom: var(--ag-widget-vertical-spacing);\n}\n\n.ag-charts-format-sub-level-group-container .ag-charts-format-sub-level-group-item.ag-font-panel-no-header {\n  margin: 0;\n}\n\n.ag-charts-settings-group-container {\n  padding: var(--ag-grid-size);\n  row-gap: 8px;\n  display: grid;\n  grid-template-columns: 60px 1fr 60px 1fr 60px;\n}\n.ag-charts-settings-group-container .ag-chart-mini-thumbnail:nth-child(3n+1) {\n  grid-column: 1;\n}\n.ag-charts-settings-group-container .ag-chart-mini-thumbnail:nth-child(3n+2) {\n  grid-column: 3;\n}\n.ag-charts-settings-group-container .ag-chart-mini-thumbnail:nth-child(3n+3) {\n  grid-column: 5;\n}\n\n.ag-chart-menu-panel {\n  background-color: var(--ag-control-panel-background-color);\n}\n.ag-ltr .ag-chart-menu-panel {\n  border-left: solid 1px var(--ag-border-color);\n}\n.ag-rtl .ag-chart-menu-panel {\n  border-right: solid 1px var(--ag-border-color);\n}\n\n.ag-date-time-list-page-title-bar {\n  display: flex;\n}\n\n.ag-date-time-list-page-title {\n  flex-grow: 1;\n  text-align: center;\n}\n\n.ag-date-time-list-page-column-labels-row,\n.ag-date-time-list-page-entries-row {\n  display: flex;\n}\n\n.ag-date-time-list-page-column-label,\n.ag-date-time-list-page-entry {\n  flex-basis: 0;\n  flex-grow: 1;\n}\n\n.ag-date-time-list-page-entry {\n  cursor: pointer;\n  text-align: center;\n}\n\n.ag-date-time-list-page-column-label {\n  text-align: center;\n}\n\n.ag-advanced-filter-header {\n  position: relative;\n  display: flex;\n  align-items: center;\n  padding-left: var(--ag-cell-horizontal-padding);\n  padding-right: var(--ag-cell-horizontal-padding);\n}\n\n.ag-advanced-filter {\n  display: flex;\n  align-items: center;\n  width: 100%;\n}\n\n.ag-advanced-filter-apply-button,\n.ag-advanced-filter-builder-button {\n  line-height: normal;\n  white-space: nowrap;\n}\n.ag-ltr .ag-advanced-filter-apply-button,\n.ag-ltr .ag-advanced-filter-builder-button {\n  margin-left: calc(var(--ag-grid-size) * 2);\n}\n.ag-rtl .ag-advanced-filter-apply-button,\n.ag-rtl .ag-advanced-filter-builder-button {\n  margin-right: calc(var(--ag-grid-size) * 2);\n}\n\n.ag-advanced-filter-builder-button {\n  display: flex;\n  align-items: center;\n  border: 0;\n  background-color: unset;\n  color: var(--ag-foreground-color);\n  font-size: var(--ag-font-size);\n  font-weight: 600;\n}\n.ag-advanced-filter-builder-button:hover:not(:disabled) {\n  background-color: var(--ag-row-hover-color);\n}\n.ag-advanced-filter-builder-button:not(:disabled) {\n  cursor: pointer;\n}\n\n.ag-advanced-filter-builder-button-label {\n  margin-left: var(--ag-grid-size);\n}\n\n.ag-advanced-filter-builder {\n  -moz-user-select: none;\n  -webkit-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  width: 100%;\n  background-color: var(--ag-control-panel-background-color);\n  display: flex;\n  flex-direction: column;\n}\n\n.ag-advanced-filter-builder-list {\n  flex: 1;\n  overflow: auto;\n}\n.ag-advanced-filter-builder-list .ag-list-item-hovered::after {\n  content: \"\";\n  position: absolute;\n  left: 0;\n  right: 0;\n  height: 1px;\n}\n.ag-advanced-filter-builder-list .ag-item-highlight-top::after {\n  top: 0;\n}\n.ag-advanced-filter-builder-list .ag-item-highlight-bottom::after {\n  bottom: 0;\n}\n\n.ag-advanced-filter-builder-button-panel {\n  display: flex;\n  justify-content: flex-end;\n  padding: var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding);\n  border-top: var(--ag-borders-secondary) var(--ag-secondary-border-color);\n}\n\n.ag-advanced-filter-builder .ag-advanced-filter-builder-button-panel .ag-advanced-filter-builder-apply-button,\n.ag-advanced-filter-builder .ag-advanced-filter-builder-button-panel .ag-advanced-filter-builder-cancel-button {\n  margin-left: calc(var(--ag-grid-size) * 2);\n}\n\n.ag-advanced-filter-builder-item-wrapper {\n  display: flex;\n  flex: 1 1 auto;\n  align-items: center;\n  justify-content: space-between;\n  overflow: hidden;\n  padding-left: calc(var(--ag-icon-size) / 2);\n  padding-right: var(--ag-icon-size);\n}\n\n.ag-virtual-list-viewport .ag-advanced-filter-builder-item-wrapper .ag-tab-guard {\n  position: absolute;\n}\n\n.ag-advanced-filter-builder-item-tree-lines > * {\n  width: var(--ag-advanced-filter-builder-indent-size);\n}\n\n.ag-advanced-filter-builder-item-tree-lines .ag-advanced-filter-builder-item-tree-line-root {\n  width: var(--ag-icon-size);\n}\n.ag-advanced-filter-builder-item-tree-lines .ag-advanced-filter-builder-item-tree-line-root::before {\n  top: 50%;\n  height: 50%;\n}\n\n.ag-advanced-filter-builder-item-tree-line-horizontal,\n.ag-advanced-filter-builder-item-tree-line-vertical,\n.ag-advanced-filter-builder-item-tree-line-vertical-top,\n.ag-advanced-filter-builder-item-tree-line-vertical-bottom {\n  position: relative;\n  height: 100%;\n  display: flex;\n  align-items: center;\n}\n.ag-advanced-filter-builder-item-tree-line-horizontal::before, .ag-advanced-filter-builder-item-tree-line-horizontal::after,\n.ag-advanced-filter-builder-item-tree-line-vertical::before,\n.ag-advanced-filter-builder-item-tree-line-vertical::after,\n.ag-advanced-filter-builder-item-tree-line-vertical-top::before,\n.ag-advanced-filter-builder-item-tree-line-vertical-top::after,\n.ag-advanced-filter-builder-item-tree-line-vertical-bottom::before,\n.ag-advanced-filter-builder-item-tree-line-vertical-bottom::after {\n  content: \"\";\n  position: absolute;\n  height: 100%;\n}\n\n.ag-advanced-filter-builder-item-tree-line-horizontal::after {\n  height: 50%;\n  width: calc(var(--ag-advanced-filter-builder-indent-size) - var(--ag-icon-size));\n  top: 0;\n  left: calc(var(--ag-icon-size) / 2);\n  border-bottom: 1px solid;\n  border-color: var(--ag-border-color);\n}\n\n.ag-advanced-filter-builder-item-tree-line-vertical::before {\n  width: calc(var(--ag-advanced-filter-builder-indent-size) - var(--ag-icon-size) / 2);\n  top: 0;\n  left: calc(var(--ag-icon-size) / 2);\n  border-left: 1px solid;\n  border-color: var(--ag-border-color);\n}\n\n.ag-advanced-filter-builder-item-tree-line-vertical-top::before {\n  height: 50%;\n  width: calc(var(--ag-advanced-filter-builder-indent-size) - var(--ag-icon-size) / 2);\n  top: 0;\n  left: calc(var(--ag-icon-size) / 2);\n  border-left: 1px solid;\n  border-color: var(--ag-border-color);\n}\n\n.ag-advanced-filter-builder-item-tree-line-vertical-bottom::before {\n  height: calc((100% - 1.5 * var(--ag-icon-size)) / 2);\n  width: calc(var(--ag-icon-size) / 2);\n  top: calc((100% + 1.5 * var(--ag-icon-size)) / 2);\n  left: calc(var(--ag-icon-size) / 2);\n  border-left: 1px solid;\n  border-color: var(--ag-border-color);\n}\n\n.ag-advanced-filter-builder-item-condition {\n  padding-top: var(--ag-grid-size);\n  padding-bottom: var(--ag-grid-size);\n}\n\n.ag-advanced-filter-builder-item,\n.ag-advanced-filter-builder-item-condition,\n.ag-advanced-filter-builder-pill-wrapper,\n.ag-advanced-filter-builder-pill,\n.ag-advanced-filter-builder-item-buttons,\n.ag-advanced-filter-builder-item-tree-lines {\n  display: flex;\n  align-items: center;\n  height: 100%;\n}\n\n.ag-advanced-filter-builder-pill-wrapper {\n  margin: 0px var(--ag-grid-size);\n}\n\n.ag-advanced-filter-builder-pill {\n  position: relative;\n  border-radius: var(--ag-border-radius);\n  padding: var(--ag-grid-size) calc(var(--ag-grid-size) * 2);\n  min-height: calc(100% - var(--ag-grid-size) * 3);\n  min-width: calc(var(--ag-grid-size) * 2);\n}\n.ag-advanced-filter-builder-pill .ag-picker-field-display {\n  margin-right: var(--ag-grid-size);\n}\n.ag-advanced-filter-builder-pill .ag-advanced-filter-builder-value-number {\n  font-family: monospace;\n  font-weight: 700;\n}\n.ag-advanced-filter-builder-pill .ag-advanced-filter-builder-value-empty {\n  color: var(--ag-disabled-foreground-color);\n}\n\n.ag-advanced-filter-builder-pill:focus-visible {\n  outline: none;\n}\n.ag-advanced-filter-builder-pill:focus-visible::after {\n  content: \"\";\n  position: absolute;\n  background-color: transparent;\n  pointer-events: none;\n  top: -4px;\n  left: -4px;\n  display: block;\n  width: calc(100% - -8px);\n  height: calc(100% - -8px);\n  border: 1px solid;\n  border-color: var(--ag-input-focus-border-color);\n}\n\n.ag-advanced-filter-builder-item-button:focus-visible {\n  outline: none;\n}\n.ag-advanced-filter-builder-item-button:focus-visible::after {\n  content: \"\";\n  position: absolute;\n  background-color: transparent;\n  pointer-events: none;\n  top: -4px;\n  left: -4px;\n  display: block;\n  width: calc(100% - -8px);\n  height: calc(100% - -8px);\n  border: 1px solid;\n  border-color: var(--ag-input-focus-border-color);\n}\n\n.ag-advanced-filter-builder-pill-display {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  font-weight: 500;\n}\n\n.ag-advanced-filter-builder-join-pill {\n  color: var(--ag-foreground-color);\n  background-color: var(--ag-advanced-filter-join-pill-color);\n  cursor: pointer;\n}\n\n.ag-advanced-filter-builder-column-pill {\n  color: var(--ag-foreground-color);\n  background-color: var(--ag-advanced-filter-column-pill-color);\n  cursor: pointer;\n}\n\n.ag-advanced-filter-builder-option-pill {\n  color: var(--ag-foreground-color);\n  background-color: var(--ag-advanced-filter-option-pill-color);\n  cursor: pointer;\n}\n\n.ag-advanced-filter-builder-value-pill {\n  color: var(--ag-foreground-color);\n  background-color: var(--ag-advanced-filter-value-pill-color);\n  cursor: text;\n  max-width: 140px;\n}\n.ag-advanced-filter-builder-value-pill .ag-advanced-filter-builder-pill-display {\n  display: block;\n}\n\n.ag-advanced-filter-builder-item-buttons > * {\n  margin: 0 calc(var(--ag-grid-size) * 0.5);\n}\n\n.ag-advanced-filter-builder-item-button {\n  position: relative;\n  cursor: pointer;\n  color: var(--ag-secondary-foreground-color);\n  opacity: 50%;\n}\n\n.ag-advanced-filter-builder-item-button-disabled {\n  color: var(--ag-disabled-foreground-color);\n  cursor: default;\n}\n\n.ag-advanced-filter-builder-virtual-list-container {\n  top: var(--ag-grid-size);\n}\n\n.ag-advanced-filter-builder-virtual-list-item {\n  display: flex;\n  cursor: default;\n  height: var(--ag-list-item-height);\n}\n.ag-advanced-filter-builder-virtual-list-item:hover {\n  background-color: var(--ag-row-hover-color);\n}\n.ag-advanced-filter-builder-virtual-list-item:hover .ag-advanced-filter-builder-item-button {\n  opacity: 100%;\n}\n\n.ag-advanced-filter-builder-virtual-list-item-highlight .ag-advanced-filter-builder-item-button:focus-visible,\n.ag-advanced-filter-builder-validation .ag-advanced-filter-builder-invalid {\n  opacity: 100%;\n}\n\n.ag-advanced-filter-builder-invalid {\n  margin: 0 var(--ag-grid-size);\n  color: var(--ag-invalid-color);\n  cursor: default;\n}\n\n.ag-row-number-cell {\n  background-color: var(--ag-header-background-color);\n  color: var(--ag-header-foreground-color);\n  font-size: var(--ag-font-size);\n  font-family: var(--ag-font-family);\n}\n\n.ag-row-number-header.ag-row-number-selection-enabled {\n  cursor: cell;\n}\n\n.ag-row-number-range-highlight {\n  background-color: var(--ag-range-header-highlight-color);\n}\n\n.ag-row-number-range-selected {\n  background-color: var(--ag-row-numbers-selected-color);\n}\n\n.ag-ltr .ag-row-number-header,\n.ag-ltr .ag-cell.ag-row-number-cell:not(.ag-cell-last-left-pinned) {\n  border-right: var(--ag-pinned-column-border);\n}\n.ag-ltr .ag-cell.ag-row-number-cell.ag-row-number-selection-enabled {\n  cursor: url(" + ___CSS_LOADER_URL_REPLACEMENT_2___ + "), auto;\n}\n\n.ag-rtl .ag-row-number-header,\n.ag-rtl .ag-cell.ag-row-number-cell:not(.ag-cell-first-right-pinned) {\n  border-left: var(--ag-pinned-column-border);\n}\n.ag-rtl .ag-cell.ag-row-number-cell.ag-row-number-selection-enabled {\n  cursor: url(" + ___CSS_LOADER_URL_REPLACEMENT_3___ + "), auto;\n}\n\n.ag-cell-batch-edit {\n  background-color: var(--ag-cell-batch-edit-background-color);\n  color: var(--ag-cell-batch-edit-text-color);\n}\n\n.ag-cell.ag-cell-inline-editing {\n  background-color: var(--ag-background-color);\n  background-image: linear-gradient(0deg, var(--ag-input-background-color), var(--ag-input-background-color));\n}\n\n.ag-row-batch-edit {\n  background-color: var(--ag-row-batch-edit-background-color);\n  color: var(--ag-row-batch-edit-text-color);\n}\n\n.ag-input-field-input {\n  width: 100%;\n  min-width: 0;\n}\n\n.ag-checkbox-input-wrapper {\n  font-family: var(--ag-icon-font-family);\n  font-weight: var(--ag-icon-font-weight);\n  color: var(--ag-icon-font-color);\n  font-size: var(--ag-icon-size);\n  line-height: var(--ag-icon-size);\n  font-style: normal;\n  font-variant: normal;\n  text-transform: none;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  width: var(--ag-icon-size);\n  height: var(--ag-icon-size);\n  background-color: var(--ag-checkbox-background-color);\n  border-radius: var(--ag-checkbox-border-radius);\n  display: inline-block;\n  vertical-align: middle;\n  flex: none;\n}\n.ag-checkbox-input-wrapper input,\n.ag-checkbox-input-wrapper input {\n  -webkit-appearance: none;\n  opacity: 0;\n  width: 100%;\n  height: 100%;\n}\n.ag-checkbox-input-wrapper:focus-within, .ag-checkbox-input-wrapper:active {\n  outline: none;\n  box-shadow: var(--ag-input-focus-box-shadow);\n}\n.ag-cell-editing-error .ag-checkbox-input-wrapper:focus-within, .ag-cell-editing-error .ag-checkbox-input-wrapper:active {\n  box-shadow: var(--ag-input-error-focus-box-shadow);\n}\n.ag-checkbox-input-wrapper.ag-disabled {\n  opacity: 0.5;\n}\n.ag-checkbox-input-wrapper::after {\n  content: var(--ag-icon-font-code-checkbox-unchecked, \"\\f108\");\n  font-family: inherit;\n  color: var(--ag-checkbox-unchecked-color);\n  display: var(--ag-icon-font-display-checkbox-unchecked, var(--ag-icon-font-display));\n  position: absolute;\n  top: 0;\n  left: 0;\n  pointer-events: none;\n}\n.ag-checkbox-input-wrapper.ag-checked::after {\n  content: var(--ag-icon-font-code-checkbox-checked, \"\\f106\");\n  color: var(--ag-checkbox-checked-color);\n  display: var(--ag-icon-font-display-checkbox-checked, var(--ag-icon-font-display));\n  position: absolute;\n  top: 0;\n  left: 0;\n  pointer-events: none;\n}\n.ag-checkbox-input-wrapper.ag-indeterminate::after {\n  content: var(--ag-icon-font-code-checkbox-indeterminate, \"\\f107\");\n  color: var(--ag-checkbox-indeterminate-color);\n  display: var(--ag-icon-font-display-checkbox-indeterminate, var(--ag-icon-font-display));\n  position: absolute;\n  top: 0;\n  left: 0;\n  pointer-events: none;\n}\n.ag-checkbox-input-wrapper::before {\n  content: \"\";\n  background: transparent center/contain no-repeat;\n  position: absolute;\n  inset: 0;\n  background-image: var(--ag-icon-image-checkbox-unchecked, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-checkbox-unchecked, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-checkbox-unchecked, var(--ag-icon-image-opacity, 0.9));\n}\n.ag-checkbox-input-wrapper.ag-checked::before {\n  background-image: var(--ag-icon-image-checkbox-checked, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-checkbox-checked, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-checkbox-checked, var(--ag-icon-image-opacity, 0.9));\n}\n.ag-checkbox-input-wrapper.ag-indeterminate::before {\n  background-image: var(--ag-icon-image-checkbox-indeterminate, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-checkbox-indeterminate, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-checkbox-indeterminate, var(--ag-icon-image-opacity, 0.9));\n}\n\n.ag-toggle-button-input-wrapper {\n  box-sizing: border-box;\n  width: var(--ag-toggle-button-width);\n  min-width: var(--ag-toggle-button-width);\n  max-width: var(--ag-toggle-button-width);\n  height: var(--ag-toggle-button-height);\n  background-color: var(--ag-toggle-button-off-background-color);\n  border-radius: calc(var(--ag-toggle-button-height) * 0.5);\n  position: relative;\n  flex: none;\n  border: var(--ag-toggle-button-border-width) solid;\n  border-color: var(--ag-toggle-button-off-border-color);\n}\n.ag-toggle-button-input-wrapper input {\n  opacity: 0;\n  height: 100%;\n  width: 100%;\n}\n.ag-toggle-button-input-wrapper:focus-within {\n  outline: none;\n  box-shadow: var(--ag-input-focus-box-shadow);\n}\n.ag-toggle-button-input-wrapper.ag-disabled {\n  opacity: 0.5;\n}\n.ag-toggle-button-input-wrapper.ag-checked {\n  background-color: var(--ag-toggle-button-on-background-color);\n  border-color: var(--ag-toggle-button-on-border-color);\n}\n.ag-toggle-button-input-wrapper::before {\n  content: \" \";\n  position: absolute;\n  top: calc(0px - var(--ag-toggle-button-border-width));\n  left: calc(0px - var(--ag-toggle-button-border-width));\n  display: block;\n  box-sizing: border-box;\n  height: var(--ag-toggle-button-height);\n  width: var(--ag-toggle-button-height);\n  background-color: var(--ag-toggle-button-switch-background-color);\n  border-radius: 100%;\n  transition: left 100ms;\n  border: var(--ag-toggle-button-border-width) solid;\n  border-color: var(--ag-toggle-button-switch-border-color);\n}\n.ag-toggle-button-input-wrapper.ag-checked::before {\n  left: calc(100% - var(--ag-toggle-button-height) + var(--ag-toggle-button-border-width));\n  border-color: var(--ag-toggle-button-on-border-color);\n}\n\n.ag-radio-button-input-wrapper {\n  font-family: var(--ag-icon-font-family);\n  font-weight: var(--ag-icon-font-weight);\n  color: var(--ag-icon-font-color);\n  font-size: var(--ag-icon-size);\n  line-height: var(--ag-icon-size);\n  font-style: normal;\n  font-variant: normal;\n  text-transform: none;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  width: var(--ag-icon-size);\n  height: var(--ag-icon-size);\n  background-color: var(--ag-checkbox-background-color);\n  border-radius: var(--ag-checkbox-border-radius);\n  display: inline-block;\n  vertical-align: middle;\n  flex: none;\n  border-radius: var(--ag-icon-size);\n}\n.ag-radio-button-input-wrapper input,\n.ag-radio-button-input-wrapper input {\n  -webkit-appearance: none;\n  opacity: 0;\n  width: 100%;\n  height: 100%;\n}\n.ag-radio-button-input-wrapper:focus-within, .ag-radio-button-input-wrapper:active {\n  outline: none;\n  box-shadow: var(--ag-input-focus-box-shadow);\n}\n.ag-cell-editing-error .ag-radio-button-input-wrapper:focus-within, .ag-cell-editing-error .ag-radio-button-input-wrapper:active {\n  box-shadow: var(--ag-input-error-focus-box-shadow);\n}\n.ag-radio-button-input-wrapper.ag-disabled {\n  opacity: 0.5;\n}\n.ag-radio-button-input-wrapper::after {\n  content: var(--ag-icon-font-code-radio-button-off, \"\\f127\");\n  color: var(--ag-checkbox-unchecked-color);\n  display: var(--ag-icon-font-display-radio-button-off, var(--ag-icon-font-display));\n  position: absolute;\n  top: 0;\n  left: 0;\n  pointer-events: none;\n}\n.ag-radio-button-input-wrapper.ag-checked::after {\n  content: var(--ag-icon-font-code-radio-button-on, \"\\f128\");\n  color: var(--ag-checkbox-checked-color);\n  display: var(--ag-icon-font-display-radio-button-on, var(--ag-icon-font-display));\n  position: absolute;\n  top: 0;\n  left: 0;\n  pointer-events: none;\n}\n.ag-radio-button-input-wrapper::before {\n  content: \"\";\n  background: transparent center/contain no-repeat;\n  position: absolute;\n  inset: 0;\n  background-image: var(--ag-icon-image-radio-button-off, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-radio-button-off, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-radio-button-off, var(--ag-icon-image-opacity, 0.9));\n}\n.ag-radio-button-input-wrapper.ag-checked::before {\n  background-image: var(--ag-icon-image-radio-button-on, var(--ag-icon-image));\n  display: var(--ag-icon-image-display-radio-button-on, var(--ag-icon-image-display));\n  opacity: var(--ag-icon-image-opacity-radio-button-on, var(--ag-icon-image-opacity, 0.9));\n}\n\ninput[class^=ag-][type=range] {\n  -webkit-appearance: none;\n  width: 100%;\n  height: 100%;\n  background: none;\n  overflow: visible;\n}\ninput[class^=ag-][type=range]::-webkit-slider-runnable-track {\n  margin: 0;\n  padding: 0;\n  width: 100%;\n  height: 3px;\n  background-color: var(--ag-border-color);\n  border-radius: var(--ag-border-radius);\n  border-radius: var(--ag-checkbox-border-radius);\n}\ninput[class^=ag-][type=range]::-moz-range-track {\n  margin: 0;\n  padding: 0;\n  width: 100%;\n  height: 3px;\n  background-color: var(--ag-border-color);\n  border-radius: var(--ag-border-radius);\n  border-radius: var(--ag-checkbox-border-radius);\n}\ninput[class^=ag-][type=range]::-ms-track {\n  margin: 0;\n  padding: 0;\n  width: 100%;\n  height: 3px;\n  background-color: var(--ag-border-color);\n  border-radius: var(--ag-border-radius);\n  border-radius: var(--ag-checkbox-border-radius);\n  color: transparent;\n  width: calc(100% - 2px);\n}\ninput[class^=ag-][type=range]::-webkit-slider-thumb {\n  margin: 0;\n  padding: 0;\n  -webkit-appearance: none;\n  width: var(--ag-icon-size);\n  height: var(--ag-icon-size);\n  background-color: var(--ag-background-color);\n  border: 1px solid;\n  border-color: var(--ag-checkbox-unchecked-color);\n  border-radius: var(--ag-icon-size);\n  transform: translateY(calc(var(--ag-icon-size) * -0.5 + 1.5px));\n}\ninput[class^=ag-][type=range]::-ms-thumb {\n  margin: 0;\n  padding: 0;\n  -webkit-appearance: none;\n  width: var(--ag-icon-size);\n  height: var(--ag-icon-size);\n  background-color: var(--ag-background-color);\n  border: 1px solid;\n  border-color: var(--ag-checkbox-unchecked-color);\n  border-radius: var(--ag-icon-size);\n}\ninput[class^=ag-][type=range]::-moz-ag-range-thumb {\n  margin: 0;\n  padding: 0;\n  -webkit-appearance: none;\n  width: var(--ag-icon-size);\n  height: var(--ag-icon-size);\n  background-color: var(--ag-background-color);\n  border: 1px solid;\n  border-color: var(--ag-checkbox-unchecked-color);\n  border-radius: var(--ag-icon-size);\n}\ninput[class^=ag-][type=range]:focus {\n  outline: none;\n}\ninput[class^=ag-][type=range]:focus::-webkit-slider-thumb {\n  box-shadow: var(--ag-input-focus-box-shadow);\n  border-color: var(--ag-checkbox-checked-color);\n}\ninput[class^=ag-][type=range]:focus::-ms-thumb {\n  box-shadow: var(--ag-input-focus-box-shadow);\n  border-color: var(--ag-checkbox-checked-color);\n}\ninput[class^=ag-][type=range]:focus::-moz-ag-range-thumb {\n  box-shadow: var(--ag-input-focus-box-shadow);\n  border-color: var(--ag-checkbox-checked-color);\n}\ninput[class^=ag-][type=range]:active::-webkit-slider-runnable-track {\n  background-color: var(--ag-input-focus-border-color);\n}\ninput[class^=ag-][type=range]:active::-moz-ag-range-track {\n  background-color: var(--ag-input-focus-border-color);\n}\ninput[class^=ag-][type=range]:active::-ms-track {\n  background-color: var(--ag-input-focus-border-color);\n}\ninput[class^=ag-][type=range]:disabled {\n  opacity: 0.5;\n}\n", ""]);
// Exports
/* harmony default export */ __webpack_exports__.A = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 71229:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(36758);
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40935);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".ag-theme-alpine,\n.ag-theme-alpine-dark,\n.ag-theme-alpine-auto-dark {\n  --ag-alpine-active-color: #2196f3;\n  --ag-selected-row-background-color: rgba(33, 150, 243, 0.3);\n  --ag-row-hover-color: rgba(33, 150, 243, 0.1);\n  --ag-column-hover-color: rgba(33, 150, 243, 0.1);\n  --ag-input-focus-border-color: rgba(33, 150, 243, 0.4);\n  --ag-range-selection-background-color: rgba(33, 150, 243, 0.2);\n  --ag-range-selection-background-color-2: rgba(33, 150, 243, 0.36);\n  --ag-range-selection-background-color-3: rgba(33, 150, 243, 0.49);\n  --ag-range-selection-background-color-4: rgba(33, 150, 243, 0.59);\n  --ag-row-numbers-selected-color: color-mix(in srgb, transparent, var(--ag-alpine-active-color) 50%);\n  --ag-background-color: #fff;\n  --ag-foreground-color: #181d1f;\n  --ag-border-color: #babfc7;\n  --ag-secondary-border-color: #dde2eb;\n  --ag-header-background-color: #f8f8f8;\n  --ag-tooltip-background-color: #f8f8f8;\n  --ag-odd-row-background-color: #fcfcfc;\n  --ag-control-panel-background-color: #f8f8f8;\n  --ag-subheader-background-color: #fff;\n  --ag-invalid-color: #e02525;\n  --ag-checkbox-unchecked-color: #999;\n  --ag-advanced-filter-join-pill-color: #f08e8d;\n  --ag-advanced-filter-column-pill-color: #a6e194;\n  --ag-advanced-filter-option-pill-color: #f3c08b;\n  --ag-advanced-filter-value-pill-color: #85c0e4;\n  --ag-find-match-color: var(--ag-foreground-color);\n  --ag-find-match-background-color: #ffff00;\n  --ag-find-active-match-color: var(--ag-foreground-color);\n  --ag-find-active-match-background-color: #ffa500;\n  --ag-checkbox-background-color: var(--ag-background-color);\n  --ag-checkbox-checked-color: var(--ag-alpine-active-color);\n  --ag-range-selection-border-color: var(--ag-alpine-active-color);\n  --ag-secondary-foreground-color: var(--ag-foreground-color);\n  --ag-input-border-color: var(--ag-border-color);\n  --ag-input-border-color-invalid: var(--ag-invalid-color);\n  --ag-input-focus-box-shadow: 0 0 2px 0.1rem var(--ag-input-focus-border-color);\n  --ag-input-error-focus-box-shadow: 0 0 2px 0.1rem var(--ag-invalid-color);\n  --ag-panel-background-color: var(--ag-header-background-color);\n  --ag-menu-background-color: var(--ag-header-background-color);\n  --ag-filter-panel-apply-button-color: var(--ag-background-color);\n  --ag-filter-panel-apply-button-background-color: var(--ag-alpine-active-color);\n  --ag-disabled-foreground-color: rgba(24, 29, 31, 0.5);\n  --ag-chip-background-color: rgba(24, 29, 31, 0.07);\n  --ag-input-disabled-border-color: rgba(186, 191, 199, 0.3);\n  --ag-input-disabled-background-color: rgba(186, 191, 199, 0.15);\n  --ag-borders: solid 1px;\n  --ag-border-radius: 3px;\n  --ag-borders-side-button: none;\n  --ag-side-button-selected-background-color: transparent;\n  --ag-header-column-resize-handle-display: block;\n  --ag-header-column-resize-handle-width: 2px;\n  --ag-header-column-resize-handle-height: 30%;\n  --ag-grid-size: 6px;\n  --ag-icon-size: 16px;\n  --ag-row-height: calc(var(--ag-grid-size) * 7);\n  --ag-header-height: calc(var(--ag-grid-size) * 8);\n  --ag-list-item-height: calc(var(--ag-grid-size) * 4);\n  --ag-column-select-indent-size: var(--ag-icon-size);\n  --ag-set-filter-indent-size: var(--ag-icon-size);\n  --ag-advanced-filter-builder-indent-size: calc(var(--ag-icon-size) + var(--ag-grid-size) * 2);\n  --ag-cell-horizontal-padding: calc(var(--ag-grid-size) * 3);\n  --ag-cell-widget-spacing: calc(var(--ag-grid-size) * 2);\n  --ag-widget-container-vertical-padding: calc(var(--ag-grid-size) * 2);\n  --ag-widget-container-horizontal-padding: calc(var(--ag-grid-size) * 2);\n  --ag-widget-vertical-spacing: calc(var(--ag-grid-size) * 1.5);\n  --ag-toggle-button-height: 18px;\n  --ag-toggle-button-width: 28px;\n  --ag-font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Oxygen-Sans, Ubuntu, Cantarell,\n      \"Helvetica Neue\", sans-serif;\n  --ag-font-size: 13px;\n  --ag-icon-font-family: agGridAlpine;\n  --ag-selected-tab-underline-color: var(--ag-alpine-active-color);\n  --ag-selected-tab-underline-width: 2px;\n  --ag-selected-tab-underline-transition-speed: 0.3s;\n  --ag-tab-min-width: 240px;\n  --ag-card-shadow: 0 1px 4px 1px rgba(186, 191, 199, 0.4);\n  --ag-popup-shadow: var(--ag-card-shadow);\n  --ag-side-bar-panel-width: 250px;\n}\n\n.ag-theme-alpine-dark {\n  --ag-background-color: #181d1f;\n  --ag-foreground-color: #fff;\n  --ag-border-color: #68686e;\n  --ag-secondary-border-color: rgba(88, 86, 82, 0.5);\n  --ag-modal-overlay-background-color: rgba(24, 29, 31, 0.66);\n  --ag-header-background-color: #222628;\n  --ag-tooltip-background-color: #222628;\n  --ag-odd-row-background-color: #222628;\n  --ag-control-panel-background-color: #222628;\n  --ag-subheader-background-color: #000;\n  --ag-input-disabled-background-color: #282c2f;\n  --ag-input-focus-box-shadow: 0 0 2px 0.5px rgba(255, 255, 255, 0.5), 0 0 4px 3px var(--ag-input-focus-border-color);\n  --ag-input-error-focus-box-shadow: 0 0 2px 0.5px rgba(255, 255, 255, 0.5),\n      0 0 4px 3px color-mix(in srgb, var(--ag-background-color), var(--ag-invalid-color) 0.5%);\n  --ag-card-shadow: 0 1px 20px 1px black;\n  --ag-disabled-foreground-color: rgba(255, 255, 255, 0.5);\n  --ag-chip-background-color: rgba(255, 255, 255, 0.07);\n  --ag-input-disabled-border-color: rgba(104, 104, 110, 0.3);\n  --ag-input-disabled-background-color: rgba(104, 104, 110, 0.07);\n  --ag-advanced-filter-join-pill-color: #7a3a37;\n  --ag-advanced-filter-column-pill-color: #355f2d;\n  --ag-advanced-filter-option-pill-color: #5a3168;\n  --ag-advanced-filter-value-pill-color: #374c86;\n  --ag-find-match-color: var(--ag-background-color);\n  --ag-find-active-match-color: var(--ag-background-color);\n  --ag-filter-panel-apply-button-color: var(--ag-foreground-color);\n  --ag-row-loading-skeleton-effect-color: rgba(202, 203, 204, 0.4);\n  --ag-cell-batch-edit-text-color: #f3d0b3;\n  color-scheme: dark;\n}\n\n@media (prefers-color-scheme: dark) {\n  .ag-theme-alpine-auto-dark {\n    --ag-background-color: #181d1f;\n    --ag-foreground-color: #fff;\n    --ag-border-color: #68686e;\n    --ag-secondary-border-color: rgba(88, 86, 82, 0.5);\n    --ag-modal-overlay-background-color: rgba(24, 29, 31, 0.66);\n    --ag-header-background-color: #222628;\n    --ag-tooltip-background-color: #222628;\n    --ag-odd-row-background-color: #222628;\n    --ag-control-panel-background-color: #222628;\n    --ag-subheader-background-color: #000;\n    --ag-input-disabled-background-color: #282c2f;\n    --ag-input-focus-box-shadow: 0 0 2px 0.5px rgba(255, 255, 255, 0.5), 0 0 4px 3px var(--ag-input-focus-border-color);\n    --ag-input-error-focus-box-shadow: 0 0 2px 0.5px rgba(255, 255, 255, 0.5),\n        0 0 4px 3px color-mix(in srgb, var(--ag-background-color), var(--ag-invalid-color) 0.5%);\n    --ag-card-shadow: 0 1px 20px 1px black;\n    --ag-disabled-foreground-color: rgba(255, 255, 255, 0.5);\n    --ag-chip-background-color: rgba(255, 255, 255, 0.07);\n    --ag-input-disabled-border-color: rgba(104, 104, 110, 0.3);\n    --ag-input-disabled-background-color: rgba(104, 104, 110, 0.07);\n    --ag-advanced-filter-join-pill-color: #7a3a37;\n    --ag-advanced-filter-column-pill-color: #355f2d;\n    --ag-advanced-filter-option-pill-color: #5a3168;\n    --ag-advanced-filter-value-pill-color: #374c86;\n    --ag-find-match-color: var(--ag-background-color);\n    --ag-find-active-match-color: var(--ag-background-color);\n    --ag-filter-panel-apply-button-color: var(--ag-foreground-color);\n    --ag-row-loading-skeleton-effect-color: rgba(202, 203, 204, 0.4);\n    --ag-cell-batch-edit-text-color: #f3d0b3;\n    color-scheme: dark;\n  }\n}\n.ag-theme-alpine .ag-filter-toolpanel-header,\n.ag-theme-alpine .ag-filter-toolpanel-search,\n.ag-theme-alpine .ag-status-bar,\n.ag-theme-alpine .ag-header-row,\n.ag-theme-alpine .ag-row-number-cell,\n.ag-theme-alpine .ag-panel-title-bar-title,\n.ag-theme-alpine .ag-multi-filter-group-title-bar,\n.ag-theme-alpine .ag-filter-card-title,\n.ag-theme-alpine-dark .ag-filter-toolpanel-header,\n.ag-theme-alpine-dark .ag-filter-toolpanel-search,\n.ag-theme-alpine-dark .ag-status-bar,\n.ag-theme-alpine-dark .ag-header-row,\n.ag-theme-alpine-dark .ag-row-number-cell,\n.ag-theme-alpine-dark .ag-panel-title-bar-title,\n.ag-theme-alpine-dark .ag-multi-filter-group-title-bar,\n.ag-theme-alpine-dark .ag-filter-card-title,\n.ag-theme-alpine-auto-dark .ag-filter-toolpanel-header,\n.ag-theme-alpine-auto-dark .ag-filter-toolpanel-search,\n.ag-theme-alpine-auto-dark .ag-status-bar,\n.ag-theme-alpine-auto-dark .ag-header-row,\n.ag-theme-alpine-auto-dark .ag-row-number-cell,\n.ag-theme-alpine-auto-dark .ag-panel-title-bar-title,\n.ag-theme-alpine-auto-dark .ag-multi-filter-group-title-bar,\n.ag-theme-alpine-auto-dark .ag-filter-card-title {\n  font-weight: 700;\n  color: var(--ag-header-foreground-color);\n}\n.ag-theme-alpine .ag-row,\n.ag-theme-alpine-dark .ag-row,\n.ag-theme-alpine-auto-dark .ag-row {\n  font-size: calc(var(--ag-font-size) + 1px);\n}\n.ag-theme-alpine input[class^=ag-]:not([type]),\n.ag-theme-alpine input[class^=ag-][type=text],\n.ag-theme-alpine input[class^=ag-][type=number],\n.ag-theme-alpine input[class^=ag-][type=tel],\n.ag-theme-alpine input[class^=ag-][type=date],\n.ag-theme-alpine input[class^=ag-][type=datetime-local],\n.ag-theme-alpine textarea[class^=ag-],\n.ag-theme-alpine-dark input[class^=ag-]:not([type]),\n.ag-theme-alpine-dark input[class^=ag-][type=text],\n.ag-theme-alpine-dark input[class^=ag-][type=number],\n.ag-theme-alpine-dark input[class^=ag-][type=tel],\n.ag-theme-alpine-dark input[class^=ag-][type=date],\n.ag-theme-alpine-dark input[class^=ag-][type=datetime-local],\n.ag-theme-alpine-dark textarea[class^=ag-],\n.ag-theme-alpine-auto-dark input[class^=ag-]:not([type]),\n.ag-theme-alpine-auto-dark input[class^=ag-][type=text],\n.ag-theme-alpine-auto-dark input[class^=ag-][type=number],\n.ag-theme-alpine-auto-dark input[class^=ag-][type=tel],\n.ag-theme-alpine-auto-dark input[class^=ag-][type=date],\n.ag-theme-alpine-auto-dark input[class^=ag-][type=datetime-local],\n.ag-theme-alpine-auto-dark textarea[class^=ag-] {\n  min-height: calc(var(--ag-grid-size) * 4);\n  border-radius: var(--ag-border-radius);\n}\n.ag-theme-alpine .ag-ltr input[class^=ag-]:not([type]), .ag-theme-alpine .ag-ltr input[class^=ag-][type=text], .ag-theme-alpine .ag-ltr input[class^=ag-][type=number], .ag-theme-alpine .ag-ltr input[class^=ag-][type=tel], .ag-theme-alpine .ag-ltr input[class^=ag-][type=date], .ag-theme-alpine .ag-ltr input[class^=ag-][type=datetime-local], .ag-theme-alpine .ag-ltr textarea[class^=ag-], .ag-theme-alpine-dark .ag-ltr input[class^=ag-]:not([type]), .ag-theme-alpine-dark .ag-ltr input[class^=ag-][type=text], .ag-theme-alpine-dark .ag-ltr input[class^=ag-][type=number], .ag-theme-alpine-dark .ag-ltr input[class^=ag-][type=tel], .ag-theme-alpine-dark .ag-ltr input[class^=ag-][type=date], .ag-theme-alpine-dark .ag-ltr input[class^=ag-][type=datetime-local], .ag-theme-alpine-dark .ag-ltr textarea[class^=ag-], .ag-theme-alpine-auto-dark .ag-ltr input[class^=ag-]:not([type]), .ag-theme-alpine-auto-dark .ag-ltr input[class^=ag-][type=text], .ag-theme-alpine-auto-dark .ag-ltr input[class^=ag-][type=number], .ag-theme-alpine-auto-dark .ag-ltr input[class^=ag-][type=tel], .ag-theme-alpine-auto-dark .ag-ltr input[class^=ag-][type=date], .ag-theme-alpine-auto-dark .ag-ltr input[class^=ag-][type=datetime-local], .ag-theme-alpine-auto-dark .ag-ltr textarea[class^=ag-] {\n  padding-left: var(--ag-grid-size);\n}\n\n.ag-theme-alpine .ag-rtl input[class^=ag-]:not([type]), .ag-theme-alpine .ag-rtl input[class^=ag-][type=text], .ag-theme-alpine .ag-rtl input[class^=ag-][type=number], .ag-theme-alpine .ag-rtl input[class^=ag-][type=tel], .ag-theme-alpine .ag-rtl input[class^=ag-][type=date], .ag-theme-alpine .ag-rtl input[class^=ag-][type=datetime-local], .ag-theme-alpine .ag-rtl textarea[class^=ag-], .ag-theme-alpine-dark .ag-rtl input[class^=ag-]:not([type]), .ag-theme-alpine-dark .ag-rtl input[class^=ag-][type=text], .ag-theme-alpine-dark .ag-rtl input[class^=ag-][type=number], .ag-theme-alpine-dark .ag-rtl input[class^=ag-][type=tel], .ag-theme-alpine-dark .ag-rtl input[class^=ag-][type=date], .ag-theme-alpine-dark .ag-rtl input[class^=ag-][type=datetime-local], .ag-theme-alpine-dark .ag-rtl textarea[class^=ag-], .ag-theme-alpine-auto-dark .ag-rtl input[class^=ag-]:not([type]), .ag-theme-alpine-auto-dark .ag-rtl input[class^=ag-][type=text], .ag-theme-alpine-auto-dark .ag-rtl input[class^=ag-][type=number], .ag-theme-alpine-auto-dark .ag-rtl input[class^=ag-][type=tel], .ag-theme-alpine-auto-dark .ag-rtl input[class^=ag-][type=date], .ag-theme-alpine-auto-dark .ag-rtl input[class^=ag-][type=datetime-local], .ag-theme-alpine-auto-dark .ag-rtl textarea[class^=ag-] {\n  padding-right: var(--ag-grid-size);\n}\n\n.ag-theme-alpine .ag-tab,\n.ag-theme-alpine-dark .ag-tab,\n.ag-theme-alpine-auto-dark .ag-tab {\n  padding: calc(var(--ag-grid-size) * 1.5);\n  transition: color 0.4s;\n  flex: 1 1 auto;\n}\n.ag-theme-alpine .ag-tab-selected,\n.ag-theme-alpine-dark .ag-tab-selected,\n.ag-theme-alpine-auto-dark .ag-tab-selected {\n  color: var(--ag-alpine-active-color);\n}\n.ag-theme-alpine .ag-menu,\n.ag-theme-alpine-dark .ag-menu,\n.ag-theme-alpine-auto-dark .ag-menu {\n  background-color: var(--ag-control-panel-background-color);\n}\n.ag-theme-alpine .ag-panel-content-wrapper .ag-column-select,\n.ag-theme-alpine-dark .ag-panel-content-wrapper .ag-column-select,\n.ag-theme-alpine-auto-dark .ag-panel-content-wrapper .ag-column-select {\n  background-color: var(--ag-control-panel-background-color);\n}\n.ag-theme-alpine .ag-menu-header,\n.ag-theme-alpine-dark .ag-menu-header,\n.ag-theme-alpine-auto-dark .ag-menu-header {\n  background-color: var(--ag-control-panel-background-color);\n  padding-top: 1px;\n}\n.ag-theme-alpine .ag-tabs-header,\n.ag-theme-alpine-dark .ag-tabs-header,\n.ag-theme-alpine-auto-dark .ag-tabs-header {\n  border-bottom: var(--ag-borders) var(--ag-border-color);\n}\n.ag-theme-alpine .ag-charts-settings-group-title-bar,\n.ag-theme-alpine .ag-charts-data-group-title-bar,\n.ag-theme-alpine .ag-charts-format-top-level-group-title-bar,\n.ag-theme-alpine .ag-charts-advanced-settings-top-level-group-title-bar,\n.ag-theme-alpine-dark .ag-charts-settings-group-title-bar,\n.ag-theme-alpine-dark .ag-charts-data-group-title-bar,\n.ag-theme-alpine-dark .ag-charts-format-top-level-group-title-bar,\n.ag-theme-alpine-dark .ag-charts-advanced-settings-top-level-group-title-bar,\n.ag-theme-alpine-auto-dark .ag-charts-settings-group-title-bar,\n.ag-theme-alpine-auto-dark .ag-charts-data-group-title-bar,\n.ag-theme-alpine-auto-dark .ag-charts-format-top-level-group-title-bar,\n.ag-theme-alpine-auto-dark .ag-charts-advanced-settings-top-level-group-title-bar {\n  padding: var(--ag-grid-size) calc(var(--ag-grid-size) * 2);\n  line-height: calc(var(--ag-icon-size) + var(--ag-grid-size) - 2px);\n}\n.ag-theme-alpine .ag-chart-mini-thumbnail,\n.ag-theme-alpine-dark .ag-chart-mini-thumbnail,\n.ag-theme-alpine-auto-dark .ag-chart-mini-thumbnail {\n  background-color: var(--ag-background-color);\n}\n.ag-theme-alpine .ag-chart-settings-nav-bar,\n.ag-theme-alpine-dark .ag-chart-settings-nav-bar,\n.ag-theme-alpine-auto-dark .ag-chart-settings-nav-bar {\n  border-top: var(--ag-borders-secondary) var(--ag-secondary-border-color);\n}\n.ag-theme-alpine .ag-ltr .ag-group-title-bar-icon, .ag-theme-alpine-dark .ag-ltr .ag-group-title-bar-icon, .ag-theme-alpine-auto-dark .ag-ltr .ag-group-title-bar-icon {\n  margin-right: var(--ag-grid-size);\n}\n\n.ag-theme-alpine .ag-rtl .ag-group-title-bar-icon, .ag-theme-alpine-dark .ag-rtl .ag-group-title-bar-icon, .ag-theme-alpine-auto-dark .ag-rtl .ag-group-title-bar-icon {\n  margin-left: var(--ag-grid-size);\n}\n\n.ag-theme-alpine .ag-charts-format-top-level-group-toolbar,\n.ag-theme-alpine .ag-charts-advanced-settings-top-level-group-toolbar,\n.ag-theme-alpine-dark .ag-charts-format-top-level-group-toolbar,\n.ag-theme-alpine-dark .ag-charts-advanced-settings-top-level-group-toolbar,\n.ag-theme-alpine-auto-dark .ag-charts-format-top-level-group-toolbar,\n.ag-theme-alpine-auto-dark .ag-charts-advanced-settings-top-level-group-toolbar {\n  margin-top: var(--ag-grid-size);\n}\n.ag-theme-alpine .ag-ltr .ag-charts-format-top-level-group-toolbar, .ag-theme-alpine .ag-ltr .ag-charts-advanced-settings-top-level-group-toolbar, .ag-theme-alpine-dark .ag-ltr .ag-charts-format-top-level-group-toolbar, .ag-theme-alpine-dark .ag-ltr .ag-charts-advanced-settings-top-level-group-toolbar, .ag-theme-alpine-auto-dark .ag-ltr .ag-charts-format-top-level-group-toolbar, .ag-theme-alpine-auto-dark .ag-ltr .ag-charts-advanced-settings-top-level-group-toolbar {\n  padding-left: calc(var(--ag-icon-size) * 0.5 + var(--ag-grid-size) * 2);\n}\n\n.ag-theme-alpine .ag-rtl .ag-charts-format-top-level-group-toolbar, .ag-theme-alpine .ag-rtl .ag-charts-advanced-settings-top-level-group-toolbar, .ag-theme-alpine-dark .ag-rtl .ag-charts-format-top-level-group-toolbar, .ag-theme-alpine-dark .ag-rtl .ag-charts-advanced-settings-top-level-group-toolbar, .ag-theme-alpine-auto-dark .ag-rtl .ag-charts-format-top-level-group-toolbar, .ag-theme-alpine-auto-dark .ag-rtl .ag-charts-advanced-settings-top-level-group-toolbar {\n  padding-right: calc(var(--ag-icon-size) * 0.5 + var(--ag-grid-size) * 2);\n}\n\n.ag-theme-alpine .ag-charts-format-sub-level-group,\n.ag-theme-alpine-dark .ag-charts-format-sub-level-group,\n.ag-theme-alpine-auto-dark .ag-charts-format-sub-level-group {\n  border-left: dashed 1px;\n  border-left-color: var(--ag-border-color);\n  padding-left: var(--ag-grid-size);\n  margin-bottom: calc(var(--ag-grid-size) * 2);\n}\n.ag-theme-alpine .ag-charts-format-sub-level-group-title-bar,\n.ag-theme-alpine-dark .ag-charts-format-sub-level-group-title-bar,\n.ag-theme-alpine-auto-dark .ag-charts-format-sub-level-group-title-bar {\n  padding-top: 0;\n  padding-bottom: 0;\n  background: none;\n  font-weight: 700;\n}\n.ag-theme-alpine .ag-charts-format-sub-level-group-container,\n.ag-theme-alpine-dark .ag-charts-format-sub-level-group-container,\n.ag-theme-alpine-auto-dark .ag-charts-format-sub-level-group-container {\n  padding-bottom: 0;\n}\n.ag-theme-alpine .ag-charts-format-sub-level-group-item:last-child,\n.ag-theme-alpine-dark .ag-charts-format-sub-level-group-item:last-child,\n.ag-theme-alpine-auto-dark .ag-charts-format-sub-level-group-item:last-child {\n  margin-bottom: 0;\n}\n.ag-theme-alpine.ag-dnd-ghost,\n.ag-theme-alpine-dark.ag-dnd-ghost,\n.ag-theme-alpine-auto-dark.ag-dnd-ghost {\n  font-size: calc(var(--ag-font-size) - 1px);\n  font-weight: 700;\n}\n.ag-theme-alpine .ag-side-buttons,\n.ag-theme-alpine-dark .ag-side-buttons,\n.ag-theme-alpine-auto-dark .ag-side-buttons {\n  width: calc(var(--ag-grid-size) * 5);\n}\n.ag-theme-alpine .ag-standard-button,\n.ag-theme-alpine-dark .ag-standard-button,\n.ag-theme-alpine-auto-dark .ag-standard-button {\n  font-family: inherit;\n  appearance: none;\n  -webkit-appearance: none;\n  border-radius: var(--ag-border-radius);\n  border: 1px solid;\n  border-color: var(--ag-alpine-active-color);\n  color: var(--ag-alpine-active-color);\n  background-color: var(--ag-background-color);\n  font-weight: 600;\n  padding: var(--ag-grid-size) calc(var(--ag-grid-size) * 2);\n}\n.ag-theme-alpine .ag-standard-button:hover,\n.ag-theme-alpine-dark .ag-standard-button:hover,\n.ag-theme-alpine-auto-dark .ag-standard-button:hover {\n  border-color: var(--ag-alpine-active-color);\n  background-color: var(--ag-row-hover-color);\n}\n.ag-theme-alpine .ag-standard-button:active,\n.ag-theme-alpine-dark .ag-standard-button:active,\n.ag-theme-alpine-auto-dark .ag-standard-button:active {\n  border-color: var(--ag-alpine-active-color);\n  background-color: var(--ag-alpine-active-color);\n  color: var(--ag-background-color);\n}\n.ag-theme-alpine .ag-standard-button:disabled,\n.ag-theme-alpine-dark .ag-standard-button:disabled,\n.ag-theme-alpine-auto-dark .ag-standard-button:disabled {\n  color: var(--ag-disabled-foreground-color);\n  background-color: var(--ag-input-disabled-background-color);\n  border-color: var(--ag-input-disabled-border-color);\n}\n.ag-theme-alpine .ag-column-drop-vertical,\n.ag-theme-alpine-dark .ag-column-drop-vertical,\n.ag-theme-alpine-auto-dark .ag-column-drop-vertical {\n  min-height: 75px;\n}\n.ag-theme-alpine .ag-column-drop-vertical-title-bar,\n.ag-theme-alpine-dark .ag-column-drop-vertical-title-bar,\n.ag-theme-alpine-auto-dark .ag-column-drop-vertical-title-bar {\n  padding: calc(var(--ag-grid-size) * 2);\n  padding-bottom: 0px;\n}\n.ag-theme-alpine .ag-column-drop-vertical-empty-message,\n.ag-theme-alpine-dark .ag-column-drop-vertical-empty-message,\n.ag-theme-alpine-auto-dark .ag-column-drop-vertical-empty-message {\n  display: flex;\n  align-items: center;\n  border: dashed 1px;\n  border-color: var(--ag-border-color);\n  margin: calc(var(--ag-grid-size) * 2);\n  padding: calc(var(--ag-grid-size) * 2);\n}\n.ag-theme-alpine .ag-column-drop-empty-message,\n.ag-theme-alpine-dark .ag-column-drop-empty-message,\n.ag-theme-alpine-auto-dark .ag-column-drop-empty-message {\n  color: var(--ag-foreground-color);\n  opacity: 0.75;\n}\n.ag-theme-alpine .ag-pill-select .ag-column-drop,\n.ag-theme-alpine-dark .ag-pill-select .ag-column-drop,\n.ag-theme-alpine-auto-dark .ag-pill-select .ag-column-drop {\n  min-height: unset;\n}\n.ag-theme-alpine .ag-status-bar,\n.ag-theme-alpine-dark .ag-status-bar,\n.ag-theme-alpine-auto-dark .ag-status-bar {\n  font-weight: normal;\n}\n.ag-theme-alpine .ag-status-name-value-value,\n.ag-theme-alpine-dark .ag-status-name-value-value,\n.ag-theme-alpine-auto-dark .ag-status-name-value-value {\n  font-weight: 700;\n}\n.ag-theme-alpine .ag-paging-number,\n.ag-theme-alpine .ag-paging-row-summary-panel-number,\n.ag-theme-alpine-dark .ag-paging-number,\n.ag-theme-alpine-dark .ag-paging-row-summary-panel-number,\n.ag-theme-alpine-auto-dark .ag-paging-number,\n.ag-theme-alpine-auto-dark .ag-paging-row-summary-panel-number {\n  font-weight: 700;\n}\n.ag-theme-alpine .ag-column-drop-cell-button,\n.ag-theme-alpine-dark .ag-column-drop-cell-button,\n.ag-theme-alpine-auto-dark .ag-column-drop-cell-button {\n  opacity: 0.5;\n}\n.ag-theme-alpine .ag-column-drop-cell-button:hover,\n.ag-theme-alpine-dark .ag-column-drop-cell-button:hover,\n.ag-theme-alpine-auto-dark .ag-column-drop-cell-button:hover {\n  opacity: 0.75;\n}\n.ag-theme-alpine .ag-column-select-column-readonly.ag-icon-grip,\n.ag-theme-alpine .ag-column-select-column-readonly .ag-icon-grip,\n.ag-theme-alpine-dark .ag-column-select-column-readonly.ag-icon-grip,\n.ag-theme-alpine-dark .ag-column-select-column-readonly .ag-icon-grip,\n.ag-theme-alpine-auto-dark .ag-column-select-column-readonly.ag-icon-grip,\n.ag-theme-alpine-auto-dark .ag-column-select-column-readonly .ag-icon-grip {\n  opacity: 0.35;\n}\n.ag-theme-alpine .ag-header-cell-menu-button:hover,\n.ag-theme-alpine .ag-header-cell-filter-button:hover,\n.ag-theme-alpine .ag-side-button-button:hover,\n.ag-theme-alpine .ag-tab:hover,\n.ag-theme-alpine .ag-panel-title-bar-button:hover,\n.ag-theme-alpine .ag-header-expand-icon:hover,\n.ag-theme-alpine .ag-column-group-icons:hover,\n.ag-theme-alpine .ag-set-filter-group-icons:hover,\n.ag-theme-alpine .ag-group-expanded .ag-icon:hover,\n.ag-theme-alpine .ag-group-contracted .ag-icon:hover,\n.ag-theme-alpine .ag-chart-settings-prev:hover,\n.ag-theme-alpine .ag-chart-settings-next:hover,\n.ag-theme-alpine .ag-group-title-bar-icon:hover,\n.ag-theme-alpine .ag-column-select-header-icon:hover,\n.ag-theme-alpine .ag-floating-filter-button-button:hover,\n.ag-theme-alpine .ag-filter-toolpanel-expand:hover,\n.ag-theme-alpine .ag-chart-menu-icon:hover,\n.ag-theme-alpine-dark .ag-header-cell-menu-button:hover,\n.ag-theme-alpine-dark .ag-header-cell-filter-button:hover,\n.ag-theme-alpine-dark .ag-side-button-button:hover,\n.ag-theme-alpine-dark .ag-tab:hover,\n.ag-theme-alpine-dark .ag-panel-title-bar-button:hover,\n.ag-theme-alpine-dark .ag-header-expand-icon:hover,\n.ag-theme-alpine-dark .ag-column-group-icons:hover,\n.ag-theme-alpine-dark .ag-set-filter-group-icons:hover,\n.ag-theme-alpine-dark .ag-group-expanded .ag-icon:hover,\n.ag-theme-alpine-dark .ag-group-contracted .ag-icon:hover,\n.ag-theme-alpine-dark .ag-chart-settings-prev:hover,\n.ag-theme-alpine-dark .ag-chart-settings-next:hover,\n.ag-theme-alpine-dark .ag-group-title-bar-icon:hover,\n.ag-theme-alpine-dark .ag-column-select-header-icon:hover,\n.ag-theme-alpine-dark .ag-floating-filter-button-button:hover,\n.ag-theme-alpine-dark .ag-filter-toolpanel-expand:hover,\n.ag-theme-alpine-dark .ag-chart-menu-icon:hover,\n.ag-theme-alpine-auto-dark .ag-header-cell-menu-button:hover,\n.ag-theme-alpine-auto-dark .ag-header-cell-filter-button:hover,\n.ag-theme-alpine-auto-dark .ag-side-button-button:hover,\n.ag-theme-alpine-auto-dark .ag-tab:hover,\n.ag-theme-alpine-auto-dark .ag-panel-title-bar-button:hover,\n.ag-theme-alpine-auto-dark .ag-header-expand-icon:hover,\n.ag-theme-alpine-auto-dark .ag-column-group-icons:hover,\n.ag-theme-alpine-auto-dark .ag-set-filter-group-icons:hover,\n.ag-theme-alpine-auto-dark .ag-group-expanded .ag-icon:hover,\n.ag-theme-alpine-auto-dark .ag-group-contracted .ag-icon:hover,\n.ag-theme-alpine-auto-dark .ag-chart-settings-prev:hover,\n.ag-theme-alpine-auto-dark .ag-chart-settings-next:hover,\n.ag-theme-alpine-auto-dark .ag-group-title-bar-icon:hover,\n.ag-theme-alpine-auto-dark .ag-column-select-header-icon:hover,\n.ag-theme-alpine-auto-dark .ag-floating-filter-button-button:hover,\n.ag-theme-alpine-auto-dark .ag-filter-toolpanel-expand:hover,\n.ag-theme-alpine-auto-dark .ag-chart-menu-icon:hover {\n  color: var(--ag-alpine-active-color);\n}\n.ag-theme-alpine .ag-header-cell-menu-button:hover .ag-icon,\n.ag-theme-alpine .ag-header-cell-filter-button:hover .ag-icon,\n.ag-theme-alpine .ag-side-button-button:hover .ag-icon,\n.ag-theme-alpine .ag-panel-title-bar-button:hover .ag-icon,\n.ag-theme-alpine .ag-floating-filter-button-button:hover .ag-icon,\n.ag-theme-alpine-dark .ag-header-cell-menu-button:hover .ag-icon,\n.ag-theme-alpine-dark .ag-header-cell-filter-button:hover .ag-icon,\n.ag-theme-alpine-dark .ag-side-button-button:hover .ag-icon,\n.ag-theme-alpine-dark .ag-panel-title-bar-button:hover .ag-icon,\n.ag-theme-alpine-dark .ag-floating-filter-button-button:hover .ag-icon,\n.ag-theme-alpine-auto-dark .ag-header-cell-menu-button:hover .ag-icon,\n.ag-theme-alpine-auto-dark .ag-header-cell-filter-button:hover .ag-icon,\n.ag-theme-alpine-auto-dark .ag-side-button-button:hover .ag-icon,\n.ag-theme-alpine-auto-dark .ag-panel-title-bar-button:hover .ag-icon,\n.ag-theme-alpine-auto-dark .ag-floating-filter-button-button:hover .ag-icon {\n  color: inherit;\n}\n.ag-theme-alpine .ag-filter-active .ag-icon-filter,\n.ag-theme-alpine-dark .ag-filter-active .ag-icon-filter,\n.ag-theme-alpine-auto-dark .ag-filter-active .ag-icon-filter {\n  color: var(--ag-alpine-active-color);\n}\n.ag-theme-alpine .ag-chart-settings-card-item.ag-not-selected:hover,\n.ag-theme-alpine-dark .ag-chart-settings-card-item.ag-not-selected:hover,\n.ag-theme-alpine-auto-dark .ag-chart-settings-card-item.ag-not-selected:hover {\n  opacity: 0.35;\n}\n.ag-theme-alpine .ag-ltr .ag-panel-title-bar-button, .ag-theme-alpine-dark .ag-ltr .ag-panel-title-bar-button, .ag-theme-alpine-auto-dark .ag-ltr .ag-panel-title-bar-button {\n  margin-left: calc(var(--ag-grid-size) * 2);\n  margin-right: var(--ag-grid-size);\n}\n\n.ag-theme-alpine .ag-rtl .ag-panel-title-bar-button, .ag-theme-alpine-dark .ag-rtl .ag-panel-title-bar-button, .ag-theme-alpine-auto-dark .ag-rtl .ag-panel-title-bar-button {\n  margin-right: calc(var(--ag-grid-size) * 2);\n  margin-left: var(--ag-grid-size);\n}\n\n.ag-theme-alpine .ag-ltr .ag-filter-toolpanel-group-container, .ag-theme-alpine-dark .ag-ltr .ag-filter-toolpanel-group-container, .ag-theme-alpine-auto-dark .ag-ltr .ag-filter-toolpanel-group-container {\n  padding-left: var(--ag-grid-size);\n}\n\n.ag-theme-alpine .ag-rtl .ag-filter-toolpanel-group-container, .ag-theme-alpine-dark .ag-rtl .ag-filter-toolpanel-group-container, .ag-theme-alpine-auto-dark .ag-rtl .ag-filter-toolpanel-group-container {\n  padding-right: var(--ag-grid-size);\n}\n\n.ag-theme-alpine .ag-filter-toolpanel-instance-filter,\n.ag-theme-alpine-dark .ag-filter-toolpanel-instance-filter,\n.ag-theme-alpine-auto-dark .ag-filter-toolpanel-instance-filter {\n  border: none;\n  background-color: var(--ag-control-panel-background-color);\n}\n.ag-theme-alpine .ag-ltr .ag-filter-toolpanel-instance-filter, .ag-theme-alpine-dark .ag-ltr .ag-filter-toolpanel-instance-filter, .ag-theme-alpine-auto-dark .ag-ltr .ag-filter-toolpanel-instance-filter {\n  border-left: dashed 1px;\n  border-left-color: var(--ag-border-color);\n  margin-left: calc(var(--ag-icon-size) * 0.5);\n}\n\n.ag-theme-alpine .ag-rtl .ag-filter-toolpanel-instance-filter, .ag-theme-alpine-dark .ag-rtl .ag-filter-toolpanel-instance-filter, .ag-theme-alpine-auto-dark .ag-rtl .ag-filter-toolpanel-instance-filter {\n  border-right: dashed 1px;\n  border-right-color: var(--ag-border-color);\n  margin-right: calc(var(--ag-icon-size) * 0.5);\n}\n\n.ag-theme-alpine .ag-set-filter-list,\n.ag-theme-alpine-dark .ag-set-filter-list,\n.ag-theme-alpine-auto-dark .ag-set-filter-list {\n  padding-top: calc(var(--ag-grid-size) * 0.5);\n  padding-bottom: calc(var(--ag-grid-size) * 0.5);\n}\n.ag-theme-alpine .ag-filter-add-button .ag-icon,\n.ag-theme-alpine-dark .ag-filter-add-button .ag-icon,\n.ag-theme-alpine-auto-dark .ag-filter-add-button .ag-icon {\n  color: var(--ag-alpine-active-color);\n}\n.ag-theme-alpine .ag-layout-auto-height .ag-center-cols-viewport,\n.ag-theme-alpine .ag-layout-auto-height .ag-center-cols-container,\n.ag-theme-alpine .ag-layout-print .ag-center-cols-viewport,\n.ag-theme-alpine .ag-layout-print .ag-center-cols-container,\n.ag-theme-alpine-dark .ag-layout-auto-height .ag-center-cols-viewport,\n.ag-theme-alpine-dark .ag-layout-auto-height .ag-center-cols-container,\n.ag-theme-alpine-dark .ag-layout-print .ag-center-cols-viewport,\n.ag-theme-alpine-dark .ag-layout-print .ag-center-cols-container,\n.ag-theme-alpine-auto-dark .ag-layout-auto-height .ag-center-cols-viewport,\n.ag-theme-alpine-auto-dark .ag-layout-auto-height .ag-center-cols-container,\n.ag-theme-alpine-auto-dark .ag-layout-print .ag-center-cols-viewport,\n.ag-theme-alpine-auto-dark .ag-layout-print .ag-center-cols-container {\n  min-height: 150px;\n}\n.ag-theme-alpine .ag-date-time-list-page-entry-is-current,\n.ag-theme-alpine-dark .ag-date-time-list-page-entry-is-current,\n.ag-theme-alpine-auto-dark .ag-date-time-list-page-entry-is-current {\n  background-color: var(--ag-alpine-active-color);\n}\n.ag-theme-alpine .ag-advanced-filter-builder-button,\n.ag-theme-alpine-dark .ag-advanced-filter-builder-button,\n.ag-theme-alpine-auto-dark .ag-advanced-filter-builder-button {\n  padding: var(--ag-grid-size);\n  font-weight: 600;\n}\n.ag-theme-alpine .ag-list-item-hovered::after,\n.ag-theme-alpine-dark .ag-list-item-hovered::after,\n.ag-theme-alpine-auto-dark .ag-list-item-hovered::after {\n  background-color: var(--ag-alpine-active-color);\n}\n.ag-theme-alpine .ag-pill .ag-pill-button:hover,\n.ag-theme-alpine-dark .ag-pill .ag-pill-button:hover,\n.ag-theme-alpine-auto-dark .ag-pill .ag-pill-button:hover {\n  color: var(--ag-alpine-active-color);\n}\n.ag-theme-alpine .ag-header-highlight-before::after,\n.ag-theme-alpine .ag-header-highlight-after::after,\n.ag-theme-alpine-dark .ag-header-highlight-before::after,\n.ag-theme-alpine-dark .ag-header-highlight-after::after,\n.ag-theme-alpine-auto-dark .ag-header-highlight-before::after,\n.ag-theme-alpine-auto-dark .ag-header-highlight-after::after {\n  background-color: var(--ag-alpine-active-color);\n}\n.ag-theme-alpine .ag-advanced-filter-builder-item-button-disabled .ag-icon,\n.ag-theme-alpine .ag-disabled .ag-icon,\n.ag-theme-alpine .ag-column-select-column-group-readonly .ag-icon,\n.ag-theme-alpine [disabled] .ag-icon,\n.ag-theme-alpine-dark .ag-advanced-filter-builder-item-button-disabled .ag-icon,\n.ag-theme-alpine-dark .ag-disabled .ag-icon,\n.ag-theme-alpine-dark .ag-column-select-column-group-readonly .ag-icon,\n.ag-theme-alpine-dark [disabled] .ag-icon,\n.ag-theme-alpine-auto-dark .ag-advanced-filter-builder-item-button-disabled .ag-icon,\n.ag-theme-alpine-auto-dark .ag-disabled .ag-icon,\n.ag-theme-alpine-auto-dark .ag-column-select-column-group-readonly .ag-icon,\n.ag-theme-alpine-auto-dark [disabled] .ag-icon {\n  color: var(--ag-disabled-foreground-color);\n}\n", ""]);
// Exports
/* harmony default export */ __webpack_exports__.A = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 93871:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(36758);
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40935);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20062);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(50221), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, "@font-face {\n  font-family: \"agGridAlpine\";\n  src: url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ");\n  font-weight: normal;\n  font-style: normal;\n}\n.ag-theme-alpine,\n.ag-theme-alpine-dark,\n.ag-theme-alpine-auto-dark {\n  --ag-alpine-active-color: #2196f3;\n  --ag-selected-row-background-color: rgba(33, 150, 243, 0.3);\n  --ag-row-hover-color: rgba(33, 150, 243, 0.1);\n  --ag-column-hover-color: rgba(33, 150, 243, 0.1);\n  --ag-input-focus-border-color: rgba(33, 150, 243, 0.4);\n  --ag-range-selection-background-color: rgba(33, 150, 243, 0.2);\n  --ag-range-selection-background-color-2: rgba(33, 150, 243, 0.36);\n  --ag-range-selection-background-color-3: rgba(33, 150, 243, 0.49);\n  --ag-range-selection-background-color-4: rgba(33, 150, 243, 0.59);\n  --ag-row-numbers-selected-color: color-mix(in srgb, transparent, var(--ag-alpine-active-color) 50%);\n  --ag-background-color: #fff;\n  --ag-foreground-color: #181d1f;\n  --ag-border-color: #babfc7;\n  --ag-secondary-border-color: #dde2eb;\n  --ag-header-background-color: #f8f8f8;\n  --ag-tooltip-background-color: #f8f8f8;\n  --ag-odd-row-background-color: #fcfcfc;\n  --ag-control-panel-background-color: #f8f8f8;\n  --ag-subheader-background-color: #fff;\n  --ag-invalid-color: #e02525;\n  --ag-checkbox-unchecked-color: #999;\n  --ag-advanced-filter-join-pill-color: #f08e8d;\n  --ag-advanced-filter-column-pill-color: #a6e194;\n  --ag-advanced-filter-option-pill-color: #f3c08b;\n  --ag-advanced-filter-value-pill-color: #85c0e4;\n  --ag-find-match-color: var(--ag-foreground-color);\n  --ag-find-match-background-color: #ffff00;\n  --ag-find-active-match-color: var(--ag-foreground-color);\n  --ag-find-active-match-background-color: #ffa500;\n  --ag-checkbox-background-color: var(--ag-background-color);\n  --ag-checkbox-checked-color: var(--ag-alpine-active-color);\n  --ag-range-selection-border-color: var(--ag-alpine-active-color);\n  --ag-secondary-foreground-color: var(--ag-foreground-color);\n  --ag-input-border-color: var(--ag-border-color);\n  --ag-input-border-color-invalid: var(--ag-invalid-color);\n  --ag-input-focus-box-shadow: 0 0 2px 0.1rem var(--ag-input-focus-border-color);\n  --ag-input-error-focus-box-shadow: 0 0 2px 0.1rem var(--ag-invalid-color);\n  --ag-panel-background-color: var(--ag-header-background-color);\n  --ag-menu-background-color: var(--ag-header-background-color);\n  --ag-filter-panel-apply-button-color: var(--ag-background-color);\n  --ag-filter-panel-apply-button-background-color: var(--ag-alpine-active-color);\n  --ag-disabled-foreground-color: rgba(24, 29, 31, 0.5);\n  --ag-chip-background-color: rgba(24, 29, 31, 0.07);\n  --ag-input-disabled-border-color: rgba(186, 191, 199, 0.3);\n  --ag-input-disabled-background-color: rgba(186, 191, 199, 0.15);\n  --ag-borders: solid 1px;\n  --ag-border-radius: 3px;\n  --ag-borders-side-button: none;\n  --ag-side-button-selected-background-color: transparent;\n  --ag-header-column-resize-handle-display: block;\n  --ag-header-column-resize-handle-width: 2px;\n  --ag-header-column-resize-handle-height: 30%;\n  --ag-grid-size: 6px;\n  --ag-icon-size: 16px;\n  --ag-row-height: calc(var(--ag-grid-size) * 7);\n  --ag-header-height: calc(var(--ag-grid-size) * 8);\n  --ag-list-item-height: calc(var(--ag-grid-size) * 4);\n  --ag-column-select-indent-size: var(--ag-icon-size);\n  --ag-set-filter-indent-size: var(--ag-icon-size);\n  --ag-advanced-filter-builder-indent-size: calc(var(--ag-icon-size) + var(--ag-grid-size) * 2);\n  --ag-cell-horizontal-padding: calc(var(--ag-grid-size) * 3);\n  --ag-cell-widget-spacing: calc(var(--ag-grid-size) * 2);\n  --ag-widget-container-vertical-padding: calc(var(--ag-grid-size) * 2);\n  --ag-widget-container-horizontal-padding: calc(var(--ag-grid-size) * 2);\n  --ag-widget-vertical-spacing: calc(var(--ag-grid-size) * 1.5);\n  --ag-toggle-button-height: 18px;\n  --ag-toggle-button-width: 28px;\n  --ag-font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Oxygen-Sans, Ubuntu, Cantarell,\n      \"Helvetica Neue\", sans-serif;\n  --ag-font-size: 13px;\n  --ag-icon-font-family: agGridAlpine;\n  --ag-selected-tab-underline-color: var(--ag-alpine-active-color);\n  --ag-selected-tab-underline-width: 2px;\n  --ag-selected-tab-underline-transition-speed: 0.3s;\n  --ag-tab-min-width: 240px;\n  --ag-card-shadow: 0 1px 4px 1px rgba(186, 191, 199, 0.4);\n  --ag-popup-shadow: var(--ag-card-shadow);\n  --ag-side-bar-panel-width: 250px;\n}\n\n.ag-theme-alpine-dark {\n  --ag-background-color: #181d1f;\n  --ag-foreground-color: #fff;\n  --ag-border-color: #68686e;\n  --ag-secondary-border-color: rgba(88, 86, 82, 0.5);\n  --ag-modal-overlay-background-color: rgba(24, 29, 31, 0.66);\n  --ag-header-background-color: #222628;\n  --ag-tooltip-background-color: #222628;\n  --ag-odd-row-background-color: #222628;\n  --ag-control-panel-background-color: #222628;\n  --ag-subheader-background-color: #000;\n  --ag-input-disabled-background-color: #282c2f;\n  --ag-input-focus-box-shadow: 0 0 2px 0.5px rgba(255, 255, 255, 0.5), 0 0 4px 3px var(--ag-input-focus-border-color);\n  --ag-input-error-focus-box-shadow: 0 0 2px 0.5px rgba(255, 255, 255, 0.5),\n      0 0 4px 3px color-mix(in srgb, var(--ag-background-color), var(--ag-invalid-color) 0.5%);\n  --ag-card-shadow: 0 1px 20px 1px black;\n  --ag-disabled-foreground-color: rgba(255, 255, 255, 0.5);\n  --ag-chip-background-color: rgba(255, 255, 255, 0.07);\n  --ag-input-disabled-border-color: rgba(104, 104, 110, 0.3);\n  --ag-input-disabled-background-color: rgba(104, 104, 110, 0.07);\n  --ag-advanced-filter-join-pill-color: #7a3a37;\n  --ag-advanced-filter-column-pill-color: #355f2d;\n  --ag-advanced-filter-option-pill-color: #5a3168;\n  --ag-advanced-filter-value-pill-color: #374c86;\n  --ag-find-match-color: var(--ag-background-color);\n  --ag-find-active-match-color: var(--ag-background-color);\n  --ag-filter-panel-apply-button-color: var(--ag-foreground-color);\n  --ag-row-loading-skeleton-effect-color: rgba(202, 203, 204, 0.4);\n  --ag-cell-batch-edit-text-color: #f3d0b3;\n  color-scheme: dark;\n}\n\n@media (prefers-color-scheme: dark) {\n  .ag-theme-alpine-auto-dark {\n    --ag-background-color: #181d1f;\n    --ag-foreground-color: #fff;\n    --ag-border-color: #68686e;\n    --ag-secondary-border-color: rgba(88, 86, 82, 0.5);\n    --ag-modal-overlay-background-color: rgba(24, 29, 31, 0.66);\n    --ag-header-background-color: #222628;\n    --ag-tooltip-background-color: #222628;\n    --ag-odd-row-background-color: #222628;\n    --ag-control-panel-background-color: #222628;\n    --ag-subheader-background-color: #000;\n    --ag-input-disabled-background-color: #282c2f;\n    --ag-input-focus-box-shadow: 0 0 2px 0.5px rgba(255, 255, 255, 0.5), 0 0 4px 3px var(--ag-input-focus-border-color);\n    --ag-input-error-focus-box-shadow: 0 0 2px 0.5px rgba(255, 255, 255, 0.5),\n        0 0 4px 3px color-mix(in srgb, var(--ag-background-color), var(--ag-invalid-color) 0.5%);\n    --ag-card-shadow: 0 1px 20px 1px black;\n    --ag-disabled-foreground-color: rgba(255, 255, 255, 0.5);\n    --ag-chip-background-color: rgba(255, 255, 255, 0.07);\n    --ag-input-disabled-border-color: rgba(104, 104, 110, 0.3);\n    --ag-input-disabled-background-color: rgba(104, 104, 110, 0.07);\n    --ag-advanced-filter-join-pill-color: #7a3a37;\n    --ag-advanced-filter-column-pill-color: #355f2d;\n    --ag-advanced-filter-option-pill-color: #5a3168;\n    --ag-advanced-filter-value-pill-color: #374c86;\n    --ag-find-match-color: var(--ag-background-color);\n    --ag-find-active-match-color: var(--ag-background-color);\n    --ag-filter-panel-apply-button-color: var(--ag-foreground-color);\n    --ag-row-loading-skeleton-effect-color: rgba(202, 203, 204, 0.4);\n    --ag-cell-batch-edit-text-color: #f3d0b3;\n    color-scheme: dark;\n  }\n}\n.ag-theme-alpine .ag-filter-toolpanel-header,\n.ag-theme-alpine .ag-filter-toolpanel-search,\n.ag-theme-alpine .ag-status-bar,\n.ag-theme-alpine .ag-header-row,\n.ag-theme-alpine .ag-row-number-cell,\n.ag-theme-alpine .ag-panel-title-bar-title,\n.ag-theme-alpine .ag-multi-filter-group-title-bar,\n.ag-theme-alpine .ag-filter-card-title,\n.ag-theme-alpine-dark .ag-filter-toolpanel-header,\n.ag-theme-alpine-dark .ag-filter-toolpanel-search,\n.ag-theme-alpine-dark .ag-status-bar,\n.ag-theme-alpine-dark .ag-header-row,\n.ag-theme-alpine-dark .ag-row-number-cell,\n.ag-theme-alpine-dark .ag-panel-title-bar-title,\n.ag-theme-alpine-dark .ag-multi-filter-group-title-bar,\n.ag-theme-alpine-dark .ag-filter-card-title,\n.ag-theme-alpine-auto-dark .ag-filter-toolpanel-header,\n.ag-theme-alpine-auto-dark .ag-filter-toolpanel-search,\n.ag-theme-alpine-auto-dark .ag-status-bar,\n.ag-theme-alpine-auto-dark .ag-header-row,\n.ag-theme-alpine-auto-dark .ag-row-number-cell,\n.ag-theme-alpine-auto-dark .ag-panel-title-bar-title,\n.ag-theme-alpine-auto-dark .ag-multi-filter-group-title-bar,\n.ag-theme-alpine-auto-dark .ag-filter-card-title {\n  font-weight: 700;\n  color: var(--ag-header-foreground-color);\n}\n.ag-theme-alpine .ag-row,\n.ag-theme-alpine-dark .ag-row,\n.ag-theme-alpine-auto-dark .ag-row {\n  font-size: calc(var(--ag-font-size) + 1px);\n}\n.ag-theme-alpine input[class^=ag-]:not([type]),\n.ag-theme-alpine input[class^=ag-][type=text],\n.ag-theme-alpine input[class^=ag-][type=number],\n.ag-theme-alpine input[class^=ag-][type=tel],\n.ag-theme-alpine input[class^=ag-][type=date],\n.ag-theme-alpine input[class^=ag-][type=datetime-local],\n.ag-theme-alpine textarea[class^=ag-],\n.ag-theme-alpine-dark input[class^=ag-]:not([type]),\n.ag-theme-alpine-dark input[class^=ag-][type=text],\n.ag-theme-alpine-dark input[class^=ag-][type=number],\n.ag-theme-alpine-dark input[class^=ag-][type=tel],\n.ag-theme-alpine-dark input[class^=ag-][type=date],\n.ag-theme-alpine-dark input[class^=ag-][type=datetime-local],\n.ag-theme-alpine-dark textarea[class^=ag-],\n.ag-theme-alpine-auto-dark input[class^=ag-]:not([type]),\n.ag-theme-alpine-auto-dark input[class^=ag-][type=text],\n.ag-theme-alpine-auto-dark input[class^=ag-][type=number],\n.ag-theme-alpine-auto-dark input[class^=ag-][type=tel],\n.ag-theme-alpine-auto-dark input[class^=ag-][type=date],\n.ag-theme-alpine-auto-dark input[class^=ag-][type=datetime-local],\n.ag-theme-alpine-auto-dark textarea[class^=ag-] {\n  min-height: calc(var(--ag-grid-size) * 4);\n  border-radius: var(--ag-border-radius);\n}\n.ag-theme-alpine .ag-ltr input[class^=ag-]:not([type]), .ag-theme-alpine .ag-ltr input[class^=ag-][type=text], .ag-theme-alpine .ag-ltr input[class^=ag-][type=number], .ag-theme-alpine .ag-ltr input[class^=ag-][type=tel], .ag-theme-alpine .ag-ltr input[class^=ag-][type=date], .ag-theme-alpine .ag-ltr input[class^=ag-][type=datetime-local], .ag-theme-alpine .ag-ltr textarea[class^=ag-], .ag-theme-alpine-dark .ag-ltr input[class^=ag-]:not([type]), .ag-theme-alpine-dark .ag-ltr input[class^=ag-][type=text], .ag-theme-alpine-dark .ag-ltr input[class^=ag-][type=number], .ag-theme-alpine-dark .ag-ltr input[class^=ag-][type=tel], .ag-theme-alpine-dark .ag-ltr input[class^=ag-][type=date], .ag-theme-alpine-dark .ag-ltr input[class^=ag-][type=datetime-local], .ag-theme-alpine-dark .ag-ltr textarea[class^=ag-], .ag-theme-alpine-auto-dark .ag-ltr input[class^=ag-]:not([type]), .ag-theme-alpine-auto-dark .ag-ltr input[class^=ag-][type=text], .ag-theme-alpine-auto-dark .ag-ltr input[class^=ag-][type=number], .ag-theme-alpine-auto-dark .ag-ltr input[class^=ag-][type=tel], .ag-theme-alpine-auto-dark .ag-ltr input[class^=ag-][type=date], .ag-theme-alpine-auto-dark .ag-ltr input[class^=ag-][type=datetime-local], .ag-theme-alpine-auto-dark .ag-ltr textarea[class^=ag-] {\n  padding-left: var(--ag-grid-size);\n}\n\n.ag-theme-alpine .ag-rtl input[class^=ag-]:not([type]), .ag-theme-alpine .ag-rtl input[class^=ag-][type=text], .ag-theme-alpine .ag-rtl input[class^=ag-][type=number], .ag-theme-alpine .ag-rtl input[class^=ag-][type=tel], .ag-theme-alpine .ag-rtl input[class^=ag-][type=date], .ag-theme-alpine .ag-rtl input[class^=ag-][type=datetime-local], .ag-theme-alpine .ag-rtl textarea[class^=ag-], .ag-theme-alpine-dark .ag-rtl input[class^=ag-]:not([type]), .ag-theme-alpine-dark .ag-rtl input[class^=ag-][type=text], .ag-theme-alpine-dark .ag-rtl input[class^=ag-][type=number], .ag-theme-alpine-dark .ag-rtl input[class^=ag-][type=tel], .ag-theme-alpine-dark .ag-rtl input[class^=ag-][type=date], .ag-theme-alpine-dark .ag-rtl input[class^=ag-][type=datetime-local], .ag-theme-alpine-dark .ag-rtl textarea[class^=ag-], .ag-theme-alpine-auto-dark .ag-rtl input[class^=ag-]:not([type]), .ag-theme-alpine-auto-dark .ag-rtl input[class^=ag-][type=text], .ag-theme-alpine-auto-dark .ag-rtl input[class^=ag-][type=number], .ag-theme-alpine-auto-dark .ag-rtl input[class^=ag-][type=tel], .ag-theme-alpine-auto-dark .ag-rtl input[class^=ag-][type=date], .ag-theme-alpine-auto-dark .ag-rtl input[class^=ag-][type=datetime-local], .ag-theme-alpine-auto-dark .ag-rtl textarea[class^=ag-] {\n  padding-right: var(--ag-grid-size);\n}\n\n.ag-theme-alpine .ag-tab,\n.ag-theme-alpine-dark .ag-tab,\n.ag-theme-alpine-auto-dark .ag-tab {\n  padding: calc(var(--ag-grid-size) * 1.5);\n  transition: color 0.4s;\n  flex: 1 1 auto;\n}\n.ag-theme-alpine .ag-tab-selected,\n.ag-theme-alpine-dark .ag-tab-selected,\n.ag-theme-alpine-auto-dark .ag-tab-selected {\n  color: var(--ag-alpine-active-color);\n}\n.ag-theme-alpine .ag-menu,\n.ag-theme-alpine-dark .ag-menu,\n.ag-theme-alpine-auto-dark .ag-menu {\n  background-color: var(--ag-control-panel-background-color);\n}\n.ag-theme-alpine .ag-panel-content-wrapper .ag-column-select,\n.ag-theme-alpine-dark .ag-panel-content-wrapper .ag-column-select,\n.ag-theme-alpine-auto-dark .ag-panel-content-wrapper .ag-column-select {\n  background-color: var(--ag-control-panel-background-color);\n}\n.ag-theme-alpine .ag-menu-header,\n.ag-theme-alpine-dark .ag-menu-header,\n.ag-theme-alpine-auto-dark .ag-menu-header {\n  background-color: var(--ag-control-panel-background-color);\n  padding-top: 1px;\n}\n.ag-theme-alpine .ag-tabs-header,\n.ag-theme-alpine-dark .ag-tabs-header,\n.ag-theme-alpine-auto-dark .ag-tabs-header {\n  border-bottom: var(--ag-borders) var(--ag-border-color);\n}\n.ag-theme-alpine .ag-charts-settings-group-title-bar,\n.ag-theme-alpine .ag-charts-data-group-title-bar,\n.ag-theme-alpine .ag-charts-format-top-level-group-title-bar,\n.ag-theme-alpine .ag-charts-advanced-settings-top-level-group-title-bar,\n.ag-theme-alpine-dark .ag-charts-settings-group-title-bar,\n.ag-theme-alpine-dark .ag-charts-data-group-title-bar,\n.ag-theme-alpine-dark .ag-charts-format-top-level-group-title-bar,\n.ag-theme-alpine-dark .ag-charts-advanced-settings-top-level-group-title-bar,\n.ag-theme-alpine-auto-dark .ag-charts-settings-group-title-bar,\n.ag-theme-alpine-auto-dark .ag-charts-data-group-title-bar,\n.ag-theme-alpine-auto-dark .ag-charts-format-top-level-group-title-bar,\n.ag-theme-alpine-auto-dark .ag-charts-advanced-settings-top-level-group-title-bar {\n  padding: var(--ag-grid-size) calc(var(--ag-grid-size) * 2);\n  line-height: calc(var(--ag-icon-size) + var(--ag-grid-size) - 2px);\n}\n.ag-theme-alpine .ag-chart-mini-thumbnail,\n.ag-theme-alpine-dark .ag-chart-mini-thumbnail,\n.ag-theme-alpine-auto-dark .ag-chart-mini-thumbnail {\n  background-color: var(--ag-background-color);\n}\n.ag-theme-alpine .ag-chart-settings-nav-bar,\n.ag-theme-alpine-dark .ag-chart-settings-nav-bar,\n.ag-theme-alpine-auto-dark .ag-chart-settings-nav-bar {\n  border-top: var(--ag-borders-secondary) var(--ag-secondary-border-color);\n}\n.ag-theme-alpine .ag-ltr .ag-group-title-bar-icon, .ag-theme-alpine-dark .ag-ltr .ag-group-title-bar-icon, .ag-theme-alpine-auto-dark .ag-ltr .ag-group-title-bar-icon {\n  margin-right: var(--ag-grid-size);\n}\n\n.ag-theme-alpine .ag-rtl .ag-group-title-bar-icon, .ag-theme-alpine-dark .ag-rtl .ag-group-title-bar-icon, .ag-theme-alpine-auto-dark .ag-rtl .ag-group-title-bar-icon {\n  margin-left: var(--ag-grid-size);\n}\n\n.ag-theme-alpine .ag-charts-format-top-level-group-toolbar,\n.ag-theme-alpine .ag-charts-advanced-settings-top-level-group-toolbar,\n.ag-theme-alpine-dark .ag-charts-format-top-level-group-toolbar,\n.ag-theme-alpine-dark .ag-charts-advanced-settings-top-level-group-toolbar,\n.ag-theme-alpine-auto-dark .ag-charts-format-top-level-group-toolbar,\n.ag-theme-alpine-auto-dark .ag-charts-advanced-settings-top-level-group-toolbar {\n  margin-top: var(--ag-grid-size);\n}\n.ag-theme-alpine .ag-ltr .ag-charts-format-top-level-group-toolbar, .ag-theme-alpine .ag-ltr .ag-charts-advanced-settings-top-level-group-toolbar, .ag-theme-alpine-dark .ag-ltr .ag-charts-format-top-level-group-toolbar, .ag-theme-alpine-dark .ag-ltr .ag-charts-advanced-settings-top-level-group-toolbar, .ag-theme-alpine-auto-dark .ag-ltr .ag-charts-format-top-level-group-toolbar, .ag-theme-alpine-auto-dark .ag-ltr .ag-charts-advanced-settings-top-level-group-toolbar {\n  padding-left: calc(var(--ag-icon-size) * 0.5 + var(--ag-grid-size) * 2);\n}\n\n.ag-theme-alpine .ag-rtl .ag-charts-format-top-level-group-toolbar, .ag-theme-alpine .ag-rtl .ag-charts-advanced-settings-top-level-group-toolbar, .ag-theme-alpine-dark .ag-rtl .ag-charts-format-top-level-group-toolbar, .ag-theme-alpine-dark .ag-rtl .ag-charts-advanced-settings-top-level-group-toolbar, .ag-theme-alpine-auto-dark .ag-rtl .ag-charts-format-top-level-group-toolbar, .ag-theme-alpine-auto-dark .ag-rtl .ag-charts-advanced-settings-top-level-group-toolbar {\n  padding-right: calc(var(--ag-icon-size) * 0.5 + var(--ag-grid-size) * 2);\n}\n\n.ag-theme-alpine .ag-charts-format-sub-level-group,\n.ag-theme-alpine-dark .ag-charts-format-sub-level-group,\n.ag-theme-alpine-auto-dark .ag-charts-format-sub-level-group {\n  border-left: dashed 1px;\n  border-left-color: var(--ag-border-color);\n  padding-left: var(--ag-grid-size);\n  margin-bottom: calc(var(--ag-grid-size) * 2);\n}\n.ag-theme-alpine .ag-charts-format-sub-level-group-title-bar,\n.ag-theme-alpine-dark .ag-charts-format-sub-level-group-title-bar,\n.ag-theme-alpine-auto-dark .ag-charts-format-sub-level-group-title-bar {\n  padding-top: 0;\n  padding-bottom: 0;\n  background: none;\n  font-weight: 700;\n}\n.ag-theme-alpine .ag-charts-format-sub-level-group-container,\n.ag-theme-alpine-dark .ag-charts-format-sub-level-group-container,\n.ag-theme-alpine-auto-dark .ag-charts-format-sub-level-group-container {\n  padding-bottom: 0;\n}\n.ag-theme-alpine .ag-charts-format-sub-level-group-item:last-child,\n.ag-theme-alpine-dark .ag-charts-format-sub-level-group-item:last-child,\n.ag-theme-alpine-auto-dark .ag-charts-format-sub-level-group-item:last-child {\n  margin-bottom: 0;\n}\n.ag-theme-alpine.ag-dnd-ghost,\n.ag-theme-alpine-dark.ag-dnd-ghost,\n.ag-theme-alpine-auto-dark.ag-dnd-ghost {\n  font-size: calc(var(--ag-font-size) - 1px);\n  font-weight: 700;\n}\n.ag-theme-alpine .ag-side-buttons,\n.ag-theme-alpine-dark .ag-side-buttons,\n.ag-theme-alpine-auto-dark .ag-side-buttons {\n  width: calc(var(--ag-grid-size) * 5);\n}\n.ag-theme-alpine .ag-standard-button,\n.ag-theme-alpine-dark .ag-standard-button,\n.ag-theme-alpine-auto-dark .ag-standard-button {\n  font-family: inherit;\n  appearance: none;\n  -webkit-appearance: none;\n  border-radius: var(--ag-border-radius);\n  border: 1px solid;\n  border-color: var(--ag-alpine-active-color);\n  color: var(--ag-alpine-active-color);\n  background-color: var(--ag-background-color);\n  font-weight: 600;\n  padding: var(--ag-grid-size) calc(var(--ag-grid-size) * 2);\n}\n.ag-theme-alpine .ag-standard-button:hover,\n.ag-theme-alpine-dark .ag-standard-button:hover,\n.ag-theme-alpine-auto-dark .ag-standard-button:hover {\n  border-color: var(--ag-alpine-active-color);\n  background-color: var(--ag-row-hover-color);\n}\n.ag-theme-alpine .ag-standard-button:active,\n.ag-theme-alpine-dark .ag-standard-button:active,\n.ag-theme-alpine-auto-dark .ag-standard-button:active {\n  border-color: var(--ag-alpine-active-color);\n  background-color: var(--ag-alpine-active-color);\n  color: var(--ag-background-color);\n}\n.ag-theme-alpine .ag-standard-button:disabled,\n.ag-theme-alpine-dark .ag-standard-button:disabled,\n.ag-theme-alpine-auto-dark .ag-standard-button:disabled {\n  color: var(--ag-disabled-foreground-color);\n  background-color: var(--ag-input-disabled-background-color);\n  border-color: var(--ag-input-disabled-border-color);\n}\n.ag-theme-alpine .ag-column-drop-vertical,\n.ag-theme-alpine-dark .ag-column-drop-vertical,\n.ag-theme-alpine-auto-dark .ag-column-drop-vertical {\n  min-height: 75px;\n}\n.ag-theme-alpine .ag-column-drop-vertical-title-bar,\n.ag-theme-alpine-dark .ag-column-drop-vertical-title-bar,\n.ag-theme-alpine-auto-dark .ag-column-drop-vertical-title-bar {\n  padding: calc(var(--ag-grid-size) * 2);\n  padding-bottom: 0px;\n}\n.ag-theme-alpine .ag-column-drop-vertical-empty-message,\n.ag-theme-alpine-dark .ag-column-drop-vertical-empty-message,\n.ag-theme-alpine-auto-dark .ag-column-drop-vertical-empty-message {\n  display: flex;\n  align-items: center;\n  border: dashed 1px;\n  border-color: var(--ag-border-color);\n  margin: calc(var(--ag-grid-size) * 2);\n  padding: calc(var(--ag-grid-size) * 2);\n}\n.ag-theme-alpine .ag-column-drop-empty-message,\n.ag-theme-alpine-dark .ag-column-drop-empty-message,\n.ag-theme-alpine-auto-dark .ag-column-drop-empty-message {\n  color: var(--ag-foreground-color);\n  opacity: 0.75;\n}\n.ag-theme-alpine .ag-pill-select .ag-column-drop,\n.ag-theme-alpine-dark .ag-pill-select .ag-column-drop,\n.ag-theme-alpine-auto-dark .ag-pill-select .ag-column-drop {\n  min-height: unset;\n}\n.ag-theme-alpine .ag-status-bar,\n.ag-theme-alpine-dark .ag-status-bar,\n.ag-theme-alpine-auto-dark .ag-status-bar {\n  font-weight: normal;\n}\n.ag-theme-alpine .ag-status-name-value-value,\n.ag-theme-alpine-dark .ag-status-name-value-value,\n.ag-theme-alpine-auto-dark .ag-status-name-value-value {\n  font-weight: 700;\n}\n.ag-theme-alpine .ag-paging-number,\n.ag-theme-alpine .ag-paging-row-summary-panel-number,\n.ag-theme-alpine-dark .ag-paging-number,\n.ag-theme-alpine-dark .ag-paging-row-summary-panel-number,\n.ag-theme-alpine-auto-dark .ag-paging-number,\n.ag-theme-alpine-auto-dark .ag-paging-row-summary-panel-number {\n  font-weight: 700;\n}\n.ag-theme-alpine .ag-column-drop-cell-button,\n.ag-theme-alpine-dark .ag-column-drop-cell-button,\n.ag-theme-alpine-auto-dark .ag-column-drop-cell-button {\n  opacity: 0.5;\n}\n.ag-theme-alpine .ag-column-drop-cell-button:hover,\n.ag-theme-alpine-dark .ag-column-drop-cell-button:hover,\n.ag-theme-alpine-auto-dark .ag-column-drop-cell-button:hover {\n  opacity: 0.75;\n}\n.ag-theme-alpine .ag-column-select-column-readonly.ag-icon-grip,\n.ag-theme-alpine .ag-column-select-column-readonly .ag-icon-grip,\n.ag-theme-alpine-dark .ag-column-select-column-readonly.ag-icon-grip,\n.ag-theme-alpine-dark .ag-column-select-column-readonly .ag-icon-grip,\n.ag-theme-alpine-auto-dark .ag-column-select-column-readonly.ag-icon-grip,\n.ag-theme-alpine-auto-dark .ag-column-select-column-readonly .ag-icon-grip {\n  opacity: 0.35;\n}\n.ag-theme-alpine .ag-header-cell-menu-button:hover,\n.ag-theme-alpine .ag-header-cell-filter-button:hover,\n.ag-theme-alpine .ag-side-button-button:hover,\n.ag-theme-alpine .ag-tab:hover,\n.ag-theme-alpine .ag-panel-title-bar-button:hover,\n.ag-theme-alpine .ag-header-expand-icon:hover,\n.ag-theme-alpine .ag-column-group-icons:hover,\n.ag-theme-alpine .ag-set-filter-group-icons:hover,\n.ag-theme-alpine .ag-group-expanded .ag-icon:hover,\n.ag-theme-alpine .ag-group-contracted .ag-icon:hover,\n.ag-theme-alpine .ag-chart-settings-prev:hover,\n.ag-theme-alpine .ag-chart-settings-next:hover,\n.ag-theme-alpine .ag-group-title-bar-icon:hover,\n.ag-theme-alpine .ag-column-select-header-icon:hover,\n.ag-theme-alpine .ag-floating-filter-button-button:hover,\n.ag-theme-alpine .ag-filter-toolpanel-expand:hover,\n.ag-theme-alpine .ag-chart-menu-icon:hover,\n.ag-theme-alpine-dark .ag-header-cell-menu-button:hover,\n.ag-theme-alpine-dark .ag-header-cell-filter-button:hover,\n.ag-theme-alpine-dark .ag-side-button-button:hover,\n.ag-theme-alpine-dark .ag-tab:hover,\n.ag-theme-alpine-dark .ag-panel-title-bar-button:hover,\n.ag-theme-alpine-dark .ag-header-expand-icon:hover,\n.ag-theme-alpine-dark .ag-column-group-icons:hover,\n.ag-theme-alpine-dark .ag-set-filter-group-icons:hover,\n.ag-theme-alpine-dark .ag-group-expanded .ag-icon:hover,\n.ag-theme-alpine-dark .ag-group-contracted .ag-icon:hover,\n.ag-theme-alpine-dark .ag-chart-settings-prev:hover,\n.ag-theme-alpine-dark .ag-chart-settings-next:hover,\n.ag-theme-alpine-dark .ag-group-title-bar-icon:hover,\n.ag-theme-alpine-dark .ag-column-select-header-icon:hover,\n.ag-theme-alpine-dark .ag-floating-filter-button-button:hover,\n.ag-theme-alpine-dark .ag-filter-toolpanel-expand:hover,\n.ag-theme-alpine-dark .ag-chart-menu-icon:hover,\n.ag-theme-alpine-auto-dark .ag-header-cell-menu-button:hover,\n.ag-theme-alpine-auto-dark .ag-header-cell-filter-button:hover,\n.ag-theme-alpine-auto-dark .ag-side-button-button:hover,\n.ag-theme-alpine-auto-dark .ag-tab:hover,\n.ag-theme-alpine-auto-dark .ag-panel-title-bar-button:hover,\n.ag-theme-alpine-auto-dark .ag-header-expand-icon:hover,\n.ag-theme-alpine-auto-dark .ag-column-group-icons:hover,\n.ag-theme-alpine-auto-dark .ag-set-filter-group-icons:hover,\n.ag-theme-alpine-auto-dark .ag-group-expanded .ag-icon:hover,\n.ag-theme-alpine-auto-dark .ag-group-contracted .ag-icon:hover,\n.ag-theme-alpine-auto-dark .ag-chart-settings-prev:hover,\n.ag-theme-alpine-auto-dark .ag-chart-settings-next:hover,\n.ag-theme-alpine-auto-dark .ag-group-title-bar-icon:hover,\n.ag-theme-alpine-auto-dark .ag-column-select-header-icon:hover,\n.ag-theme-alpine-auto-dark .ag-floating-filter-button-button:hover,\n.ag-theme-alpine-auto-dark .ag-filter-toolpanel-expand:hover,\n.ag-theme-alpine-auto-dark .ag-chart-menu-icon:hover {\n  color: var(--ag-alpine-active-color);\n}\n.ag-theme-alpine .ag-header-cell-menu-button:hover .ag-icon,\n.ag-theme-alpine .ag-header-cell-filter-button:hover .ag-icon,\n.ag-theme-alpine .ag-side-button-button:hover .ag-icon,\n.ag-theme-alpine .ag-panel-title-bar-button:hover .ag-icon,\n.ag-theme-alpine .ag-floating-filter-button-button:hover .ag-icon,\n.ag-theme-alpine-dark .ag-header-cell-menu-button:hover .ag-icon,\n.ag-theme-alpine-dark .ag-header-cell-filter-button:hover .ag-icon,\n.ag-theme-alpine-dark .ag-side-button-button:hover .ag-icon,\n.ag-theme-alpine-dark .ag-panel-title-bar-button:hover .ag-icon,\n.ag-theme-alpine-dark .ag-floating-filter-button-button:hover .ag-icon,\n.ag-theme-alpine-auto-dark .ag-header-cell-menu-button:hover .ag-icon,\n.ag-theme-alpine-auto-dark .ag-header-cell-filter-button:hover .ag-icon,\n.ag-theme-alpine-auto-dark .ag-side-button-button:hover .ag-icon,\n.ag-theme-alpine-auto-dark .ag-panel-title-bar-button:hover .ag-icon,\n.ag-theme-alpine-auto-dark .ag-floating-filter-button-button:hover .ag-icon {\n  color: inherit;\n}\n.ag-theme-alpine .ag-filter-active .ag-icon-filter,\n.ag-theme-alpine-dark .ag-filter-active .ag-icon-filter,\n.ag-theme-alpine-auto-dark .ag-filter-active .ag-icon-filter {\n  color: var(--ag-alpine-active-color);\n}\n.ag-theme-alpine .ag-chart-settings-card-item.ag-not-selected:hover,\n.ag-theme-alpine-dark .ag-chart-settings-card-item.ag-not-selected:hover,\n.ag-theme-alpine-auto-dark .ag-chart-settings-card-item.ag-not-selected:hover {\n  opacity: 0.35;\n}\n.ag-theme-alpine .ag-ltr .ag-panel-title-bar-button, .ag-theme-alpine-dark .ag-ltr .ag-panel-title-bar-button, .ag-theme-alpine-auto-dark .ag-ltr .ag-panel-title-bar-button {\n  margin-left: calc(var(--ag-grid-size) * 2);\n  margin-right: var(--ag-grid-size);\n}\n\n.ag-theme-alpine .ag-rtl .ag-panel-title-bar-button, .ag-theme-alpine-dark .ag-rtl .ag-panel-title-bar-button, .ag-theme-alpine-auto-dark .ag-rtl .ag-panel-title-bar-button {\n  margin-right: calc(var(--ag-grid-size) * 2);\n  margin-left: var(--ag-grid-size);\n}\n\n.ag-theme-alpine .ag-ltr .ag-filter-toolpanel-group-container, .ag-theme-alpine-dark .ag-ltr .ag-filter-toolpanel-group-container, .ag-theme-alpine-auto-dark .ag-ltr .ag-filter-toolpanel-group-container {\n  padding-left: var(--ag-grid-size);\n}\n\n.ag-theme-alpine .ag-rtl .ag-filter-toolpanel-group-container, .ag-theme-alpine-dark .ag-rtl .ag-filter-toolpanel-group-container, .ag-theme-alpine-auto-dark .ag-rtl .ag-filter-toolpanel-group-container {\n  padding-right: var(--ag-grid-size);\n}\n\n.ag-theme-alpine .ag-filter-toolpanel-instance-filter,\n.ag-theme-alpine-dark .ag-filter-toolpanel-instance-filter,\n.ag-theme-alpine-auto-dark .ag-filter-toolpanel-instance-filter {\n  border: none;\n  background-color: var(--ag-control-panel-background-color);\n}\n.ag-theme-alpine .ag-ltr .ag-filter-toolpanel-instance-filter, .ag-theme-alpine-dark .ag-ltr .ag-filter-toolpanel-instance-filter, .ag-theme-alpine-auto-dark .ag-ltr .ag-filter-toolpanel-instance-filter {\n  border-left: dashed 1px;\n  border-left-color: var(--ag-border-color);\n  margin-left: calc(var(--ag-icon-size) * 0.5);\n}\n\n.ag-theme-alpine .ag-rtl .ag-filter-toolpanel-instance-filter, .ag-theme-alpine-dark .ag-rtl .ag-filter-toolpanel-instance-filter, .ag-theme-alpine-auto-dark .ag-rtl .ag-filter-toolpanel-instance-filter {\n  border-right: dashed 1px;\n  border-right-color: var(--ag-border-color);\n  margin-right: calc(var(--ag-icon-size) * 0.5);\n}\n\n.ag-theme-alpine .ag-set-filter-list,\n.ag-theme-alpine-dark .ag-set-filter-list,\n.ag-theme-alpine-auto-dark .ag-set-filter-list {\n  padding-top: calc(var(--ag-grid-size) * 0.5);\n  padding-bottom: calc(var(--ag-grid-size) * 0.5);\n}\n.ag-theme-alpine .ag-filter-add-button .ag-icon,\n.ag-theme-alpine-dark .ag-filter-add-button .ag-icon,\n.ag-theme-alpine-auto-dark .ag-filter-add-button .ag-icon {\n  color: var(--ag-alpine-active-color);\n}\n.ag-theme-alpine .ag-layout-auto-height .ag-center-cols-viewport,\n.ag-theme-alpine .ag-layout-auto-height .ag-center-cols-container,\n.ag-theme-alpine .ag-layout-print .ag-center-cols-viewport,\n.ag-theme-alpine .ag-layout-print .ag-center-cols-container,\n.ag-theme-alpine-dark .ag-layout-auto-height .ag-center-cols-viewport,\n.ag-theme-alpine-dark .ag-layout-auto-height .ag-center-cols-container,\n.ag-theme-alpine-dark .ag-layout-print .ag-center-cols-viewport,\n.ag-theme-alpine-dark .ag-layout-print .ag-center-cols-container,\n.ag-theme-alpine-auto-dark .ag-layout-auto-height .ag-center-cols-viewport,\n.ag-theme-alpine-auto-dark .ag-layout-auto-height .ag-center-cols-container,\n.ag-theme-alpine-auto-dark .ag-layout-print .ag-center-cols-viewport,\n.ag-theme-alpine-auto-dark .ag-layout-print .ag-center-cols-container {\n  min-height: 150px;\n}\n.ag-theme-alpine .ag-date-time-list-page-entry-is-current,\n.ag-theme-alpine-dark .ag-date-time-list-page-entry-is-current,\n.ag-theme-alpine-auto-dark .ag-date-time-list-page-entry-is-current {\n  background-color: var(--ag-alpine-active-color);\n}\n.ag-theme-alpine .ag-advanced-filter-builder-button,\n.ag-theme-alpine-dark .ag-advanced-filter-builder-button,\n.ag-theme-alpine-auto-dark .ag-advanced-filter-builder-button {\n  padding: var(--ag-grid-size);\n  font-weight: 600;\n}\n.ag-theme-alpine .ag-list-item-hovered::after,\n.ag-theme-alpine-dark .ag-list-item-hovered::after,\n.ag-theme-alpine-auto-dark .ag-list-item-hovered::after {\n  background-color: var(--ag-alpine-active-color);\n}\n.ag-theme-alpine .ag-pill .ag-pill-button:hover,\n.ag-theme-alpine-dark .ag-pill .ag-pill-button:hover,\n.ag-theme-alpine-auto-dark .ag-pill .ag-pill-button:hover {\n  color: var(--ag-alpine-active-color);\n}\n.ag-theme-alpine .ag-header-highlight-before::after,\n.ag-theme-alpine .ag-header-highlight-after::after,\n.ag-theme-alpine-dark .ag-header-highlight-before::after,\n.ag-theme-alpine-dark .ag-header-highlight-after::after,\n.ag-theme-alpine-auto-dark .ag-header-highlight-before::after,\n.ag-theme-alpine-auto-dark .ag-header-highlight-after::after {\n  background-color: var(--ag-alpine-active-color);\n}\n.ag-theme-alpine .ag-advanced-filter-builder-item-button-disabled .ag-icon,\n.ag-theme-alpine .ag-disabled .ag-icon,\n.ag-theme-alpine .ag-column-select-column-group-readonly .ag-icon,\n.ag-theme-alpine [disabled] .ag-icon,\n.ag-theme-alpine-dark .ag-advanced-filter-builder-item-button-disabled .ag-icon,\n.ag-theme-alpine-dark .ag-disabled .ag-icon,\n.ag-theme-alpine-dark .ag-column-select-column-group-readonly .ag-icon,\n.ag-theme-alpine-dark [disabled] .ag-icon,\n.ag-theme-alpine-auto-dark .ag-advanced-filter-builder-item-button-disabled .ag-icon,\n.ag-theme-alpine-auto-dark .ag-disabled .ag-icon,\n.ag-theme-alpine-auto-dark .ag-column-select-column-group-readonly .ag-icon,\n.ag-theme-alpine-auto-dark [disabled] .ag-icon {\n  color: var(--ag-disabled-foreground-color);\n}\n", ""]);
// Exports
/* harmony default export */ __webpack_exports__.A = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 48225:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(36758);
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40935);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".ag-theme-balham,\n.ag-theme-balham-dark,\n.ag-theme-balham-auto-dark {\n  --ag-balham-active-color: #0091ea;\n  --ag-foreground-color: #000;\n  --ag-background-color: #fff;\n  --ag-header-background-color: #f5f7f7;\n  --ag-tooltip-background-color: #cbd0d3;\n  --ag-subheader-background-color: #e2e9eb;\n  --ag-control-panel-background-color: #f5f7f7;\n  --ag-border-color: #bdc3c7;\n  --ag-odd-row-background-color: #fcfdfe;\n  --ag-row-hover-color: #ecf0f1;\n  --ag-column-hover-color: #ecf0f1;\n  --ag-input-border-color: #95a5a6;\n  --ag-invalid-color: #e02525;\n  --ag-input-disabled-background-color: #ebebeb;\n  --ag-checkbox-unchecked-color: #7f8c8d;\n  --ag-input-focus-border-color: #719ece;\n  --ag-advanced-filter-join-pill-color: #f08e8d;\n  --ag-advanced-filter-column-pill-color: #a6e194;\n  --ag-advanced-filter-option-pill-color: #f3c08b;\n  --ag-advanced-filter-value-pill-color: #85c0e4;\n  --ag-find-match-color: var(--ag-foreground-color);\n  --ag-find-match-background-color: #ffff00;\n  --ag-find-active-match-color: var(--ag-foreground-color);\n  --ag-find-active-match-background-color: #ffa500;\n  --ag-input-focus-box-shadow: 0 0 2px 1px var(--ag-input-focus-border-color);\n  --ag-input-error-focus-box-shadow: 0 0 2px 1px var(--ag-invalid-color);\n  --ag-range-selection-border-color: var(--ag-balham-active-color);\n  --ag-checkbox-checked-color: var(--ag-balham-active-color);\n  --ag-checkbox-background-color: var(--ag-background-color);\n  --ag-panel-background-color: var(--ag-header-background-color);\n  --ag-filter-panel-apply-button-color: var(--ag-background-color);\n  --ag-filter-panel-apply-button-background-color: var(--ag-balham-active-color);\n  --ag-secondary-foreground-color: rgba(0, 0, 0, 0.54);\n  --ag-disabled-foreground-color: rgba(0, 0, 0, 0.38);\n  --ag-subheader-toolbar-background-color: rgba(226, 233, 235, 0.5);\n  --ag-row-border-color: rgba(189, 195, 199, 0.58);\n  --ag-chip-background-color: rgba(0, 0, 0, 0.1);\n  --ag-range-selection-background-color: rgba(0, 145, 234, 0.2);\n  --ag-range-selection-background-color-2: rgba(0, 145, 234, 0.36);\n  --ag-range-selection-background-color-3: rgba(0, 145, 234, 0.49);\n  --ag-range-selection-background-color-4: rgba(0, 145, 234, 0.59);\n  --ag-selected-row-background-color: rgba(0, 145, 234, 0.28);\n  --ag-header-column-separator-color: rgba(189, 195, 199, 0.5);\n  --ag-input-disabled-border-color: rgba(149, 165, 166, 0.3);\n  --ag-row-numbers-selected-color: color-mix(in srgb, transparent, var(--ag-balham-active-color) 50%);\n  --ag-header-column-separator-display: block;\n  --ag-header-column-separator-height: 50%;\n  --ag-grid-size: 4px;\n  --ag-icon-size: 16px;\n  --ag-row-height: calc(var(--ag-grid-size) * 7);\n  --ag-header-height: calc(var(--ag-grid-size) * 8);\n  --ag-list-item-height: calc(var(--ag-grid-size) * 6);\n  --ag-row-group-indent-size: calc(var(--ag-grid-size) * 3 + var(--ag-icon-size));\n  --ag-cell-horizontal-padding: calc(var(--ag-grid-size) * 3);\n  --ag-input-height: calc(var(--ag-grid-size) * 4);\n  --ag-chart-menu-panel-width: 240px;\n  --ag-font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Oxygen-Sans, Ubuntu, Cantarell,\n      \"Helvetica Neue\", sans-serif;\n  --ag-font-size: 12px;\n  --ag-icon-font-family: agGridBalham;\n  --ag-border-radius: 2px;\n  --ag-checkbox-border-radius: 3px;\n  --ag-card-shadow: none;\n}\n\n.ag-theme-balham-dark {\n  --ag-balham-active-color: #00b0ff;\n  --ag-foreground-color: #f5f5f5;\n  --ag-background-color: #2d3436;\n  --ag-header-background-color: #1c1c1c;\n  --ag-tooltip-background-color: #1c1f20;\n  --ag-subheader-background-color: #111;\n  --ag-control-panel-background-color: #202020;\n  --ag-border-color: #424242;\n  --ag-odd-row-background-color: #262c2e;\n  --ag-row-hover-color: #3d4749;\n  --ag-column-hover-color: #3d4749;\n  --ag-input-border-color: #f0f0f0;\n  --ag-input-disabled-background-color: rgba(48, 46, 46, 0.3);\n  --ag-modal-overlay-background-color: rgba(45, 52, 54, 0.66);\n  --ag-checkbox-unchecked-color: #ecf0f1;\n  --ag-advanced-filter-join-pill-color: #7a3a37;\n  --ag-advanced-filter-column-pill-color: #355f2d;\n  --ag-advanced-filter-option-pill-color: #5a3168;\n  --ag-advanced-filter-value-pill-color: #374c86;\n  --ag-find-match-color: var(--ag-background-color);\n  --ag-find-active-match-color: var(--ag-background-color);\n  --ag-filter-panel-apply-button-color: var(--ag-foreground-color);\n  --ag-secondary-foreground-color: var(--ag-foreground-color);\n  --ag-disabled-foreground-color: rgba(245, 245, 245, 0.38);\n  --ag-subheader-toolbar-background-color: rgba(17, 17, 17, 0.5);\n  --ag-row-border-color: #5c5c5c;\n  --ag-chip-background-color: rgba(245, 245, 245, 0.08);\n  --ag-range-selection-background-color: rgba(0, 176, 255, 0.2);\n  --ag-range-selection-background-color-2: rgba(0, 176, 255, 0.36);\n  --ag-range-selection-background-color-3: rgba(0, 176, 255, 0.49);\n  --ag-range-selection-background-color-4: rgba(0, 176, 255, 0.59);\n  --ag-selected-row-background-color: rgba(0, 176, 255, 0.28);\n  --ag-header-column-separator-color: rgba(66, 66, 66, 0.5);\n  --ag-input-disabled-border-color: rgba(240, 240, 240, 0.3);\n  --ag-header-foreground-color: rgba(245, 245, 245, 0.64);\n  --ag-toggle-button-off-background-color: transparent;\n  --ag-toggle-button-off-border-color: var(--ag-foreground-color);\n  --ag-range-selection-chart-category-background-color: rgba(26, 177, 74, 0.5);\n  --ag-range-selection-chart-background-color: rgba(45, 166, 255, 0.5);\n  --ag-input-focus-box-shadow: 0 0 4px 1.5px var(--ag-input-focus-border-color);\n  --ag-input-error-focus-box-shadow: 0 0 4px 1.5px\n      color-mix(in srgb, var(--ag-background-color), var(--ag-invalid-color) 0.5%);\n  --ag-row-loading-skeleton-effect-color: rgba(202, 203, 204, 0.4);\n  --ag-cell-batch-edit-text-color: #f3d0b3;\n  color-scheme: dark;\n}\n\n@media (prefers-color-scheme: dark) {\n  .ag-theme-balham-auto-dark {\n    --ag-balham-active-color: #00b0ff;\n    --ag-foreground-color: #f5f5f5;\n    --ag-background-color: #2d3436;\n    --ag-header-background-color: #1c1c1c;\n    --ag-tooltip-background-color: #1c1f20;\n    --ag-subheader-background-color: #111;\n    --ag-control-panel-background-color: #202020;\n    --ag-border-color: #424242;\n    --ag-odd-row-background-color: #262c2e;\n    --ag-row-hover-color: #3d4749;\n    --ag-column-hover-color: #3d4749;\n    --ag-input-border-color: #f0f0f0;\n    --ag-input-disabled-background-color: rgba(48, 46, 46, 0.3);\n    --ag-modal-overlay-background-color: rgba(45, 52, 54, 0.66);\n    --ag-checkbox-unchecked-color: #ecf0f1;\n    --ag-advanced-filter-join-pill-color: #7a3a37;\n    --ag-advanced-filter-column-pill-color: #355f2d;\n    --ag-advanced-filter-option-pill-color: #5a3168;\n    --ag-advanced-filter-value-pill-color: #374c86;\n    --ag-find-match-color: var(--ag-background-color);\n    --ag-find-active-match-color: var(--ag-background-color);\n    --ag-filter-panel-apply-button-color: var(--ag-foreground-color);\n    --ag-secondary-foreground-color: var(--ag-foreground-color);\n    --ag-disabled-foreground-color: rgba(245, 245, 245, 0.38);\n    --ag-subheader-toolbar-background-color: rgba(17, 17, 17, 0.5);\n    --ag-row-border-color: #5c5c5c;\n    --ag-chip-background-color: rgba(245, 245, 245, 0.08);\n    --ag-range-selection-background-color: rgba(0, 176, 255, 0.2);\n    --ag-range-selection-background-color-2: rgba(0, 176, 255, 0.36);\n    --ag-range-selection-background-color-3: rgba(0, 176, 255, 0.49);\n    --ag-range-selection-background-color-4: rgba(0, 176, 255, 0.59);\n    --ag-selected-row-background-color: rgba(0, 176, 255, 0.28);\n    --ag-header-column-separator-color: rgba(66, 66, 66, 0.5);\n    --ag-input-disabled-border-color: rgba(240, 240, 240, 0.3);\n    --ag-header-foreground-color: rgba(245, 245, 245, 0.64);\n    --ag-toggle-button-off-background-color: transparent;\n    --ag-toggle-button-off-border-color: var(--ag-foreground-color);\n    --ag-range-selection-chart-category-background-color: rgba(26, 177, 74, 0.5);\n    --ag-range-selection-chart-background-color: rgba(45, 166, 255, 0.5);\n    --ag-input-focus-box-shadow: 0 0 4px 1.5px var(--ag-input-focus-border-color);\n    --ag-input-error-focus-box-shadow: 0 0 4px 1.5px\n        color-mix(in srgb, var(--ag-background-color), var(--ag-invalid-color) 0.5%);\n    --ag-row-loading-skeleton-effect-color: rgba(202, 203, 204, 0.4);\n    --ag-cell-batch-edit-text-color: #f3d0b3;\n    color-scheme: dark;\n  }\n}\n.ag-theme-balham .ag-filter-toolpanel-header,\n.ag-theme-balham .ag-filter-toolpanel-search,\n.ag-theme-balham .ag-status-bar,\n.ag-theme-balham .ag-header-row,\n.ag-theme-balham .ag-row-number-cell,\n.ag-theme-balham .ag-multi-filter-group-title-bar,\n.ag-theme-balham-dark .ag-filter-toolpanel-header,\n.ag-theme-balham-dark .ag-filter-toolpanel-search,\n.ag-theme-balham-dark .ag-status-bar,\n.ag-theme-balham-dark .ag-header-row,\n.ag-theme-balham-dark .ag-row-number-cell,\n.ag-theme-balham-dark .ag-multi-filter-group-title-bar,\n.ag-theme-balham-auto-dark .ag-filter-toolpanel-header,\n.ag-theme-balham-auto-dark .ag-filter-toolpanel-search,\n.ag-theme-balham-auto-dark .ag-status-bar,\n.ag-theme-balham-auto-dark .ag-header-row,\n.ag-theme-balham-auto-dark .ag-row-number-cell,\n.ag-theme-balham-auto-dark .ag-multi-filter-group-title-bar {\n  font-weight: 600;\n  color: var(--ag-header-foreground-color);\n}\n.ag-theme-balham .ag-ltr input[class^=ag-]:not([type]), .ag-theme-balham .ag-ltr input[class^=ag-][type=text], .ag-theme-balham .ag-ltr input[class^=ag-][type=number], .ag-theme-balham .ag-ltr input[class^=ag-][type=tel], .ag-theme-balham .ag-ltr input[class^=ag-][type=date], .ag-theme-balham .ag-ltr input[class^=ag-][type=datetime-local], .ag-theme-balham .ag-ltr textarea[class^=ag-], .ag-theme-balham-dark .ag-ltr input[class^=ag-]:not([type]), .ag-theme-balham-dark .ag-ltr input[class^=ag-][type=text], .ag-theme-balham-dark .ag-ltr input[class^=ag-][type=number], .ag-theme-balham-dark .ag-ltr input[class^=ag-][type=tel], .ag-theme-balham-dark .ag-ltr input[class^=ag-][type=date], .ag-theme-balham-dark .ag-ltr input[class^=ag-][type=datetime-local], .ag-theme-balham-dark .ag-ltr textarea[class^=ag-], .ag-theme-balham-auto-dark .ag-ltr input[class^=ag-]:not([type]), .ag-theme-balham-auto-dark .ag-ltr input[class^=ag-][type=text], .ag-theme-balham-auto-dark .ag-ltr input[class^=ag-][type=number], .ag-theme-balham-auto-dark .ag-ltr input[class^=ag-][type=tel], .ag-theme-balham-auto-dark .ag-ltr input[class^=ag-][type=date], .ag-theme-balham-auto-dark .ag-ltr input[class^=ag-][type=datetime-local], .ag-theme-balham-auto-dark .ag-ltr textarea[class^=ag-] {\n  padding-left: var(--ag-grid-size);\n}\n\n.ag-theme-balham .ag-rtl input[class^=ag-]:not([type]), .ag-theme-balham .ag-rtl input[class^=ag-][type=text], .ag-theme-balham .ag-rtl input[class^=ag-][type=number], .ag-theme-balham .ag-rtl input[class^=ag-][type=tel], .ag-theme-balham .ag-rtl input[class^=ag-][type=date], .ag-theme-balham .ag-rtl input[class^=ag-][type=datetime-local], .ag-theme-balham .ag-rtl textarea[class^=ag-], .ag-theme-balham-dark .ag-rtl input[class^=ag-]:not([type]), .ag-theme-balham-dark .ag-rtl input[class^=ag-][type=text], .ag-theme-balham-dark .ag-rtl input[class^=ag-][type=number], .ag-theme-balham-dark .ag-rtl input[class^=ag-][type=tel], .ag-theme-balham-dark .ag-rtl input[class^=ag-][type=date], .ag-theme-balham-dark .ag-rtl input[class^=ag-][type=datetime-local], .ag-theme-balham-dark .ag-rtl textarea[class^=ag-], .ag-theme-balham-auto-dark .ag-rtl input[class^=ag-]:not([type]), .ag-theme-balham-auto-dark .ag-rtl input[class^=ag-][type=text], .ag-theme-balham-auto-dark .ag-rtl input[class^=ag-][type=number], .ag-theme-balham-auto-dark .ag-rtl input[class^=ag-][type=tel], .ag-theme-balham-auto-dark .ag-rtl input[class^=ag-][type=date], .ag-theme-balham-auto-dark .ag-rtl input[class^=ag-][type=datetime-local], .ag-theme-balham-auto-dark .ag-rtl textarea[class^=ag-] {\n  padding-right: var(--ag-grid-size);\n}\n\n.ag-theme-balham .ag-column-drop-vertical-empty-message,\n.ag-theme-balham .ag-status-bar,\n.ag-theme-balham-dark .ag-column-drop-vertical-empty-message,\n.ag-theme-balham-dark .ag-status-bar,\n.ag-theme-balham-auto-dark .ag-column-drop-vertical-empty-message,\n.ag-theme-balham-auto-dark .ag-status-bar {\n  font-weight: 600;\n  color: var(--ag-disabled-foreground-color);\n}\n.ag-theme-balham.ag-dnd-ghost,\n.ag-theme-balham-dark.ag-dnd-ghost,\n.ag-theme-balham-auto-dark.ag-dnd-ghost {\n  font-size: var(--ag-font-size);\n  font-weight: 600;\n}\n.ag-theme-balham .ag-tab,\n.ag-theme-balham-dark .ag-tab,\n.ag-theme-balham-auto-dark .ag-tab {\n  border: 1px solid transparent;\n  padding: var(--ag-grid-size) calc(var(--ag-grid-size) * 2);\n  margin: var(--ag-grid-size);\n  margin-bottom: -1px;\n}\n.ag-theme-balham .ag-tab-selected,\n.ag-theme-balham-dark .ag-tab-selected,\n.ag-theme-balham-auto-dark .ag-tab-selected {\n  background-color: var(--ag-background-color);\n  border-color: var(--ag-border-color);\n  border-bottom-color: transparent;\n}\n.ag-theme-balham .ag-tabs-header,\n.ag-theme-balham-dark .ag-tabs-header,\n.ag-theme-balham-auto-dark .ag-tabs-header {\n  border-bottom: 1px solid var(--ag-border-color);\n}\n.ag-theme-balham .ag-column-drop-cell,\n.ag-theme-balham-dark .ag-column-drop-cell,\n.ag-theme-balham-auto-dark .ag-column-drop-cell {\n  height: calc(var(--ag-grid-size) * 6);\n}\n.ag-theme-balham .ag-column-drop-vertical-title,\n.ag-theme-balham-dark .ag-column-drop-vertical-title,\n.ag-theme-balham-auto-dark .ag-column-drop-vertical-title {\n  color: var(--ag-foreground-color);\n}\n.ag-theme-balham .ag-column-drop-vertical-cell,\n.ag-theme-balham-dark .ag-column-drop-vertical-cell,\n.ag-theme-balham-auto-dark .ag-column-drop-vertical-cell {\n  margin-left: calc(var(--ag-grid-size) * 2);\n  margin-right: calc(var(--ag-grid-size) * 2);\n}\n.ag-theme-balham .ag-column-drop-vertical-cell-text,\n.ag-theme-balham-dark .ag-column-drop-vertical-cell-text,\n.ag-theme-balham-auto-dark .ag-column-drop-vertical-cell-text {\n  margin-left: calc(var(--ag-grid-size) * 2);\n}\n.ag-theme-balham .ag-column-drop-vertical-icon,\n.ag-theme-balham-dark .ag-column-drop-vertical-icon,\n.ag-theme-balham-auto-dark .ag-column-drop-vertical-icon {\n  color: var(--ag-secondary-foreground-color);\n}\n.ag-theme-balham .ag-ltr .ag-column-drop-vertical-empty-message, .ag-theme-balham-dark .ag-ltr .ag-column-drop-vertical-empty-message, .ag-theme-balham-auto-dark .ag-ltr .ag-column-drop-vertical-empty-message {\n  padding-left: calc(var(--ag-icon-size) + var(--ag-grid-size) * 2);\n  padding-right: var(--ag-grid-size);\n}\n\n.ag-theme-balham .ag-rtl .ag-column-drop-vertical-empty-message, .ag-theme-balham-dark .ag-rtl .ag-column-drop-vertical-empty-message, .ag-theme-balham-auto-dark .ag-rtl .ag-column-drop-vertical-empty-message {\n  padding-right: calc(var(--ag-icon-size) + var(--ag-grid-size) * 2);\n  padding-left: var(--ag-grid-size);\n}\n\n.ag-theme-balham .ag-column-drop-horizontal,\n.ag-theme-balham-dark .ag-column-drop-horizontal,\n.ag-theme-balham-auto-dark .ag-column-drop-horizontal {\n  height: var(--ag-header-height);\n}\n.ag-theme-balham .ag-column-drop-empty,\n.ag-theme-balham-dark .ag-column-drop-empty,\n.ag-theme-balham-auto-dark .ag-column-drop-empty {\n  color: var(--ag-disabled-foreground-color);\n}\n.ag-theme-balham .ag-column-drop-horizontal-cell-text,\n.ag-theme-balham-dark .ag-column-drop-horizontal-cell-text,\n.ag-theme-balham-auto-dark .ag-column-drop-horizontal-cell-text {\n  margin-left: calc(var(--ag-grid-size) * 2);\n}\n.ag-theme-balham .ag-column-drop-vertical,\n.ag-theme-balham-dark .ag-column-drop-vertical,\n.ag-theme-balham-auto-dark .ag-column-drop-vertical {\n  padding-top: calc(var(--ag-grid-size) * 2);\n}\n.ag-theme-balham .ag-column-select-column-readonly.ag-icon-grip,\n.ag-theme-balham .ag-column-select-column-readonly .ag-icon-grip,\n.ag-theme-balham-dark .ag-column-select-column-readonly.ag-icon-grip,\n.ag-theme-balham-dark .ag-column-select-column-readonly .ag-icon-grip,\n.ag-theme-balham-auto-dark .ag-column-select-column-readonly.ag-icon-grip,\n.ag-theme-balham-auto-dark .ag-column-select-column-readonly .ag-icon-grip {\n  opacity: 0.35;\n}\n.ag-theme-balham .ag-menu-header,\n.ag-theme-balham-dark .ag-menu-header,\n.ag-theme-balham-auto-dark .ag-menu-header {\n  background-color: var(--ag-header-background-color);\n}\n.ag-theme-balham .ag-overlay-loading-center,\n.ag-theme-balham-dark .ag-overlay-loading-center,\n.ag-theme-balham-auto-dark .ag-overlay-loading-center {\n  background-color: var(--ag-background-color);\n  border: 1px solid var(--ag-border-color);\n  color: var(--ag-foreground-color);\n  padding: calc(var(--ag-grid-size) * 4);\n}\n.ag-theme-balham .ag-tooltip,\n.ag-theme-balham-dark .ag-tooltip,\n.ag-theme-balham-auto-dark .ag-tooltip {\n  border: none;\n}\n.ag-theme-balham .ag-panel-title-bar-button-icon,\n.ag-theme-balham-dark .ag-panel-title-bar-button-icon,\n.ag-theme-balham-auto-dark .ag-panel-title-bar-button-icon {\n  font-size: calc(var(--ag-icon-size) + var(--ag-grid-size));\n}\n.ag-theme-balham .ag-panel,\n.ag-theme-balham-dark .ag-panel,\n.ag-theme-balham-auto-dark .ag-panel {\n  background-color: var(--ag-header-background-color);\n}\n.ag-theme-balham .ag-chart-data-section,\n.ag-theme-balham .ag-chart-format-section,\n.ag-theme-balham .ag-chart-advanced-settings-section,\n.ag-theme-balham-dark .ag-chart-data-section,\n.ag-theme-balham-dark .ag-chart-format-section,\n.ag-theme-balham-dark .ag-chart-advanced-settings-section,\n.ag-theme-balham-auto-dark .ag-chart-data-section,\n.ag-theme-balham-auto-dark .ag-chart-format-section,\n.ag-theme-balham-auto-dark .ag-chart-advanced-settings-section {\n  padding-bottom: calc(var(--ag-grid-size) * 0.5);\n}\n.ag-theme-balham .ag-group-toolbar,\n.ag-theme-balham-dark .ag-group-toolbar,\n.ag-theme-balham-auto-dark .ag-group-toolbar {\n  background-color: var(--ag-subheader-toolbar-background-color);\n}\n.ag-theme-balham .ag-chart-tab,\n.ag-theme-balham-dark .ag-chart-tab,\n.ag-theme-balham-auto-dark .ag-chart-tab {\n  padding-top: calc(var(--ag-grid-size) * 0.5);\n}\n.ag-theme-balham .ag-charts-format-sub-level-group-item,\n.ag-theme-balham-dark .ag-charts-format-sub-level-group-item,\n.ag-theme-balham-auto-dark .ag-charts-format-sub-level-group-item {\n  margin-bottom: calc(var(--ag-grid-size) * 1.5);\n}\n.ag-theme-balham .ag-filter-active .ag-icon-filter,\n.ag-theme-balham-dark .ag-filter-active .ag-icon-filter,\n.ag-theme-balham-auto-dark .ag-filter-active .ag-icon-filter {\n  color: var(--ag-balham-active-color);\n}\n.ag-theme-balham .ag-color-input input[class^=ag-][type=text].ag-input-field-input,\n.ag-theme-balham-dark .ag-color-input input[class^=ag-][type=text].ag-input-field-input,\n.ag-theme-balham-auto-dark .ag-color-input input[class^=ag-][type=text].ag-input-field-input {\n  min-height: calc(var(--ag-icon-size) + 4px);\n}\n.ag-theme-balham .ag-list-item-hovered::after,\n.ag-theme-balham-dark .ag-list-item-hovered::after,\n.ag-theme-balham-auto-dark .ag-list-item-hovered::after {\n  background-color: var(--ag-balham-active-color);\n}\n.ag-theme-balham .ag-pill .ag-pill-button:hover,\n.ag-theme-balham-dark .ag-pill .ag-pill-button:hover,\n.ag-theme-balham-auto-dark .ag-pill .ag-pill-button:hover {\n  color: var(--ag-balham-active-color);\n}\n.ag-theme-balham .ag-header-highlight-before::after,\n.ag-theme-balham .ag-header-highlight-after::after,\n.ag-theme-balham-dark .ag-header-highlight-before::after,\n.ag-theme-balham-dark .ag-header-highlight-after::after,\n.ag-theme-balham-auto-dark .ag-header-highlight-before::after,\n.ag-theme-balham-auto-dark .ag-header-highlight-after::after {\n  background-color: var(--ag-balham-active-color);\n}\n.ag-theme-balham .ag-advanced-filter-builder-item-button-disabled .ag-icon,\n.ag-theme-balham .ag-disabled .ag-icon,\n.ag-theme-balham .ag-column-select-column-group-readonly .ag-icon,\n.ag-theme-balham [disabled] .ag-icon,\n.ag-theme-balham-dark .ag-advanced-filter-builder-item-button-disabled .ag-icon,\n.ag-theme-balham-dark .ag-disabled .ag-icon,\n.ag-theme-balham-dark .ag-column-select-column-group-readonly .ag-icon,\n.ag-theme-balham-dark [disabled] .ag-icon,\n.ag-theme-balham-auto-dark .ag-advanced-filter-builder-item-button-disabled .ag-icon,\n.ag-theme-balham-auto-dark .ag-disabled .ag-icon,\n.ag-theme-balham-auto-dark .ag-column-select-column-group-readonly .ag-icon,\n.ag-theme-balham-auto-dark [disabled] .ag-icon {\n  color: var(--ag-disabled-foreground-color);\n}\n.ag-theme-balham .ag-filter-panel .ag-standard-button.ag-filter-panel-buttons-apply-button:disabled,\n.ag-theme-balham-dark .ag-filter-panel .ag-standard-button.ag-filter-panel-buttons-apply-button:disabled,\n.ag-theme-balham-auto-dark .ag-filter-panel .ag-standard-button.ag-filter-panel-buttons-apply-button:disabled {\n  color: unset;\n  background-color: unset;\n}\n.ag-theme-balham .ag-filter-card-title,\n.ag-theme-balham-dark .ag-filter-card-title,\n.ag-theme-balham-auto-dark .ag-filter-card-title {\n  font-weight: 600;\n}\n", ""]);
// Exports
/* harmony default export */ __webpack_exports__.A = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 55251:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(36758);
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40935);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20062);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(38906), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, "@font-face {\n  font-family: \"agGridBalham\";\n  src: url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ");\n  font-weight: normal;\n  font-style: normal;\n}\n.ag-theme-balham,\n.ag-theme-balham-dark,\n.ag-theme-balham-auto-dark {\n  --ag-balham-active-color: #0091ea;\n  --ag-foreground-color: #000;\n  --ag-background-color: #fff;\n  --ag-header-background-color: #f5f7f7;\n  --ag-tooltip-background-color: #cbd0d3;\n  --ag-subheader-background-color: #e2e9eb;\n  --ag-control-panel-background-color: #f5f7f7;\n  --ag-border-color: #bdc3c7;\n  --ag-odd-row-background-color: #fcfdfe;\n  --ag-row-hover-color: #ecf0f1;\n  --ag-column-hover-color: #ecf0f1;\n  --ag-input-border-color: #95a5a6;\n  --ag-invalid-color: #e02525;\n  --ag-input-disabled-background-color: #ebebeb;\n  --ag-checkbox-unchecked-color: #7f8c8d;\n  --ag-input-focus-border-color: #719ece;\n  --ag-advanced-filter-join-pill-color: #f08e8d;\n  --ag-advanced-filter-column-pill-color: #a6e194;\n  --ag-advanced-filter-option-pill-color: #f3c08b;\n  --ag-advanced-filter-value-pill-color: #85c0e4;\n  --ag-find-match-color: var(--ag-foreground-color);\n  --ag-find-match-background-color: #ffff00;\n  --ag-find-active-match-color: var(--ag-foreground-color);\n  --ag-find-active-match-background-color: #ffa500;\n  --ag-input-focus-box-shadow: 0 0 2px 1px var(--ag-input-focus-border-color);\n  --ag-input-error-focus-box-shadow: 0 0 2px 1px var(--ag-invalid-color);\n  --ag-range-selection-border-color: var(--ag-balham-active-color);\n  --ag-checkbox-checked-color: var(--ag-balham-active-color);\n  --ag-checkbox-background-color: var(--ag-background-color);\n  --ag-panel-background-color: var(--ag-header-background-color);\n  --ag-filter-panel-apply-button-color: var(--ag-background-color);\n  --ag-filter-panel-apply-button-background-color: var(--ag-balham-active-color);\n  --ag-secondary-foreground-color: rgba(0, 0, 0, 0.54);\n  --ag-disabled-foreground-color: rgba(0, 0, 0, 0.38);\n  --ag-subheader-toolbar-background-color: rgba(226, 233, 235, 0.5);\n  --ag-row-border-color: rgba(189, 195, 199, 0.58);\n  --ag-chip-background-color: rgba(0, 0, 0, 0.1);\n  --ag-range-selection-background-color: rgba(0, 145, 234, 0.2);\n  --ag-range-selection-background-color-2: rgba(0, 145, 234, 0.36);\n  --ag-range-selection-background-color-3: rgba(0, 145, 234, 0.49);\n  --ag-range-selection-background-color-4: rgba(0, 145, 234, 0.59);\n  --ag-selected-row-background-color: rgba(0, 145, 234, 0.28);\n  --ag-header-column-separator-color: rgba(189, 195, 199, 0.5);\n  --ag-input-disabled-border-color: rgba(149, 165, 166, 0.3);\n  --ag-row-numbers-selected-color: color-mix(in srgb, transparent, var(--ag-balham-active-color) 50%);\n  --ag-header-column-separator-display: block;\n  --ag-header-column-separator-height: 50%;\n  --ag-grid-size: 4px;\n  --ag-icon-size: 16px;\n  --ag-row-height: calc(var(--ag-grid-size) * 7);\n  --ag-header-height: calc(var(--ag-grid-size) * 8);\n  --ag-list-item-height: calc(var(--ag-grid-size) * 6);\n  --ag-row-group-indent-size: calc(var(--ag-grid-size) * 3 + var(--ag-icon-size));\n  --ag-cell-horizontal-padding: calc(var(--ag-grid-size) * 3);\n  --ag-input-height: calc(var(--ag-grid-size) * 4);\n  --ag-chart-menu-panel-width: 240px;\n  --ag-font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Oxygen-Sans, Ubuntu, Cantarell,\n      \"Helvetica Neue\", sans-serif;\n  --ag-font-size: 12px;\n  --ag-icon-font-family: agGridBalham;\n  --ag-border-radius: 2px;\n  --ag-checkbox-border-radius: 3px;\n  --ag-card-shadow: none;\n}\n\n.ag-theme-balham-dark {\n  --ag-balham-active-color: #00b0ff;\n  --ag-foreground-color: #f5f5f5;\n  --ag-background-color: #2d3436;\n  --ag-header-background-color: #1c1c1c;\n  --ag-tooltip-background-color: #1c1f20;\n  --ag-subheader-background-color: #111;\n  --ag-control-panel-background-color: #202020;\n  --ag-border-color: #424242;\n  --ag-odd-row-background-color: #262c2e;\n  --ag-row-hover-color: #3d4749;\n  --ag-column-hover-color: #3d4749;\n  --ag-input-border-color: #f0f0f0;\n  --ag-input-disabled-background-color: rgba(48, 46, 46, 0.3);\n  --ag-modal-overlay-background-color: rgba(45, 52, 54, 0.66);\n  --ag-checkbox-unchecked-color: #ecf0f1;\n  --ag-advanced-filter-join-pill-color: #7a3a37;\n  --ag-advanced-filter-column-pill-color: #355f2d;\n  --ag-advanced-filter-option-pill-color: #5a3168;\n  --ag-advanced-filter-value-pill-color: #374c86;\n  --ag-find-match-color: var(--ag-background-color);\n  --ag-find-active-match-color: var(--ag-background-color);\n  --ag-filter-panel-apply-button-color: var(--ag-foreground-color);\n  --ag-secondary-foreground-color: var(--ag-foreground-color);\n  --ag-disabled-foreground-color: rgba(245, 245, 245, 0.38);\n  --ag-subheader-toolbar-background-color: rgba(17, 17, 17, 0.5);\n  --ag-row-border-color: #5c5c5c;\n  --ag-chip-background-color: rgba(245, 245, 245, 0.08);\n  --ag-range-selection-background-color: rgba(0, 176, 255, 0.2);\n  --ag-range-selection-background-color-2: rgba(0, 176, 255, 0.36);\n  --ag-range-selection-background-color-3: rgba(0, 176, 255, 0.49);\n  --ag-range-selection-background-color-4: rgba(0, 176, 255, 0.59);\n  --ag-selected-row-background-color: rgba(0, 176, 255, 0.28);\n  --ag-header-column-separator-color: rgba(66, 66, 66, 0.5);\n  --ag-input-disabled-border-color: rgba(240, 240, 240, 0.3);\n  --ag-header-foreground-color: rgba(245, 245, 245, 0.64);\n  --ag-toggle-button-off-background-color: transparent;\n  --ag-toggle-button-off-border-color: var(--ag-foreground-color);\n  --ag-range-selection-chart-category-background-color: rgba(26, 177, 74, 0.5);\n  --ag-range-selection-chart-background-color: rgba(45, 166, 255, 0.5);\n  --ag-input-focus-box-shadow: 0 0 4px 1.5px var(--ag-input-focus-border-color);\n  --ag-input-error-focus-box-shadow: 0 0 4px 1.5px\n      color-mix(in srgb, var(--ag-background-color), var(--ag-invalid-color) 0.5%);\n  --ag-row-loading-skeleton-effect-color: rgba(202, 203, 204, 0.4);\n  --ag-cell-batch-edit-text-color: #f3d0b3;\n  color-scheme: dark;\n}\n\n@media (prefers-color-scheme: dark) {\n  .ag-theme-balham-auto-dark {\n    --ag-balham-active-color: #00b0ff;\n    --ag-foreground-color: #f5f5f5;\n    --ag-background-color: #2d3436;\n    --ag-header-background-color: #1c1c1c;\n    --ag-tooltip-background-color: #1c1f20;\n    --ag-subheader-background-color: #111;\n    --ag-control-panel-background-color: #202020;\n    --ag-border-color: #424242;\n    --ag-odd-row-background-color: #262c2e;\n    --ag-row-hover-color: #3d4749;\n    --ag-column-hover-color: #3d4749;\n    --ag-input-border-color: #f0f0f0;\n    --ag-input-disabled-background-color: rgba(48, 46, 46, 0.3);\n    --ag-modal-overlay-background-color: rgba(45, 52, 54, 0.66);\n    --ag-checkbox-unchecked-color: #ecf0f1;\n    --ag-advanced-filter-join-pill-color: #7a3a37;\n    --ag-advanced-filter-column-pill-color: #355f2d;\n    --ag-advanced-filter-option-pill-color: #5a3168;\n    --ag-advanced-filter-value-pill-color: #374c86;\n    --ag-find-match-color: var(--ag-background-color);\n    --ag-find-active-match-color: var(--ag-background-color);\n    --ag-filter-panel-apply-button-color: var(--ag-foreground-color);\n    --ag-secondary-foreground-color: var(--ag-foreground-color);\n    --ag-disabled-foreground-color: rgba(245, 245, 245, 0.38);\n    --ag-subheader-toolbar-background-color: rgba(17, 17, 17, 0.5);\n    --ag-row-border-color: #5c5c5c;\n    --ag-chip-background-color: rgba(245, 245, 245, 0.08);\n    --ag-range-selection-background-color: rgba(0, 176, 255, 0.2);\n    --ag-range-selection-background-color-2: rgba(0, 176, 255, 0.36);\n    --ag-range-selection-background-color-3: rgba(0, 176, 255, 0.49);\n    --ag-range-selection-background-color-4: rgba(0, 176, 255, 0.59);\n    --ag-selected-row-background-color: rgba(0, 176, 255, 0.28);\n    --ag-header-column-separator-color: rgba(66, 66, 66, 0.5);\n    --ag-input-disabled-border-color: rgba(240, 240, 240, 0.3);\n    --ag-header-foreground-color: rgba(245, 245, 245, 0.64);\n    --ag-toggle-button-off-background-color: transparent;\n    --ag-toggle-button-off-border-color: var(--ag-foreground-color);\n    --ag-range-selection-chart-category-background-color: rgba(26, 177, 74, 0.5);\n    --ag-range-selection-chart-background-color: rgba(45, 166, 255, 0.5);\n    --ag-input-focus-box-shadow: 0 0 4px 1.5px var(--ag-input-focus-border-color);\n    --ag-input-error-focus-box-shadow: 0 0 4px 1.5px\n        color-mix(in srgb, var(--ag-background-color), var(--ag-invalid-color) 0.5%);\n    --ag-row-loading-skeleton-effect-color: rgba(202, 203, 204, 0.4);\n    --ag-cell-batch-edit-text-color: #f3d0b3;\n    color-scheme: dark;\n  }\n}\n.ag-theme-balham .ag-filter-toolpanel-header,\n.ag-theme-balham .ag-filter-toolpanel-search,\n.ag-theme-balham .ag-status-bar,\n.ag-theme-balham .ag-header-row,\n.ag-theme-balham .ag-row-number-cell,\n.ag-theme-balham .ag-multi-filter-group-title-bar,\n.ag-theme-balham-dark .ag-filter-toolpanel-header,\n.ag-theme-balham-dark .ag-filter-toolpanel-search,\n.ag-theme-balham-dark .ag-status-bar,\n.ag-theme-balham-dark .ag-header-row,\n.ag-theme-balham-dark .ag-row-number-cell,\n.ag-theme-balham-dark .ag-multi-filter-group-title-bar,\n.ag-theme-balham-auto-dark .ag-filter-toolpanel-header,\n.ag-theme-balham-auto-dark .ag-filter-toolpanel-search,\n.ag-theme-balham-auto-dark .ag-status-bar,\n.ag-theme-balham-auto-dark .ag-header-row,\n.ag-theme-balham-auto-dark .ag-row-number-cell,\n.ag-theme-balham-auto-dark .ag-multi-filter-group-title-bar {\n  font-weight: 600;\n  color: var(--ag-header-foreground-color);\n}\n.ag-theme-balham .ag-ltr input[class^=ag-]:not([type]), .ag-theme-balham .ag-ltr input[class^=ag-][type=text], .ag-theme-balham .ag-ltr input[class^=ag-][type=number], .ag-theme-balham .ag-ltr input[class^=ag-][type=tel], .ag-theme-balham .ag-ltr input[class^=ag-][type=date], .ag-theme-balham .ag-ltr input[class^=ag-][type=datetime-local], .ag-theme-balham .ag-ltr textarea[class^=ag-], .ag-theme-balham-dark .ag-ltr input[class^=ag-]:not([type]), .ag-theme-balham-dark .ag-ltr input[class^=ag-][type=text], .ag-theme-balham-dark .ag-ltr input[class^=ag-][type=number], .ag-theme-balham-dark .ag-ltr input[class^=ag-][type=tel], .ag-theme-balham-dark .ag-ltr input[class^=ag-][type=date], .ag-theme-balham-dark .ag-ltr input[class^=ag-][type=datetime-local], .ag-theme-balham-dark .ag-ltr textarea[class^=ag-], .ag-theme-balham-auto-dark .ag-ltr input[class^=ag-]:not([type]), .ag-theme-balham-auto-dark .ag-ltr input[class^=ag-][type=text], .ag-theme-balham-auto-dark .ag-ltr input[class^=ag-][type=number], .ag-theme-balham-auto-dark .ag-ltr input[class^=ag-][type=tel], .ag-theme-balham-auto-dark .ag-ltr input[class^=ag-][type=date], .ag-theme-balham-auto-dark .ag-ltr input[class^=ag-][type=datetime-local], .ag-theme-balham-auto-dark .ag-ltr textarea[class^=ag-] {\n  padding-left: var(--ag-grid-size);\n}\n\n.ag-theme-balham .ag-rtl input[class^=ag-]:not([type]), .ag-theme-balham .ag-rtl input[class^=ag-][type=text], .ag-theme-balham .ag-rtl input[class^=ag-][type=number], .ag-theme-balham .ag-rtl input[class^=ag-][type=tel], .ag-theme-balham .ag-rtl input[class^=ag-][type=date], .ag-theme-balham .ag-rtl input[class^=ag-][type=datetime-local], .ag-theme-balham .ag-rtl textarea[class^=ag-], .ag-theme-balham-dark .ag-rtl input[class^=ag-]:not([type]), .ag-theme-balham-dark .ag-rtl input[class^=ag-][type=text], .ag-theme-balham-dark .ag-rtl input[class^=ag-][type=number], .ag-theme-balham-dark .ag-rtl input[class^=ag-][type=tel], .ag-theme-balham-dark .ag-rtl input[class^=ag-][type=date], .ag-theme-balham-dark .ag-rtl input[class^=ag-][type=datetime-local], .ag-theme-balham-dark .ag-rtl textarea[class^=ag-], .ag-theme-balham-auto-dark .ag-rtl input[class^=ag-]:not([type]), .ag-theme-balham-auto-dark .ag-rtl input[class^=ag-][type=text], .ag-theme-balham-auto-dark .ag-rtl input[class^=ag-][type=number], .ag-theme-balham-auto-dark .ag-rtl input[class^=ag-][type=tel], .ag-theme-balham-auto-dark .ag-rtl input[class^=ag-][type=date], .ag-theme-balham-auto-dark .ag-rtl input[class^=ag-][type=datetime-local], .ag-theme-balham-auto-dark .ag-rtl textarea[class^=ag-] {\n  padding-right: var(--ag-grid-size);\n}\n\n.ag-theme-balham .ag-column-drop-vertical-empty-message,\n.ag-theme-balham .ag-status-bar,\n.ag-theme-balham-dark .ag-column-drop-vertical-empty-message,\n.ag-theme-balham-dark .ag-status-bar,\n.ag-theme-balham-auto-dark .ag-column-drop-vertical-empty-message,\n.ag-theme-balham-auto-dark .ag-status-bar {\n  font-weight: 600;\n  color: var(--ag-disabled-foreground-color);\n}\n.ag-theme-balham.ag-dnd-ghost,\n.ag-theme-balham-dark.ag-dnd-ghost,\n.ag-theme-balham-auto-dark.ag-dnd-ghost {\n  font-size: var(--ag-font-size);\n  font-weight: 600;\n}\n.ag-theme-balham .ag-tab,\n.ag-theme-balham-dark .ag-tab,\n.ag-theme-balham-auto-dark .ag-tab {\n  border: 1px solid transparent;\n  padding: var(--ag-grid-size) calc(var(--ag-grid-size) * 2);\n  margin: var(--ag-grid-size);\n  margin-bottom: -1px;\n}\n.ag-theme-balham .ag-tab-selected,\n.ag-theme-balham-dark .ag-tab-selected,\n.ag-theme-balham-auto-dark .ag-tab-selected {\n  background-color: var(--ag-background-color);\n  border-color: var(--ag-border-color);\n  border-bottom-color: transparent;\n}\n.ag-theme-balham .ag-tabs-header,\n.ag-theme-balham-dark .ag-tabs-header,\n.ag-theme-balham-auto-dark .ag-tabs-header {\n  border-bottom: 1px solid var(--ag-border-color);\n}\n.ag-theme-balham .ag-column-drop-cell,\n.ag-theme-balham-dark .ag-column-drop-cell,\n.ag-theme-balham-auto-dark .ag-column-drop-cell {\n  height: calc(var(--ag-grid-size) * 6);\n}\n.ag-theme-balham .ag-column-drop-vertical-title,\n.ag-theme-balham-dark .ag-column-drop-vertical-title,\n.ag-theme-balham-auto-dark .ag-column-drop-vertical-title {\n  color: var(--ag-foreground-color);\n}\n.ag-theme-balham .ag-column-drop-vertical-cell,\n.ag-theme-balham-dark .ag-column-drop-vertical-cell,\n.ag-theme-balham-auto-dark .ag-column-drop-vertical-cell {\n  margin-left: calc(var(--ag-grid-size) * 2);\n  margin-right: calc(var(--ag-grid-size) * 2);\n}\n.ag-theme-balham .ag-column-drop-vertical-cell-text,\n.ag-theme-balham-dark .ag-column-drop-vertical-cell-text,\n.ag-theme-balham-auto-dark .ag-column-drop-vertical-cell-text {\n  margin-left: calc(var(--ag-grid-size) * 2);\n}\n.ag-theme-balham .ag-column-drop-vertical-icon,\n.ag-theme-balham-dark .ag-column-drop-vertical-icon,\n.ag-theme-balham-auto-dark .ag-column-drop-vertical-icon {\n  color: var(--ag-secondary-foreground-color);\n}\n.ag-theme-balham .ag-ltr .ag-column-drop-vertical-empty-message, .ag-theme-balham-dark .ag-ltr .ag-column-drop-vertical-empty-message, .ag-theme-balham-auto-dark .ag-ltr .ag-column-drop-vertical-empty-message {\n  padding-left: calc(var(--ag-icon-size) + var(--ag-grid-size) * 2);\n  padding-right: var(--ag-grid-size);\n}\n\n.ag-theme-balham .ag-rtl .ag-column-drop-vertical-empty-message, .ag-theme-balham-dark .ag-rtl .ag-column-drop-vertical-empty-message, .ag-theme-balham-auto-dark .ag-rtl .ag-column-drop-vertical-empty-message {\n  padding-right: calc(var(--ag-icon-size) + var(--ag-grid-size) * 2);\n  padding-left: var(--ag-grid-size);\n}\n\n.ag-theme-balham .ag-column-drop-horizontal,\n.ag-theme-balham-dark .ag-column-drop-horizontal,\n.ag-theme-balham-auto-dark .ag-column-drop-horizontal {\n  height: var(--ag-header-height);\n}\n.ag-theme-balham .ag-column-drop-empty,\n.ag-theme-balham-dark .ag-column-drop-empty,\n.ag-theme-balham-auto-dark .ag-column-drop-empty {\n  color: var(--ag-disabled-foreground-color);\n}\n.ag-theme-balham .ag-column-drop-horizontal-cell-text,\n.ag-theme-balham-dark .ag-column-drop-horizontal-cell-text,\n.ag-theme-balham-auto-dark .ag-column-drop-horizontal-cell-text {\n  margin-left: calc(var(--ag-grid-size) * 2);\n}\n.ag-theme-balham .ag-column-drop-vertical,\n.ag-theme-balham-dark .ag-column-drop-vertical,\n.ag-theme-balham-auto-dark .ag-column-drop-vertical {\n  padding-top: calc(var(--ag-grid-size) * 2);\n}\n.ag-theme-balham .ag-column-select-column-readonly.ag-icon-grip,\n.ag-theme-balham .ag-column-select-column-readonly .ag-icon-grip,\n.ag-theme-balham-dark .ag-column-select-column-readonly.ag-icon-grip,\n.ag-theme-balham-dark .ag-column-select-column-readonly .ag-icon-grip,\n.ag-theme-balham-auto-dark .ag-column-select-column-readonly.ag-icon-grip,\n.ag-theme-balham-auto-dark .ag-column-select-column-readonly .ag-icon-grip {\n  opacity: 0.35;\n}\n.ag-theme-balham .ag-menu-header,\n.ag-theme-balham-dark .ag-menu-header,\n.ag-theme-balham-auto-dark .ag-menu-header {\n  background-color: var(--ag-header-background-color);\n}\n.ag-theme-balham .ag-overlay-loading-center,\n.ag-theme-balham-dark .ag-overlay-loading-center,\n.ag-theme-balham-auto-dark .ag-overlay-loading-center {\n  background-color: var(--ag-background-color);\n  border: 1px solid var(--ag-border-color);\n  color: var(--ag-foreground-color);\n  padding: calc(var(--ag-grid-size) * 4);\n}\n.ag-theme-balham .ag-tooltip,\n.ag-theme-balham-dark .ag-tooltip,\n.ag-theme-balham-auto-dark .ag-tooltip {\n  border: none;\n}\n.ag-theme-balham .ag-panel-title-bar-button-icon,\n.ag-theme-balham-dark .ag-panel-title-bar-button-icon,\n.ag-theme-balham-auto-dark .ag-panel-title-bar-button-icon {\n  font-size: calc(var(--ag-icon-size) + var(--ag-grid-size));\n}\n.ag-theme-balham .ag-panel,\n.ag-theme-balham-dark .ag-panel,\n.ag-theme-balham-auto-dark .ag-panel {\n  background-color: var(--ag-header-background-color);\n}\n.ag-theme-balham .ag-chart-data-section,\n.ag-theme-balham .ag-chart-format-section,\n.ag-theme-balham .ag-chart-advanced-settings-section,\n.ag-theme-balham-dark .ag-chart-data-section,\n.ag-theme-balham-dark .ag-chart-format-section,\n.ag-theme-balham-dark .ag-chart-advanced-settings-section,\n.ag-theme-balham-auto-dark .ag-chart-data-section,\n.ag-theme-balham-auto-dark .ag-chart-format-section,\n.ag-theme-balham-auto-dark .ag-chart-advanced-settings-section {\n  padding-bottom: calc(var(--ag-grid-size) * 0.5);\n}\n.ag-theme-balham .ag-group-toolbar,\n.ag-theme-balham-dark .ag-group-toolbar,\n.ag-theme-balham-auto-dark .ag-group-toolbar {\n  background-color: var(--ag-subheader-toolbar-background-color);\n}\n.ag-theme-balham .ag-chart-tab,\n.ag-theme-balham-dark .ag-chart-tab,\n.ag-theme-balham-auto-dark .ag-chart-tab {\n  padding-top: calc(var(--ag-grid-size) * 0.5);\n}\n.ag-theme-balham .ag-charts-format-sub-level-group-item,\n.ag-theme-balham-dark .ag-charts-format-sub-level-group-item,\n.ag-theme-balham-auto-dark .ag-charts-format-sub-level-group-item {\n  margin-bottom: calc(var(--ag-grid-size) * 1.5);\n}\n.ag-theme-balham .ag-filter-active .ag-icon-filter,\n.ag-theme-balham-dark .ag-filter-active .ag-icon-filter,\n.ag-theme-balham-auto-dark .ag-filter-active .ag-icon-filter {\n  color: var(--ag-balham-active-color);\n}\n.ag-theme-balham .ag-color-input input[class^=ag-][type=text].ag-input-field-input,\n.ag-theme-balham-dark .ag-color-input input[class^=ag-][type=text].ag-input-field-input,\n.ag-theme-balham-auto-dark .ag-color-input input[class^=ag-][type=text].ag-input-field-input {\n  min-height: calc(var(--ag-icon-size) + 4px);\n}\n.ag-theme-balham .ag-list-item-hovered::after,\n.ag-theme-balham-dark .ag-list-item-hovered::after,\n.ag-theme-balham-auto-dark .ag-list-item-hovered::after {\n  background-color: var(--ag-balham-active-color);\n}\n.ag-theme-balham .ag-pill .ag-pill-button:hover,\n.ag-theme-balham-dark .ag-pill .ag-pill-button:hover,\n.ag-theme-balham-auto-dark .ag-pill .ag-pill-button:hover {\n  color: var(--ag-balham-active-color);\n}\n.ag-theme-balham .ag-header-highlight-before::after,\n.ag-theme-balham .ag-header-highlight-after::after,\n.ag-theme-balham-dark .ag-header-highlight-before::after,\n.ag-theme-balham-dark .ag-header-highlight-after::after,\n.ag-theme-balham-auto-dark .ag-header-highlight-before::after,\n.ag-theme-balham-auto-dark .ag-header-highlight-after::after {\n  background-color: var(--ag-balham-active-color);\n}\n.ag-theme-balham .ag-advanced-filter-builder-item-button-disabled .ag-icon,\n.ag-theme-balham .ag-disabled .ag-icon,\n.ag-theme-balham .ag-column-select-column-group-readonly .ag-icon,\n.ag-theme-balham [disabled] .ag-icon,\n.ag-theme-balham-dark .ag-advanced-filter-builder-item-button-disabled .ag-icon,\n.ag-theme-balham-dark .ag-disabled .ag-icon,\n.ag-theme-balham-dark .ag-column-select-column-group-readonly .ag-icon,\n.ag-theme-balham-dark [disabled] .ag-icon,\n.ag-theme-balham-auto-dark .ag-advanced-filter-builder-item-button-disabled .ag-icon,\n.ag-theme-balham-auto-dark .ag-disabled .ag-icon,\n.ag-theme-balham-auto-dark .ag-column-select-column-group-readonly .ag-icon,\n.ag-theme-balham-auto-dark [disabled] .ag-icon {\n  color: var(--ag-disabled-foreground-color);\n}\n.ag-theme-balham .ag-filter-panel .ag-standard-button.ag-filter-panel-buttons-apply-button:disabled,\n.ag-theme-balham-dark .ag-filter-panel .ag-standard-button.ag-filter-panel-buttons-apply-button:disabled,\n.ag-theme-balham-auto-dark .ag-filter-panel .ag-standard-button.ag-filter-panel-buttons-apply-button:disabled {\n  color: unset;\n  background-color: unset;\n}\n.ag-theme-balham .ag-filter-card-title,\n.ag-theme-balham-dark .ag-filter-card-title,\n.ag-theme-balham-auto-dark .ag-filter-card-title {\n  font-weight: 600;\n}\n", ""]);
// Exports
/* harmony default export */ __webpack_exports__.A = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 64023:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(36758);
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40935);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".ag-theme-material,\n.ag-theme-material-dark,\n.ag-theme-material-auto-dark {\n  --ag-material-primary-color: #3f51b5;\n  --ag-material-accent-color: #ff4081;\n  --ag-foreground-color: rgba(0, 0, 0, 0.87);\n  --ag-secondary-foreground-color: rgba(0, 0, 0, 0.54);\n  --ag-disabled-foreground-color: rgba(0, 0, 0, 0.38);\n  --ag-background-color: #fff;\n  --ag-header-background-color: #fff;\n  --ag-tooltip-background-color: #fff;\n  --ag-subheader-background-color: #eee;\n  --ag-subheader-toolbar-background-color: rgba(238, 238, 238, 0.5);\n  --ag-header-cell-hover-background-color: #f2f2f2;\n  --ag-chip-background-color: #e2e2e2;\n  --ag-range-selection-background-color: rgba(122, 134, 203, 0.1);\n  --ag-range-selection-background-color-2: rgba(122, 134, 203, 0.19);\n  --ag-range-selection-background-color-3: rgba(122, 134, 203, 0.27);\n  --ag-range-selection-background-color-4: rgba(122, 134, 203, 0.34);\n  --ag-row-numbers-selected-color: color-mix(in srgb, transparent, var(--ag-material-accent-color) 50%);\n  --ag-range-selection-highlight-color: #fce4ec;\n  --ag-row-hover-color: #fafafa;\n  --ag-column-hover-color: #fafafa;\n  --ag-control-panel-background-color: #fafafa;\n  --ag-selected-row-background-color: rgba(33, 150, 243, 0.3);\n  --ag-checkbox-unchecked-color: #333;\n  --ag-value-change-value-highlight-background-color: #00acc1;\n  --ag-side-button-selected-background-color: transparent;\n  --ag-advanced-filter-join-pill-color: #f08e8d;\n  --ag-advanced-filter-column-pill-color: #a6e194;\n  --ag-advanced-filter-option-pill-color: #f3c08b;\n  --ag-advanced-filter-value-pill-color: #85c0e4;\n  --ag-find-match-color: var(--ag-foreground-color);\n  --ag-find-match-background-color: #ffff00;\n  --ag-find-active-match-color: var(--ag-foreground-color);\n  --ag-find-active-match-background-color: #ffa500;\n  --ag-filter-panel-apply-button-color: var(--ag-material-primary-color);\n  --ag-filter-panel-apply-button-background-color: transparent;\n  --ag-range-selection-border-color: var(--ag-material-primary-color);\n  --ag-checkbox-checked-color: var(--ag-material-accent-color);\n  --ag-borders: none;\n  --ag-borders-critical: solid 1px;\n  --ag-border-color: #e2e2e2;\n  --ag-grid-size: 8px;\n  --ag-icon-size: 18px;\n  --ag-header-height: calc(var(--ag-grid-size) * 7);\n  --ag-row-height: calc(var(--ag-grid-size) * 6);\n  --ag-cell-horizontal-padding: calc(var(--ag-grid-size) * 3);\n  --ag-list-item-height: calc(var(--ag-grid-size) * 4);\n  --ag-row-group-indent-size: calc(var(--ag-grid-size) * 3 + var(--ag-icon-size));\n  --ag-filter-tool-panel-sub-level-row-height: calc(var(--ag-grid-size) * 4);\n  --ag-checkbox-border-radius: 2px;\n  --ag-toggle-button-switch-border-width: 2px;\n  --ag-toggle-button-height: var(--ag-icon-size);\n  --ag-widget-container-horizontal-padding: calc(var(--ag-grid-size) * 1.5);\n  --ag-widget-container-vertical-padding: calc(var(--ag-grid-size) * 2);\n  --ag-widget-vertical-spacing: calc(var(--ag-grid-size) * 1.75);\n  --ag-font-family: Roboto, -apple-system, BlinkMacSystemFont, \"Segoe UI\", Oxygen-Sans, Ubuntu, Cantarell,\n      \"Helvetica Neue\", sans-serif;\n  --ag-font-size: 13px;\n  --ag-icon-font-family: agGridMaterial;\n  --ag-selected-tab-underline-color: var(--ag-material-primary-color);\n  --ag-selected-tab-underline-width: 2px;\n  --ag-input-focus-border-color: var(--ag-material-primary-color);\n  --ag-input-focus-box-shadow: 0 0 0 5px rgba(32, 33, 36, 0.122);\n  --ag-input-error-focus-box-shadow: 0 0 0 5px\n      color-mix(in srgb, var(--ag-background-color), var(--ag-invalid-color) 0.5%);\n  --ag-card-shadow: 0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14),\n      0 1px 5px 0 rgba(0, 0, 0, 0.12);\n  --ag-card-radius: 2px;\n  --ag-invalid-color: #e02525;\n}\n\n.ag-theme-material-dark {\n  --ag-material-primary-color: #3f51b5;\n  --ag-material-accent-color: #bb86fcff;\n  --ag-range-selection-border-color: var(--ag-material-accent-color);\n  --ag-find-match-color: var(--ag-background-color);\n  --ag-find-active-match-color: var(--ag-background-color);\n  --ag-background-color: #121212ff;\n  --ag-foreground-color: #ffffffff;\n  --ag-data-color: #f5f5f5ff;\n  --ag-header-cell-hover-background-color: #000000ff;\n  --ag-advanced-filter-join-pill-color: #7a3a37ff;\n  --ag-advanced-filter-column-pill-color: #355f2dff;\n  --ag-advanced-filter-option-pill-color: #5a3168ff;\n  --ag-advanced-filter-value-pill-color: #374c86ff;\n  --ag-input-disabled-border-color: #3a434eff;\n  --ag-input-disabled-background-color: #68686e12;\n  --ag-selected-row-background-color: #bb86fc33;\n  --ag-row-hover-color: #bb86fc33;\n  --ag-column-hover-color: #f5f5f50d;\n  --ag-range-selection-background-color: #bb86fc1a;\n  --ag-range-selection-background-color-2: #bb86fc30;\n  --ag-range-selection-background-color-3: #bb86fc45;\n  --ag-range-selection-background-color-4: #bb86fc57;\n  --ag-border-color: #383838ff;\n  --ag-secondary-border-color: #383838ff;\n  --ag-header-background-color: #121212ff;\n  --ag-tooltip-background-color: #212b38ff;\n  --ag-odd-row-background-color: #121212ff;\n  --ag-control-panel-background-color: #2c2c2cff;\n  --ag-subheader-background-color: #ffffff0d;\n  --ag-subheader-toolbar-background-color: #2c2c2cff;\n  --ag-invalid-color: #e02525ff;\n  --ag-checkbox-unchecked-color: #797e87ff;\n  --ag-checkbox-background-color: #121212ff;\n  --ag-secondary-foreground-color: #f5f5f5ff;\n  --ag-input-border-color: #383838ff;\n  --ag-input-border-color-invalid: #e02525ff;\n  --ag-disabled-foreground-color: #f5f5f580;\n  --ag-chip-background-color: #22262812;\n  --ag-side-button-selected-background-color: #2c2c2cff;\n  --ag-selected-tab-underline-color: #3f51b5ff;\n  --ag-modal-overlay-background-color: #121212a8;\n  --ag-value-change-delta-up-color: #43a047a8;\n  --ag-value-change-delta-down-color: #e53935ff;\n  --ag-menu-background-color: #2c2c2cff;\n  --ag-row-loading-skeleton-effect-color: rgba(202, 203, 204, 0.4);\n  --ag-cell-batch-edit-text-color: #f3d0b3;\n  color-scheme: dark;\n}\n\n@media (prefers-color-scheme: dark) {\n  .ag-theme-material-auto-dark {\n    --ag-material-primary-color: #3f51b5;\n    --ag-material-accent-color: #bb86fcff;\n    --ag-range-selection-border-color: var(--ag-material-accent-color);\n    --ag-find-match-color: var(--ag-background-color);\n    --ag-find-active-match-color: var(--ag-background-color);\n    --ag-background-color: #121212ff;\n    --ag-foreground-color: #ffffffff;\n    --ag-data-color: #f5f5f5ff;\n    --ag-header-cell-hover-background-color: #000000ff;\n    --ag-advanced-filter-join-pill-color: #7a3a37ff;\n    --ag-advanced-filter-column-pill-color: #355f2dff;\n    --ag-advanced-filter-option-pill-color: #5a3168ff;\n    --ag-advanced-filter-value-pill-color: #374c86ff;\n    --ag-input-disabled-border-color: #3a434eff;\n    --ag-input-disabled-background-color: #68686e12;\n    --ag-selected-row-background-color: #bb86fc33;\n    --ag-row-hover-color: #bb86fc33;\n    --ag-column-hover-color: #f5f5f50d;\n    --ag-range-selection-background-color: #bb86fc1a;\n    --ag-range-selection-background-color-2: #bb86fc30;\n    --ag-range-selection-background-color-3: #bb86fc45;\n    --ag-range-selection-background-color-4: #bb86fc57;\n    --ag-border-color: #383838ff;\n    --ag-secondary-border-color: #383838ff;\n    --ag-header-background-color: #121212ff;\n    --ag-tooltip-background-color: #212b38ff;\n    --ag-odd-row-background-color: #121212ff;\n    --ag-control-panel-background-color: #2c2c2cff;\n    --ag-subheader-background-color: #ffffff0d;\n    --ag-subheader-toolbar-background-color: #2c2c2cff;\n    --ag-invalid-color: #e02525ff;\n    --ag-checkbox-unchecked-color: #797e87ff;\n    --ag-checkbox-background-color: #121212ff;\n    --ag-secondary-foreground-color: #f5f5f5ff;\n    --ag-input-border-color: #383838ff;\n    --ag-input-border-color-invalid: #e02525ff;\n    --ag-disabled-foreground-color: #f5f5f580;\n    --ag-chip-background-color: #22262812;\n    --ag-side-button-selected-background-color: #2c2c2cff;\n    --ag-selected-tab-underline-color: #3f51b5ff;\n    --ag-modal-overlay-background-color: #121212a8;\n    --ag-value-change-delta-up-color: #43a047a8;\n    --ag-value-change-delta-down-color: #e53935ff;\n    --ag-menu-background-color: #2c2c2cff;\n    --ag-row-loading-skeleton-effect-color: rgba(202, 203, 204, 0.4);\n    --ag-cell-batch-edit-text-color: #f3d0b3;\n    color-scheme: dark;\n  }\n}\n.ag-theme-material .ag-filter-toolpanel-header,\n.ag-theme-material .ag-filter-toolpanel-search,\n.ag-theme-material .ag-status-bar,\n.ag-theme-material .ag-header-row,\n.ag-theme-material .ag-row-number-cell,\n.ag-theme-material .ag-panel-title-bar-title,\n.ag-theme-material .ag-multi-filter-group-title-bar,\n.ag-theme-material-dark .ag-filter-toolpanel-header,\n.ag-theme-material-dark .ag-filter-toolpanel-search,\n.ag-theme-material-dark .ag-status-bar,\n.ag-theme-material-dark .ag-header-row,\n.ag-theme-material-dark .ag-row-number-cell,\n.ag-theme-material-dark .ag-panel-title-bar-title,\n.ag-theme-material-dark .ag-multi-filter-group-title-bar,\n.ag-theme-material-auto-dark .ag-filter-toolpanel-header,\n.ag-theme-material-auto-dark .ag-filter-toolpanel-search,\n.ag-theme-material-auto-dark .ag-status-bar,\n.ag-theme-material-auto-dark .ag-header-row,\n.ag-theme-material-auto-dark .ag-row-number-cell,\n.ag-theme-material-auto-dark .ag-panel-title-bar-title,\n.ag-theme-material-auto-dark .ag-multi-filter-group-title-bar {\n  font-size: calc(var(--ag-font-size) - 1px);\n  font-weight: 600;\n  color: var(--ag-header-foreground-color);\n}\n.ag-theme-material .ag-tab,\n.ag-theme-material-dark .ag-tab,\n.ag-theme-material-auto-dark .ag-tab {\n  height: calc(var(--ag-grid-size) * 4.5);\n  flex: 1 1 auto;\n}\n.ag-theme-material .ag-tabs-header,\n.ag-theme-material .ag-column-drop-horizontal,\n.ag-theme-material-dark .ag-tabs-header,\n.ag-theme-material-dark .ag-column-drop-horizontal,\n.ag-theme-material-auto-dark .ag-tabs-header,\n.ag-theme-material-auto-dark .ag-column-drop-horizontal {\n  background-color: var(--ag-subheader-background-color);\n}\n.ag-theme-material .ag-tabs-body,\n.ag-theme-material-dark .ag-tabs-body,\n.ag-theme-material-auto-dark .ag-tabs-body {\n  padding: calc(var(--ag-grid-size) * 0.5) 0;\n}\n.ag-theme-material .ag-tabs-body .ag-menu-list,\n.ag-theme-material-dark .ag-tabs-body .ag-menu-list,\n.ag-theme-material-auto-dark .ag-tabs-body .ag-menu-list {\n  padding-top: 0;\n  padding-bottom: 0;\n}\n.ag-theme-material .ag-header-cell,\n.ag-theme-material .ag-header-group-cell,\n.ag-theme-material-dark .ag-header-cell,\n.ag-theme-material-dark .ag-header-group-cell,\n.ag-theme-material-auto-dark .ag-header-cell,\n.ag-theme-material-auto-dark .ag-header-group-cell {\n  transition: background-color 0.5s;\n}\n.ag-theme-material .ag-row-last:not(.ag-row-first) .ag-cell-inline-editing,\n.ag-theme-material-dark .ag-row-last:not(.ag-row-first) .ag-cell-inline-editing,\n.ag-theme-material-auto-dark .ag-row-last:not(.ag-row-first) .ag-cell-inline-editing {\n  bottom: 0;\n}\n.ag-theme-material .ag-cell-inline-editing,\n.ag-theme-material-dark .ag-cell-inline-editing,\n.ag-theme-material-auto-dark .ag-cell-inline-editing {\n  padding: var(--ag-grid-size);\n  height: calc(var(--ag-row-height) + var(--ag-grid-size) * 3);\n  border-color: var(--ag-border-color) !important;\n}\n.ag-theme-material .ag-has-focus .ag-cell-inline-editing,\n.ag-theme-material-dark .ag-has-focus .ag-cell-inline-editing,\n.ag-theme-material-auto-dark .ag-has-focus .ag-cell-inline-editing {\n  border-color: var(--ag-input-focus-border-color) !important;\n}\n.ag-theme-material .ag-column-drop-vertical,\n.ag-theme-material-dark .ag-column-drop-vertical,\n.ag-theme-material-auto-dark .ag-column-drop-vertical {\n  border-bottom: solid 1px;\n  border-bottom-color: var(--ag-border-color);\n  padding-top: var(--ag-grid-size);\n}\n.ag-theme-material .ag-column-drop-vertical.ag-last-column-drop,\n.ag-theme-material-dark .ag-column-drop-vertical.ag-last-column-drop,\n.ag-theme-material-auto-dark .ag-column-drop-vertical.ag-last-column-drop {\n  border-bottom: none;\n}\n.ag-theme-material .ag-column-drop-vertical-cell,\n.ag-theme-material-dark .ag-column-drop-vertical-cell,\n.ag-theme-material-auto-dark .ag-column-drop-vertical-cell {\n  margin-left: 0;\n}\n.ag-theme-material .ag-column-drop-vertical-empty-message,\n.ag-theme-material-dark .ag-column-drop-vertical-empty-message,\n.ag-theme-material-auto-dark .ag-column-drop-vertical-empty-message {\n  font-size: calc(var(--ag-font-size) - 1px);\n  font-weight: 600;\n  color: var(--ag-disabled-foreground-color);\n}\n.ag-theme-material .ag-ltr .ag-column-drop-vertical-empty-message, .ag-theme-material-dark .ag-ltr .ag-column-drop-vertical-empty-message, .ag-theme-material-auto-dark .ag-ltr .ag-column-drop-vertical-empty-message {\n  padding-left: calc(var(--ag-icon-size) + var(--ag-grid-size) * 2);\n  padding-right: var(--ag-grid-size);\n}\n\n.ag-theme-material .ag-rtl .ag-column-drop-vertical-empty-message, .ag-theme-material-dark .ag-rtl .ag-column-drop-vertical-empty-message, .ag-theme-material-auto-dark .ag-rtl .ag-column-drop-vertical-empty-message {\n  padding-right: calc(var(--ag-icon-size) + var(--ag-grid-size) * 2);\n  padding-left: var(--ag-grid-size);\n}\n\n.ag-theme-material .ag-status-bar,\n.ag-theme-material-dark .ag-status-bar,\n.ag-theme-material-auto-dark .ag-status-bar {\n  border: solid 1px;\n  border-color: var(--ag-border-color);\n}\n.ag-theme-material .ag-column-panel-column-select,\n.ag-theme-material-dark .ag-column-panel-column-select,\n.ag-theme-material-auto-dark .ag-column-panel-column-select {\n  border-top: solid 1px;\n  border-top-color: var(--ag-border-color);\n}\n.ag-theme-material .ag-column-select,\n.ag-theme-material .ag-column-select-header,\n.ag-theme-material-dark .ag-column-select,\n.ag-theme-material-dark .ag-column-select-header,\n.ag-theme-material-auto-dark .ag-column-select,\n.ag-theme-material-auto-dark .ag-column-select-header {\n  border-bottom: solid 1px;\n  border-bottom-color: var(--ag-border-color);\n}\n.ag-theme-material .ag-column-select-header,\n.ag-theme-material-dark .ag-column-select-header,\n.ag-theme-material-auto-dark .ag-column-select-header {\n  height: var(--ag-header-height);\n}\n.ag-theme-material .ag-group-title-bar,\n.ag-theme-material-dark .ag-group-title-bar,\n.ag-theme-material-auto-dark .ag-group-title-bar {\n  padding: calc(var(--ag-grid-size) * 0.75) var(--ag-grid-size);\n}\n.ag-theme-material .ag-charts-format-sub-level-group-title-bar,\n.ag-theme-material-dark .ag-charts-format-sub-level-group-title-bar,\n.ag-theme-material-auto-dark .ag-charts-format-sub-level-group-title-bar {\n  padding: calc(var(--ag-grid-size) * 0.5) var(--ag-grid-size);\n}\n.ag-theme-material .ag-chart-data-section,\n.ag-theme-material .ag-chart-format-section,\n.ag-theme-material .ag-chart-advanced-settings-section,\n.ag-theme-material-dark .ag-chart-data-section,\n.ag-theme-material-dark .ag-chart-format-section,\n.ag-theme-material-dark .ag-chart-advanced-settings-section,\n.ag-theme-material-auto-dark .ag-chart-data-section,\n.ag-theme-material-auto-dark .ag-chart-format-section,\n.ag-theme-material-auto-dark .ag-chart-advanced-settings-section {\n  padding-bottom: calc(var(--ag-grid-size) * 0.5);\n}\n.ag-theme-material input[class^=ag-]:not([type]),\n.ag-theme-material input[class^=ag-][type=text],\n.ag-theme-material input[class^=ag-][type=number],\n.ag-theme-material input[class^=ag-][type=tel],\n.ag-theme-material input[class^=ag-][type=date],\n.ag-theme-material input[class^=ag-][type=datetime-local],\n.ag-theme-material textarea[class^=ag-],\n.ag-theme-material-dark input[class^=ag-]:not([type]),\n.ag-theme-material-dark input[class^=ag-][type=text],\n.ag-theme-material-dark input[class^=ag-][type=number],\n.ag-theme-material-dark input[class^=ag-][type=tel],\n.ag-theme-material-dark input[class^=ag-][type=date],\n.ag-theme-material-dark input[class^=ag-][type=datetime-local],\n.ag-theme-material-dark textarea[class^=ag-],\n.ag-theme-material-auto-dark input[class^=ag-]:not([type]),\n.ag-theme-material-auto-dark input[class^=ag-][type=text],\n.ag-theme-material-auto-dark input[class^=ag-][type=number],\n.ag-theme-material-auto-dark input[class^=ag-][type=tel],\n.ag-theme-material-auto-dark input[class^=ag-][type=date],\n.ag-theme-material-auto-dark input[class^=ag-][type=datetime-local],\n.ag-theme-material-auto-dark textarea[class^=ag-] {\n  background: transparent;\n  color: var(--ag-foreground-color);\n  font-family: inherit;\n  font-size: inherit;\n  padding-bottom: var(--ag-grid-size);\n  border-width: 0;\n  border-radius: 0;\n  border-bottom: 2px solid;\n  border-bottom-color: var(--ag-border-color);\n}\n.ag-theme-material input[class^=ag-]:not([type]):not(textarea),\n.ag-theme-material input[class^=ag-][type=text]:not(textarea),\n.ag-theme-material input[class^=ag-][type=number]:not(textarea),\n.ag-theme-material input[class^=ag-][type=tel]:not(textarea),\n.ag-theme-material input[class^=ag-][type=date]:not(textarea),\n.ag-theme-material input[class^=ag-][type=datetime-local]:not(textarea),\n.ag-theme-material textarea[class^=ag-]:not(textarea),\n.ag-theme-material-dark input[class^=ag-]:not([type]):not(textarea),\n.ag-theme-material-dark input[class^=ag-][type=text]:not(textarea),\n.ag-theme-material-dark input[class^=ag-][type=number]:not(textarea),\n.ag-theme-material-dark input[class^=ag-][type=tel]:not(textarea),\n.ag-theme-material-dark input[class^=ag-][type=date]:not(textarea),\n.ag-theme-material-dark input[class^=ag-][type=datetime-local]:not(textarea),\n.ag-theme-material-dark textarea[class^=ag-]:not(textarea),\n.ag-theme-material-auto-dark input[class^=ag-]:not([type]):not(textarea),\n.ag-theme-material-auto-dark input[class^=ag-][type=text]:not(textarea),\n.ag-theme-material-auto-dark input[class^=ag-][type=number]:not(textarea),\n.ag-theme-material-auto-dark input[class^=ag-][type=tel]:not(textarea),\n.ag-theme-material-auto-dark input[class^=ag-][type=date]:not(textarea),\n.ag-theme-material-auto-dark input[class^=ag-][type=datetime-local]:not(textarea),\n.ag-theme-material-auto-dark textarea[class^=ag-]:not(textarea) {\n  height: calc(var(--ag-grid-size) * 5);\n}\n.ag-theme-material input[class^=ag-]:not([type]):focus,\n.ag-theme-material input[class^=ag-][type=text]:focus,\n.ag-theme-material input[class^=ag-][type=number]:focus,\n.ag-theme-material input[class^=ag-][type=tel]:focus,\n.ag-theme-material input[class^=ag-][type=date]:focus,\n.ag-theme-material input[class^=ag-][type=datetime-local]:focus,\n.ag-theme-material textarea[class^=ag-]:focus,\n.ag-theme-material-dark input[class^=ag-]:not([type]):focus,\n.ag-theme-material-dark input[class^=ag-][type=text]:focus,\n.ag-theme-material-dark input[class^=ag-][type=number]:focus,\n.ag-theme-material-dark input[class^=ag-][type=tel]:focus,\n.ag-theme-material-dark input[class^=ag-][type=date]:focus,\n.ag-theme-material-dark input[class^=ag-][type=datetime-local]:focus,\n.ag-theme-material-dark textarea[class^=ag-]:focus,\n.ag-theme-material-auto-dark input[class^=ag-]:not([type]):focus,\n.ag-theme-material-auto-dark input[class^=ag-][type=text]:focus,\n.ag-theme-material-auto-dark input[class^=ag-][type=number]:focus,\n.ag-theme-material-auto-dark input[class^=ag-][type=tel]:focus,\n.ag-theme-material-auto-dark input[class^=ag-][type=date]:focus,\n.ag-theme-material-auto-dark input[class^=ag-][type=datetime-local]:focus,\n.ag-theme-material-auto-dark textarea[class^=ag-]:focus {\n  border-bottom: 2px solid;\n  border-bottom-color: var(--ag-material-primary-color);\n  outline: none;\n  box-shadow: none;\n}\n.ag-theme-material input[class^=ag-]:not([type])::placeholder,\n.ag-theme-material input[class^=ag-][type=text]::placeholder,\n.ag-theme-material input[class^=ag-][type=number]::placeholder,\n.ag-theme-material input[class^=ag-][type=tel]::placeholder,\n.ag-theme-material input[class^=ag-][type=date]::placeholder,\n.ag-theme-material input[class^=ag-][type=datetime-local]::placeholder,\n.ag-theme-material textarea[class^=ag-]::placeholder,\n.ag-theme-material-dark input[class^=ag-]:not([type])::placeholder,\n.ag-theme-material-dark input[class^=ag-][type=text]::placeholder,\n.ag-theme-material-dark input[class^=ag-][type=number]::placeholder,\n.ag-theme-material-dark input[class^=ag-][type=tel]::placeholder,\n.ag-theme-material-dark input[class^=ag-][type=date]::placeholder,\n.ag-theme-material-dark input[class^=ag-][type=datetime-local]::placeholder,\n.ag-theme-material-dark textarea[class^=ag-]::placeholder,\n.ag-theme-material-auto-dark input[class^=ag-]:not([type])::placeholder,\n.ag-theme-material-auto-dark input[class^=ag-][type=text]::placeholder,\n.ag-theme-material-auto-dark input[class^=ag-][type=number]::placeholder,\n.ag-theme-material-auto-dark input[class^=ag-][type=tel]::placeholder,\n.ag-theme-material-auto-dark input[class^=ag-][type=date]::placeholder,\n.ag-theme-material-auto-dark input[class^=ag-][type=datetime-local]::placeholder,\n.ag-theme-material-auto-dark textarea[class^=ag-]::placeholder {\n  color: var(--ag-disabled-foreground-color);\n}\n.ag-theme-material input[class^=ag-]:not([type]):disabled,\n.ag-theme-material input[class^=ag-][type=text]:disabled,\n.ag-theme-material input[class^=ag-][type=number]:disabled,\n.ag-theme-material input[class^=ag-][type=tel]:disabled,\n.ag-theme-material input[class^=ag-][type=date]:disabled,\n.ag-theme-material input[class^=ag-][type=datetime-local]:disabled,\n.ag-theme-material textarea[class^=ag-]:disabled,\n.ag-theme-material-dark input[class^=ag-]:not([type]):disabled,\n.ag-theme-material-dark input[class^=ag-][type=text]:disabled,\n.ag-theme-material-dark input[class^=ag-][type=number]:disabled,\n.ag-theme-material-dark input[class^=ag-][type=tel]:disabled,\n.ag-theme-material-dark input[class^=ag-][type=date]:disabled,\n.ag-theme-material-dark input[class^=ag-][type=datetime-local]:disabled,\n.ag-theme-material-dark textarea[class^=ag-]:disabled,\n.ag-theme-material-auto-dark input[class^=ag-]:not([type]):disabled,\n.ag-theme-material-auto-dark input[class^=ag-][type=text]:disabled,\n.ag-theme-material-auto-dark input[class^=ag-][type=number]:disabled,\n.ag-theme-material-auto-dark input[class^=ag-][type=tel]:disabled,\n.ag-theme-material-auto-dark input[class^=ag-][type=date]:disabled,\n.ag-theme-material-auto-dark input[class^=ag-][type=datetime-local]:disabled,\n.ag-theme-material-auto-dark textarea[class^=ag-]:disabled {\n  border-bottom: 1px solid;\n  border-bottom-color: var(--ag-border-color);\n}\n.ag-theme-material input[class^=ag-]:not([type]):invalid,\n.ag-theme-material input[class^=ag-][type=text]:invalid,\n.ag-theme-material input[class^=ag-][type=number]:invalid,\n.ag-theme-material input[class^=ag-][type=tel]:invalid,\n.ag-theme-material input[class^=ag-][type=date]:invalid,\n.ag-theme-material input[class^=ag-][type=datetime-local]:invalid,\n.ag-theme-material textarea[class^=ag-]:invalid,\n.ag-theme-material-dark input[class^=ag-]:not([type]):invalid,\n.ag-theme-material-dark input[class^=ag-][type=text]:invalid,\n.ag-theme-material-dark input[class^=ag-][type=number]:invalid,\n.ag-theme-material-dark input[class^=ag-][type=tel]:invalid,\n.ag-theme-material-dark input[class^=ag-][type=date]:invalid,\n.ag-theme-material-dark input[class^=ag-][type=datetime-local]:invalid,\n.ag-theme-material-dark textarea[class^=ag-]:invalid,\n.ag-theme-material-auto-dark input[class^=ag-]:not([type]):invalid,\n.ag-theme-material-auto-dark input[class^=ag-][type=text]:invalid,\n.ag-theme-material-auto-dark input[class^=ag-][type=number]:invalid,\n.ag-theme-material-auto-dark input[class^=ag-][type=tel]:invalid,\n.ag-theme-material-auto-dark input[class^=ag-][type=date]:invalid,\n.ag-theme-material-auto-dark input[class^=ag-][type=datetime-local]:invalid,\n.ag-theme-material-auto-dark textarea[class^=ag-]:invalid {\n  border-width: 0;\n  border-bottom: 1px solid;\n  border-bottom-color: var(--ag-invalid-color);\n  color: var(--ag-invalid-color);\n}\n.ag-theme-material .ag-standard-button,\n.ag-theme-material-dark .ag-standard-button,\n.ag-theme-material-auto-dark .ag-standard-button {\n  appearance: none;\n  background-color: transparent;\n  border: 0;\n  color: var(--ag-material-primary-color);\n  font-family: inherit;\n  font-size: inherit;\n  margin: 0;\n  padding: 0;\n  text-transform: uppercase;\n}\n.ag-theme-material .ag-standard-button:disabled,\n.ag-theme-material-dark .ag-standard-button:disabled,\n.ag-theme-material-auto-dark .ag-standard-button:disabled {\n  color: var(--ag-disabled-foreground-color);\n  background-color: var(--ag-input-disabled-background-color);\n  border-color: var(--ag-input-disabled-border-color);\n}\n.ag-theme-material.ag-dnd-ghost,\n.ag-theme-material-dark.ag-dnd-ghost,\n.ag-theme-material-auto-dark.ag-dnd-ghost {\n  font-size: calc(var(--ag-font-size) - 1px);\n  font-weight: 600;\n}\n.ag-theme-material .ag-filter-toolpanel-header,\n.ag-theme-material-dark .ag-filter-toolpanel-header,\n.ag-theme-material-auto-dark .ag-filter-toolpanel-header {\n  height: calc(var(--ag-grid-size) * 4);\n}\n.ag-theme-material .ag-filter-toolpanel-group-level-0-header,\n.ag-theme-material-dark .ag-filter-toolpanel-group-level-0-header,\n.ag-theme-material-auto-dark .ag-filter-toolpanel-group-level-0-header {\n  height: calc(var(--ag-grid-size) * 7);\n}\n.ag-theme-material .ag-filter-card-title,\n.ag-theme-material-dark .ag-filter-card-title,\n.ag-theme-material-auto-dark .ag-filter-card-title {\n  font-size: calc(var(--ag-font-size) - 1px);\n  font-weight: 600;\n}\n.ag-theme-material .ag-filter-panel .ag-standard-button,\n.ag-theme-material-dark .ag-filter-panel .ag-standard-button,\n.ag-theme-material-auto-dark .ag-filter-panel .ag-standard-button {\n  padding: var(--ag-grid-size);\n}\n.ag-theme-material .ag-filter-add-button,\n.ag-theme-material-dark .ag-filter-add-button,\n.ag-theme-material-auto-dark .ag-filter-add-button {\n  border-bottom: 2px solid var(--ag-material-primary-color);\n}\n.ag-theme-material .ag-filter-add-button .ag-icon,\n.ag-theme-material-dark .ag-filter-add-button .ag-icon,\n.ag-theme-material-auto-dark .ag-filter-add-button .ag-icon {\n  color: var(--ag-material-active-color);\n}\n.ag-theme-material .ag-ltr .ag-filter-apply-panel-button, .ag-theme-material .ag-ltr .ag-advanced-filter-apply-button, .ag-theme-material .ag-ltr .ag-advanced-filter-builder-button, .ag-theme-material-dark .ag-ltr .ag-filter-apply-panel-button, .ag-theme-material-dark .ag-ltr .ag-advanced-filter-apply-button, .ag-theme-material-dark .ag-ltr .ag-advanced-filter-builder-button, .ag-theme-material-auto-dark .ag-ltr .ag-filter-apply-panel-button, .ag-theme-material-auto-dark .ag-ltr .ag-advanced-filter-apply-button, .ag-theme-material-auto-dark .ag-ltr .ag-advanced-filter-builder-button {\n  margin-left: var(--ag-grid-size);\n}\n\n.ag-theme-material .ag-rtl .ag-filter-apply-panel-button, .ag-theme-material .ag-rtl .ag-advanced-filter-apply-button, .ag-theme-material .ag-rtl .ag-advanced-filter-builder-button, .ag-theme-material-dark .ag-rtl .ag-filter-apply-panel-button, .ag-theme-material-dark .ag-rtl .ag-advanced-filter-apply-button, .ag-theme-material-dark .ag-rtl .ag-advanced-filter-builder-button, .ag-theme-material-auto-dark .ag-rtl .ag-filter-apply-panel-button, .ag-theme-material-auto-dark .ag-rtl .ag-advanced-filter-apply-button, .ag-theme-material-auto-dark .ag-rtl .ag-advanced-filter-builder-button {\n  margin-right: var(--ag-grid-size);\n}\n\n.ag-theme-material .ag-layout-auto-height .ag-center-cols-viewport,\n.ag-theme-material .ag-layout-auto-height .ag-center-cols-container,\n.ag-theme-material .ag-layout-print .ag-center-cols-viewport,\n.ag-theme-material .ag-layout-print .ag-center-cols-container,\n.ag-theme-material-dark .ag-layout-auto-height .ag-center-cols-viewport,\n.ag-theme-material-dark .ag-layout-auto-height .ag-center-cols-container,\n.ag-theme-material-dark .ag-layout-print .ag-center-cols-viewport,\n.ag-theme-material-dark .ag-layout-print .ag-center-cols-container,\n.ag-theme-material-auto-dark .ag-layout-auto-height .ag-center-cols-viewport,\n.ag-theme-material-auto-dark .ag-layout-auto-height .ag-center-cols-container,\n.ag-theme-material-auto-dark .ag-layout-print .ag-center-cols-viewport,\n.ag-theme-material-auto-dark .ag-layout-print .ag-center-cols-container {\n  min-height: 150px;\n}\n.ag-theme-material .ag-picker-field-wrapper:focus-within,\n.ag-theme-material-dark .ag-picker-field-wrapper:focus-within,\n.ag-theme-material-auto-dark .ag-picker-field-wrapper:focus-within {\n  box-shadow: 0 0 0 1px var(--ag-material-primary-color);\n}\n.ag-theme-material .ag-rich-select-list,\n.ag-theme-material-dark .ag-rich-select-list,\n.ag-theme-material-auto-dark .ag-rich-select-list {\n  box-shadow: rgba(0, 0, 0, 0.2) 0px 5px 5px -3px, rgba(0, 0, 0, 0.14) 0px 8px 10px 1px, rgba(0, 0, 0, 0.12) 0px 3px 14px 2px;\n}\n.ag-theme-material .ag-advanced-filter-builder-button-label,\n.ag-theme-material-dark .ag-advanced-filter-builder-button-label,\n.ag-theme-material-auto-dark .ag-advanced-filter-builder-button-label {\n  text-transform: uppercase;\n}\n.ag-theme-material .ag-filter-active .ag-icon-filter,\n.ag-theme-material-dark .ag-filter-active .ag-icon-filter,\n.ag-theme-material-auto-dark .ag-filter-active .ag-icon-filter {\n  color: var(--ag-material-accent-color);\n}\n.ag-theme-material .ag-list-item-hovered::after,\n.ag-theme-material-dark .ag-list-item-hovered::after,\n.ag-theme-material-auto-dark .ag-list-item-hovered::after {\n  background-color: var(--ag-material-primary-color);\n}\n.ag-theme-material .ag-pill .ag-pill-button:hover,\n.ag-theme-material-dark .ag-pill .ag-pill-button:hover,\n.ag-theme-material-auto-dark .ag-pill .ag-pill-button:hover {\n  color: var(--ag-material-primary-color);\n}\n.ag-theme-material .ag-header-highlight-before::after,\n.ag-theme-material .ag-header-highlight-after::after,\n.ag-theme-material-dark .ag-header-highlight-before::after,\n.ag-theme-material-dark .ag-header-highlight-after::after,\n.ag-theme-material-auto-dark .ag-header-highlight-before::after,\n.ag-theme-material-auto-dark .ag-header-highlight-after::after {\n  background-color: var(--ag-material-primary-color);\n}\n.ag-theme-material .ag-advanced-filter-builder-item-button-disabled .ag-icon,\n.ag-theme-material .ag-disabled .ag-icon,\n.ag-theme-material .ag-column-select-column-group-readonly .ag-icon,\n.ag-theme-material [disabled] .ag-icon,\n.ag-theme-material-dark .ag-advanced-filter-builder-item-button-disabled .ag-icon,\n.ag-theme-material-dark .ag-disabled .ag-icon,\n.ag-theme-material-dark .ag-column-select-column-group-readonly .ag-icon,\n.ag-theme-material-dark [disabled] .ag-icon,\n.ag-theme-material-auto-dark .ag-advanced-filter-builder-item-button-disabled .ag-icon,\n.ag-theme-material-auto-dark .ag-disabled .ag-icon,\n.ag-theme-material-auto-dark .ag-column-select-column-group-readonly .ag-icon,\n.ag-theme-material-auto-dark [disabled] .ag-icon {\n  color: var(--ag-disabled-foreground-color);\n}\n", ""]);
// Exports
/* harmony default export */ __webpack_exports__.A = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 83973:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(36758);
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40935);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20062);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(80902), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, "@font-face {\n  font-family: \"agGridMaterial\";\n  src: url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ");\n  font-weight: normal;\n  font-style: normal;\n}\n.ag-theme-material,\n.ag-theme-material-dark,\n.ag-theme-material-auto-dark {\n  --ag-material-primary-color: #3f51b5;\n  --ag-material-accent-color: #ff4081;\n  --ag-foreground-color: rgba(0, 0, 0, 0.87);\n  --ag-secondary-foreground-color: rgba(0, 0, 0, 0.54);\n  --ag-disabled-foreground-color: rgba(0, 0, 0, 0.38);\n  --ag-background-color: #fff;\n  --ag-header-background-color: #fff;\n  --ag-tooltip-background-color: #fff;\n  --ag-subheader-background-color: #eee;\n  --ag-subheader-toolbar-background-color: rgba(238, 238, 238, 0.5);\n  --ag-header-cell-hover-background-color: #f2f2f2;\n  --ag-chip-background-color: #e2e2e2;\n  --ag-range-selection-background-color: rgba(122, 134, 203, 0.1);\n  --ag-range-selection-background-color-2: rgba(122, 134, 203, 0.19);\n  --ag-range-selection-background-color-3: rgba(122, 134, 203, 0.27);\n  --ag-range-selection-background-color-4: rgba(122, 134, 203, 0.34);\n  --ag-row-numbers-selected-color: color-mix(in srgb, transparent, var(--ag-material-accent-color) 50%);\n  --ag-range-selection-highlight-color: #fce4ec;\n  --ag-row-hover-color: #fafafa;\n  --ag-column-hover-color: #fafafa;\n  --ag-control-panel-background-color: #fafafa;\n  --ag-selected-row-background-color: rgba(33, 150, 243, 0.3);\n  --ag-checkbox-unchecked-color: #333;\n  --ag-value-change-value-highlight-background-color: #00acc1;\n  --ag-side-button-selected-background-color: transparent;\n  --ag-advanced-filter-join-pill-color: #f08e8d;\n  --ag-advanced-filter-column-pill-color: #a6e194;\n  --ag-advanced-filter-option-pill-color: #f3c08b;\n  --ag-advanced-filter-value-pill-color: #85c0e4;\n  --ag-find-match-color: var(--ag-foreground-color);\n  --ag-find-match-background-color: #ffff00;\n  --ag-find-active-match-color: var(--ag-foreground-color);\n  --ag-find-active-match-background-color: #ffa500;\n  --ag-filter-panel-apply-button-color: var(--ag-material-primary-color);\n  --ag-filter-panel-apply-button-background-color: transparent;\n  --ag-range-selection-border-color: var(--ag-material-primary-color);\n  --ag-checkbox-checked-color: var(--ag-material-accent-color);\n  --ag-borders: none;\n  --ag-borders-critical: solid 1px;\n  --ag-border-color: #e2e2e2;\n  --ag-grid-size: 8px;\n  --ag-icon-size: 18px;\n  --ag-header-height: calc(var(--ag-grid-size) * 7);\n  --ag-row-height: calc(var(--ag-grid-size) * 6);\n  --ag-cell-horizontal-padding: calc(var(--ag-grid-size) * 3);\n  --ag-list-item-height: calc(var(--ag-grid-size) * 4);\n  --ag-row-group-indent-size: calc(var(--ag-grid-size) * 3 + var(--ag-icon-size));\n  --ag-filter-tool-panel-sub-level-row-height: calc(var(--ag-grid-size) * 4);\n  --ag-checkbox-border-radius: 2px;\n  --ag-toggle-button-switch-border-width: 2px;\n  --ag-toggle-button-height: var(--ag-icon-size);\n  --ag-widget-container-horizontal-padding: calc(var(--ag-grid-size) * 1.5);\n  --ag-widget-container-vertical-padding: calc(var(--ag-grid-size) * 2);\n  --ag-widget-vertical-spacing: calc(var(--ag-grid-size) * 1.75);\n  --ag-font-family: Roboto, -apple-system, BlinkMacSystemFont, \"Segoe UI\", Oxygen-Sans, Ubuntu, Cantarell,\n      \"Helvetica Neue\", sans-serif;\n  --ag-font-size: 13px;\n  --ag-icon-font-family: agGridMaterial;\n  --ag-selected-tab-underline-color: var(--ag-material-primary-color);\n  --ag-selected-tab-underline-width: 2px;\n  --ag-input-focus-border-color: var(--ag-material-primary-color);\n  --ag-input-focus-box-shadow: 0 0 0 5px rgba(32, 33, 36, 0.122);\n  --ag-input-error-focus-box-shadow: 0 0 0 5px\n      color-mix(in srgb, var(--ag-background-color), var(--ag-invalid-color) 0.5%);\n  --ag-card-shadow: 0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14),\n      0 1px 5px 0 rgba(0, 0, 0, 0.12);\n  --ag-card-radius: 2px;\n  --ag-invalid-color: #e02525;\n}\n\n.ag-theme-material-dark {\n  --ag-material-primary-color: #3f51b5;\n  --ag-material-accent-color: #bb86fcff;\n  --ag-range-selection-border-color: var(--ag-material-accent-color);\n  --ag-find-match-color: var(--ag-background-color);\n  --ag-find-active-match-color: var(--ag-background-color);\n  --ag-background-color: #121212ff;\n  --ag-foreground-color: #ffffffff;\n  --ag-data-color: #f5f5f5ff;\n  --ag-header-cell-hover-background-color: #000000ff;\n  --ag-advanced-filter-join-pill-color: #7a3a37ff;\n  --ag-advanced-filter-column-pill-color: #355f2dff;\n  --ag-advanced-filter-option-pill-color: #5a3168ff;\n  --ag-advanced-filter-value-pill-color: #374c86ff;\n  --ag-input-disabled-border-color: #3a434eff;\n  --ag-input-disabled-background-color: #68686e12;\n  --ag-selected-row-background-color: #bb86fc33;\n  --ag-row-hover-color: #bb86fc33;\n  --ag-column-hover-color: #f5f5f50d;\n  --ag-range-selection-background-color: #bb86fc1a;\n  --ag-range-selection-background-color-2: #bb86fc30;\n  --ag-range-selection-background-color-3: #bb86fc45;\n  --ag-range-selection-background-color-4: #bb86fc57;\n  --ag-border-color: #383838ff;\n  --ag-secondary-border-color: #383838ff;\n  --ag-header-background-color: #121212ff;\n  --ag-tooltip-background-color: #212b38ff;\n  --ag-odd-row-background-color: #121212ff;\n  --ag-control-panel-background-color: #2c2c2cff;\n  --ag-subheader-background-color: #ffffff0d;\n  --ag-subheader-toolbar-background-color: #2c2c2cff;\n  --ag-invalid-color: #e02525ff;\n  --ag-checkbox-unchecked-color: #797e87ff;\n  --ag-checkbox-background-color: #121212ff;\n  --ag-secondary-foreground-color: #f5f5f5ff;\n  --ag-input-border-color: #383838ff;\n  --ag-input-border-color-invalid: #e02525ff;\n  --ag-disabled-foreground-color: #f5f5f580;\n  --ag-chip-background-color: #22262812;\n  --ag-side-button-selected-background-color: #2c2c2cff;\n  --ag-selected-tab-underline-color: #3f51b5ff;\n  --ag-modal-overlay-background-color: #121212a8;\n  --ag-value-change-delta-up-color: #43a047a8;\n  --ag-value-change-delta-down-color: #e53935ff;\n  --ag-menu-background-color: #2c2c2cff;\n  --ag-row-loading-skeleton-effect-color: rgba(202, 203, 204, 0.4);\n  --ag-cell-batch-edit-text-color: #f3d0b3;\n  color-scheme: dark;\n}\n\n@media (prefers-color-scheme: dark) {\n  .ag-theme-material-auto-dark {\n    --ag-material-primary-color: #3f51b5;\n    --ag-material-accent-color: #bb86fcff;\n    --ag-range-selection-border-color: var(--ag-material-accent-color);\n    --ag-find-match-color: var(--ag-background-color);\n    --ag-find-active-match-color: var(--ag-background-color);\n    --ag-background-color: #121212ff;\n    --ag-foreground-color: #ffffffff;\n    --ag-data-color: #f5f5f5ff;\n    --ag-header-cell-hover-background-color: #000000ff;\n    --ag-advanced-filter-join-pill-color: #7a3a37ff;\n    --ag-advanced-filter-column-pill-color: #355f2dff;\n    --ag-advanced-filter-option-pill-color: #5a3168ff;\n    --ag-advanced-filter-value-pill-color: #374c86ff;\n    --ag-input-disabled-border-color: #3a434eff;\n    --ag-input-disabled-background-color: #68686e12;\n    --ag-selected-row-background-color: #bb86fc33;\n    --ag-row-hover-color: #bb86fc33;\n    --ag-column-hover-color: #f5f5f50d;\n    --ag-range-selection-background-color: #bb86fc1a;\n    --ag-range-selection-background-color-2: #bb86fc30;\n    --ag-range-selection-background-color-3: #bb86fc45;\n    --ag-range-selection-background-color-4: #bb86fc57;\n    --ag-border-color: #383838ff;\n    --ag-secondary-border-color: #383838ff;\n    --ag-header-background-color: #121212ff;\n    --ag-tooltip-background-color: #212b38ff;\n    --ag-odd-row-background-color: #121212ff;\n    --ag-control-panel-background-color: #2c2c2cff;\n    --ag-subheader-background-color: #ffffff0d;\n    --ag-subheader-toolbar-background-color: #2c2c2cff;\n    --ag-invalid-color: #e02525ff;\n    --ag-checkbox-unchecked-color: #797e87ff;\n    --ag-checkbox-background-color: #121212ff;\n    --ag-secondary-foreground-color: #f5f5f5ff;\n    --ag-input-border-color: #383838ff;\n    --ag-input-border-color-invalid: #e02525ff;\n    --ag-disabled-foreground-color: #f5f5f580;\n    --ag-chip-background-color: #22262812;\n    --ag-side-button-selected-background-color: #2c2c2cff;\n    --ag-selected-tab-underline-color: #3f51b5ff;\n    --ag-modal-overlay-background-color: #121212a8;\n    --ag-value-change-delta-up-color: #43a047a8;\n    --ag-value-change-delta-down-color: #e53935ff;\n    --ag-menu-background-color: #2c2c2cff;\n    --ag-row-loading-skeleton-effect-color: rgba(202, 203, 204, 0.4);\n    --ag-cell-batch-edit-text-color: #f3d0b3;\n    color-scheme: dark;\n  }\n}\n.ag-theme-material .ag-filter-toolpanel-header,\n.ag-theme-material .ag-filter-toolpanel-search,\n.ag-theme-material .ag-status-bar,\n.ag-theme-material .ag-header-row,\n.ag-theme-material .ag-row-number-cell,\n.ag-theme-material .ag-panel-title-bar-title,\n.ag-theme-material .ag-multi-filter-group-title-bar,\n.ag-theme-material-dark .ag-filter-toolpanel-header,\n.ag-theme-material-dark .ag-filter-toolpanel-search,\n.ag-theme-material-dark .ag-status-bar,\n.ag-theme-material-dark .ag-header-row,\n.ag-theme-material-dark .ag-row-number-cell,\n.ag-theme-material-dark .ag-panel-title-bar-title,\n.ag-theme-material-dark .ag-multi-filter-group-title-bar,\n.ag-theme-material-auto-dark .ag-filter-toolpanel-header,\n.ag-theme-material-auto-dark .ag-filter-toolpanel-search,\n.ag-theme-material-auto-dark .ag-status-bar,\n.ag-theme-material-auto-dark .ag-header-row,\n.ag-theme-material-auto-dark .ag-row-number-cell,\n.ag-theme-material-auto-dark .ag-panel-title-bar-title,\n.ag-theme-material-auto-dark .ag-multi-filter-group-title-bar {\n  font-size: calc(var(--ag-font-size) - 1px);\n  font-weight: 600;\n  color: var(--ag-header-foreground-color);\n}\n.ag-theme-material .ag-tab,\n.ag-theme-material-dark .ag-tab,\n.ag-theme-material-auto-dark .ag-tab {\n  height: calc(var(--ag-grid-size) * 4.5);\n  flex: 1 1 auto;\n}\n.ag-theme-material .ag-tabs-header,\n.ag-theme-material .ag-column-drop-horizontal,\n.ag-theme-material-dark .ag-tabs-header,\n.ag-theme-material-dark .ag-column-drop-horizontal,\n.ag-theme-material-auto-dark .ag-tabs-header,\n.ag-theme-material-auto-dark .ag-column-drop-horizontal {\n  background-color: var(--ag-subheader-background-color);\n}\n.ag-theme-material .ag-tabs-body,\n.ag-theme-material-dark .ag-tabs-body,\n.ag-theme-material-auto-dark .ag-tabs-body {\n  padding: calc(var(--ag-grid-size) * 0.5) 0;\n}\n.ag-theme-material .ag-tabs-body .ag-menu-list,\n.ag-theme-material-dark .ag-tabs-body .ag-menu-list,\n.ag-theme-material-auto-dark .ag-tabs-body .ag-menu-list {\n  padding-top: 0;\n  padding-bottom: 0;\n}\n.ag-theme-material .ag-header-cell,\n.ag-theme-material .ag-header-group-cell,\n.ag-theme-material-dark .ag-header-cell,\n.ag-theme-material-dark .ag-header-group-cell,\n.ag-theme-material-auto-dark .ag-header-cell,\n.ag-theme-material-auto-dark .ag-header-group-cell {\n  transition: background-color 0.5s;\n}\n.ag-theme-material .ag-row-last:not(.ag-row-first) .ag-cell-inline-editing,\n.ag-theme-material-dark .ag-row-last:not(.ag-row-first) .ag-cell-inline-editing,\n.ag-theme-material-auto-dark .ag-row-last:not(.ag-row-first) .ag-cell-inline-editing {\n  bottom: 0;\n}\n.ag-theme-material .ag-cell-inline-editing,\n.ag-theme-material-dark .ag-cell-inline-editing,\n.ag-theme-material-auto-dark .ag-cell-inline-editing {\n  padding: var(--ag-grid-size);\n  height: calc(var(--ag-row-height) + var(--ag-grid-size) * 3);\n  border-color: var(--ag-border-color) !important;\n}\n.ag-theme-material .ag-has-focus .ag-cell-inline-editing,\n.ag-theme-material-dark .ag-has-focus .ag-cell-inline-editing,\n.ag-theme-material-auto-dark .ag-has-focus .ag-cell-inline-editing {\n  border-color: var(--ag-input-focus-border-color) !important;\n}\n.ag-theme-material .ag-column-drop-vertical,\n.ag-theme-material-dark .ag-column-drop-vertical,\n.ag-theme-material-auto-dark .ag-column-drop-vertical {\n  border-bottom: solid 1px;\n  border-bottom-color: var(--ag-border-color);\n  padding-top: var(--ag-grid-size);\n}\n.ag-theme-material .ag-column-drop-vertical.ag-last-column-drop,\n.ag-theme-material-dark .ag-column-drop-vertical.ag-last-column-drop,\n.ag-theme-material-auto-dark .ag-column-drop-vertical.ag-last-column-drop {\n  border-bottom: none;\n}\n.ag-theme-material .ag-column-drop-vertical-cell,\n.ag-theme-material-dark .ag-column-drop-vertical-cell,\n.ag-theme-material-auto-dark .ag-column-drop-vertical-cell {\n  margin-left: 0;\n}\n.ag-theme-material .ag-column-drop-vertical-empty-message,\n.ag-theme-material-dark .ag-column-drop-vertical-empty-message,\n.ag-theme-material-auto-dark .ag-column-drop-vertical-empty-message {\n  font-size: calc(var(--ag-font-size) - 1px);\n  font-weight: 600;\n  color: var(--ag-disabled-foreground-color);\n}\n.ag-theme-material .ag-ltr .ag-column-drop-vertical-empty-message, .ag-theme-material-dark .ag-ltr .ag-column-drop-vertical-empty-message, .ag-theme-material-auto-dark .ag-ltr .ag-column-drop-vertical-empty-message {\n  padding-left: calc(var(--ag-icon-size) + var(--ag-grid-size) * 2);\n  padding-right: var(--ag-grid-size);\n}\n\n.ag-theme-material .ag-rtl .ag-column-drop-vertical-empty-message, .ag-theme-material-dark .ag-rtl .ag-column-drop-vertical-empty-message, .ag-theme-material-auto-dark .ag-rtl .ag-column-drop-vertical-empty-message {\n  padding-right: calc(var(--ag-icon-size) + var(--ag-grid-size) * 2);\n  padding-left: var(--ag-grid-size);\n}\n\n.ag-theme-material .ag-status-bar,\n.ag-theme-material-dark .ag-status-bar,\n.ag-theme-material-auto-dark .ag-status-bar {\n  border: solid 1px;\n  border-color: var(--ag-border-color);\n}\n.ag-theme-material .ag-column-panel-column-select,\n.ag-theme-material-dark .ag-column-panel-column-select,\n.ag-theme-material-auto-dark .ag-column-panel-column-select {\n  border-top: solid 1px;\n  border-top-color: var(--ag-border-color);\n}\n.ag-theme-material .ag-column-select,\n.ag-theme-material .ag-column-select-header,\n.ag-theme-material-dark .ag-column-select,\n.ag-theme-material-dark .ag-column-select-header,\n.ag-theme-material-auto-dark .ag-column-select,\n.ag-theme-material-auto-dark .ag-column-select-header {\n  border-bottom: solid 1px;\n  border-bottom-color: var(--ag-border-color);\n}\n.ag-theme-material .ag-column-select-header,\n.ag-theme-material-dark .ag-column-select-header,\n.ag-theme-material-auto-dark .ag-column-select-header {\n  height: var(--ag-header-height);\n}\n.ag-theme-material .ag-group-title-bar,\n.ag-theme-material-dark .ag-group-title-bar,\n.ag-theme-material-auto-dark .ag-group-title-bar {\n  padding: calc(var(--ag-grid-size) * 0.75) var(--ag-grid-size);\n}\n.ag-theme-material .ag-charts-format-sub-level-group-title-bar,\n.ag-theme-material-dark .ag-charts-format-sub-level-group-title-bar,\n.ag-theme-material-auto-dark .ag-charts-format-sub-level-group-title-bar {\n  padding: calc(var(--ag-grid-size) * 0.5) var(--ag-grid-size);\n}\n.ag-theme-material .ag-chart-data-section,\n.ag-theme-material .ag-chart-format-section,\n.ag-theme-material .ag-chart-advanced-settings-section,\n.ag-theme-material-dark .ag-chart-data-section,\n.ag-theme-material-dark .ag-chart-format-section,\n.ag-theme-material-dark .ag-chart-advanced-settings-section,\n.ag-theme-material-auto-dark .ag-chart-data-section,\n.ag-theme-material-auto-dark .ag-chart-format-section,\n.ag-theme-material-auto-dark .ag-chart-advanced-settings-section {\n  padding-bottom: calc(var(--ag-grid-size) * 0.5);\n}\n.ag-theme-material input[class^=ag-]:not([type]),\n.ag-theme-material input[class^=ag-][type=text],\n.ag-theme-material input[class^=ag-][type=number],\n.ag-theme-material input[class^=ag-][type=tel],\n.ag-theme-material input[class^=ag-][type=date],\n.ag-theme-material input[class^=ag-][type=datetime-local],\n.ag-theme-material textarea[class^=ag-],\n.ag-theme-material-dark input[class^=ag-]:not([type]),\n.ag-theme-material-dark input[class^=ag-][type=text],\n.ag-theme-material-dark input[class^=ag-][type=number],\n.ag-theme-material-dark input[class^=ag-][type=tel],\n.ag-theme-material-dark input[class^=ag-][type=date],\n.ag-theme-material-dark input[class^=ag-][type=datetime-local],\n.ag-theme-material-dark textarea[class^=ag-],\n.ag-theme-material-auto-dark input[class^=ag-]:not([type]),\n.ag-theme-material-auto-dark input[class^=ag-][type=text],\n.ag-theme-material-auto-dark input[class^=ag-][type=number],\n.ag-theme-material-auto-dark input[class^=ag-][type=tel],\n.ag-theme-material-auto-dark input[class^=ag-][type=date],\n.ag-theme-material-auto-dark input[class^=ag-][type=datetime-local],\n.ag-theme-material-auto-dark textarea[class^=ag-] {\n  background: transparent;\n  color: var(--ag-foreground-color);\n  font-family: inherit;\n  font-size: inherit;\n  padding-bottom: var(--ag-grid-size);\n  border-width: 0;\n  border-radius: 0;\n  border-bottom: 2px solid;\n  border-bottom-color: var(--ag-border-color);\n}\n.ag-theme-material input[class^=ag-]:not([type]):not(textarea),\n.ag-theme-material input[class^=ag-][type=text]:not(textarea),\n.ag-theme-material input[class^=ag-][type=number]:not(textarea),\n.ag-theme-material input[class^=ag-][type=tel]:not(textarea),\n.ag-theme-material input[class^=ag-][type=date]:not(textarea),\n.ag-theme-material input[class^=ag-][type=datetime-local]:not(textarea),\n.ag-theme-material textarea[class^=ag-]:not(textarea),\n.ag-theme-material-dark input[class^=ag-]:not([type]):not(textarea),\n.ag-theme-material-dark input[class^=ag-][type=text]:not(textarea),\n.ag-theme-material-dark input[class^=ag-][type=number]:not(textarea),\n.ag-theme-material-dark input[class^=ag-][type=tel]:not(textarea),\n.ag-theme-material-dark input[class^=ag-][type=date]:not(textarea),\n.ag-theme-material-dark input[class^=ag-][type=datetime-local]:not(textarea),\n.ag-theme-material-dark textarea[class^=ag-]:not(textarea),\n.ag-theme-material-auto-dark input[class^=ag-]:not([type]):not(textarea),\n.ag-theme-material-auto-dark input[class^=ag-][type=text]:not(textarea),\n.ag-theme-material-auto-dark input[class^=ag-][type=number]:not(textarea),\n.ag-theme-material-auto-dark input[class^=ag-][type=tel]:not(textarea),\n.ag-theme-material-auto-dark input[class^=ag-][type=date]:not(textarea),\n.ag-theme-material-auto-dark input[class^=ag-][type=datetime-local]:not(textarea),\n.ag-theme-material-auto-dark textarea[class^=ag-]:not(textarea) {\n  height: calc(var(--ag-grid-size) * 5);\n}\n.ag-theme-material input[class^=ag-]:not([type]):focus,\n.ag-theme-material input[class^=ag-][type=text]:focus,\n.ag-theme-material input[class^=ag-][type=number]:focus,\n.ag-theme-material input[class^=ag-][type=tel]:focus,\n.ag-theme-material input[class^=ag-][type=date]:focus,\n.ag-theme-material input[class^=ag-][type=datetime-local]:focus,\n.ag-theme-material textarea[class^=ag-]:focus,\n.ag-theme-material-dark input[class^=ag-]:not([type]):focus,\n.ag-theme-material-dark input[class^=ag-][type=text]:focus,\n.ag-theme-material-dark input[class^=ag-][type=number]:focus,\n.ag-theme-material-dark input[class^=ag-][type=tel]:focus,\n.ag-theme-material-dark input[class^=ag-][type=date]:focus,\n.ag-theme-material-dark input[class^=ag-][type=datetime-local]:focus,\n.ag-theme-material-dark textarea[class^=ag-]:focus,\n.ag-theme-material-auto-dark input[class^=ag-]:not([type]):focus,\n.ag-theme-material-auto-dark input[class^=ag-][type=text]:focus,\n.ag-theme-material-auto-dark input[class^=ag-][type=number]:focus,\n.ag-theme-material-auto-dark input[class^=ag-][type=tel]:focus,\n.ag-theme-material-auto-dark input[class^=ag-][type=date]:focus,\n.ag-theme-material-auto-dark input[class^=ag-][type=datetime-local]:focus,\n.ag-theme-material-auto-dark textarea[class^=ag-]:focus {\n  border-bottom: 2px solid;\n  border-bottom-color: var(--ag-material-primary-color);\n  outline: none;\n  box-shadow: none;\n}\n.ag-theme-material input[class^=ag-]:not([type])::placeholder,\n.ag-theme-material input[class^=ag-][type=text]::placeholder,\n.ag-theme-material input[class^=ag-][type=number]::placeholder,\n.ag-theme-material input[class^=ag-][type=tel]::placeholder,\n.ag-theme-material input[class^=ag-][type=date]::placeholder,\n.ag-theme-material input[class^=ag-][type=datetime-local]::placeholder,\n.ag-theme-material textarea[class^=ag-]::placeholder,\n.ag-theme-material-dark input[class^=ag-]:not([type])::placeholder,\n.ag-theme-material-dark input[class^=ag-][type=text]::placeholder,\n.ag-theme-material-dark input[class^=ag-][type=number]::placeholder,\n.ag-theme-material-dark input[class^=ag-][type=tel]::placeholder,\n.ag-theme-material-dark input[class^=ag-][type=date]::placeholder,\n.ag-theme-material-dark input[class^=ag-][type=datetime-local]::placeholder,\n.ag-theme-material-dark textarea[class^=ag-]::placeholder,\n.ag-theme-material-auto-dark input[class^=ag-]:not([type])::placeholder,\n.ag-theme-material-auto-dark input[class^=ag-][type=text]::placeholder,\n.ag-theme-material-auto-dark input[class^=ag-][type=number]::placeholder,\n.ag-theme-material-auto-dark input[class^=ag-][type=tel]::placeholder,\n.ag-theme-material-auto-dark input[class^=ag-][type=date]::placeholder,\n.ag-theme-material-auto-dark input[class^=ag-][type=datetime-local]::placeholder,\n.ag-theme-material-auto-dark textarea[class^=ag-]::placeholder {\n  color: var(--ag-disabled-foreground-color);\n}\n.ag-theme-material input[class^=ag-]:not([type]):disabled,\n.ag-theme-material input[class^=ag-][type=text]:disabled,\n.ag-theme-material input[class^=ag-][type=number]:disabled,\n.ag-theme-material input[class^=ag-][type=tel]:disabled,\n.ag-theme-material input[class^=ag-][type=date]:disabled,\n.ag-theme-material input[class^=ag-][type=datetime-local]:disabled,\n.ag-theme-material textarea[class^=ag-]:disabled,\n.ag-theme-material-dark input[class^=ag-]:not([type]):disabled,\n.ag-theme-material-dark input[class^=ag-][type=text]:disabled,\n.ag-theme-material-dark input[class^=ag-][type=number]:disabled,\n.ag-theme-material-dark input[class^=ag-][type=tel]:disabled,\n.ag-theme-material-dark input[class^=ag-][type=date]:disabled,\n.ag-theme-material-dark input[class^=ag-][type=datetime-local]:disabled,\n.ag-theme-material-dark textarea[class^=ag-]:disabled,\n.ag-theme-material-auto-dark input[class^=ag-]:not([type]):disabled,\n.ag-theme-material-auto-dark input[class^=ag-][type=text]:disabled,\n.ag-theme-material-auto-dark input[class^=ag-][type=number]:disabled,\n.ag-theme-material-auto-dark input[class^=ag-][type=tel]:disabled,\n.ag-theme-material-auto-dark input[class^=ag-][type=date]:disabled,\n.ag-theme-material-auto-dark input[class^=ag-][type=datetime-local]:disabled,\n.ag-theme-material-auto-dark textarea[class^=ag-]:disabled {\n  border-bottom: 1px solid;\n  border-bottom-color: var(--ag-border-color);\n}\n.ag-theme-material input[class^=ag-]:not([type]):invalid,\n.ag-theme-material input[class^=ag-][type=text]:invalid,\n.ag-theme-material input[class^=ag-][type=number]:invalid,\n.ag-theme-material input[class^=ag-][type=tel]:invalid,\n.ag-theme-material input[class^=ag-][type=date]:invalid,\n.ag-theme-material input[class^=ag-][type=datetime-local]:invalid,\n.ag-theme-material textarea[class^=ag-]:invalid,\n.ag-theme-material-dark input[class^=ag-]:not([type]):invalid,\n.ag-theme-material-dark input[class^=ag-][type=text]:invalid,\n.ag-theme-material-dark input[class^=ag-][type=number]:invalid,\n.ag-theme-material-dark input[class^=ag-][type=tel]:invalid,\n.ag-theme-material-dark input[class^=ag-][type=date]:invalid,\n.ag-theme-material-dark input[class^=ag-][type=datetime-local]:invalid,\n.ag-theme-material-dark textarea[class^=ag-]:invalid,\n.ag-theme-material-auto-dark input[class^=ag-]:not([type]):invalid,\n.ag-theme-material-auto-dark input[class^=ag-][type=text]:invalid,\n.ag-theme-material-auto-dark input[class^=ag-][type=number]:invalid,\n.ag-theme-material-auto-dark input[class^=ag-][type=tel]:invalid,\n.ag-theme-material-auto-dark input[class^=ag-][type=date]:invalid,\n.ag-theme-material-auto-dark input[class^=ag-][type=datetime-local]:invalid,\n.ag-theme-material-auto-dark textarea[class^=ag-]:invalid {\n  border-width: 0;\n  border-bottom: 1px solid;\n  border-bottom-color: var(--ag-invalid-color);\n  color: var(--ag-invalid-color);\n}\n.ag-theme-material .ag-standard-button,\n.ag-theme-material-dark .ag-standard-button,\n.ag-theme-material-auto-dark .ag-standard-button {\n  appearance: none;\n  background-color: transparent;\n  border: 0;\n  color: var(--ag-material-primary-color);\n  font-family: inherit;\n  font-size: inherit;\n  margin: 0;\n  padding: 0;\n  text-transform: uppercase;\n}\n.ag-theme-material .ag-standard-button:disabled,\n.ag-theme-material-dark .ag-standard-button:disabled,\n.ag-theme-material-auto-dark .ag-standard-button:disabled {\n  color: var(--ag-disabled-foreground-color);\n  background-color: var(--ag-input-disabled-background-color);\n  border-color: var(--ag-input-disabled-border-color);\n}\n.ag-theme-material.ag-dnd-ghost,\n.ag-theme-material-dark.ag-dnd-ghost,\n.ag-theme-material-auto-dark.ag-dnd-ghost {\n  font-size: calc(var(--ag-font-size) - 1px);\n  font-weight: 600;\n}\n.ag-theme-material .ag-filter-toolpanel-header,\n.ag-theme-material-dark .ag-filter-toolpanel-header,\n.ag-theme-material-auto-dark .ag-filter-toolpanel-header {\n  height: calc(var(--ag-grid-size) * 4);\n}\n.ag-theme-material .ag-filter-toolpanel-group-level-0-header,\n.ag-theme-material-dark .ag-filter-toolpanel-group-level-0-header,\n.ag-theme-material-auto-dark .ag-filter-toolpanel-group-level-0-header {\n  height: calc(var(--ag-grid-size) * 7);\n}\n.ag-theme-material .ag-filter-card-title,\n.ag-theme-material-dark .ag-filter-card-title,\n.ag-theme-material-auto-dark .ag-filter-card-title {\n  font-size: calc(var(--ag-font-size) - 1px);\n  font-weight: 600;\n}\n.ag-theme-material .ag-filter-panel .ag-standard-button,\n.ag-theme-material-dark .ag-filter-panel .ag-standard-button,\n.ag-theme-material-auto-dark .ag-filter-panel .ag-standard-button {\n  padding: var(--ag-grid-size);\n}\n.ag-theme-material .ag-filter-add-button,\n.ag-theme-material-dark .ag-filter-add-button,\n.ag-theme-material-auto-dark .ag-filter-add-button {\n  border-bottom: 2px solid var(--ag-material-primary-color);\n}\n.ag-theme-material .ag-filter-add-button .ag-icon,\n.ag-theme-material-dark .ag-filter-add-button .ag-icon,\n.ag-theme-material-auto-dark .ag-filter-add-button .ag-icon {\n  color: var(--ag-material-active-color);\n}\n.ag-theme-material .ag-ltr .ag-filter-apply-panel-button, .ag-theme-material .ag-ltr .ag-advanced-filter-apply-button, .ag-theme-material .ag-ltr .ag-advanced-filter-builder-button, .ag-theme-material-dark .ag-ltr .ag-filter-apply-panel-button, .ag-theme-material-dark .ag-ltr .ag-advanced-filter-apply-button, .ag-theme-material-dark .ag-ltr .ag-advanced-filter-builder-button, .ag-theme-material-auto-dark .ag-ltr .ag-filter-apply-panel-button, .ag-theme-material-auto-dark .ag-ltr .ag-advanced-filter-apply-button, .ag-theme-material-auto-dark .ag-ltr .ag-advanced-filter-builder-button {\n  margin-left: var(--ag-grid-size);\n}\n\n.ag-theme-material .ag-rtl .ag-filter-apply-panel-button, .ag-theme-material .ag-rtl .ag-advanced-filter-apply-button, .ag-theme-material .ag-rtl .ag-advanced-filter-builder-button, .ag-theme-material-dark .ag-rtl .ag-filter-apply-panel-button, .ag-theme-material-dark .ag-rtl .ag-advanced-filter-apply-button, .ag-theme-material-dark .ag-rtl .ag-advanced-filter-builder-button, .ag-theme-material-auto-dark .ag-rtl .ag-filter-apply-panel-button, .ag-theme-material-auto-dark .ag-rtl .ag-advanced-filter-apply-button, .ag-theme-material-auto-dark .ag-rtl .ag-advanced-filter-builder-button {\n  margin-right: var(--ag-grid-size);\n}\n\n.ag-theme-material .ag-layout-auto-height .ag-center-cols-viewport,\n.ag-theme-material .ag-layout-auto-height .ag-center-cols-container,\n.ag-theme-material .ag-layout-print .ag-center-cols-viewport,\n.ag-theme-material .ag-layout-print .ag-center-cols-container,\n.ag-theme-material-dark .ag-layout-auto-height .ag-center-cols-viewport,\n.ag-theme-material-dark .ag-layout-auto-height .ag-center-cols-container,\n.ag-theme-material-dark .ag-layout-print .ag-center-cols-viewport,\n.ag-theme-material-dark .ag-layout-print .ag-center-cols-container,\n.ag-theme-material-auto-dark .ag-layout-auto-height .ag-center-cols-viewport,\n.ag-theme-material-auto-dark .ag-layout-auto-height .ag-center-cols-container,\n.ag-theme-material-auto-dark .ag-layout-print .ag-center-cols-viewport,\n.ag-theme-material-auto-dark .ag-layout-print .ag-center-cols-container {\n  min-height: 150px;\n}\n.ag-theme-material .ag-picker-field-wrapper:focus-within,\n.ag-theme-material-dark .ag-picker-field-wrapper:focus-within,\n.ag-theme-material-auto-dark .ag-picker-field-wrapper:focus-within {\n  box-shadow: 0 0 0 1px var(--ag-material-primary-color);\n}\n.ag-theme-material .ag-rich-select-list,\n.ag-theme-material-dark .ag-rich-select-list,\n.ag-theme-material-auto-dark .ag-rich-select-list {\n  box-shadow: rgba(0, 0, 0, 0.2) 0px 5px 5px -3px, rgba(0, 0, 0, 0.14) 0px 8px 10px 1px, rgba(0, 0, 0, 0.12) 0px 3px 14px 2px;\n}\n.ag-theme-material .ag-advanced-filter-builder-button-label,\n.ag-theme-material-dark .ag-advanced-filter-builder-button-label,\n.ag-theme-material-auto-dark .ag-advanced-filter-builder-button-label {\n  text-transform: uppercase;\n}\n.ag-theme-material .ag-filter-active .ag-icon-filter,\n.ag-theme-material-dark .ag-filter-active .ag-icon-filter,\n.ag-theme-material-auto-dark .ag-filter-active .ag-icon-filter {\n  color: var(--ag-material-accent-color);\n}\n.ag-theme-material .ag-list-item-hovered::after,\n.ag-theme-material-dark .ag-list-item-hovered::after,\n.ag-theme-material-auto-dark .ag-list-item-hovered::after {\n  background-color: var(--ag-material-primary-color);\n}\n.ag-theme-material .ag-pill .ag-pill-button:hover,\n.ag-theme-material-dark .ag-pill .ag-pill-button:hover,\n.ag-theme-material-auto-dark .ag-pill .ag-pill-button:hover {\n  color: var(--ag-material-primary-color);\n}\n.ag-theme-material .ag-header-highlight-before::after,\n.ag-theme-material .ag-header-highlight-after::after,\n.ag-theme-material-dark .ag-header-highlight-before::after,\n.ag-theme-material-dark .ag-header-highlight-after::after,\n.ag-theme-material-auto-dark .ag-header-highlight-before::after,\n.ag-theme-material-auto-dark .ag-header-highlight-after::after {\n  background-color: var(--ag-material-primary-color);\n}\n.ag-theme-material .ag-advanced-filter-builder-item-button-disabled .ag-icon,\n.ag-theme-material .ag-disabled .ag-icon,\n.ag-theme-material .ag-column-select-column-group-readonly .ag-icon,\n.ag-theme-material [disabled] .ag-icon,\n.ag-theme-material-dark .ag-advanced-filter-builder-item-button-disabled .ag-icon,\n.ag-theme-material-dark .ag-disabled .ag-icon,\n.ag-theme-material-dark .ag-column-select-column-group-readonly .ag-icon,\n.ag-theme-material-dark [disabled] .ag-icon,\n.ag-theme-material-auto-dark .ag-advanced-filter-builder-item-button-disabled .ag-icon,\n.ag-theme-material-auto-dark .ag-disabled .ag-icon,\n.ag-theme-material-auto-dark .ag-column-select-column-group-readonly .ag-icon,\n.ag-theme-material-auto-dark [disabled] .ag-icon {\n  color: var(--ag-disabled-foreground-color);\n}\n", ""]);
// Exports
/* harmony default export */ __webpack_exports__.A = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 30145:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(36758);
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40935);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20062);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(47249), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".ag-theme-quartz,\n.ag-theme-quartz-dark,\n.ag-theme-quartz-auto-dark {\n  --ag-active-color: #2196f3;\n  --ag-background-color: #fff;\n  --ag-foreground-color: #181d1f;\n  --ag-border-color: color-mix(in srgb, transparent, var(--ag-foreground-color) 15%);\n  --ag-secondary-border-color: var(--ag-border-color);\n  --ag-header-background-color: color-mix(in srgb, var(--ag-background-color), var(--ag-foreground-color) 2%);\n  --ag-tooltip-background-color: var(--ag-header-background-color);\n  --ag-control-panel-background-color: var(--ag-header-background-color);\n  --ag-subheader-background-color: transparent;\n  --ag-invalid-color: #e02525;\n  --ag-checkbox-unchecked-color: color-mix(in srgb, var(--ag-background-color), var(--ag-foreground-color) 30%);\n  --ag-advanced-filter-join-pill-color: #f08e8d;\n  --ag-advanced-filter-column-pill-color: #a6e194;\n  --ag-advanced-filter-option-pill-color: #f3c08b;\n  --ag-advanced-filter-value-pill-color: #85c0e4;\n  --ag-header-column-resize-handle-color: var(--ag-secondary-border-color);\n  --ag-icon-font-color: color-mix(in srgb, transparent, var(--ag-foreground-color) 90%);\n  --ag-find-match-color: var(--ag-foreground-color);\n  --ag-find-match-background-color: #ffff00;\n  --ag-find-active-match-color: var(--ag-foreground-color);\n  --ag-find-active-match-background-color: #ffa500;\n  --ag-panel-background-color: color-mix(in srgb, var(--ag-background-color), var(--ag-foreground-color) 3%);\n  --ag-panel-border-color: color-mix(in srgb, transparent, var(--ag-foreground-color) 20%);\n  --ag-menu-background-color: color-mix(in srgb, var(--ag-background-color), var(--ag-foreground-color) 3%);\n  --ag-menu-border-color: color-mix(in srgb, transparent, var(--ag-foreground-color) 20%);\n  --ag-selected-row-background-color: color-mix(in srgb, transparent, var(--ag-active-color) 8%);\n  --ag-row-hover-color: color-mix(in srgb, transparent, var(--ag-active-color) 12%);\n  --ag-column-hover-color: color-mix(in srgb, transparent, var(--ag-foreground-color) 5%);\n  --ag-input-focus-border-color: var(--ag-active-color);\n  --ag-range-selection-background-color: color-mix(in srgb, transparent, var(--ag-active-color) 20%);\n  --ag-input-focus-box-shadow: 0 0 0 3px color-mix(in srgb, transparent, var(--ag-input-focus-border-color) 47%);\n  --ag-input-error-focus-box-shadow: 0 0 0 3px\n      color-mix(in srgb, var(--ag-background-color), var(--ag-invalid-color) 50%);\n  --ag-range-selection-background-color-2: color-mix(in srgb, transparent, var(--ag-active-color) 36%);\n  --ag-range-selection-background-color-3: color-mix(in srgb, transparent, var(--ag-active-color) 49%);\n  --ag-range-selection-background-color-4: color-mix(in srgb, transparent, var(--ag-active-color) 59%);\n  --ag-row-numbers-selected-color: color-mix(in srgb, transparent, var(--ag-active-color) 50%);\n  --ag-checkbox-background-color: var(--ag-background-color);\n  --ag-checkbox-checked-color: var(--ag-active-color);\n  --ag-range-selection-border-color: var(--ag-active-color);\n  --ag-secondary-foreground-color: var(--ag-foreground-color);\n  --ag-input-border-color: var(--ag-border-color);\n  --ag-input-border-color-invalid: var(--ag-invalid-color);\n  --ag-disabled-foreground-color: color-mix(in srgb, transparent, var(--ag-foreground-color) 50%);\n  --ag-chip-background-color: color-mix(in srgb, transparent, var(--ag-foreground-color) 7%);\n  --ag-chip-border-color: color-mix(in srgb, var(--ag-header-background-color), var(--ag-foreground-color) 13%);\n  --ag-input-disabled-border-color: var(--ag-border-color);\n  --ag-input-disabled-background-color: color-mix(in srgb, var(--ag-background-color), var(--ag-foreground-color) 6%);\n  --ag-modal-overlay-background-color: color-mix(in srgb, transparent, var(--ag-background-color) 66%);\n  --ag-chart-menu-label-color: color-mix(in srgb, transparent, var(--ag-foreground-color) 80%);\n  --ag-chart-menu-pill-select-button-color: color-mix(in srgb, transparent, var(--ag-foreground-color) 70%);\n  --ag-filter-panel-card-subtle-color: color-mix(in srgb, transparent, var(--ag-foreground-color) 70%);\n  --ag-borders: solid 1px;\n  --ag-border-radius: 4px;\n  --ag-wrapper-border-radius: 8px;\n  --ag-borders-side-button: none;\n  --ag-side-button-selected-background-color: transparent;\n  --ag-header-column-resize-handle-display: block;\n  --ag-header-column-resize-handle-width: 2px;\n  --ag-header-column-resize-handle-height: 30%;\n  --ag-grid-size: 8px;\n  --ag-icon-size: 16px;\n  --ag-header-height: calc(var(--ag-font-size) + var(--ag-grid-size) * 4.25);\n  --ag-row-height: calc(var(--ag-font-size) + var(--ag-grid-size) * 3.5);\n  --ag-list-item-height: calc(\n      var(--ag-icon-size) + var(--ag-widget-vertical-spacing)\n  );\n  --ag-column-select-indent-size: var(--ag-icon-size);\n  --ag-set-filter-indent-size: var(--ag-icon-size);\n  --ag-filter-tool-panel-group-indent: var(--ag-grid-size);\n  --ag-advanced-filter-builder-indent-size: calc(var(--ag-icon-size) + var(--ag-grid-size) * 2);\n  --ag-cell-horizontal-padding: calc(var(--ag-grid-size) * 2);\n  --ag-cell-widget-spacing: calc(var(--ag-grid-size) * 1.5);\n  --ag-widget-container-vertical-padding: calc(var(--ag-grid-size) * 1.5);\n  --ag-widget-container-horizontal-padding: calc(var(--ag-grid-size) * 1.5);\n  --ag-widget-horizontal-spacing: calc(var(--ag-grid-size) * 1.5);\n  --ag-widget-vertical-spacing: calc(var(--ag-grid-size) * 1);\n  --ag-toggle-button-height: 18px;\n  --ag-toggle-button-width: 28px;\n  --ag-toggle-button-border-width: 2px;\n  --ag-font-family: \"IBM Plex Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Oxygen-Sans, Ubuntu,\n      Cantarell, \"Helvetica Neue\", sans-serif;\n  --ag-font-size: 14px;\n  --ag-icon-font-family: agGridQuartz;\n  --ag-tab-min-width: 290px;\n  --ag-chart-menu-panel-width: 260px;\n  --ag-card-shadow: 0 1px 4px 1px rgba(186, 191, 199, 0.4);\n  --ag-popup-shadow: 0 0 16px 0 rgba(0, 0, 0, 0.15);\n  --ag-side-bar-panel-width: 250px;\n  --ag-filter-panel-apply-button-color: var(--ag-background-color);\n  --ag-filter-panel-apply-button-background-color: var(--ag-active-color);\n}\n\n.ag-theme-quartz-dark {\n  --ag-background-color: color-mix(in srgb, #fff, #182230 97%);\n  --ag-foreground-color: #fff;\n  --ag-border-color: rgba(255, 255, 255, 0.16);\n  --ag-secondary-border-color: color-mix(in srgb, transparent, var(--ag-foreground-color) 10%);\n  --ag-header-background-color: color-mix(in srgb, #fff, #182230 93%);\n  --ag-tooltip-background-color: color-mix(in srgb, #fff, #182230 96%);\n  --ag-control-panel-background-color: color-mix(in srgb, #fff, #182230 93%);\n  --ag-input-disabled-background-color: #68686e12;\n  --ag-card-shadow: 0 1px 20px 1px black;\n  --ag-input-border-color: var(--ag-border-color);\n  --ag-input-disabled-border-color: rgba(255, 255, 255, 0.07);\n  --ag-checkbox-unchecked-color: color-mix(in srgb, var(--ag-background-color), var(--ag-foreground-color) 40%);\n  --ag-row-hover-color: color-mix(in srgb, transparent, var(--ag-active-color) 20%);\n  --ag-selected-row-background-color: var(--ag-row-hover-color);\n  --ag-panel-background-color: color-mix(in srgb, var(--ag-background-color), var(--ag-foreground-color) 10%);\n  --ag-panel-border-color: color-mix(in srgb, transparent, var(--ag-foreground-color) 10%);\n  --ag-menu-background-color: color-mix(in srgb, var(--ag-background-color), var(--ag-foreground-color) 10%);\n  --ag-menu-border-color: color-mix(in srgb, transparent, var(--ag-foreground-color) 10%);\n  --ag-advanced-filter-join-pill-color: #7a3a37;\n  --ag-advanced-filter-column-pill-color: #355f2d;\n  --ag-advanced-filter-option-pill-color: #5a3168;\n  --ag-advanced-filter-value-pill-color: #374c86;\n  --ag-find-match-color: var(--ag-background-color);\n  --ag-find-active-match-color: var(--ag-background-color);\n  --ag-filter-panel-apply-button-color: var(--ag-foreground-color);\n  --ag-popup-shadow: 0 0px 20px rgba(0, 0, 0, 0.3);\n  --ag-row-loading-skeleton-effect-color: rgba(202, 203, 204, 0.4);\n  --ag-cell-batch-edit-text-color: #f3d0b3;\n  color-scheme: dark;\n}\n\n@media (prefers-color-scheme: dark) {\n  .ag-theme-quartz-auto-dark {\n    --ag-background-color: color-mix(in srgb, #fff, #182230 97%);\n    --ag-foreground-color: #fff;\n    --ag-border-color: rgba(255, 255, 255, 0.16);\n    --ag-secondary-border-color: color-mix(in srgb, transparent, var(--ag-foreground-color) 10%);\n    --ag-header-background-color: color-mix(in srgb, #fff, #182230 93%);\n    --ag-tooltip-background-color: color-mix(in srgb, #fff, #182230 96%);\n    --ag-control-panel-background-color: color-mix(in srgb, #fff, #182230 93%);\n    --ag-input-disabled-background-color: #68686e12;\n    --ag-card-shadow: 0 1px 20px 1px black;\n    --ag-input-border-color: var(--ag-border-color);\n    --ag-input-disabled-border-color: rgba(255, 255, 255, 0.07);\n    --ag-checkbox-unchecked-color: color-mix(in srgb, var(--ag-background-color), var(--ag-foreground-color) 40%);\n    --ag-row-hover-color: color-mix(in srgb, transparent, var(--ag-active-color) 20%);\n    --ag-selected-row-background-color: var(--ag-row-hover-color);\n    --ag-panel-background-color: color-mix(in srgb, var(--ag-background-color), var(--ag-foreground-color) 10%);\n    --ag-panel-border-color: color-mix(in srgb, transparent, var(--ag-foreground-color) 10%);\n    --ag-menu-background-color: color-mix(in srgb, var(--ag-background-color), var(--ag-foreground-color) 10%);\n    --ag-menu-border-color: color-mix(in srgb, transparent, var(--ag-foreground-color) 10%);\n    --ag-advanced-filter-join-pill-color: #7a3a37;\n    --ag-advanced-filter-column-pill-color: #355f2d;\n    --ag-advanced-filter-option-pill-color: #5a3168;\n    --ag-advanced-filter-value-pill-color: #374c86;\n    --ag-find-match-color: var(--ag-background-color);\n    --ag-find-active-match-color: var(--ag-background-color);\n    --ag-filter-panel-apply-button-color: var(--ag-foreground-color);\n    --ag-popup-shadow: 0 0px 20px rgba(0, 0, 0, 0.3);\n    --ag-row-loading-skeleton-effect-color: rgba(202, 203, 204, 0.4);\n    --ag-cell-batch-edit-text-color: #f3d0b3;\n    color-scheme: dark;\n  }\n}\n.ag-theme-quartz .ag-filter-toolpanel-header,\n.ag-theme-quartz .ag-filter-toolpanel-search,\n.ag-theme-quartz .ag-status-bar,\n.ag-theme-quartz .ag-header-row,\n.ag-theme-quartz .ag-row-number-cell,\n.ag-theme-quartz .ag-panel-title-bar-title,\n.ag-theme-quartz .ag-multi-filter-group-title-bar,\n.ag-theme-quartz .ag-filter-card-title,\n.ag-theme-quartz-dark .ag-filter-toolpanel-header,\n.ag-theme-quartz-dark .ag-filter-toolpanel-search,\n.ag-theme-quartz-dark .ag-status-bar,\n.ag-theme-quartz-dark .ag-header-row,\n.ag-theme-quartz-dark .ag-row-number-cell,\n.ag-theme-quartz-dark .ag-panel-title-bar-title,\n.ag-theme-quartz-dark .ag-multi-filter-group-title-bar,\n.ag-theme-quartz-dark .ag-filter-card-title,\n.ag-theme-quartz-auto-dark .ag-filter-toolpanel-header,\n.ag-theme-quartz-auto-dark .ag-filter-toolpanel-search,\n.ag-theme-quartz-auto-dark .ag-status-bar,\n.ag-theme-quartz-auto-dark .ag-header-row,\n.ag-theme-quartz-auto-dark .ag-row-number-cell,\n.ag-theme-quartz-auto-dark .ag-panel-title-bar-title,\n.ag-theme-quartz-auto-dark .ag-multi-filter-group-title-bar,\n.ag-theme-quartz-auto-dark .ag-filter-card-title {\n  font-weight: 500;\n  color: var(--ag-header-foreground-color);\n}\n.ag-theme-quartz input[class^=ag-]:not([type]),\n.ag-theme-quartz input[class^=ag-][type=text],\n.ag-theme-quartz input[class^=ag-][type=number],\n.ag-theme-quartz input[class^=ag-][type=tel],\n.ag-theme-quartz input[class^=ag-][type=date],\n.ag-theme-quartz input[class^=ag-][type=datetime-local],\n.ag-theme-quartz textarea[class^=ag-],\n.ag-theme-quartz-dark input[class^=ag-]:not([type]),\n.ag-theme-quartz-dark input[class^=ag-][type=text],\n.ag-theme-quartz-dark input[class^=ag-][type=number],\n.ag-theme-quartz-dark input[class^=ag-][type=tel],\n.ag-theme-quartz-dark input[class^=ag-][type=date],\n.ag-theme-quartz-dark input[class^=ag-][type=datetime-local],\n.ag-theme-quartz-dark textarea[class^=ag-],\n.ag-theme-quartz-auto-dark input[class^=ag-]:not([type]),\n.ag-theme-quartz-auto-dark input[class^=ag-][type=text],\n.ag-theme-quartz-auto-dark input[class^=ag-][type=number],\n.ag-theme-quartz-auto-dark input[class^=ag-][type=tel],\n.ag-theme-quartz-auto-dark input[class^=ag-][type=date],\n.ag-theme-quartz-auto-dark input[class^=ag-][type=datetime-local],\n.ag-theme-quartz-auto-dark textarea[class^=ag-] {\n  min-height: calc(var(--ag-grid-size) * 4);\n  border-radius: var(--ag-border-radius);\n}\n.ag-theme-quartz .ag-ltr input[class^=ag-]:not([type]), .ag-theme-quartz .ag-ltr input[class^=ag-][type=text], .ag-theme-quartz .ag-ltr input[class^=ag-][type=number], .ag-theme-quartz .ag-ltr input[class^=ag-][type=tel], .ag-theme-quartz .ag-ltr input[class^=ag-][type=date], .ag-theme-quartz .ag-ltr input[class^=ag-][type=datetime-local], .ag-theme-quartz .ag-ltr textarea[class^=ag-], .ag-theme-quartz-dark .ag-ltr input[class^=ag-]:not([type]), .ag-theme-quartz-dark .ag-ltr input[class^=ag-][type=text], .ag-theme-quartz-dark .ag-ltr input[class^=ag-][type=number], .ag-theme-quartz-dark .ag-ltr input[class^=ag-][type=tel], .ag-theme-quartz-dark .ag-ltr input[class^=ag-][type=date], .ag-theme-quartz-dark .ag-ltr input[class^=ag-][type=datetime-local], .ag-theme-quartz-dark .ag-ltr textarea[class^=ag-], .ag-theme-quartz-auto-dark .ag-ltr input[class^=ag-]:not([type]), .ag-theme-quartz-auto-dark .ag-ltr input[class^=ag-][type=text], .ag-theme-quartz-auto-dark .ag-ltr input[class^=ag-][type=number], .ag-theme-quartz-auto-dark .ag-ltr input[class^=ag-][type=tel], .ag-theme-quartz-auto-dark .ag-ltr input[class^=ag-][type=date], .ag-theme-quartz-auto-dark .ag-ltr input[class^=ag-][type=datetime-local], .ag-theme-quartz-auto-dark .ag-ltr textarea[class^=ag-] {\n  padding-left: var(--ag-grid-size);\n}\n\n.ag-theme-quartz .ag-rtl input[class^=ag-]:not([type]), .ag-theme-quartz .ag-rtl input[class^=ag-][type=text], .ag-theme-quartz .ag-rtl input[class^=ag-][type=number], .ag-theme-quartz .ag-rtl input[class^=ag-][type=tel], .ag-theme-quartz .ag-rtl input[class^=ag-][type=date], .ag-theme-quartz .ag-rtl input[class^=ag-][type=datetime-local], .ag-theme-quartz .ag-rtl textarea[class^=ag-], .ag-theme-quartz-dark .ag-rtl input[class^=ag-]:not([type]), .ag-theme-quartz-dark .ag-rtl input[class^=ag-][type=text], .ag-theme-quartz-dark .ag-rtl input[class^=ag-][type=number], .ag-theme-quartz-dark .ag-rtl input[class^=ag-][type=tel], .ag-theme-quartz-dark .ag-rtl input[class^=ag-][type=date], .ag-theme-quartz-dark .ag-rtl input[class^=ag-][type=datetime-local], .ag-theme-quartz-dark .ag-rtl textarea[class^=ag-], .ag-theme-quartz-auto-dark .ag-rtl input[class^=ag-]:not([type]), .ag-theme-quartz-auto-dark .ag-rtl input[class^=ag-][type=text], .ag-theme-quartz-auto-dark .ag-rtl input[class^=ag-][type=number], .ag-theme-quartz-auto-dark .ag-rtl input[class^=ag-][type=tel], .ag-theme-quartz-auto-dark .ag-rtl input[class^=ag-][type=date], .ag-theme-quartz-auto-dark .ag-rtl input[class^=ag-][type=datetime-local], .ag-theme-quartz-auto-dark .ag-rtl textarea[class^=ag-] {\n  padding-right: var(--ag-grid-size);\n}\n\n.ag-theme-quartz .ag-picker-field-wrapper,\n.ag-theme-quartz-dark .ag-picker-field-wrapper,\n.ag-theme-quartz-auto-dark .ag-picker-field-wrapper {\n  min-height: calc(var(--ag-grid-size) * 4);\n}\n.ag-theme-quartz .ag-tab,\n.ag-theme-quartz-dark .ag-tab,\n.ag-theme-quartz-auto-dark .ag-tab {\n  padding: var(--ag-grid-size);\n  border-left: var(--ag-borders) transparent;\n  border-right: var(--ag-borders) transparent;\n  flex: 1 1 auto;\n}\n.ag-theme-quartz .ag-tab-selected,\n.ag-theme-quartz-dark .ag-tab-selected,\n.ag-theme-quartz-auto-dark .ag-tab-selected {\n  background-color: var(--ag-background-color);\n}\n.ag-theme-quartz .ag-ltr .ag-tab-selected:not(:first-of-type), .ag-theme-quartz-dark .ag-ltr .ag-tab-selected:not(:first-of-type), .ag-theme-quartz-auto-dark .ag-ltr .ag-tab-selected:not(:first-of-type) {\n  border-left-color: var(--ag-border-color);\n}\n\n.ag-theme-quartz .ag-rtl .ag-tab-selected:not(:first-of-type), .ag-theme-quartz-dark .ag-rtl .ag-tab-selected:not(:first-of-type), .ag-theme-quartz-auto-dark .ag-rtl .ag-tab-selected:not(:first-of-type) {\n  border-right-color: var(--ag-border-color);\n}\n\n.ag-theme-quartz .ag-ltr .ag-tab-selected:not(:last-of-type), .ag-theme-quartz-dark .ag-ltr .ag-tab-selected:not(:last-of-type), .ag-theme-quartz-auto-dark .ag-ltr .ag-tab-selected:not(:last-of-type) {\n  border-right-color: var(--ag-border-color);\n}\n\n.ag-theme-quartz .ag-rtl .ag-tab-selected:not(:last-of-type), .ag-theme-quartz-dark .ag-rtl .ag-tab-selected:not(:last-of-type), .ag-theme-quartz-auto-dark .ag-rtl .ag-tab-selected:not(:last-of-type) {\n  border-left-color: var(--ag-border-color);\n}\n\n.ag-theme-quartz .ag-tab:not(.ag-tab-selected),\n.ag-theme-quartz-dark .ag-tab:not(.ag-tab-selected),\n.ag-theme-quartz-auto-dark .ag-tab:not(.ag-tab-selected) {\n  opacity: 0.7;\n}\n.ag-theme-quartz .ag-tab:not(.ag-tab-selected):hover,\n.ag-theme-quartz-dark .ag-tab:not(.ag-tab-selected):hover,\n.ag-theme-quartz-auto-dark .ag-tab:not(.ag-tab-selected):hover {\n  opacity: 1;\n}\n.ag-theme-quartz .ag-menu,\n.ag-theme-quartz-dark .ag-menu,\n.ag-theme-quartz-auto-dark .ag-menu {\n  color: color-mix(in srgb, transparent, var(--ag-foreground-color) 95%);\n}\n.ag-theme-quartz .ag-panel-content-wrapper .ag-column-select,\n.ag-theme-quartz-dark .ag-panel-content-wrapper .ag-column-select,\n.ag-theme-quartz-auto-dark .ag-panel-content-wrapper .ag-column-select {\n  background-color: var(--ag-control-panel-background-color);\n  color: color-mix(in srgb, transparent, var(--ag-foreground-color) 95%);\n}\n.ag-theme-quartz .ag-menu-header,\n.ag-theme-quartz-dark .ag-menu-header,\n.ag-theme-quartz-auto-dark .ag-menu-header {\n  background-color: var(--ag-control-panel-background-color);\n}\n.ag-theme-quartz .ag-menu-option,\n.ag-theme-quartz-dark .ag-menu-option,\n.ag-theme-quartz-auto-dark .ag-menu-option {\n  font-weight: 500;\n  cursor: pointer;\n}\n.ag-theme-quartz .ag-ltr .ag-menu-option-popup-pointer .ag-icon, .ag-theme-quartz-dark .ag-ltr .ag-menu-option-popup-pointer .ag-icon, .ag-theme-quartz-auto-dark .ag-ltr .ag-menu-option-popup-pointer .ag-icon {\n  text-align: right;\n}\n\n.ag-theme-quartz .ag-rtl .ag-menu-option-popup-pointer .ag-icon, .ag-theme-quartz-dark .ag-rtl .ag-menu-option-popup-pointer .ag-icon, .ag-theme-quartz-auto-dark .ag-rtl .ag-menu-option-popup-pointer .ag-icon {\n  text-align: left;\n}\n\n.ag-theme-quartz .ag-tabs-header,\n.ag-theme-quartz-dark .ag-tabs-header,\n.ag-theme-quartz-auto-dark .ag-tabs-header {\n  border-bottom: var(--ag-borders) var(--ag-border-color);\n  display: flex;\n  background-color: color-mix(in srgb, transparent, var(--ag-foreground-color) 5%);\n}\n.ag-theme-quartz .ag-side-bar,\n.ag-theme-quartz-dark .ag-side-bar,\n.ag-theme-quartz-auto-dark .ag-side-bar {\n  background-color: var(--ag-control-panel-background-color);\n  min-width: calc(var(--ag-icon-size) + var(--ag-grid-size) * 2);\n}\n.ag-theme-quartz .ag-side-buttons,\n.ag-theme-quartz-dark .ag-side-buttons,\n.ag-theme-quartz-auto-dark .ag-side-buttons {\n  padding: 0;\n  align-self: stretch;\n  width: calc(var(--ag-icon-size) + var(--ag-grid-size) * 2);\n  background: var(--ag-control-panel-background-color);\n}\n.ag-theme-quartz .ag-side-button,\n.ag-theme-quartz-dark .ag-side-button,\n.ag-theme-quartz-auto-dark .ag-side-button {\n  border-top: var(--ag-borders) transparent;\n  border-bottom: var(--ag-borders) transparent;\n}\n@media (max-resolution: 1.5x) {\n  .ag-theme-quartz .ag-side-button-label,\n  .ag-theme-quartz-dark .ag-side-button-label,\n  .ag-theme-quartz-auto-dark .ag-side-button-label {\n    font-family: \"Segoe UI\", var(--ag-font-family);\n    transform: rotate(0.05deg);\n  }\n}\n.ag-theme-quartz .ag-side-button.ag-selected,\n.ag-theme-quartz-dark .ag-side-button.ag-selected,\n.ag-theme-quartz-auto-dark .ag-side-button.ag-selected {\n  border-bottom-color: var(--ag-border-color);\n  background-color: var(--ag-background-color);\n}\n.ag-theme-quartz .ag-side-button.ag-selected:not(:first-of-type),\n.ag-theme-quartz-dark .ag-side-button.ag-selected:not(:first-of-type),\n.ag-theme-quartz-auto-dark .ag-side-button.ag-selected:not(:first-of-type) {\n  border-top-color: var(--ag-border-color);\n}\n.ag-theme-quartz .ag-column-panel-column-select,\n.ag-theme-quartz-dark .ag-column-panel-column-select,\n.ag-theme-quartz-auto-dark .ag-column-panel-column-select {\n  border-top: none;\n  border-bottom: 1px solid var(--ag-secondary-border-color);\n}\n.ag-theme-quartz .ag-filter-toolpanel-search,\n.ag-theme-quartz-dark .ag-filter-toolpanel-search,\n.ag-theme-quartz-auto-dark .ag-filter-toolpanel-search {\n  height: initial;\n  margin-top: var(--ag-widget-container-vertical-padding);\n}\n.ag-theme-quartz .ag-filter-toolpanel-search-input,\n.ag-theme-quartz-dark .ag-filter-toolpanel-search-input,\n.ag-theme-quartz-auto-dark .ag-filter-toolpanel-search-input {\n  margin: 0;\n}\n.ag-theme-quartz .ag-filter-apply-panel,\n.ag-theme-quartz-dark .ag-filter-apply-panel,\n.ag-theme-quartz-auto-dark .ag-filter-apply-panel {\n  border: none;\n  padding-top: var(--ag-widget-vertical-spacing);\n}\n.ag-theme-quartz .ag-chart-tabbed-menu-body,\n.ag-theme-quartz-dark .ag-chart-tabbed-menu-body,\n.ag-theme-quartz-auto-dark .ag-chart-tabbed-menu-body {\n  position: relative;\n}\n.ag-theme-quartz .ag-chart-tabbed-menu-body::after,\n.ag-theme-quartz-dark .ag-chart-tabbed-menu-body::after,\n.ag-theme-quartz-auto-dark .ag-chart-tabbed-menu-body::after {\n  content: \"\";\n  position: absolute;\n  display: block;\n  top: 0;\n  left: 0;\n  right: 0;\n  height: 16px;\n  background: linear-gradient(var(--ag-control-panel-background-color), transparent);\n}\n.ag-theme-quartz .ag-charts-settings-group-title-bar,\n.ag-theme-quartz .ag-charts-data-group-title-bar,\n.ag-theme-quartz .ag-charts-format-top-level-group-title-bar,\n.ag-theme-quartz .ag-charts-advanced-settings-top-level-group-title-bar,\n.ag-theme-quartz .ag-charts-settings-group-container,\n.ag-theme-quartz-dark .ag-charts-settings-group-title-bar,\n.ag-theme-quartz-dark .ag-charts-data-group-title-bar,\n.ag-theme-quartz-dark .ag-charts-format-top-level-group-title-bar,\n.ag-theme-quartz-dark .ag-charts-advanced-settings-top-level-group-title-bar,\n.ag-theme-quartz-dark .ag-charts-settings-group-container,\n.ag-theme-quartz-auto-dark .ag-charts-settings-group-title-bar,\n.ag-theme-quartz-auto-dark .ag-charts-data-group-title-bar,\n.ag-theme-quartz-auto-dark .ag-charts-format-top-level-group-title-bar,\n.ag-theme-quartz-auto-dark .ag-charts-advanced-settings-top-level-group-title-bar,\n.ag-theme-quartz-auto-dark .ag-charts-settings-group-container {\n  border-top: none;\n  font-weight: 500;\n}\n.ag-theme-quartz .ag-chart-mini-thumbnail,\n.ag-theme-quartz-dark .ag-chart-mini-thumbnail,\n.ag-theme-quartz-auto-dark .ag-chart-mini-thumbnail {\n  background-color: var(--ag-background-color);\n  margin-top: 0;\n  margin-bottom: 0;\n}\n.ag-theme-quartz .ag-chart-settings-nav-bar,\n.ag-theme-quartz-dark .ag-chart-settings-nav-bar,\n.ag-theme-quartz-auto-dark .ag-chart-settings-nav-bar {\n  border-top: var(--ag-borders-secondary) var(--ag-secondary-border-color);\n}\n.ag-theme-quartz .ag-charts-format-sub-level-group-title-bar,\n.ag-theme-quartz-dark .ag-charts-format-sub-level-group-title-bar,\n.ag-theme-quartz-auto-dark .ag-charts-format-sub-level-group-title-bar {\n  background: none;\n  font-weight: 500;\n}\n.ag-theme-quartz .ag-chart-data-section .ag-label:not(.ag-group-title-bar),\n.ag-theme-quartz .ag-chart-format-section .ag-label:not(.ag-group-title-bar),\n.ag-theme-quartz-dark .ag-chart-data-section .ag-label:not(.ag-group-title-bar),\n.ag-theme-quartz-dark .ag-chart-format-section .ag-label:not(.ag-group-title-bar),\n.ag-theme-quartz-auto-dark .ag-chart-data-section .ag-label:not(.ag-group-title-bar),\n.ag-theme-quartz-auto-dark .ag-chart-format-section .ag-label:not(.ag-group-title-bar) {\n  color: var(--ag-chart-menu-label-color);\n}\n.ag-theme-quartz .ag-chart-data-section .ag-label-align-top .ag-label,\n.ag-theme-quartz .ag-chart-format-section .ag-label-align-top .ag-label,\n.ag-theme-quartz-dark .ag-chart-data-section .ag-label-align-top .ag-label,\n.ag-theme-quartz-dark .ag-chart-format-section .ag-label-align-top .ag-label,\n.ag-theme-quartz-auto-dark .ag-chart-data-section .ag-label-align-top .ag-label,\n.ag-theme-quartz-auto-dark .ag-chart-format-section .ag-label-align-top .ag-label {\n  margin-top: calc(var(--ag-widget-vertical-spacing) * 0.5);\n  margin-bottom: var(--ag-widget-vertical-spacing);\n}\n.ag-theme-quartz .ag-chart-data-section .ag-slider.ag-label-align-top .ag-label,\n.ag-theme-quartz .ag-chart-format-section .ag-slider.ag-label-align-top .ag-label,\n.ag-theme-quartz-dark .ag-chart-data-section .ag-slider.ag-label-align-top .ag-label,\n.ag-theme-quartz-dark .ag-chart-format-section .ag-slider.ag-label-align-top .ag-label,\n.ag-theme-quartz-auto-dark .ag-chart-data-section .ag-slider.ag-label-align-top .ag-label,\n.ag-theme-quartz-auto-dark .ag-chart-format-section .ag-slider.ag-label-align-top .ag-label {\n  margin-bottom: 0;\n}\n.ag-theme-quartz .ag-chart-data-section label,\n.ag-theme-quartz .ag-chart-format-section label,\n.ag-theme-quartz-dark .ag-chart-data-section label,\n.ag-theme-quartz-dark .ag-chart-format-section label,\n.ag-theme-quartz-auto-dark .ag-chart-data-section label,\n.ag-theme-quartz-auto-dark .ag-chart-format-section label {\n  display: inline-block;\n}\n.ag-theme-quartz .ag-chart-format-wrapper,\n.ag-theme-quartz .ag-chart-data-wrapper,\n.ag-theme-quartz .ag-charts-format-top-level-group,\n.ag-theme-quartz .ag-charts-format-top-level-group-title-bar,\n.ag-theme-quartz .ag-charts-format-top-level-group .ag-charts-format-top-level-group-container,\n.ag-theme-quartz .ag-charts-format-top-level-group-item,\n.ag-theme-quartz .ag-charts-format-sub-level-group,\n.ag-theme-quartz .ag-charts-format-sub-level-group-title-bar,\n.ag-theme-quartz .ag-charts-format-sub-level-group-container,\n.ag-theme-quartz .ag-charts-format-sub-level-group-item:last-child,\n.ag-theme-quartz .ag-charts-format-sub-level-group-container > *,\n.ag-theme-quartz .ag-charts-data-group-title-bar,\n.ag-theme-quartz .ag-charts-data-group-container,\n.ag-theme-quartz .ag-charts-settings-group-title-bar,\n.ag-theme-quartz .ag-charts-settings-group-container,\n.ag-theme-quartz-dark .ag-chart-format-wrapper,\n.ag-theme-quartz-dark .ag-chart-data-wrapper,\n.ag-theme-quartz-dark .ag-charts-format-top-level-group,\n.ag-theme-quartz-dark .ag-charts-format-top-level-group-title-bar,\n.ag-theme-quartz-dark .ag-charts-format-top-level-group .ag-charts-format-top-level-group-container,\n.ag-theme-quartz-dark .ag-charts-format-top-level-group-item,\n.ag-theme-quartz-dark .ag-charts-format-sub-level-group,\n.ag-theme-quartz-dark .ag-charts-format-sub-level-group-title-bar,\n.ag-theme-quartz-dark .ag-charts-format-sub-level-group-container,\n.ag-theme-quartz-dark .ag-charts-format-sub-level-group-item:last-child,\n.ag-theme-quartz-dark .ag-charts-format-sub-level-group-container > *,\n.ag-theme-quartz-dark .ag-charts-data-group-title-bar,\n.ag-theme-quartz-dark .ag-charts-data-group-container,\n.ag-theme-quartz-dark .ag-charts-settings-group-title-bar,\n.ag-theme-quartz-dark .ag-charts-settings-group-container,\n.ag-theme-quartz-auto-dark .ag-chart-format-wrapper,\n.ag-theme-quartz-auto-dark .ag-chart-data-wrapper,\n.ag-theme-quartz-auto-dark .ag-charts-format-top-level-group,\n.ag-theme-quartz-auto-dark .ag-charts-format-top-level-group-title-bar,\n.ag-theme-quartz-auto-dark .ag-charts-format-top-level-group .ag-charts-format-top-level-group-container,\n.ag-theme-quartz-auto-dark .ag-charts-format-top-level-group-item,\n.ag-theme-quartz-auto-dark .ag-charts-format-sub-level-group,\n.ag-theme-quartz-auto-dark .ag-charts-format-sub-level-group-title-bar,\n.ag-theme-quartz-auto-dark .ag-charts-format-sub-level-group-container,\n.ag-theme-quartz-auto-dark .ag-charts-format-sub-level-group-item:last-child,\n.ag-theme-quartz-auto-dark .ag-charts-format-sub-level-group-container > *,\n.ag-theme-quartz-auto-dark .ag-charts-data-group-title-bar,\n.ag-theme-quartz-auto-dark .ag-charts-data-group-container,\n.ag-theme-quartz-auto-dark .ag-charts-settings-group-title-bar,\n.ag-theme-quartz-auto-dark .ag-charts-settings-group-container {\n  padding: 0;\n  margin: 0;\n}\n.ag-theme-quartz .ag-charts-format-top-level-group,\n.ag-theme-quartz .ag-charts-data-group,\n.ag-theme-quartz-dark .ag-charts-format-top-level-group,\n.ag-theme-quartz-dark .ag-charts-data-group,\n.ag-theme-quartz-auto-dark .ag-charts-format-top-level-group,\n.ag-theme-quartz-auto-dark .ag-charts-data-group {\n  border-top: var(--ag-borders-secondary) var(--ag-secondary-border-color);\n}\n.ag-theme-quartz .ag-charts-format-top-level-group-title-bar,\n.ag-theme-quartz .ag-charts-data-group-title-bar,\n.ag-theme-quartz .ag-charts-settings-group-title-bar,\n.ag-theme-quartz-dark .ag-charts-format-top-level-group-title-bar,\n.ag-theme-quartz-dark .ag-charts-data-group-title-bar,\n.ag-theme-quartz-dark .ag-charts-settings-group-title-bar,\n.ag-theme-quartz-auto-dark .ag-charts-format-top-level-group-title-bar,\n.ag-theme-quartz-auto-dark .ag-charts-data-group-title-bar,\n.ag-theme-quartz-auto-dark .ag-charts-settings-group-title-bar {\n  padding: var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding);\n}\n.ag-theme-quartz .ag-charts-format-top-level-group .ag-charts-format-top-level-group-container,\n.ag-theme-quartz .ag-charts-data-group .ag-charts-data-group-container,\n.ag-theme-quartz .ag-charts-settings-group .ag-charts-settings-group-container,\n.ag-theme-quartz-dark .ag-charts-format-top-level-group .ag-charts-format-top-level-group-container,\n.ag-theme-quartz-dark .ag-charts-data-group .ag-charts-data-group-container,\n.ag-theme-quartz-dark .ag-charts-settings-group .ag-charts-settings-group-container,\n.ag-theme-quartz-auto-dark .ag-charts-format-top-level-group .ag-charts-format-top-level-group-container,\n.ag-theme-quartz-auto-dark .ag-charts-data-group .ag-charts-data-group-container,\n.ag-theme-quartz-auto-dark .ag-charts-settings-group .ag-charts-settings-group-container {\n  padding: 0 var(--ag-widget-container-horizontal-padding);\n}\n.ag-theme-quartz .ag-charts-format-sub-level-group-title-bar,\n.ag-theme-quartz-dark .ag-charts-format-sub-level-group-title-bar,\n.ag-theme-quartz-auto-dark .ag-charts-format-sub-level-group-title-bar {\n  padding: var(--ag-widget-vertical-spacing) 0;\n}\n.ag-theme-quartz .ag-charts-format-sub-level-group-container,\n.ag-theme-quartz-dark .ag-charts-format-sub-level-group-container,\n.ag-theme-quartz-auto-dark .ag-charts-format-sub-level-group-container {\n  padding-top: var(--ag-widget-vertical-spacing);\n  padding-bottom: var(--ag-widget-container-vertical-padding);\n}\n.ag-theme-quartz .ag-charts-format-top-level-group-container > *,\n.ag-theme-quartz .ag-charts-format-sub-level-group-container > *,\n.ag-theme-quartz-dark .ag-charts-format-top-level-group-container > *,\n.ag-theme-quartz-dark .ag-charts-format-sub-level-group-container > *,\n.ag-theme-quartz-auto-dark .ag-charts-format-top-level-group-container > *,\n.ag-theme-quartz-auto-dark .ag-charts-format-sub-level-group-container > * {\n  margin-bottom: var(--ag-widget-vertical-spacing);\n}\n.ag-theme-quartz .ag-charts-data-group-item,\n.ag-theme-quartz-dark .ag-charts-data-group-item,\n.ag-theme-quartz-auto-dark .ag-charts-data-group-item {\n  padding-bottom: var(--ag-widget-container-vertical-padding);\n}\n.ag-theme-quartz .ag-chart-settings-mini-wrapper,\n.ag-theme-quartz-dark .ag-chart-settings-mini-wrapper,\n.ag-theme-quartz-auto-dark .ag-chart-settings-mini-wrapper {\n  padding-bottom: var(--ag-widget-container-vertical-padding);\n}\n.ag-theme-quartz .ag-chart-advanced-settings-section,\n.ag-theme-quartz-dark .ag-chart-advanced-settings-section,\n.ag-theme-quartz-auto-dark .ag-chart-advanced-settings-section {\n  padding-top: var(--ag-widget-container-vertical-padding);\n  padding-bottom: var(--ag-widget-container-vertical-padding);\n}\n.ag-theme-quartz .ag-charts-advanced-settings-top-level-group .ag-charts-advanced-settings-top-level-group-title-bar,\n.ag-theme-quartz .ag-charts-advanced-settings-top-level-group .ag-charts-advanced-settings-top-level-group-container,\n.ag-theme-quartz-dark .ag-charts-advanced-settings-top-level-group .ag-charts-advanced-settings-top-level-group-title-bar,\n.ag-theme-quartz-dark .ag-charts-advanced-settings-top-level-group .ag-charts-advanced-settings-top-level-group-container,\n.ag-theme-quartz-auto-dark .ag-charts-advanced-settings-top-level-group .ag-charts-advanced-settings-top-level-group-title-bar,\n.ag-theme-quartz-auto-dark .ag-charts-advanced-settings-top-level-group .ag-charts-advanced-settings-top-level-group-container {\n  padding: 0 var(--ag-widget-container-horizontal-padding);\n}\n.ag-theme-quartz .ag-charts-advanced-settings-top-level-group-container,\n.ag-theme-quartz-dark .ag-charts-advanced-settings-top-level-group-container,\n.ag-theme-quartz-auto-dark .ag-charts-advanced-settings-top-level-group-container {\n  margin: 0;\n}\n.ag-theme-quartz .ag-charts-advanced-settings-top-level-group-item,\n.ag-theme-quartz-dark .ag-charts-advanced-settings-top-level-group-item,\n.ag-theme-quartz-auto-dark .ag-charts-advanced-settings-top-level-group-item {\n  margin-top: calc(var(--ag-widget-vertical-spacing) * 2);\n  margin-bottom: 0;\n}\n.ag-theme-quartz .ag-ltr .ag-group-title-bar-icon, .ag-theme-quartz-dark .ag-ltr .ag-group-title-bar-icon, .ag-theme-quartz-auto-dark .ag-ltr .ag-group-title-bar-icon {\n  margin-right: var(--ag-grid-size);\n}\n\n.ag-theme-quartz .ag-rtl .ag-group-title-bar-icon, .ag-theme-quartz-dark .ag-rtl .ag-group-title-bar-icon, .ag-theme-quartz-auto-dark .ag-rtl .ag-group-title-bar-icon {\n  margin-left: var(--ag-grid-size);\n}\n\n.ag-theme-quartz .ag-spectrum-color,\n.ag-theme-quartz .ag-spectrum-fill,\n.ag-theme-quartz-dark .ag-spectrum-color,\n.ag-theme-quartz-dark .ag-spectrum-fill,\n.ag-theme-quartz-auto-dark .ag-spectrum-color,\n.ag-theme-quartz-auto-dark .ag-spectrum-fill {\n  border-radius: var(--ag-border-radius);\n}\n.ag-theme-quartz .ag-spectrum-dragger,\n.ag-theme-quartz-dark .ag-spectrum-dragger,\n.ag-theme-quartz-auto-dark .ag-spectrum-dragger {\n  border-radius: 18px;\n  height: 18px;\n  width: 18px;\n  border: 3px solid white;\n}\n.ag-theme-quartz .ag-spectrum-tools,\n.ag-theme-quartz-dark .ag-spectrum-tools,\n.ag-theme-quartz-auto-dark .ag-spectrum-tools {\n  padding-left: 0;\n  padding-right: 0;\n  padding-bottom: 0;\n}\n.ag-theme-quartz .ag-spectrum-tool,\n.ag-theme-quartz-dark .ag-spectrum-tool,\n.ag-theme-quartz-auto-dark .ag-spectrum-tool {\n  height: 12px;\n}\n.ag-theme-quartz .ag-spectrum-hue-background,\n.ag-theme-quartz .ag-spectrum-alpha-background,\n.ag-theme-quartz-dark .ag-spectrum-hue-background,\n.ag-theme-quartz-dark .ag-spectrum-alpha-background,\n.ag-theme-quartz-auto-dark .ag-spectrum-hue-background,\n.ag-theme-quartz-auto-dark .ag-spectrum-alpha-background {\n  border-radius: 12px;\n}\n.ag-theme-quartz .ag-spectrum-slider,\n.ag-theme-quartz-dark .ag-spectrum-slider,\n.ag-theme-quartz-auto-dark .ag-spectrum-slider {\n  margin-top: -15px;\n  width: 18px;\n  height: 18px;\n  border-radius: 18px;\n  border: 3px solid rgb(248, 248, 248);\n}\n.ag-theme-quartz .ag-recent-colors,\n.ag-theme-quartz-dark .ag-recent-colors,\n.ag-theme-quartz-auto-dark .ag-recent-colors {\n  margin-left: var(--ag-grid-size);\n  margin-right: var(--ag-grid-size);\n  margin-bottom: 2px;\n}\n.ag-theme-quartz .ag-color-input-color,\n.ag-theme-quartz .ag-color-picker-color,\n.ag-theme-quartz .ag-recent-color,\n.ag-theme-quartz-dark .ag-color-input-color,\n.ag-theme-quartz-dark .ag-color-picker-color,\n.ag-theme-quartz-dark .ag-recent-color,\n.ag-theme-quartz-auto-dark .ag-color-input-color,\n.ag-theme-quartz-auto-dark .ag-color-picker-color,\n.ag-theme-quartz-auto-dark .ag-recent-color {\n  border-radius: 4px;\n}\n.ag-theme-quartz .ag-recent-color,\n.ag-theme-quartz-dark .ag-recent-color,\n.ag-theme-quartz-auto-dark .ag-recent-color {\n  border: var(--ag-borders-secondary) var(--ag-secondary-border-color);\n}\n.ag-theme-quartz.ag-dnd-ghost,\n.ag-theme-quartz-dark.ag-dnd-ghost,\n.ag-theme-quartz-auto-dark.ag-dnd-ghost {\n  font-weight: 500;\n}\n.ag-theme-quartz .ag-standard-button,\n.ag-theme-quartz-dark .ag-standard-button,\n.ag-theme-quartz-auto-dark .ag-standard-button {\n  font-family: inherit;\n  appearance: none;\n  -webkit-appearance: none;\n  border-radius: var(--ag-border-radius);\n  border: solid 1px var(--ag-input-border-color);\n  background-color: var(--ag-background-color);\n  padding: var(--ag-grid-size) calc(var(--ag-grid-size) * 2);\n  cursor: pointer;\n}\n.ag-theme-quartz .ag-standard-button:hover,\n.ag-theme-quartz-dark .ag-standard-button:hover,\n.ag-theme-quartz-auto-dark .ag-standard-button:hover {\n  background-color: var(--ag-row-hover-color);\n}\n.ag-theme-quartz .ag-standard-button:active,\n.ag-theme-quartz-dark .ag-standard-button:active,\n.ag-theme-quartz-auto-dark .ag-standard-button:active {\n  border-color: var(--ag-active-color);\n}\n.ag-theme-quartz .ag-standard-button:disabled,\n.ag-theme-quartz-dark .ag-standard-button:disabled,\n.ag-theme-quartz-auto-dark .ag-standard-button:disabled {\n  color: var(--ag-disabled-foreground-color);\n  background-color: var(--ag-input-disabled-background-color);\n  border-color: var(--ag-input-disabled-border-color);\n}\n.ag-theme-quartz .ag-column-drop-cell,\n.ag-theme-quartz-dark .ag-column-drop-cell,\n.ag-theme-quartz-auto-dark .ag-column-drop-cell {\n  border-radius: calc(var(--ag-grid-size) * 3);\n  height: calc(var(--ag-grid-size) * 3);\n  padding: 0 var(--ag-grid-size);\n}\n.ag-theme-quartz .ag-column-drop-cell-button,\n.ag-theme-quartz-dark .ag-column-drop-cell-button,\n.ag-theme-quartz-auto-dark .ag-column-drop-cell-button {\n  min-width: 0;\n  margin: 0;\n}\n.ag-theme-quartz .ag-column-drop-cell-drag-handle,\n.ag-theme-quartz-dark .ag-column-drop-cell-drag-handle,\n.ag-theme-quartz-auto-dark .ag-column-drop-cell-drag-handle {\n  margin-left: 0;\n}\n.ag-theme-quartz .ag-column-drop-vertical,\n.ag-theme-quartz-dark .ag-column-drop-vertical,\n.ag-theme-quartz-auto-dark .ag-column-drop-vertical {\n  min-height: 75px;\n}\n.ag-theme-quartz .ag-column-drop-vertical-title-bar,\n.ag-theme-quartz-dark .ag-column-drop-vertical-title-bar,\n.ag-theme-quartz-auto-dark .ag-column-drop-vertical-title-bar {\n  padding: var(--ag-widget-container-vertical-padding) calc(var(--ag-grid-size) * 2) 0;\n}\n.ag-theme-quartz .ag-ltr .ag-column-drop-vertical-icon, .ag-theme-quartz-dark .ag-ltr .ag-column-drop-vertical-icon, .ag-theme-quartz-auto-dark .ag-ltr .ag-column-drop-vertical-icon {\n  margin-left: 0;\n  margin-right: var(--ag-widget-horizontal-spacing);\n}\n\n.ag-theme-quartz .ag-rtl .ag-column-drop-vertical-icon, .ag-theme-quartz-dark .ag-rtl .ag-column-drop-vertical-icon, .ag-theme-quartz-auto-dark .ag-rtl .ag-column-drop-vertical-icon {\n  margin-right: 0;\n  margin-left: var(--ag-widget-horizontal-spacing);\n}\n\n.ag-theme-quartz .ag-column-drop-vertical-empty-message,\n.ag-theme-quartz-dark .ag-column-drop-vertical-empty-message,\n.ag-theme-quartz-auto-dark .ag-column-drop-vertical-empty-message {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  border: dashed 1px;\n  border-color: var(--ag-border-color);\n  margin: calc(var(--ag-grid-size) * 1.5) calc(var(--ag-grid-size) * 2);\n  padding: calc(var(--ag-grid-size) * 2);\n}\n.ag-theme-quartz .ag-column-drop-empty-message,\n.ag-theme-quartz-dark .ag-column-drop-empty-message,\n.ag-theme-quartz-auto-dark .ag-column-drop-empty-message {\n  color: var(--ag-foreground-color);\n}\n.ag-theme-quartz .ag-pill-select .ag-column-drop,\n.ag-theme-quartz-dark .ag-pill-select .ag-column-drop,\n.ag-theme-quartz-auto-dark .ag-pill-select .ag-column-drop {\n  min-height: unset;\n}\n.ag-theme-quartz .ag-pill-select .ag-picker-field-display,\n.ag-theme-quartz-dark .ag-pill-select .ag-picker-field-display,\n.ag-theme-quartz-auto-dark .ag-pill-select .ag-picker-field-display {\n  font-weight: 500;\n  color: var(--ag-chart-menu-pill-select-button-color);\n}\n.ag-theme-quartz .ag-pill-select .ag-picker-field-icon .ag-icon,\n.ag-theme-quartz-dark .ag-pill-select .ag-picker-field-icon .ag-icon,\n.ag-theme-quartz-auto-dark .ag-pill-select .ag-picker-field-icon .ag-icon {\n  color: var(--ag-chart-menu-pill-select-button-color);\n}\n.ag-theme-quartz .ag-status-bar,\n.ag-theme-quartz-dark .ag-status-bar,\n.ag-theme-quartz-auto-dark .ag-status-bar {\n  font-weight: normal;\n}\n.ag-theme-quartz .ag-status-name-value,\n.ag-theme-quartz-dark .ag-status-name-value,\n.ag-theme-quartz-auto-dark .ag-status-name-value {\n  padding: var(--ag-widget-container-vertical-padding) 0;\n}\n.ag-theme-quartz .ag-status-name-value-value,\n.ag-theme-quartz .ag-paging-number,\n.ag-theme-quartz .ag-paging-row-summary-panel-number,\n.ag-theme-quartz-dark .ag-status-name-value-value,\n.ag-theme-quartz-dark .ag-paging-number,\n.ag-theme-quartz-dark .ag-paging-row-summary-panel-number,\n.ag-theme-quartz-auto-dark .ag-status-name-value-value,\n.ag-theme-quartz-auto-dark .ag-paging-number,\n.ag-theme-quartz-auto-dark .ag-paging-row-summary-panel-number {\n  font-weight: 500;\n}\n.ag-theme-quartz .ag-column-drop-cell-button,\n.ag-theme-quartz-dark .ag-column-drop-cell-button,\n.ag-theme-quartz-auto-dark .ag-column-drop-cell-button {\n  opacity: 0.75;\n}\n.ag-theme-quartz .ag-column-drop-cell-button:hover,\n.ag-theme-quartz-dark .ag-column-drop-cell-button:hover,\n.ag-theme-quartz-auto-dark .ag-column-drop-cell-button:hover {\n  opacity: 1;\n}\n.ag-theme-quartz .ag-header-cell-menu-button,\n.ag-theme-quartz .ag-header-cell-filter-button,\n.ag-theme-quartz .ag-panel-title-bar-button,\n.ag-theme-quartz .ag-header-expand-icon,\n.ag-theme-quartz .ag-column-group-icons,\n.ag-theme-quartz .ag-set-filter-group-icons,\n.ag-theme-quartz .ag-group-expanded .ag-icon,\n.ag-theme-quartz .ag-group-contracted .ag-icon,\n.ag-theme-quartz .ag-chart-settings-prev,\n.ag-theme-quartz .ag-chart-settings-next,\n.ag-theme-quartz .ag-group-title-bar-icon,\n.ag-theme-quartz .ag-column-select-header-icon,\n.ag-theme-quartz .ag-floating-filter-button-button,\n.ag-theme-quartz .ag-filter-toolpanel-expand,\n.ag-theme-quartz .ag-panel-title-bar-button-icon,\n.ag-theme-quartz .ag-chart-menu-icon,\n.ag-theme-quartz-dark .ag-header-cell-menu-button,\n.ag-theme-quartz-dark .ag-header-cell-filter-button,\n.ag-theme-quartz-dark .ag-panel-title-bar-button,\n.ag-theme-quartz-dark .ag-header-expand-icon,\n.ag-theme-quartz-dark .ag-column-group-icons,\n.ag-theme-quartz-dark .ag-set-filter-group-icons,\n.ag-theme-quartz-dark .ag-group-expanded .ag-icon,\n.ag-theme-quartz-dark .ag-group-contracted .ag-icon,\n.ag-theme-quartz-dark .ag-chart-settings-prev,\n.ag-theme-quartz-dark .ag-chart-settings-next,\n.ag-theme-quartz-dark .ag-group-title-bar-icon,\n.ag-theme-quartz-dark .ag-column-select-header-icon,\n.ag-theme-quartz-dark .ag-floating-filter-button-button,\n.ag-theme-quartz-dark .ag-filter-toolpanel-expand,\n.ag-theme-quartz-dark .ag-panel-title-bar-button-icon,\n.ag-theme-quartz-dark .ag-chart-menu-icon,\n.ag-theme-quartz-auto-dark .ag-header-cell-menu-button,\n.ag-theme-quartz-auto-dark .ag-header-cell-filter-button,\n.ag-theme-quartz-auto-dark .ag-panel-title-bar-button,\n.ag-theme-quartz-auto-dark .ag-header-expand-icon,\n.ag-theme-quartz-auto-dark .ag-column-group-icons,\n.ag-theme-quartz-auto-dark .ag-set-filter-group-icons,\n.ag-theme-quartz-auto-dark .ag-group-expanded .ag-icon,\n.ag-theme-quartz-auto-dark .ag-group-contracted .ag-icon,\n.ag-theme-quartz-auto-dark .ag-chart-settings-prev,\n.ag-theme-quartz-auto-dark .ag-chart-settings-next,\n.ag-theme-quartz-auto-dark .ag-group-title-bar-icon,\n.ag-theme-quartz-auto-dark .ag-column-select-header-icon,\n.ag-theme-quartz-auto-dark .ag-floating-filter-button-button,\n.ag-theme-quartz-auto-dark .ag-filter-toolpanel-expand,\n.ag-theme-quartz-auto-dark .ag-panel-title-bar-button-icon,\n.ag-theme-quartz-auto-dark .ag-chart-menu-icon {\n  --ag-quartz-icon-hover-color: color-mix(in srgb, transparent, var(--ag-foreground-color) 10%);\n}\n.ag-theme-quartz .ag-header-cell-menu-button:hover,\n.ag-theme-quartz .ag-header-cell-filter-button:hover,\n.ag-theme-quartz .ag-panel-title-bar-button:hover,\n.ag-theme-quartz .ag-header-expand-icon:hover,\n.ag-theme-quartz .ag-column-group-icons:hover,\n.ag-theme-quartz .ag-set-filter-group-icons:hover,\n.ag-theme-quartz .ag-group-expanded .ag-icon:hover,\n.ag-theme-quartz .ag-group-contracted .ag-icon:hover,\n.ag-theme-quartz .ag-chart-settings-prev:hover,\n.ag-theme-quartz .ag-chart-settings-next:hover,\n.ag-theme-quartz .ag-group-title-bar-icon:hover,\n.ag-theme-quartz .ag-column-select-header-icon:hover,\n.ag-theme-quartz .ag-floating-filter-button-button:hover,\n.ag-theme-quartz .ag-filter-toolpanel-expand:hover,\n.ag-theme-quartz .ag-panel-title-bar-button-icon:hover,\n.ag-theme-quartz .ag-chart-menu-icon:hover,\n.ag-theme-quartz-dark .ag-header-cell-menu-button:hover,\n.ag-theme-quartz-dark .ag-header-cell-filter-button:hover,\n.ag-theme-quartz-dark .ag-panel-title-bar-button:hover,\n.ag-theme-quartz-dark .ag-header-expand-icon:hover,\n.ag-theme-quartz-dark .ag-column-group-icons:hover,\n.ag-theme-quartz-dark .ag-set-filter-group-icons:hover,\n.ag-theme-quartz-dark .ag-group-expanded .ag-icon:hover,\n.ag-theme-quartz-dark .ag-group-contracted .ag-icon:hover,\n.ag-theme-quartz-dark .ag-chart-settings-prev:hover,\n.ag-theme-quartz-dark .ag-chart-settings-next:hover,\n.ag-theme-quartz-dark .ag-group-title-bar-icon:hover,\n.ag-theme-quartz-dark .ag-column-select-header-icon:hover,\n.ag-theme-quartz-dark .ag-floating-filter-button-button:hover,\n.ag-theme-quartz-dark .ag-filter-toolpanel-expand:hover,\n.ag-theme-quartz-dark .ag-panel-title-bar-button-icon:hover,\n.ag-theme-quartz-dark .ag-chart-menu-icon:hover,\n.ag-theme-quartz-auto-dark .ag-header-cell-menu-button:hover,\n.ag-theme-quartz-auto-dark .ag-header-cell-filter-button:hover,\n.ag-theme-quartz-auto-dark .ag-panel-title-bar-button:hover,\n.ag-theme-quartz-auto-dark .ag-header-expand-icon:hover,\n.ag-theme-quartz-auto-dark .ag-column-group-icons:hover,\n.ag-theme-quartz-auto-dark .ag-set-filter-group-icons:hover,\n.ag-theme-quartz-auto-dark .ag-group-expanded .ag-icon:hover,\n.ag-theme-quartz-auto-dark .ag-group-contracted .ag-icon:hover,\n.ag-theme-quartz-auto-dark .ag-chart-settings-prev:hover,\n.ag-theme-quartz-auto-dark .ag-chart-settings-next:hover,\n.ag-theme-quartz-auto-dark .ag-group-title-bar-icon:hover,\n.ag-theme-quartz-auto-dark .ag-column-select-header-icon:hover,\n.ag-theme-quartz-auto-dark .ag-floating-filter-button-button:hover,\n.ag-theme-quartz-auto-dark .ag-filter-toolpanel-expand:hover,\n.ag-theme-quartz-auto-dark .ag-panel-title-bar-button-icon:hover,\n.ag-theme-quartz-auto-dark .ag-chart-menu-icon:hover {\n  border-radius: 1px;\n  background-color: var(--ag-quartz-icon-hover-color);\n  box-shadow: 0 0 0 4px var(--ag-quartz-icon-hover-color);\n}\n.ag-theme-quartz .ag-filter-active,\n.ag-theme-quartz-dark .ag-filter-active,\n.ag-theme-quartz-auto-dark .ag-filter-active {\n  --ag-quartz-icon-active-color: color-mix(in srgb, transparent, var(--ag-active-color) 14%);\n  --ag-quartz-icon-hover-color: color-mix(in srgb, transparent, var(--ag-active-color) 28%);\n  position: relative;\n  border-radius: 1px;\n  background-color: var(--ag-quartz-icon-active-color);\n  box-shadow: 0 0 0 4px var(--ag-quartz-icon-active-color);\n}\n.ag-theme-quartz .ag-filter-active::after,\n.ag-theme-quartz-dark .ag-filter-active::after,\n.ag-theme-quartz-auto-dark .ag-filter-active::after {\n  content: \"\";\n  position: absolute;\n  width: 6px;\n  height: 6px;\n  top: -1px;\n  right: -1px;\n  border-radius: 50%;\n  background-color: var(--ag-active-color);\n}\n.ag-theme-quartz .ag-filter-active .ag-icon-filter,\n.ag-theme-quartz-dark .ag-filter-active .ag-icon-filter,\n.ag-theme-quartz-auto-dark .ag-filter-active .ag-icon-filter {\n  clip-path: path(\"M8,0C8,4.415 11.585,8 16,8L16,16L0,16L0,0L8,0Z\");\n}\n.ag-theme-quartz .ag-chart-menu,\n.ag-theme-quartz-dark .ag-chart-menu,\n.ag-theme-quartz-auto-dark .ag-chart-menu {\n  --ag-icon-size: 20px;\n  background-color: color-mix(in srgb, transparent, var(--ag-background-color) 30%);\n  padding: 4px 2px;\n}\n.ag-theme-quartz .ag-chart-menu-icon,\n.ag-theme-quartz-dark .ag-chart-menu-icon,\n.ag-theme-quartz-auto-dark .ag-chart-menu-icon {\n  opacity: 0.8;\n}\n.ag-theme-quartz .ag-drag-handle,\n.ag-theme-quartz-dark .ag-drag-handle,\n.ag-theme-quartz-auto-dark .ag-drag-handle {\n  color: var(--ag-icon-font-color);\n}\n.ag-theme-quartz .ag-menu-option-icon,\n.ag-theme-quartz .ag-compact-menu-option-icon,\n.ag-theme-quartz-dark .ag-menu-option-icon,\n.ag-theme-quartz-dark .ag-compact-menu-option-icon,\n.ag-theme-quartz-auto-dark .ag-menu-option-icon,\n.ag-theme-quartz-auto-dark .ag-compact-menu-option-icon {\n  width: var(--ag-icon-size);\n  cursor: pointer;\n}\n.ag-theme-quartz .ag-ltr .ag-menu-option-icon, .ag-theme-quartz .ag-ltr .ag-compact-menu-option-icon, .ag-theme-quartz-dark .ag-ltr .ag-menu-option-icon, .ag-theme-quartz-dark .ag-ltr .ag-compact-menu-option-icon, .ag-theme-quartz-auto-dark .ag-ltr .ag-menu-option-icon, .ag-theme-quartz-auto-dark .ag-ltr .ag-compact-menu-option-icon {\n  padding-left: calc(var(--ag-grid-size) * 1.5);\n}\n\n.ag-theme-quartz .ag-rtl .ag-menu-option-icon, .ag-theme-quartz .ag-rtl .ag-compact-menu-option-icon, .ag-theme-quartz-dark .ag-rtl .ag-menu-option-icon, .ag-theme-quartz-dark .ag-rtl .ag-compact-menu-option-icon, .ag-theme-quartz-auto-dark .ag-rtl .ag-menu-option-icon, .ag-theme-quartz-auto-dark .ag-rtl .ag-compact-menu-option-icon {\n  padding-right: calc(var(--ag-grid-size) * 1.5);\n}\n\n.ag-theme-quartz .ag-chart-settings-card-item.ag-not-selected:hover,\n.ag-theme-quartz-dark .ag-chart-settings-card-item.ag-not-selected:hover,\n.ag-theme-quartz-auto-dark .ag-chart-settings-card-item.ag-not-selected:hover {\n  opacity: 0.35;\n}\n.ag-theme-quartz .ag-ltr .ag-panel-title-bar-button, .ag-theme-quartz-dark .ag-ltr .ag-panel-title-bar-button, .ag-theme-quartz-auto-dark .ag-ltr .ag-panel-title-bar-button {\n  margin-left: calc(var(--ag-grid-size) * 2);\n  margin-right: var(--ag-grid-size);\n}\n\n.ag-theme-quartz .ag-rtl .ag-panel-title-bar-button, .ag-theme-quartz-dark .ag-rtl .ag-panel-title-bar-button, .ag-theme-quartz-auto-dark .ag-rtl .ag-panel-title-bar-button {\n  margin-right: calc(var(--ag-grid-size) * 2);\n  margin-left: var(--ag-grid-size);\n}\n\n.ag-theme-quartz .ag-multi-filter-group-title-bar,\n.ag-theme-quartz-dark .ag-multi-filter-group-title-bar,\n.ag-theme-quartz-auto-dark .ag-multi-filter-group-title-bar {\n  padding: calc(var(--ag-grid-size) * 1.5) var(--ag-grid-size);\n}\n.ag-theme-quartz .ag-ltr .ag-filter-toolpanel-instance-body, .ag-theme-quartz-dark .ag-ltr .ag-filter-toolpanel-instance-body, .ag-theme-quartz-auto-dark .ag-ltr .ag-filter-toolpanel-instance-body {\n  padding-left: var(--ag-grid-size);\n}\n\n.ag-theme-quartz .ag-rtl .ag-filter-toolpanel-instance-body, .ag-theme-quartz-dark .ag-rtl .ag-filter-toolpanel-instance-body, .ag-theme-quartz-auto-dark .ag-rtl .ag-filter-toolpanel-instance-body {\n  padding-right: var(--ag-grid-size);\n}\n\n.ag-theme-quartz .ag-filter-toolpanel-instance-filter,\n.ag-theme-quartz-dark .ag-filter-toolpanel-instance-filter,\n.ag-theme-quartz-auto-dark .ag-filter-toolpanel-instance-filter {\n  border: none;\n  background-color: var(--ag-control-panel-background-color);\n}\n.ag-theme-quartz .ag-ltr .ag-filter-toolpanel-instance-filter, .ag-theme-quartz-dark .ag-ltr .ag-filter-toolpanel-instance-filter, .ag-theme-quartz-auto-dark .ag-ltr .ag-filter-toolpanel-instance-filter {\n  margin-left: calc(var(--ag-icon-size) * 0.5);\n}\n\n.ag-theme-quartz .ag-rtl .ag-filter-toolpanel-instance-filter, .ag-theme-quartz-dark .ag-rtl .ag-filter-toolpanel-instance-filter, .ag-theme-quartz-auto-dark .ag-rtl .ag-filter-toolpanel-instance-filter {\n  margin-right: calc(var(--ag-icon-size) * 0.5);\n}\n\n.ag-theme-quartz .ag-filter-toolpanel-group-level-0,\n.ag-theme-quartz-dark .ag-filter-toolpanel-group-level-0,\n.ag-theme-quartz-auto-dark .ag-filter-toolpanel-group-level-0 {\n  border-top: none;\n}\n.ag-theme-quartz .ag-filter-toolpanel-header,\n.ag-theme-quartz-dark .ag-filter-toolpanel-header,\n.ag-theme-quartz-auto-dark .ag-filter-toolpanel-header {\n  height: initial;\n  padding-top: var(--ag-grid-size);\n  padding-bottom: var(--ag-grid-size);\n}\n.ag-theme-quartz .ag-filter-toolpanel-group-item,\n.ag-theme-quartz-dark .ag-filter-toolpanel-group-item,\n.ag-theme-quartz-auto-dark .ag-filter-toolpanel-group-item {\n  margin: 0;\n}\n.ag-theme-quartz .ag-layout-auto-height .ag-center-cols-viewport,\n.ag-theme-quartz .ag-layout-auto-height .ag-center-cols-container,\n.ag-theme-quartz .ag-layout-print .ag-center-cols-viewport,\n.ag-theme-quartz .ag-layout-print .ag-center-cols-container,\n.ag-theme-quartz-dark .ag-layout-auto-height .ag-center-cols-viewport,\n.ag-theme-quartz-dark .ag-layout-auto-height .ag-center-cols-container,\n.ag-theme-quartz-dark .ag-layout-print .ag-center-cols-viewport,\n.ag-theme-quartz-dark .ag-layout-print .ag-center-cols-container,\n.ag-theme-quartz-auto-dark .ag-layout-auto-height .ag-center-cols-viewport,\n.ag-theme-quartz-auto-dark .ag-layout-auto-height .ag-center-cols-container,\n.ag-theme-quartz-auto-dark .ag-layout-print .ag-center-cols-viewport,\n.ag-theme-quartz-auto-dark .ag-layout-print .ag-center-cols-container {\n  min-height: 150px;\n}\n.ag-theme-quartz .ag-date-time-list-page-entry-is-current,\n.ag-theme-quartz-dark .ag-date-time-list-page-entry-is-current,\n.ag-theme-quartz-auto-dark .ag-date-time-list-page-entry-is-current {\n  background-color: var(--ag-active-color);\n}\n.ag-theme-quartz .ag-advanced-filter-builder-button,\n.ag-theme-quartz-dark .ag-advanced-filter-builder-button,\n.ag-theme-quartz-auto-dark .ag-advanced-filter-builder-button {\n  padding: var(--ag-grid-size);\n  font-weight: 600;\n}\n.ag-theme-quartz .ag-advanced-filter-builder-item-button-disabled .ag-icon,\n.ag-theme-quartz .ag-disabled .ag-icon,\n.ag-theme-quartz .ag-column-select-column-group-readonly .ag-icon,\n.ag-theme-quartz [disabled] .ag-icon,\n.ag-theme-quartz-dark .ag-advanced-filter-builder-item-button-disabled .ag-icon,\n.ag-theme-quartz-dark .ag-disabled .ag-icon,\n.ag-theme-quartz-dark .ag-column-select-column-group-readonly .ag-icon,\n.ag-theme-quartz-dark [disabled] .ag-icon,\n.ag-theme-quartz-auto-dark .ag-advanced-filter-builder-item-button-disabled .ag-icon,\n.ag-theme-quartz-auto-dark .ag-disabled .ag-icon,\n.ag-theme-quartz-auto-dark .ag-column-select-column-group-readonly .ag-icon,\n.ag-theme-quartz-auto-dark [disabled] .ag-icon {\n  opacity: 0.6;\n}\n.ag-theme-quartz .ag-icon-grip,\n.ag-theme-quartz-dark .ag-icon-grip,\n.ag-theme-quartz-auto-dark .ag-icon-grip {\n  opacity: 0.7;\n}\n.ag-theme-quartz .ag-column-select-column-readonly.ag-icon-grip,\n.ag-theme-quartz .ag-column-select-column-readonly .ag-icon-grip,\n.ag-theme-quartz-dark .ag-column-select-column-readonly.ag-icon-grip,\n.ag-theme-quartz-dark .ag-column-select-column-readonly .ag-icon-grip,\n.ag-theme-quartz-auto-dark .ag-column-select-column-readonly.ag-icon-grip,\n.ag-theme-quartz-auto-dark .ag-column-select-column-readonly .ag-icon-grip {\n  opacity: 0.35;\n}\n.ag-theme-quartz .ag-column-select-header-filter-wrapper .ag-input-wrapper::before,\n.ag-theme-quartz .ag-filter-toolpanel-search .ag-input-wrapper::before,\n.ag-theme-quartz .ag-mini-filter .ag-input-wrapper::before,\n.ag-theme-quartz .ag-filter-filter .ag-input-wrapper::before,\n.ag-theme-quartz .ag-filter-add-select .ag-input-wrapper::before,\n.ag-theme-quartz-dark .ag-column-select-header-filter-wrapper .ag-input-wrapper::before,\n.ag-theme-quartz-dark .ag-filter-toolpanel-search .ag-input-wrapper::before,\n.ag-theme-quartz-dark .ag-mini-filter .ag-input-wrapper::before,\n.ag-theme-quartz-dark .ag-filter-filter .ag-input-wrapper::before,\n.ag-theme-quartz-dark .ag-filter-add-select .ag-input-wrapper::before,\n.ag-theme-quartz-auto-dark .ag-column-select-header-filter-wrapper .ag-input-wrapper::before,\n.ag-theme-quartz-auto-dark .ag-filter-toolpanel-search .ag-input-wrapper::before,\n.ag-theme-quartz-auto-dark .ag-mini-filter .ag-input-wrapper::before,\n.ag-theme-quartz-auto-dark .ag-filter-filter .ag-input-wrapper::before,\n.ag-theme-quartz-auto-dark .ag-filter-add-select .ag-input-wrapper::before {\n  position: absolute;\n  display: block;\n  width: 12px;\n  height: 12px;\n  background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ");\n  background-position: 50% 50%;\n  background-size: contain;\n  opacity: 40%;\n  content: \"\";\n  filter: var(--ag-icon-filter);\n}\n.ag-theme-quartz .ag-ltr .ag-column-select-header-filter-wrapper .ag-input-wrapper::before, .ag-theme-quartz .ag-ltr .ag-filter-toolpanel-search .ag-input-wrapper::before, .ag-theme-quartz .ag-ltr .ag-mini-filter .ag-input-wrapper::before, .ag-theme-quartz .ag-ltr .ag-filter-filter .ag-input-wrapper::before, .ag-theme-quartz .ag-ltr .ag-filter-add-select .ag-input-wrapper::before, .ag-theme-quartz-dark .ag-ltr .ag-column-select-header-filter-wrapper .ag-input-wrapper::before, .ag-theme-quartz-dark .ag-ltr .ag-filter-toolpanel-search .ag-input-wrapper::before, .ag-theme-quartz-dark .ag-ltr .ag-mini-filter .ag-input-wrapper::before, .ag-theme-quartz-dark .ag-ltr .ag-filter-filter .ag-input-wrapper::before, .ag-theme-quartz-dark .ag-ltr .ag-filter-add-select .ag-input-wrapper::before, .ag-theme-quartz-auto-dark .ag-ltr .ag-column-select-header-filter-wrapper .ag-input-wrapper::before, .ag-theme-quartz-auto-dark .ag-ltr .ag-filter-toolpanel-search .ag-input-wrapper::before, .ag-theme-quartz-auto-dark .ag-ltr .ag-mini-filter .ag-input-wrapper::before, .ag-theme-quartz-auto-dark .ag-ltr .ag-filter-filter .ag-input-wrapper::before, .ag-theme-quartz-auto-dark .ag-ltr .ag-filter-add-select .ag-input-wrapper::before {\n  margin-left: var(--ag-grid-size);\n}\n\n.ag-theme-quartz .ag-rtl .ag-column-select-header-filter-wrapper .ag-input-wrapper::before, .ag-theme-quartz .ag-rtl .ag-filter-toolpanel-search .ag-input-wrapper::before, .ag-theme-quartz .ag-rtl .ag-mini-filter .ag-input-wrapper::before, .ag-theme-quartz .ag-rtl .ag-filter-filter .ag-input-wrapper::before, .ag-theme-quartz .ag-rtl .ag-filter-add-select .ag-input-wrapper::before, .ag-theme-quartz-dark .ag-rtl .ag-column-select-header-filter-wrapper .ag-input-wrapper::before, .ag-theme-quartz-dark .ag-rtl .ag-filter-toolpanel-search .ag-input-wrapper::before, .ag-theme-quartz-dark .ag-rtl .ag-mini-filter .ag-input-wrapper::before, .ag-theme-quartz-dark .ag-rtl .ag-filter-filter .ag-input-wrapper::before, .ag-theme-quartz-dark .ag-rtl .ag-filter-add-select .ag-input-wrapper::before, .ag-theme-quartz-auto-dark .ag-rtl .ag-column-select-header-filter-wrapper .ag-input-wrapper::before, .ag-theme-quartz-auto-dark .ag-rtl .ag-filter-toolpanel-search .ag-input-wrapper::before, .ag-theme-quartz-auto-dark .ag-rtl .ag-mini-filter .ag-input-wrapper::before, .ag-theme-quartz-auto-dark .ag-rtl .ag-filter-filter .ag-input-wrapper::before, .ag-theme-quartz-auto-dark .ag-rtl .ag-filter-add-select .ag-input-wrapper::before {\n  margin-right: var(--ag-grid-size);\n}\n\n.ag-theme-quartz .ag-ltr .ag-column-select-header-filter-wrapper input.ag-text-field-input, .ag-theme-quartz .ag-ltr .ag-column-select-header-filter-wrapper input.ag-number-field-input, .ag-theme-quartz .ag-ltr .ag-filter-toolpanel-search input.ag-text-field-input, .ag-theme-quartz .ag-ltr .ag-filter-toolpanel-search input.ag-number-field-input, .ag-theme-quartz .ag-ltr .ag-mini-filter input.ag-text-field-input, .ag-theme-quartz .ag-ltr .ag-mini-filter input.ag-number-field-input, .ag-theme-quartz .ag-ltr .ag-filter-filter input.ag-text-field-input, .ag-theme-quartz .ag-ltr .ag-filter-filter input.ag-number-field-input, .ag-theme-quartz .ag-ltr .ag-filter-add-select input.ag-text-field-input, .ag-theme-quartz .ag-ltr .ag-filter-add-select input.ag-number-field-input, .ag-theme-quartz-dark .ag-ltr .ag-column-select-header-filter-wrapper input.ag-text-field-input, .ag-theme-quartz-dark .ag-ltr .ag-column-select-header-filter-wrapper input.ag-number-field-input, .ag-theme-quartz-dark .ag-ltr .ag-filter-toolpanel-search input.ag-text-field-input, .ag-theme-quartz-dark .ag-ltr .ag-filter-toolpanel-search input.ag-number-field-input, .ag-theme-quartz-dark .ag-ltr .ag-mini-filter input.ag-text-field-input, .ag-theme-quartz-dark .ag-ltr .ag-mini-filter input.ag-number-field-input, .ag-theme-quartz-dark .ag-ltr .ag-filter-filter input.ag-text-field-input, .ag-theme-quartz-dark .ag-ltr .ag-filter-filter input.ag-number-field-input, .ag-theme-quartz-dark .ag-ltr .ag-filter-add-select input.ag-text-field-input, .ag-theme-quartz-dark .ag-ltr .ag-filter-add-select input.ag-number-field-input, .ag-theme-quartz-auto-dark .ag-ltr .ag-column-select-header-filter-wrapper input.ag-text-field-input, .ag-theme-quartz-auto-dark .ag-ltr .ag-column-select-header-filter-wrapper input.ag-number-field-input, .ag-theme-quartz-auto-dark .ag-ltr .ag-filter-toolpanel-search input.ag-text-field-input, .ag-theme-quartz-auto-dark .ag-ltr .ag-filter-toolpanel-search input.ag-number-field-input, .ag-theme-quartz-auto-dark .ag-ltr .ag-mini-filter input.ag-text-field-input, .ag-theme-quartz-auto-dark .ag-ltr .ag-mini-filter input.ag-number-field-input, .ag-theme-quartz-auto-dark .ag-ltr .ag-filter-filter input.ag-text-field-input, .ag-theme-quartz-auto-dark .ag-ltr .ag-filter-filter input.ag-number-field-input, .ag-theme-quartz-auto-dark .ag-ltr .ag-filter-add-select input.ag-text-field-input, .ag-theme-quartz-auto-dark .ag-ltr .ag-filter-add-select input.ag-number-field-input {\n  padding-left: 26px;\n}\n\n.ag-theme-quartz .ag-rtl .ag-column-select-header-filter-wrapper input.ag-text-field-input, .ag-theme-quartz .ag-rtl .ag-column-select-header-filter-wrapper input.ag-number-field-input, .ag-theme-quartz .ag-rtl .ag-filter-toolpanel-search input.ag-text-field-input, .ag-theme-quartz .ag-rtl .ag-filter-toolpanel-search input.ag-number-field-input, .ag-theme-quartz .ag-rtl .ag-mini-filter input.ag-text-field-input, .ag-theme-quartz .ag-rtl .ag-mini-filter input.ag-number-field-input, .ag-theme-quartz .ag-rtl .ag-filter-filter input.ag-text-field-input, .ag-theme-quartz .ag-rtl .ag-filter-filter input.ag-number-field-input, .ag-theme-quartz .ag-rtl .ag-filter-add-select input.ag-text-field-input, .ag-theme-quartz .ag-rtl .ag-filter-add-select input.ag-number-field-input, .ag-theme-quartz-dark .ag-rtl .ag-column-select-header-filter-wrapper input.ag-text-field-input, .ag-theme-quartz-dark .ag-rtl .ag-column-select-header-filter-wrapper input.ag-number-field-input, .ag-theme-quartz-dark .ag-rtl .ag-filter-toolpanel-search input.ag-text-field-input, .ag-theme-quartz-dark .ag-rtl .ag-filter-toolpanel-search input.ag-number-field-input, .ag-theme-quartz-dark .ag-rtl .ag-mini-filter input.ag-text-field-input, .ag-theme-quartz-dark .ag-rtl .ag-mini-filter input.ag-number-field-input, .ag-theme-quartz-dark .ag-rtl .ag-filter-filter input.ag-text-field-input, .ag-theme-quartz-dark .ag-rtl .ag-filter-filter input.ag-number-field-input, .ag-theme-quartz-dark .ag-rtl .ag-filter-add-select input.ag-text-field-input, .ag-theme-quartz-dark .ag-rtl .ag-filter-add-select input.ag-number-field-input, .ag-theme-quartz-auto-dark .ag-rtl .ag-column-select-header-filter-wrapper input.ag-text-field-input, .ag-theme-quartz-auto-dark .ag-rtl .ag-column-select-header-filter-wrapper input.ag-number-field-input, .ag-theme-quartz-auto-dark .ag-rtl .ag-filter-toolpanel-search input.ag-text-field-input, .ag-theme-quartz-auto-dark .ag-rtl .ag-filter-toolpanel-search input.ag-number-field-input, .ag-theme-quartz-auto-dark .ag-rtl .ag-mini-filter input.ag-text-field-input, .ag-theme-quartz-auto-dark .ag-rtl .ag-mini-filter input.ag-number-field-input, .ag-theme-quartz-auto-dark .ag-rtl .ag-filter-filter input.ag-text-field-input, .ag-theme-quartz-auto-dark .ag-rtl .ag-filter-filter input.ag-number-field-input, .ag-theme-quartz-auto-dark .ag-rtl .ag-filter-add-select input.ag-text-field-input, .ag-theme-quartz-auto-dark .ag-rtl .ag-filter-add-select input.ag-number-field-input {\n  padding-right: 26px;\n}\n\n.ag-theme-quartz .ag-ltr .ag-column-select-add-group-indent, .ag-theme-quartz-dark .ag-ltr .ag-column-select-add-group-indent, .ag-theme-quartz-auto-dark .ag-ltr .ag-column-select-add-group-indent {\n  margin-left: calc(var(--ag-icon-size) + var(--ag-grid-size) * 1.5);\n}\n\n.ag-theme-quartz .ag-rtl .ag-column-select-add-group-indent, .ag-theme-quartz-dark .ag-rtl .ag-column-select-add-group-indent, .ag-theme-quartz-auto-dark .ag-rtl .ag-column-select-add-group-indent {\n  margin-right: calc(var(--ag-icon-size) + var(--ag-grid-size) * 1.5);\n}\n\n.ag-theme-quartz .ag-text-field-input[disabled],\n.ag-theme-quartz .ag-menu-option-disabled,\n.ag-theme-quartz-dark .ag-text-field-input[disabled],\n.ag-theme-quartz-dark .ag-menu-option-disabled,\n.ag-theme-quartz-auto-dark .ag-text-field-input[disabled],\n.ag-theme-quartz-auto-dark .ag-menu-option-disabled {\n  cursor: not-allowed;\n}\n.ag-theme-quartz .ag-checkbox-input-wrapper.ag-checked.ag-disabled,\n.ag-theme-quartz-dark .ag-checkbox-input-wrapper.ag-checked.ag-disabled,\n.ag-theme-quartz-auto-dark .ag-checkbox-input-wrapper.ag-checked.ag-disabled {\n  --ag-checkbox-checked-color: var(--ag-checkbox-unchecked-color);\n}\n.ag-theme-quartz .ag-checkbox-input,\n.ag-theme-quartz .ag-toggle-button-input,\n.ag-theme-quartz .ag-radio-button-input,\n.ag-theme-quartz input[class^=ag-][type=range],\n.ag-theme-quartz-dark .ag-checkbox-input,\n.ag-theme-quartz-dark .ag-toggle-button-input,\n.ag-theme-quartz-dark .ag-radio-button-input,\n.ag-theme-quartz-dark input[class^=ag-][type=range],\n.ag-theme-quartz-auto-dark .ag-checkbox-input,\n.ag-theme-quartz-auto-dark .ag-toggle-button-input,\n.ag-theme-quartz-auto-dark .ag-radio-button-input,\n.ag-theme-quartz-auto-dark input[class^=ag-][type=range] {\n  cursor: pointer;\n}\n.ag-theme-quartz .ag-details-row,\n.ag-theme-quartz-dark .ag-details-row,\n.ag-theme-quartz-auto-dark .ag-details-row {\n  padding: calc(var(--ag-grid-size) * 3.75);\n}\n.ag-theme-quartz .ag-list-item-hovered::after,\n.ag-theme-quartz-dark .ag-list-item-hovered::after,\n.ag-theme-quartz-auto-dark .ag-list-item-hovered::after {\n  background-color: var(--ag-active-color);\n}\n.ag-theme-quartz .ag-pill .ag-pill-button:hover,\n.ag-theme-quartz-dark .ag-pill .ag-pill-button:hover,\n.ag-theme-quartz-auto-dark .ag-pill .ag-pill-button:hover {\n  color: var(--ag-active-color);\n}\n.ag-theme-quartz .ag-header-highlight-before::after,\n.ag-theme-quartz .ag-header-highlight-after::after,\n.ag-theme-quartz-dark .ag-header-highlight-before::after,\n.ag-theme-quartz-dark .ag-header-highlight-after::after,\n.ag-theme-quartz-auto-dark .ag-header-highlight-before::after,\n.ag-theme-quartz-auto-dark .ag-header-highlight-after::after {\n  background-color: var(--ag-active-color);\n}\n\n.ag-theme-quartz-dark .ag-column-select-header-filter-wrapper .ag-input-wrapper::before,\n.ag-theme-quartz-dark .ag-filter-toolpanel-search .ag-input-wrapper::before,\n.ag-theme-quartz-dark .ag-mini-filter .ag-input-wrapper::before,\n.ag-theme-quartz-dark .ag-filter-filter .ag-input-wrapper::before {\n  opacity: 66%;\n  filter: invert(100%);\n}\n.ag-theme-quartz-dark .ag-chart-menu {\n  background-color: color-mix(in srgb, rgba(24, 39, 50, 0.3), var(--ag-background-color) 30%);\n}\n.ag-theme-quartz-dark .ag-text-field-input::placeholder {\n  color: var(--ag-data-color);\n  opacity: 0.8;\n}\n", ""]);
// Exports
/* harmony default export */ __webpack_exports__.A = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 31123:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(36758);
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40935);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20062);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(43545), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_1___ = new URL(/* asset import */ __webpack_require__(47249), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
var ___CSS_LOADER_URL_REPLACEMENT_1___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_1___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, "@font-face {\n  font-family: \"agGridQuartz\";\n  src: url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ");\n  font-weight: normal;\n  font-style: normal;\n}\n.ag-theme-quartz,\n.ag-theme-quartz-dark,\n.ag-theme-quartz-auto-dark {\n  --ag-active-color: #2196f3;\n  --ag-background-color: #fff;\n  --ag-foreground-color: #181d1f;\n  --ag-border-color: color-mix(in srgb, transparent, var(--ag-foreground-color) 15%);\n  --ag-secondary-border-color: var(--ag-border-color);\n  --ag-header-background-color: color-mix(in srgb, var(--ag-background-color), var(--ag-foreground-color) 2%);\n  --ag-tooltip-background-color: var(--ag-header-background-color);\n  --ag-control-panel-background-color: var(--ag-header-background-color);\n  --ag-subheader-background-color: transparent;\n  --ag-invalid-color: #e02525;\n  --ag-checkbox-unchecked-color: color-mix(in srgb, var(--ag-background-color), var(--ag-foreground-color) 30%);\n  --ag-advanced-filter-join-pill-color: #f08e8d;\n  --ag-advanced-filter-column-pill-color: #a6e194;\n  --ag-advanced-filter-option-pill-color: #f3c08b;\n  --ag-advanced-filter-value-pill-color: #85c0e4;\n  --ag-header-column-resize-handle-color: var(--ag-secondary-border-color);\n  --ag-icon-font-color: color-mix(in srgb, transparent, var(--ag-foreground-color) 90%);\n  --ag-find-match-color: var(--ag-foreground-color);\n  --ag-find-match-background-color: #ffff00;\n  --ag-find-active-match-color: var(--ag-foreground-color);\n  --ag-find-active-match-background-color: #ffa500;\n  --ag-panel-background-color: color-mix(in srgb, var(--ag-background-color), var(--ag-foreground-color) 3%);\n  --ag-panel-border-color: color-mix(in srgb, transparent, var(--ag-foreground-color) 20%);\n  --ag-menu-background-color: color-mix(in srgb, var(--ag-background-color), var(--ag-foreground-color) 3%);\n  --ag-menu-border-color: color-mix(in srgb, transparent, var(--ag-foreground-color) 20%);\n  --ag-selected-row-background-color: color-mix(in srgb, transparent, var(--ag-active-color) 8%);\n  --ag-row-hover-color: color-mix(in srgb, transparent, var(--ag-active-color) 12%);\n  --ag-column-hover-color: color-mix(in srgb, transparent, var(--ag-foreground-color) 5%);\n  --ag-input-focus-border-color: var(--ag-active-color);\n  --ag-range-selection-background-color: color-mix(in srgb, transparent, var(--ag-active-color) 20%);\n  --ag-input-focus-box-shadow: 0 0 0 3px color-mix(in srgb, transparent, var(--ag-input-focus-border-color) 47%);\n  --ag-input-error-focus-box-shadow: 0 0 0 3px\n      color-mix(in srgb, var(--ag-background-color), var(--ag-invalid-color) 50%);\n  --ag-range-selection-background-color-2: color-mix(in srgb, transparent, var(--ag-active-color) 36%);\n  --ag-range-selection-background-color-3: color-mix(in srgb, transparent, var(--ag-active-color) 49%);\n  --ag-range-selection-background-color-4: color-mix(in srgb, transparent, var(--ag-active-color) 59%);\n  --ag-row-numbers-selected-color: color-mix(in srgb, transparent, var(--ag-active-color) 50%);\n  --ag-checkbox-background-color: var(--ag-background-color);\n  --ag-checkbox-checked-color: var(--ag-active-color);\n  --ag-range-selection-border-color: var(--ag-active-color);\n  --ag-secondary-foreground-color: var(--ag-foreground-color);\n  --ag-input-border-color: var(--ag-border-color);\n  --ag-input-border-color-invalid: var(--ag-invalid-color);\n  --ag-disabled-foreground-color: color-mix(in srgb, transparent, var(--ag-foreground-color) 50%);\n  --ag-chip-background-color: color-mix(in srgb, transparent, var(--ag-foreground-color) 7%);\n  --ag-chip-border-color: color-mix(in srgb, var(--ag-header-background-color), var(--ag-foreground-color) 13%);\n  --ag-input-disabled-border-color: var(--ag-border-color);\n  --ag-input-disabled-background-color: color-mix(in srgb, var(--ag-background-color), var(--ag-foreground-color) 6%);\n  --ag-modal-overlay-background-color: color-mix(in srgb, transparent, var(--ag-background-color) 66%);\n  --ag-chart-menu-label-color: color-mix(in srgb, transparent, var(--ag-foreground-color) 80%);\n  --ag-chart-menu-pill-select-button-color: color-mix(in srgb, transparent, var(--ag-foreground-color) 70%);\n  --ag-filter-panel-card-subtle-color: color-mix(in srgb, transparent, var(--ag-foreground-color) 70%);\n  --ag-borders: solid 1px;\n  --ag-border-radius: 4px;\n  --ag-wrapper-border-radius: 8px;\n  --ag-borders-side-button: none;\n  --ag-side-button-selected-background-color: transparent;\n  --ag-header-column-resize-handle-display: block;\n  --ag-header-column-resize-handle-width: 2px;\n  --ag-header-column-resize-handle-height: 30%;\n  --ag-grid-size: 8px;\n  --ag-icon-size: 16px;\n  --ag-header-height: calc(var(--ag-font-size) + var(--ag-grid-size) * 4.25);\n  --ag-row-height: calc(var(--ag-font-size) + var(--ag-grid-size) * 3.5);\n  --ag-list-item-height: calc(\n      var(--ag-icon-size) + var(--ag-widget-vertical-spacing)\n  );\n  --ag-column-select-indent-size: var(--ag-icon-size);\n  --ag-set-filter-indent-size: var(--ag-icon-size);\n  --ag-filter-tool-panel-group-indent: var(--ag-grid-size);\n  --ag-advanced-filter-builder-indent-size: calc(var(--ag-icon-size) + var(--ag-grid-size) * 2);\n  --ag-cell-horizontal-padding: calc(var(--ag-grid-size) * 2);\n  --ag-cell-widget-spacing: calc(var(--ag-grid-size) * 1.5);\n  --ag-widget-container-vertical-padding: calc(var(--ag-grid-size) * 1.5);\n  --ag-widget-container-horizontal-padding: calc(var(--ag-grid-size) * 1.5);\n  --ag-widget-horizontal-spacing: calc(var(--ag-grid-size) * 1.5);\n  --ag-widget-vertical-spacing: calc(var(--ag-grid-size) * 1);\n  --ag-toggle-button-height: 18px;\n  --ag-toggle-button-width: 28px;\n  --ag-toggle-button-border-width: 2px;\n  --ag-font-family: \"IBM Plex Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Oxygen-Sans, Ubuntu,\n      Cantarell, \"Helvetica Neue\", sans-serif;\n  --ag-font-size: 14px;\n  --ag-icon-font-family: agGridQuartz;\n  --ag-tab-min-width: 290px;\n  --ag-chart-menu-panel-width: 260px;\n  --ag-card-shadow: 0 1px 4px 1px rgba(186, 191, 199, 0.4);\n  --ag-popup-shadow: 0 0 16px 0 rgba(0, 0, 0, 0.15);\n  --ag-side-bar-panel-width: 250px;\n  --ag-filter-panel-apply-button-color: var(--ag-background-color);\n  --ag-filter-panel-apply-button-background-color: var(--ag-active-color);\n}\n\n.ag-theme-quartz-dark {\n  --ag-background-color: color-mix(in srgb, #fff, #182230 97%);\n  --ag-foreground-color: #fff;\n  --ag-border-color: rgba(255, 255, 255, 0.16);\n  --ag-secondary-border-color: color-mix(in srgb, transparent, var(--ag-foreground-color) 10%);\n  --ag-header-background-color: color-mix(in srgb, #fff, #182230 93%);\n  --ag-tooltip-background-color: color-mix(in srgb, #fff, #182230 96%);\n  --ag-control-panel-background-color: color-mix(in srgb, #fff, #182230 93%);\n  --ag-input-disabled-background-color: #68686e12;\n  --ag-card-shadow: 0 1px 20px 1px black;\n  --ag-input-border-color: var(--ag-border-color);\n  --ag-input-disabled-border-color: rgba(255, 255, 255, 0.07);\n  --ag-checkbox-unchecked-color: color-mix(in srgb, var(--ag-background-color), var(--ag-foreground-color) 40%);\n  --ag-row-hover-color: color-mix(in srgb, transparent, var(--ag-active-color) 20%);\n  --ag-selected-row-background-color: var(--ag-row-hover-color);\n  --ag-panel-background-color: color-mix(in srgb, var(--ag-background-color), var(--ag-foreground-color) 10%);\n  --ag-panel-border-color: color-mix(in srgb, transparent, var(--ag-foreground-color) 10%);\n  --ag-menu-background-color: color-mix(in srgb, var(--ag-background-color), var(--ag-foreground-color) 10%);\n  --ag-menu-border-color: color-mix(in srgb, transparent, var(--ag-foreground-color) 10%);\n  --ag-advanced-filter-join-pill-color: #7a3a37;\n  --ag-advanced-filter-column-pill-color: #355f2d;\n  --ag-advanced-filter-option-pill-color: #5a3168;\n  --ag-advanced-filter-value-pill-color: #374c86;\n  --ag-find-match-color: var(--ag-background-color);\n  --ag-find-active-match-color: var(--ag-background-color);\n  --ag-filter-panel-apply-button-color: var(--ag-foreground-color);\n  --ag-popup-shadow: 0 0px 20px rgba(0, 0, 0, 0.3);\n  --ag-row-loading-skeleton-effect-color: rgba(202, 203, 204, 0.4);\n  --ag-cell-batch-edit-text-color: #f3d0b3;\n  color-scheme: dark;\n}\n\n@media (prefers-color-scheme: dark) {\n  .ag-theme-quartz-auto-dark {\n    --ag-background-color: color-mix(in srgb, #fff, #182230 97%);\n    --ag-foreground-color: #fff;\n    --ag-border-color: rgba(255, 255, 255, 0.16);\n    --ag-secondary-border-color: color-mix(in srgb, transparent, var(--ag-foreground-color) 10%);\n    --ag-header-background-color: color-mix(in srgb, #fff, #182230 93%);\n    --ag-tooltip-background-color: color-mix(in srgb, #fff, #182230 96%);\n    --ag-control-panel-background-color: color-mix(in srgb, #fff, #182230 93%);\n    --ag-input-disabled-background-color: #68686e12;\n    --ag-card-shadow: 0 1px 20px 1px black;\n    --ag-input-border-color: var(--ag-border-color);\n    --ag-input-disabled-border-color: rgba(255, 255, 255, 0.07);\n    --ag-checkbox-unchecked-color: color-mix(in srgb, var(--ag-background-color), var(--ag-foreground-color) 40%);\n    --ag-row-hover-color: color-mix(in srgb, transparent, var(--ag-active-color) 20%);\n    --ag-selected-row-background-color: var(--ag-row-hover-color);\n    --ag-panel-background-color: color-mix(in srgb, var(--ag-background-color), var(--ag-foreground-color) 10%);\n    --ag-panel-border-color: color-mix(in srgb, transparent, var(--ag-foreground-color) 10%);\n    --ag-menu-background-color: color-mix(in srgb, var(--ag-background-color), var(--ag-foreground-color) 10%);\n    --ag-menu-border-color: color-mix(in srgb, transparent, var(--ag-foreground-color) 10%);\n    --ag-advanced-filter-join-pill-color: #7a3a37;\n    --ag-advanced-filter-column-pill-color: #355f2d;\n    --ag-advanced-filter-option-pill-color: #5a3168;\n    --ag-advanced-filter-value-pill-color: #374c86;\n    --ag-find-match-color: var(--ag-background-color);\n    --ag-find-active-match-color: var(--ag-background-color);\n    --ag-filter-panel-apply-button-color: var(--ag-foreground-color);\n    --ag-popup-shadow: 0 0px 20px rgba(0, 0, 0, 0.3);\n    --ag-row-loading-skeleton-effect-color: rgba(202, 203, 204, 0.4);\n    --ag-cell-batch-edit-text-color: #f3d0b3;\n    color-scheme: dark;\n  }\n}\n.ag-theme-quartz .ag-filter-toolpanel-header,\n.ag-theme-quartz .ag-filter-toolpanel-search,\n.ag-theme-quartz .ag-status-bar,\n.ag-theme-quartz .ag-header-row,\n.ag-theme-quartz .ag-row-number-cell,\n.ag-theme-quartz .ag-panel-title-bar-title,\n.ag-theme-quartz .ag-multi-filter-group-title-bar,\n.ag-theme-quartz .ag-filter-card-title,\n.ag-theme-quartz-dark .ag-filter-toolpanel-header,\n.ag-theme-quartz-dark .ag-filter-toolpanel-search,\n.ag-theme-quartz-dark .ag-status-bar,\n.ag-theme-quartz-dark .ag-header-row,\n.ag-theme-quartz-dark .ag-row-number-cell,\n.ag-theme-quartz-dark .ag-panel-title-bar-title,\n.ag-theme-quartz-dark .ag-multi-filter-group-title-bar,\n.ag-theme-quartz-dark .ag-filter-card-title,\n.ag-theme-quartz-auto-dark .ag-filter-toolpanel-header,\n.ag-theme-quartz-auto-dark .ag-filter-toolpanel-search,\n.ag-theme-quartz-auto-dark .ag-status-bar,\n.ag-theme-quartz-auto-dark .ag-header-row,\n.ag-theme-quartz-auto-dark .ag-row-number-cell,\n.ag-theme-quartz-auto-dark .ag-panel-title-bar-title,\n.ag-theme-quartz-auto-dark .ag-multi-filter-group-title-bar,\n.ag-theme-quartz-auto-dark .ag-filter-card-title {\n  font-weight: 500;\n  color: var(--ag-header-foreground-color);\n}\n.ag-theme-quartz input[class^=ag-]:not([type]),\n.ag-theme-quartz input[class^=ag-][type=text],\n.ag-theme-quartz input[class^=ag-][type=number],\n.ag-theme-quartz input[class^=ag-][type=tel],\n.ag-theme-quartz input[class^=ag-][type=date],\n.ag-theme-quartz input[class^=ag-][type=datetime-local],\n.ag-theme-quartz textarea[class^=ag-],\n.ag-theme-quartz-dark input[class^=ag-]:not([type]),\n.ag-theme-quartz-dark input[class^=ag-][type=text],\n.ag-theme-quartz-dark input[class^=ag-][type=number],\n.ag-theme-quartz-dark input[class^=ag-][type=tel],\n.ag-theme-quartz-dark input[class^=ag-][type=date],\n.ag-theme-quartz-dark input[class^=ag-][type=datetime-local],\n.ag-theme-quartz-dark textarea[class^=ag-],\n.ag-theme-quartz-auto-dark input[class^=ag-]:not([type]),\n.ag-theme-quartz-auto-dark input[class^=ag-][type=text],\n.ag-theme-quartz-auto-dark input[class^=ag-][type=number],\n.ag-theme-quartz-auto-dark input[class^=ag-][type=tel],\n.ag-theme-quartz-auto-dark input[class^=ag-][type=date],\n.ag-theme-quartz-auto-dark input[class^=ag-][type=datetime-local],\n.ag-theme-quartz-auto-dark textarea[class^=ag-] {\n  min-height: calc(var(--ag-grid-size) * 4);\n  border-radius: var(--ag-border-radius);\n}\n.ag-theme-quartz .ag-ltr input[class^=ag-]:not([type]), .ag-theme-quartz .ag-ltr input[class^=ag-][type=text], .ag-theme-quartz .ag-ltr input[class^=ag-][type=number], .ag-theme-quartz .ag-ltr input[class^=ag-][type=tel], .ag-theme-quartz .ag-ltr input[class^=ag-][type=date], .ag-theme-quartz .ag-ltr input[class^=ag-][type=datetime-local], .ag-theme-quartz .ag-ltr textarea[class^=ag-], .ag-theme-quartz-dark .ag-ltr input[class^=ag-]:not([type]), .ag-theme-quartz-dark .ag-ltr input[class^=ag-][type=text], .ag-theme-quartz-dark .ag-ltr input[class^=ag-][type=number], .ag-theme-quartz-dark .ag-ltr input[class^=ag-][type=tel], .ag-theme-quartz-dark .ag-ltr input[class^=ag-][type=date], .ag-theme-quartz-dark .ag-ltr input[class^=ag-][type=datetime-local], .ag-theme-quartz-dark .ag-ltr textarea[class^=ag-], .ag-theme-quartz-auto-dark .ag-ltr input[class^=ag-]:not([type]), .ag-theme-quartz-auto-dark .ag-ltr input[class^=ag-][type=text], .ag-theme-quartz-auto-dark .ag-ltr input[class^=ag-][type=number], .ag-theme-quartz-auto-dark .ag-ltr input[class^=ag-][type=tel], .ag-theme-quartz-auto-dark .ag-ltr input[class^=ag-][type=date], .ag-theme-quartz-auto-dark .ag-ltr input[class^=ag-][type=datetime-local], .ag-theme-quartz-auto-dark .ag-ltr textarea[class^=ag-] {\n  padding-left: var(--ag-grid-size);\n}\n\n.ag-theme-quartz .ag-rtl input[class^=ag-]:not([type]), .ag-theme-quartz .ag-rtl input[class^=ag-][type=text], .ag-theme-quartz .ag-rtl input[class^=ag-][type=number], .ag-theme-quartz .ag-rtl input[class^=ag-][type=tel], .ag-theme-quartz .ag-rtl input[class^=ag-][type=date], .ag-theme-quartz .ag-rtl input[class^=ag-][type=datetime-local], .ag-theme-quartz .ag-rtl textarea[class^=ag-], .ag-theme-quartz-dark .ag-rtl input[class^=ag-]:not([type]), .ag-theme-quartz-dark .ag-rtl input[class^=ag-][type=text], .ag-theme-quartz-dark .ag-rtl input[class^=ag-][type=number], .ag-theme-quartz-dark .ag-rtl input[class^=ag-][type=tel], .ag-theme-quartz-dark .ag-rtl input[class^=ag-][type=date], .ag-theme-quartz-dark .ag-rtl input[class^=ag-][type=datetime-local], .ag-theme-quartz-dark .ag-rtl textarea[class^=ag-], .ag-theme-quartz-auto-dark .ag-rtl input[class^=ag-]:not([type]), .ag-theme-quartz-auto-dark .ag-rtl input[class^=ag-][type=text], .ag-theme-quartz-auto-dark .ag-rtl input[class^=ag-][type=number], .ag-theme-quartz-auto-dark .ag-rtl input[class^=ag-][type=tel], .ag-theme-quartz-auto-dark .ag-rtl input[class^=ag-][type=date], .ag-theme-quartz-auto-dark .ag-rtl input[class^=ag-][type=datetime-local], .ag-theme-quartz-auto-dark .ag-rtl textarea[class^=ag-] {\n  padding-right: var(--ag-grid-size);\n}\n\n.ag-theme-quartz .ag-picker-field-wrapper,\n.ag-theme-quartz-dark .ag-picker-field-wrapper,\n.ag-theme-quartz-auto-dark .ag-picker-field-wrapper {\n  min-height: calc(var(--ag-grid-size) * 4);\n}\n.ag-theme-quartz .ag-tab,\n.ag-theme-quartz-dark .ag-tab,\n.ag-theme-quartz-auto-dark .ag-tab {\n  padding: var(--ag-grid-size);\n  border-left: var(--ag-borders) transparent;\n  border-right: var(--ag-borders) transparent;\n  flex: 1 1 auto;\n}\n.ag-theme-quartz .ag-tab-selected,\n.ag-theme-quartz-dark .ag-tab-selected,\n.ag-theme-quartz-auto-dark .ag-tab-selected {\n  background-color: var(--ag-background-color);\n}\n.ag-theme-quartz .ag-ltr .ag-tab-selected:not(:first-of-type), .ag-theme-quartz-dark .ag-ltr .ag-tab-selected:not(:first-of-type), .ag-theme-quartz-auto-dark .ag-ltr .ag-tab-selected:not(:first-of-type) {\n  border-left-color: var(--ag-border-color);\n}\n\n.ag-theme-quartz .ag-rtl .ag-tab-selected:not(:first-of-type), .ag-theme-quartz-dark .ag-rtl .ag-tab-selected:not(:first-of-type), .ag-theme-quartz-auto-dark .ag-rtl .ag-tab-selected:not(:first-of-type) {\n  border-right-color: var(--ag-border-color);\n}\n\n.ag-theme-quartz .ag-ltr .ag-tab-selected:not(:last-of-type), .ag-theme-quartz-dark .ag-ltr .ag-tab-selected:not(:last-of-type), .ag-theme-quartz-auto-dark .ag-ltr .ag-tab-selected:not(:last-of-type) {\n  border-right-color: var(--ag-border-color);\n}\n\n.ag-theme-quartz .ag-rtl .ag-tab-selected:not(:last-of-type), .ag-theme-quartz-dark .ag-rtl .ag-tab-selected:not(:last-of-type), .ag-theme-quartz-auto-dark .ag-rtl .ag-tab-selected:not(:last-of-type) {\n  border-left-color: var(--ag-border-color);\n}\n\n.ag-theme-quartz .ag-tab:not(.ag-tab-selected),\n.ag-theme-quartz-dark .ag-tab:not(.ag-tab-selected),\n.ag-theme-quartz-auto-dark .ag-tab:not(.ag-tab-selected) {\n  opacity: 0.7;\n}\n.ag-theme-quartz .ag-tab:not(.ag-tab-selected):hover,\n.ag-theme-quartz-dark .ag-tab:not(.ag-tab-selected):hover,\n.ag-theme-quartz-auto-dark .ag-tab:not(.ag-tab-selected):hover {\n  opacity: 1;\n}\n.ag-theme-quartz .ag-menu,\n.ag-theme-quartz-dark .ag-menu,\n.ag-theme-quartz-auto-dark .ag-menu {\n  color: color-mix(in srgb, transparent, var(--ag-foreground-color) 95%);\n}\n.ag-theme-quartz .ag-panel-content-wrapper .ag-column-select,\n.ag-theme-quartz-dark .ag-panel-content-wrapper .ag-column-select,\n.ag-theme-quartz-auto-dark .ag-panel-content-wrapper .ag-column-select {\n  background-color: var(--ag-control-panel-background-color);\n  color: color-mix(in srgb, transparent, var(--ag-foreground-color) 95%);\n}\n.ag-theme-quartz .ag-menu-header,\n.ag-theme-quartz-dark .ag-menu-header,\n.ag-theme-quartz-auto-dark .ag-menu-header {\n  background-color: var(--ag-control-panel-background-color);\n}\n.ag-theme-quartz .ag-menu-option,\n.ag-theme-quartz-dark .ag-menu-option,\n.ag-theme-quartz-auto-dark .ag-menu-option {\n  font-weight: 500;\n  cursor: pointer;\n}\n.ag-theme-quartz .ag-ltr .ag-menu-option-popup-pointer .ag-icon, .ag-theme-quartz-dark .ag-ltr .ag-menu-option-popup-pointer .ag-icon, .ag-theme-quartz-auto-dark .ag-ltr .ag-menu-option-popup-pointer .ag-icon {\n  text-align: right;\n}\n\n.ag-theme-quartz .ag-rtl .ag-menu-option-popup-pointer .ag-icon, .ag-theme-quartz-dark .ag-rtl .ag-menu-option-popup-pointer .ag-icon, .ag-theme-quartz-auto-dark .ag-rtl .ag-menu-option-popup-pointer .ag-icon {\n  text-align: left;\n}\n\n.ag-theme-quartz .ag-tabs-header,\n.ag-theme-quartz-dark .ag-tabs-header,\n.ag-theme-quartz-auto-dark .ag-tabs-header {\n  border-bottom: var(--ag-borders) var(--ag-border-color);\n  display: flex;\n  background-color: color-mix(in srgb, transparent, var(--ag-foreground-color) 5%);\n}\n.ag-theme-quartz .ag-side-bar,\n.ag-theme-quartz-dark .ag-side-bar,\n.ag-theme-quartz-auto-dark .ag-side-bar {\n  background-color: var(--ag-control-panel-background-color);\n  min-width: calc(var(--ag-icon-size) + var(--ag-grid-size) * 2);\n}\n.ag-theme-quartz .ag-side-buttons,\n.ag-theme-quartz-dark .ag-side-buttons,\n.ag-theme-quartz-auto-dark .ag-side-buttons {\n  padding: 0;\n  align-self: stretch;\n  width: calc(var(--ag-icon-size) + var(--ag-grid-size) * 2);\n  background: var(--ag-control-panel-background-color);\n}\n.ag-theme-quartz .ag-side-button,\n.ag-theme-quartz-dark .ag-side-button,\n.ag-theme-quartz-auto-dark .ag-side-button {\n  border-top: var(--ag-borders) transparent;\n  border-bottom: var(--ag-borders) transparent;\n}\n@media (max-resolution: 1.5x) {\n  .ag-theme-quartz .ag-side-button-label,\n  .ag-theme-quartz-dark .ag-side-button-label,\n  .ag-theme-quartz-auto-dark .ag-side-button-label {\n    font-family: \"Segoe UI\", var(--ag-font-family);\n    transform: rotate(0.05deg);\n  }\n}\n.ag-theme-quartz .ag-side-button.ag-selected,\n.ag-theme-quartz-dark .ag-side-button.ag-selected,\n.ag-theme-quartz-auto-dark .ag-side-button.ag-selected {\n  border-bottom-color: var(--ag-border-color);\n  background-color: var(--ag-background-color);\n}\n.ag-theme-quartz .ag-side-button.ag-selected:not(:first-of-type),\n.ag-theme-quartz-dark .ag-side-button.ag-selected:not(:first-of-type),\n.ag-theme-quartz-auto-dark .ag-side-button.ag-selected:not(:first-of-type) {\n  border-top-color: var(--ag-border-color);\n}\n.ag-theme-quartz .ag-column-panel-column-select,\n.ag-theme-quartz-dark .ag-column-panel-column-select,\n.ag-theme-quartz-auto-dark .ag-column-panel-column-select {\n  border-top: none;\n  border-bottom: 1px solid var(--ag-secondary-border-color);\n}\n.ag-theme-quartz .ag-filter-toolpanel-search,\n.ag-theme-quartz-dark .ag-filter-toolpanel-search,\n.ag-theme-quartz-auto-dark .ag-filter-toolpanel-search {\n  height: initial;\n  margin-top: var(--ag-widget-container-vertical-padding);\n}\n.ag-theme-quartz .ag-filter-toolpanel-search-input,\n.ag-theme-quartz-dark .ag-filter-toolpanel-search-input,\n.ag-theme-quartz-auto-dark .ag-filter-toolpanel-search-input {\n  margin: 0;\n}\n.ag-theme-quartz .ag-filter-apply-panel,\n.ag-theme-quartz-dark .ag-filter-apply-panel,\n.ag-theme-quartz-auto-dark .ag-filter-apply-panel {\n  border: none;\n  padding-top: var(--ag-widget-vertical-spacing);\n}\n.ag-theme-quartz .ag-chart-tabbed-menu-body,\n.ag-theme-quartz-dark .ag-chart-tabbed-menu-body,\n.ag-theme-quartz-auto-dark .ag-chart-tabbed-menu-body {\n  position: relative;\n}\n.ag-theme-quartz .ag-chart-tabbed-menu-body::after,\n.ag-theme-quartz-dark .ag-chart-tabbed-menu-body::after,\n.ag-theme-quartz-auto-dark .ag-chart-tabbed-menu-body::after {\n  content: \"\";\n  position: absolute;\n  display: block;\n  top: 0;\n  left: 0;\n  right: 0;\n  height: 16px;\n  background: linear-gradient(var(--ag-control-panel-background-color), transparent);\n}\n.ag-theme-quartz .ag-charts-settings-group-title-bar,\n.ag-theme-quartz .ag-charts-data-group-title-bar,\n.ag-theme-quartz .ag-charts-format-top-level-group-title-bar,\n.ag-theme-quartz .ag-charts-advanced-settings-top-level-group-title-bar,\n.ag-theme-quartz .ag-charts-settings-group-container,\n.ag-theme-quartz-dark .ag-charts-settings-group-title-bar,\n.ag-theme-quartz-dark .ag-charts-data-group-title-bar,\n.ag-theme-quartz-dark .ag-charts-format-top-level-group-title-bar,\n.ag-theme-quartz-dark .ag-charts-advanced-settings-top-level-group-title-bar,\n.ag-theme-quartz-dark .ag-charts-settings-group-container,\n.ag-theme-quartz-auto-dark .ag-charts-settings-group-title-bar,\n.ag-theme-quartz-auto-dark .ag-charts-data-group-title-bar,\n.ag-theme-quartz-auto-dark .ag-charts-format-top-level-group-title-bar,\n.ag-theme-quartz-auto-dark .ag-charts-advanced-settings-top-level-group-title-bar,\n.ag-theme-quartz-auto-dark .ag-charts-settings-group-container {\n  border-top: none;\n  font-weight: 500;\n}\n.ag-theme-quartz .ag-chart-mini-thumbnail,\n.ag-theme-quartz-dark .ag-chart-mini-thumbnail,\n.ag-theme-quartz-auto-dark .ag-chart-mini-thumbnail {\n  background-color: var(--ag-background-color);\n  margin-top: 0;\n  margin-bottom: 0;\n}\n.ag-theme-quartz .ag-chart-settings-nav-bar,\n.ag-theme-quartz-dark .ag-chart-settings-nav-bar,\n.ag-theme-quartz-auto-dark .ag-chart-settings-nav-bar {\n  border-top: var(--ag-borders-secondary) var(--ag-secondary-border-color);\n}\n.ag-theme-quartz .ag-charts-format-sub-level-group-title-bar,\n.ag-theme-quartz-dark .ag-charts-format-sub-level-group-title-bar,\n.ag-theme-quartz-auto-dark .ag-charts-format-sub-level-group-title-bar {\n  background: none;\n  font-weight: 500;\n}\n.ag-theme-quartz .ag-chart-data-section .ag-label:not(.ag-group-title-bar),\n.ag-theme-quartz .ag-chart-format-section .ag-label:not(.ag-group-title-bar),\n.ag-theme-quartz-dark .ag-chart-data-section .ag-label:not(.ag-group-title-bar),\n.ag-theme-quartz-dark .ag-chart-format-section .ag-label:not(.ag-group-title-bar),\n.ag-theme-quartz-auto-dark .ag-chart-data-section .ag-label:not(.ag-group-title-bar),\n.ag-theme-quartz-auto-dark .ag-chart-format-section .ag-label:not(.ag-group-title-bar) {\n  color: var(--ag-chart-menu-label-color);\n}\n.ag-theme-quartz .ag-chart-data-section .ag-label-align-top .ag-label,\n.ag-theme-quartz .ag-chart-format-section .ag-label-align-top .ag-label,\n.ag-theme-quartz-dark .ag-chart-data-section .ag-label-align-top .ag-label,\n.ag-theme-quartz-dark .ag-chart-format-section .ag-label-align-top .ag-label,\n.ag-theme-quartz-auto-dark .ag-chart-data-section .ag-label-align-top .ag-label,\n.ag-theme-quartz-auto-dark .ag-chart-format-section .ag-label-align-top .ag-label {\n  margin-top: calc(var(--ag-widget-vertical-spacing) * 0.5);\n  margin-bottom: var(--ag-widget-vertical-spacing);\n}\n.ag-theme-quartz .ag-chart-data-section .ag-slider.ag-label-align-top .ag-label,\n.ag-theme-quartz .ag-chart-format-section .ag-slider.ag-label-align-top .ag-label,\n.ag-theme-quartz-dark .ag-chart-data-section .ag-slider.ag-label-align-top .ag-label,\n.ag-theme-quartz-dark .ag-chart-format-section .ag-slider.ag-label-align-top .ag-label,\n.ag-theme-quartz-auto-dark .ag-chart-data-section .ag-slider.ag-label-align-top .ag-label,\n.ag-theme-quartz-auto-dark .ag-chart-format-section .ag-slider.ag-label-align-top .ag-label {\n  margin-bottom: 0;\n}\n.ag-theme-quartz .ag-chart-data-section label,\n.ag-theme-quartz .ag-chart-format-section label,\n.ag-theme-quartz-dark .ag-chart-data-section label,\n.ag-theme-quartz-dark .ag-chart-format-section label,\n.ag-theme-quartz-auto-dark .ag-chart-data-section label,\n.ag-theme-quartz-auto-dark .ag-chart-format-section label {\n  display: inline-block;\n}\n.ag-theme-quartz .ag-chart-format-wrapper,\n.ag-theme-quartz .ag-chart-data-wrapper,\n.ag-theme-quartz .ag-charts-format-top-level-group,\n.ag-theme-quartz .ag-charts-format-top-level-group-title-bar,\n.ag-theme-quartz .ag-charts-format-top-level-group .ag-charts-format-top-level-group-container,\n.ag-theme-quartz .ag-charts-format-top-level-group-item,\n.ag-theme-quartz .ag-charts-format-sub-level-group,\n.ag-theme-quartz .ag-charts-format-sub-level-group-title-bar,\n.ag-theme-quartz .ag-charts-format-sub-level-group-container,\n.ag-theme-quartz .ag-charts-format-sub-level-group-item:last-child,\n.ag-theme-quartz .ag-charts-format-sub-level-group-container > *,\n.ag-theme-quartz .ag-charts-data-group-title-bar,\n.ag-theme-quartz .ag-charts-data-group-container,\n.ag-theme-quartz .ag-charts-settings-group-title-bar,\n.ag-theme-quartz .ag-charts-settings-group-container,\n.ag-theme-quartz-dark .ag-chart-format-wrapper,\n.ag-theme-quartz-dark .ag-chart-data-wrapper,\n.ag-theme-quartz-dark .ag-charts-format-top-level-group,\n.ag-theme-quartz-dark .ag-charts-format-top-level-group-title-bar,\n.ag-theme-quartz-dark .ag-charts-format-top-level-group .ag-charts-format-top-level-group-container,\n.ag-theme-quartz-dark .ag-charts-format-top-level-group-item,\n.ag-theme-quartz-dark .ag-charts-format-sub-level-group,\n.ag-theme-quartz-dark .ag-charts-format-sub-level-group-title-bar,\n.ag-theme-quartz-dark .ag-charts-format-sub-level-group-container,\n.ag-theme-quartz-dark .ag-charts-format-sub-level-group-item:last-child,\n.ag-theme-quartz-dark .ag-charts-format-sub-level-group-container > *,\n.ag-theme-quartz-dark .ag-charts-data-group-title-bar,\n.ag-theme-quartz-dark .ag-charts-data-group-container,\n.ag-theme-quartz-dark .ag-charts-settings-group-title-bar,\n.ag-theme-quartz-dark .ag-charts-settings-group-container,\n.ag-theme-quartz-auto-dark .ag-chart-format-wrapper,\n.ag-theme-quartz-auto-dark .ag-chart-data-wrapper,\n.ag-theme-quartz-auto-dark .ag-charts-format-top-level-group,\n.ag-theme-quartz-auto-dark .ag-charts-format-top-level-group-title-bar,\n.ag-theme-quartz-auto-dark .ag-charts-format-top-level-group .ag-charts-format-top-level-group-container,\n.ag-theme-quartz-auto-dark .ag-charts-format-top-level-group-item,\n.ag-theme-quartz-auto-dark .ag-charts-format-sub-level-group,\n.ag-theme-quartz-auto-dark .ag-charts-format-sub-level-group-title-bar,\n.ag-theme-quartz-auto-dark .ag-charts-format-sub-level-group-container,\n.ag-theme-quartz-auto-dark .ag-charts-format-sub-level-group-item:last-child,\n.ag-theme-quartz-auto-dark .ag-charts-format-sub-level-group-container > *,\n.ag-theme-quartz-auto-dark .ag-charts-data-group-title-bar,\n.ag-theme-quartz-auto-dark .ag-charts-data-group-container,\n.ag-theme-quartz-auto-dark .ag-charts-settings-group-title-bar,\n.ag-theme-quartz-auto-dark .ag-charts-settings-group-container {\n  padding: 0;\n  margin: 0;\n}\n.ag-theme-quartz .ag-charts-format-top-level-group,\n.ag-theme-quartz .ag-charts-data-group,\n.ag-theme-quartz-dark .ag-charts-format-top-level-group,\n.ag-theme-quartz-dark .ag-charts-data-group,\n.ag-theme-quartz-auto-dark .ag-charts-format-top-level-group,\n.ag-theme-quartz-auto-dark .ag-charts-data-group {\n  border-top: var(--ag-borders-secondary) var(--ag-secondary-border-color);\n}\n.ag-theme-quartz .ag-charts-format-top-level-group-title-bar,\n.ag-theme-quartz .ag-charts-data-group-title-bar,\n.ag-theme-quartz .ag-charts-settings-group-title-bar,\n.ag-theme-quartz-dark .ag-charts-format-top-level-group-title-bar,\n.ag-theme-quartz-dark .ag-charts-data-group-title-bar,\n.ag-theme-quartz-dark .ag-charts-settings-group-title-bar,\n.ag-theme-quartz-auto-dark .ag-charts-format-top-level-group-title-bar,\n.ag-theme-quartz-auto-dark .ag-charts-data-group-title-bar,\n.ag-theme-quartz-auto-dark .ag-charts-settings-group-title-bar {\n  padding: var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding);\n}\n.ag-theme-quartz .ag-charts-format-top-level-group .ag-charts-format-top-level-group-container,\n.ag-theme-quartz .ag-charts-data-group .ag-charts-data-group-container,\n.ag-theme-quartz .ag-charts-settings-group .ag-charts-settings-group-container,\n.ag-theme-quartz-dark .ag-charts-format-top-level-group .ag-charts-format-top-level-group-container,\n.ag-theme-quartz-dark .ag-charts-data-group .ag-charts-data-group-container,\n.ag-theme-quartz-dark .ag-charts-settings-group .ag-charts-settings-group-container,\n.ag-theme-quartz-auto-dark .ag-charts-format-top-level-group .ag-charts-format-top-level-group-container,\n.ag-theme-quartz-auto-dark .ag-charts-data-group .ag-charts-data-group-container,\n.ag-theme-quartz-auto-dark .ag-charts-settings-group .ag-charts-settings-group-container {\n  padding: 0 var(--ag-widget-container-horizontal-padding);\n}\n.ag-theme-quartz .ag-charts-format-sub-level-group-title-bar,\n.ag-theme-quartz-dark .ag-charts-format-sub-level-group-title-bar,\n.ag-theme-quartz-auto-dark .ag-charts-format-sub-level-group-title-bar {\n  padding: var(--ag-widget-vertical-spacing) 0;\n}\n.ag-theme-quartz .ag-charts-format-sub-level-group-container,\n.ag-theme-quartz-dark .ag-charts-format-sub-level-group-container,\n.ag-theme-quartz-auto-dark .ag-charts-format-sub-level-group-container {\n  padding-top: var(--ag-widget-vertical-spacing);\n  padding-bottom: var(--ag-widget-container-vertical-padding);\n}\n.ag-theme-quartz .ag-charts-format-top-level-group-container > *,\n.ag-theme-quartz .ag-charts-format-sub-level-group-container > *,\n.ag-theme-quartz-dark .ag-charts-format-top-level-group-container > *,\n.ag-theme-quartz-dark .ag-charts-format-sub-level-group-container > *,\n.ag-theme-quartz-auto-dark .ag-charts-format-top-level-group-container > *,\n.ag-theme-quartz-auto-dark .ag-charts-format-sub-level-group-container > * {\n  margin-bottom: var(--ag-widget-vertical-spacing);\n}\n.ag-theme-quartz .ag-charts-data-group-item,\n.ag-theme-quartz-dark .ag-charts-data-group-item,\n.ag-theme-quartz-auto-dark .ag-charts-data-group-item {\n  padding-bottom: var(--ag-widget-container-vertical-padding);\n}\n.ag-theme-quartz .ag-chart-settings-mini-wrapper,\n.ag-theme-quartz-dark .ag-chart-settings-mini-wrapper,\n.ag-theme-quartz-auto-dark .ag-chart-settings-mini-wrapper {\n  padding-bottom: var(--ag-widget-container-vertical-padding);\n}\n.ag-theme-quartz .ag-chart-advanced-settings-section,\n.ag-theme-quartz-dark .ag-chart-advanced-settings-section,\n.ag-theme-quartz-auto-dark .ag-chart-advanced-settings-section {\n  padding-top: var(--ag-widget-container-vertical-padding);\n  padding-bottom: var(--ag-widget-container-vertical-padding);\n}\n.ag-theme-quartz .ag-charts-advanced-settings-top-level-group .ag-charts-advanced-settings-top-level-group-title-bar,\n.ag-theme-quartz .ag-charts-advanced-settings-top-level-group .ag-charts-advanced-settings-top-level-group-container,\n.ag-theme-quartz-dark .ag-charts-advanced-settings-top-level-group .ag-charts-advanced-settings-top-level-group-title-bar,\n.ag-theme-quartz-dark .ag-charts-advanced-settings-top-level-group .ag-charts-advanced-settings-top-level-group-container,\n.ag-theme-quartz-auto-dark .ag-charts-advanced-settings-top-level-group .ag-charts-advanced-settings-top-level-group-title-bar,\n.ag-theme-quartz-auto-dark .ag-charts-advanced-settings-top-level-group .ag-charts-advanced-settings-top-level-group-container {\n  padding: 0 var(--ag-widget-container-horizontal-padding);\n}\n.ag-theme-quartz .ag-charts-advanced-settings-top-level-group-container,\n.ag-theme-quartz-dark .ag-charts-advanced-settings-top-level-group-container,\n.ag-theme-quartz-auto-dark .ag-charts-advanced-settings-top-level-group-container {\n  margin: 0;\n}\n.ag-theme-quartz .ag-charts-advanced-settings-top-level-group-item,\n.ag-theme-quartz-dark .ag-charts-advanced-settings-top-level-group-item,\n.ag-theme-quartz-auto-dark .ag-charts-advanced-settings-top-level-group-item {\n  margin-top: calc(var(--ag-widget-vertical-spacing) * 2);\n  margin-bottom: 0;\n}\n.ag-theme-quartz .ag-ltr .ag-group-title-bar-icon, .ag-theme-quartz-dark .ag-ltr .ag-group-title-bar-icon, .ag-theme-quartz-auto-dark .ag-ltr .ag-group-title-bar-icon {\n  margin-right: var(--ag-grid-size);\n}\n\n.ag-theme-quartz .ag-rtl .ag-group-title-bar-icon, .ag-theme-quartz-dark .ag-rtl .ag-group-title-bar-icon, .ag-theme-quartz-auto-dark .ag-rtl .ag-group-title-bar-icon {\n  margin-left: var(--ag-grid-size);\n}\n\n.ag-theme-quartz .ag-spectrum-color,\n.ag-theme-quartz .ag-spectrum-fill,\n.ag-theme-quartz-dark .ag-spectrum-color,\n.ag-theme-quartz-dark .ag-spectrum-fill,\n.ag-theme-quartz-auto-dark .ag-spectrum-color,\n.ag-theme-quartz-auto-dark .ag-spectrum-fill {\n  border-radius: var(--ag-border-radius);\n}\n.ag-theme-quartz .ag-spectrum-dragger,\n.ag-theme-quartz-dark .ag-spectrum-dragger,\n.ag-theme-quartz-auto-dark .ag-spectrum-dragger {\n  border-radius: 18px;\n  height: 18px;\n  width: 18px;\n  border: 3px solid white;\n}\n.ag-theme-quartz .ag-spectrum-tools,\n.ag-theme-quartz-dark .ag-spectrum-tools,\n.ag-theme-quartz-auto-dark .ag-spectrum-tools {\n  padding-left: 0;\n  padding-right: 0;\n  padding-bottom: 0;\n}\n.ag-theme-quartz .ag-spectrum-tool,\n.ag-theme-quartz-dark .ag-spectrum-tool,\n.ag-theme-quartz-auto-dark .ag-spectrum-tool {\n  height: 12px;\n}\n.ag-theme-quartz .ag-spectrum-hue-background,\n.ag-theme-quartz .ag-spectrum-alpha-background,\n.ag-theme-quartz-dark .ag-spectrum-hue-background,\n.ag-theme-quartz-dark .ag-spectrum-alpha-background,\n.ag-theme-quartz-auto-dark .ag-spectrum-hue-background,\n.ag-theme-quartz-auto-dark .ag-spectrum-alpha-background {\n  border-radius: 12px;\n}\n.ag-theme-quartz .ag-spectrum-slider,\n.ag-theme-quartz-dark .ag-spectrum-slider,\n.ag-theme-quartz-auto-dark .ag-spectrum-slider {\n  margin-top: -15px;\n  width: 18px;\n  height: 18px;\n  border-radius: 18px;\n  border: 3px solid rgb(248, 248, 248);\n}\n.ag-theme-quartz .ag-recent-colors,\n.ag-theme-quartz-dark .ag-recent-colors,\n.ag-theme-quartz-auto-dark .ag-recent-colors {\n  margin-left: var(--ag-grid-size);\n  margin-right: var(--ag-grid-size);\n  margin-bottom: 2px;\n}\n.ag-theme-quartz .ag-color-input-color,\n.ag-theme-quartz .ag-color-picker-color,\n.ag-theme-quartz .ag-recent-color,\n.ag-theme-quartz-dark .ag-color-input-color,\n.ag-theme-quartz-dark .ag-color-picker-color,\n.ag-theme-quartz-dark .ag-recent-color,\n.ag-theme-quartz-auto-dark .ag-color-input-color,\n.ag-theme-quartz-auto-dark .ag-color-picker-color,\n.ag-theme-quartz-auto-dark .ag-recent-color {\n  border-radius: 4px;\n}\n.ag-theme-quartz .ag-recent-color,\n.ag-theme-quartz-dark .ag-recent-color,\n.ag-theme-quartz-auto-dark .ag-recent-color {\n  border: var(--ag-borders-secondary) var(--ag-secondary-border-color);\n}\n.ag-theme-quartz.ag-dnd-ghost,\n.ag-theme-quartz-dark.ag-dnd-ghost,\n.ag-theme-quartz-auto-dark.ag-dnd-ghost {\n  font-weight: 500;\n}\n.ag-theme-quartz .ag-standard-button,\n.ag-theme-quartz-dark .ag-standard-button,\n.ag-theme-quartz-auto-dark .ag-standard-button {\n  font-family: inherit;\n  appearance: none;\n  -webkit-appearance: none;\n  border-radius: var(--ag-border-radius);\n  border: solid 1px var(--ag-input-border-color);\n  background-color: var(--ag-background-color);\n  padding: var(--ag-grid-size) calc(var(--ag-grid-size) * 2);\n  cursor: pointer;\n}\n.ag-theme-quartz .ag-standard-button:hover,\n.ag-theme-quartz-dark .ag-standard-button:hover,\n.ag-theme-quartz-auto-dark .ag-standard-button:hover {\n  background-color: var(--ag-row-hover-color);\n}\n.ag-theme-quartz .ag-standard-button:active,\n.ag-theme-quartz-dark .ag-standard-button:active,\n.ag-theme-quartz-auto-dark .ag-standard-button:active {\n  border-color: var(--ag-active-color);\n}\n.ag-theme-quartz .ag-standard-button:disabled,\n.ag-theme-quartz-dark .ag-standard-button:disabled,\n.ag-theme-quartz-auto-dark .ag-standard-button:disabled {\n  color: var(--ag-disabled-foreground-color);\n  background-color: var(--ag-input-disabled-background-color);\n  border-color: var(--ag-input-disabled-border-color);\n}\n.ag-theme-quartz .ag-column-drop-cell,\n.ag-theme-quartz-dark .ag-column-drop-cell,\n.ag-theme-quartz-auto-dark .ag-column-drop-cell {\n  border-radius: calc(var(--ag-grid-size) * 3);\n  height: calc(var(--ag-grid-size) * 3);\n  padding: 0 var(--ag-grid-size);\n}\n.ag-theme-quartz .ag-column-drop-cell-button,\n.ag-theme-quartz-dark .ag-column-drop-cell-button,\n.ag-theme-quartz-auto-dark .ag-column-drop-cell-button {\n  min-width: 0;\n  margin: 0;\n}\n.ag-theme-quartz .ag-column-drop-cell-drag-handle,\n.ag-theme-quartz-dark .ag-column-drop-cell-drag-handle,\n.ag-theme-quartz-auto-dark .ag-column-drop-cell-drag-handle {\n  margin-left: 0;\n}\n.ag-theme-quartz .ag-column-drop-vertical,\n.ag-theme-quartz-dark .ag-column-drop-vertical,\n.ag-theme-quartz-auto-dark .ag-column-drop-vertical {\n  min-height: 75px;\n}\n.ag-theme-quartz .ag-column-drop-vertical-title-bar,\n.ag-theme-quartz-dark .ag-column-drop-vertical-title-bar,\n.ag-theme-quartz-auto-dark .ag-column-drop-vertical-title-bar {\n  padding: var(--ag-widget-container-vertical-padding) calc(var(--ag-grid-size) * 2) 0;\n}\n.ag-theme-quartz .ag-ltr .ag-column-drop-vertical-icon, .ag-theme-quartz-dark .ag-ltr .ag-column-drop-vertical-icon, .ag-theme-quartz-auto-dark .ag-ltr .ag-column-drop-vertical-icon {\n  margin-left: 0;\n  margin-right: var(--ag-widget-horizontal-spacing);\n}\n\n.ag-theme-quartz .ag-rtl .ag-column-drop-vertical-icon, .ag-theme-quartz-dark .ag-rtl .ag-column-drop-vertical-icon, .ag-theme-quartz-auto-dark .ag-rtl .ag-column-drop-vertical-icon {\n  margin-right: 0;\n  margin-left: var(--ag-widget-horizontal-spacing);\n}\n\n.ag-theme-quartz .ag-column-drop-vertical-empty-message,\n.ag-theme-quartz-dark .ag-column-drop-vertical-empty-message,\n.ag-theme-quartz-auto-dark .ag-column-drop-vertical-empty-message {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  border: dashed 1px;\n  border-color: var(--ag-border-color);\n  margin: calc(var(--ag-grid-size) * 1.5) calc(var(--ag-grid-size) * 2);\n  padding: calc(var(--ag-grid-size) * 2);\n}\n.ag-theme-quartz .ag-column-drop-empty-message,\n.ag-theme-quartz-dark .ag-column-drop-empty-message,\n.ag-theme-quartz-auto-dark .ag-column-drop-empty-message {\n  color: var(--ag-foreground-color);\n}\n.ag-theme-quartz .ag-pill-select .ag-column-drop,\n.ag-theme-quartz-dark .ag-pill-select .ag-column-drop,\n.ag-theme-quartz-auto-dark .ag-pill-select .ag-column-drop {\n  min-height: unset;\n}\n.ag-theme-quartz .ag-pill-select .ag-picker-field-display,\n.ag-theme-quartz-dark .ag-pill-select .ag-picker-field-display,\n.ag-theme-quartz-auto-dark .ag-pill-select .ag-picker-field-display {\n  font-weight: 500;\n  color: var(--ag-chart-menu-pill-select-button-color);\n}\n.ag-theme-quartz .ag-pill-select .ag-picker-field-icon .ag-icon,\n.ag-theme-quartz-dark .ag-pill-select .ag-picker-field-icon .ag-icon,\n.ag-theme-quartz-auto-dark .ag-pill-select .ag-picker-field-icon .ag-icon {\n  color: var(--ag-chart-menu-pill-select-button-color);\n}\n.ag-theme-quartz .ag-status-bar,\n.ag-theme-quartz-dark .ag-status-bar,\n.ag-theme-quartz-auto-dark .ag-status-bar {\n  font-weight: normal;\n}\n.ag-theme-quartz .ag-status-name-value,\n.ag-theme-quartz-dark .ag-status-name-value,\n.ag-theme-quartz-auto-dark .ag-status-name-value {\n  padding: var(--ag-widget-container-vertical-padding) 0;\n}\n.ag-theme-quartz .ag-status-name-value-value,\n.ag-theme-quartz .ag-paging-number,\n.ag-theme-quartz .ag-paging-row-summary-panel-number,\n.ag-theme-quartz-dark .ag-status-name-value-value,\n.ag-theme-quartz-dark .ag-paging-number,\n.ag-theme-quartz-dark .ag-paging-row-summary-panel-number,\n.ag-theme-quartz-auto-dark .ag-status-name-value-value,\n.ag-theme-quartz-auto-dark .ag-paging-number,\n.ag-theme-quartz-auto-dark .ag-paging-row-summary-panel-number {\n  font-weight: 500;\n}\n.ag-theme-quartz .ag-column-drop-cell-button,\n.ag-theme-quartz-dark .ag-column-drop-cell-button,\n.ag-theme-quartz-auto-dark .ag-column-drop-cell-button {\n  opacity: 0.75;\n}\n.ag-theme-quartz .ag-column-drop-cell-button:hover,\n.ag-theme-quartz-dark .ag-column-drop-cell-button:hover,\n.ag-theme-quartz-auto-dark .ag-column-drop-cell-button:hover {\n  opacity: 1;\n}\n.ag-theme-quartz .ag-header-cell-menu-button,\n.ag-theme-quartz .ag-header-cell-filter-button,\n.ag-theme-quartz .ag-panel-title-bar-button,\n.ag-theme-quartz .ag-header-expand-icon,\n.ag-theme-quartz .ag-column-group-icons,\n.ag-theme-quartz .ag-set-filter-group-icons,\n.ag-theme-quartz .ag-group-expanded .ag-icon,\n.ag-theme-quartz .ag-group-contracted .ag-icon,\n.ag-theme-quartz .ag-chart-settings-prev,\n.ag-theme-quartz .ag-chart-settings-next,\n.ag-theme-quartz .ag-group-title-bar-icon,\n.ag-theme-quartz .ag-column-select-header-icon,\n.ag-theme-quartz .ag-floating-filter-button-button,\n.ag-theme-quartz .ag-filter-toolpanel-expand,\n.ag-theme-quartz .ag-panel-title-bar-button-icon,\n.ag-theme-quartz .ag-chart-menu-icon,\n.ag-theme-quartz-dark .ag-header-cell-menu-button,\n.ag-theme-quartz-dark .ag-header-cell-filter-button,\n.ag-theme-quartz-dark .ag-panel-title-bar-button,\n.ag-theme-quartz-dark .ag-header-expand-icon,\n.ag-theme-quartz-dark .ag-column-group-icons,\n.ag-theme-quartz-dark .ag-set-filter-group-icons,\n.ag-theme-quartz-dark .ag-group-expanded .ag-icon,\n.ag-theme-quartz-dark .ag-group-contracted .ag-icon,\n.ag-theme-quartz-dark .ag-chart-settings-prev,\n.ag-theme-quartz-dark .ag-chart-settings-next,\n.ag-theme-quartz-dark .ag-group-title-bar-icon,\n.ag-theme-quartz-dark .ag-column-select-header-icon,\n.ag-theme-quartz-dark .ag-floating-filter-button-button,\n.ag-theme-quartz-dark .ag-filter-toolpanel-expand,\n.ag-theme-quartz-dark .ag-panel-title-bar-button-icon,\n.ag-theme-quartz-dark .ag-chart-menu-icon,\n.ag-theme-quartz-auto-dark .ag-header-cell-menu-button,\n.ag-theme-quartz-auto-dark .ag-header-cell-filter-button,\n.ag-theme-quartz-auto-dark .ag-panel-title-bar-button,\n.ag-theme-quartz-auto-dark .ag-header-expand-icon,\n.ag-theme-quartz-auto-dark .ag-column-group-icons,\n.ag-theme-quartz-auto-dark .ag-set-filter-group-icons,\n.ag-theme-quartz-auto-dark .ag-group-expanded .ag-icon,\n.ag-theme-quartz-auto-dark .ag-group-contracted .ag-icon,\n.ag-theme-quartz-auto-dark .ag-chart-settings-prev,\n.ag-theme-quartz-auto-dark .ag-chart-settings-next,\n.ag-theme-quartz-auto-dark .ag-group-title-bar-icon,\n.ag-theme-quartz-auto-dark .ag-column-select-header-icon,\n.ag-theme-quartz-auto-dark .ag-floating-filter-button-button,\n.ag-theme-quartz-auto-dark .ag-filter-toolpanel-expand,\n.ag-theme-quartz-auto-dark .ag-panel-title-bar-button-icon,\n.ag-theme-quartz-auto-dark .ag-chart-menu-icon {\n  --ag-quartz-icon-hover-color: color-mix(in srgb, transparent, var(--ag-foreground-color) 10%);\n}\n.ag-theme-quartz .ag-header-cell-menu-button:hover,\n.ag-theme-quartz .ag-header-cell-filter-button:hover,\n.ag-theme-quartz .ag-panel-title-bar-button:hover,\n.ag-theme-quartz .ag-header-expand-icon:hover,\n.ag-theme-quartz .ag-column-group-icons:hover,\n.ag-theme-quartz .ag-set-filter-group-icons:hover,\n.ag-theme-quartz .ag-group-expanded .ag-icon:hover,\n.ag-theme-quartz .ag-group-contracted .ag-icon:hover,\n.ag-theme-quartz .ag-chart-settings-prev:hover,\n.ag-theme-quartz .ag-chart-settings-next:hover,\n.ag-theme-quartz .ag-group-title-bar-icon:hover,\n.ag-theme-quartz .ag-column-select-header-icon:hover,\n.ag-theme-quartz .ag-floating-filter-button-button:hover,\n.ag-theme-quartz .ag-filter-toolpanel-expand:hover,\n.ag-theme-quartz .ag-panel-title-bar-button-icon:hover,\n.ag-theme-quartz .ag-chart-menu-icon:hover,\n.ag-theme-quartz-dark .ag-header-cell-menu-button:hover,\n.ag-theme-quartz-dark .ag-header-cell-filter-button:hover,\n.ag-theme-quartz-dark .ag-panel-title-bar-button:hover,\n.ag-theme-quartz-dark .ag-header-expand-icon:hover,\n.ag-theme-quartz-dark .ag-column-group-icons:hover,\n.ag-theme-quartz-dark .ag-set-filter-group-icons:hover,\n.ag-theme-quartz-dark .ag-group-expanded .ag-icon:hover,\n.ag-theme-quartz-dark .ag-group-contracted .ag-icon:hover,\n.ag-theme-quartz-dark .ag-chart-settings-prev:hover,\n.ag-theme-quartz-dark .ag-chart-settings-next:hover,\n.ag-theme-quartz-dark .ag-group-title-bar-icon:hover,\n.ag-theme-quartz-dark .ag-column-select-header-icon:hover,\n.ag-theme-quartz-dark .ag-floating-filter-button-button:hover,\n.ag-theme-quartz-dark .ag-filter-toolpanel-expand:hover,\n.ag-theme-quartz-dark .ag-panel-title-bar-button-icon:hover,\n.ag-theme-quartz-dark .ag-chart-menu-icon:hover,\n.ag-theme-quartz-auto-dark .ag-header-cell-menu-button:hover,\n.ag-theme-quartz-auto-dark .ag-header-cell-filter-button:hover,\n.ag-theme-quartz-auto-dark .ag-panel-title-bar-button:hover,\n.ag-theme-quartz-auto-dark .ag-header-expand-icon:hover,\n.ag-theme-quartz-auto-dark .ag-column-group-icons:hover,\n.ag-theme-quartz-auto-dark .ag-set-filter-group-icons:hover,\n.ag-theme-quartz-auto-dark .ag-group-expanded .ag-icon:hover,\n.ag-theme-quartz-auto-dark .ag-group-contracted .ag-icon:hover,\n.ag-theme-quartz-auto-dark .ag-chart-settings-prev:hover,\n.ag-theme-quartz-auto-dark .ag-chart-settings-next:hover,\n.ag-theme-quartz-auto-dark .ag-group-title-bar-icon:hover,\n.ag-theme-quartz-auto-dark .ag-column-select-header-icon:hover,\n.ag-theme-quartz-auto-dark .ag-floating-filter-button-button:hover,\n.ag-theme-quartz-auto-dark .ag-filter-toolpanel-expand:hover,\n.ag-theme-quartz-auto-dark .ag-panel-title-bar-button-icon:hover,\n.ag-theme-quartz-auto-dark .ag-chart-menu-icon:hover {\n  border-radius: 1px;\n  background-color: var(--ag-quartz-icon-hover-color);\n  box-shadow: 0 0 0 4px var(--ag-quartz-icon-hover-color);\n}\n.ag-theme-quartz .ag-filter-active,\n.ag-theme-quartz-dark .ag-filter-active,\n.ag-theme-quartz-auto-dark .ag-filter-active {\n  --ag-quartz-icon-active-color: color-mix(in srgb, transparent, var(--ag-active-color) 14%);\n  --ag-quartz-icon-hover-color: color-mix(in srgb, transparent, var(--ag-active-color) 28%);\n  position: relative;\n  border-radius: 1px;\n  background-color: var(--ag-quartz-icon-active-color);\n  box-shadow: 0 0 0 4px var(--ag-quartz-icon-active-color);\n}\n.ag-theme-quartz .ag-filter-active::after,\n.ag-theme-quartz-dark .ag-filter-active::after,\n.ag-theme-quartz-auto-dark .ag-filter-active::after {\n  content: \"\";\n  position: absolute;\n  width: 6px;\n  height: 6px;\n  top: -1px;\n  right: -1px;\n  border-radius: 50%;\n  background-color: var(--ag-active-color);\n}\n.ag-theme-quartz .ag-filter-active .ag-icon-filter,\n.ag-theme-quartz-dark .ag-filter-active .ag-icon-filter,\n.ag-theme-quartz-auto-dark .ag-filter-active .ag-icon-filter {\n  clip-path: path(\"M8,0C8,4.415 11.585,8 16,8L16,16L0,16L0,0L8,0Z\");\n}\n.ag-theme-quartz .ag-chart-menu,\n.ag-theme-quartz-dark .ag-chart-menu,\n.ag-theme-quartz-auto-dark .ag-chart-menu {\n  --ag-icon-size: 20px;\n  background-color: color-mix(in srgb, transparent, var(--ag-background-color) 30%);\n  padding: 4px 2px;\n}\n.ag-theme-quartz .ag-chart-menu-icon,\n.ag-theme-quartz-dark .ag-chart-menu-icon,\n.ag-theme-quartz-auto-dark .ag-chart-menu-icon {\n  opacity: 0.8;\n}\n.ag-theme-quartz .ag-drag-handle,\n.ag-theme-quartz-dark .ag-drag-handle,\n.ag-theme-quartz-auto-dark .ag-drag-handle {\n  color: var(--ag-icon-font-color);\n}\n.ag-theme-quartz .ag-menu-option-icon,\n.ag-theme-quartz .ag-compact-menu-option-icon,\n.ag-theme-quartz-dark .ag-menu-option-icon,\n.ag-theme-quartz-dark .ag-compact-menu-option-icon,\n.ag-theme-quartz-auto-dark .ag-menu-option-icon,\n.ag-theme-quartz-auto-dark .ag-compact-menu-option-icon {\n  width: var(--ag-icon-size);\n  cursor: pointer;\n}\n.ag-theme-quartz .ag-ltr .ag-menu-option-icon, .ag-theme-quartz .ag-ltr .ag-compact-menu-option-icon, .ag-theme-quartz-dark .ag-ltr .ag-menu-option-icon, .ag-theme-quartz-dark .ag-ltr .ag-compact-menu-option-icon, .ag-theme-quartz-auto-dark .ag-ltr .ag-menu-option-icon, .ag-theme-quartz-auto-dark .ag-ltr .ag-compact-menu-option-icon {\n  padding-left: calc(var(--ag-grid-size) * 1.5);\n}\n\n.ag-theme-quartz .ag-rtl .ag-menu-option-icon, .ag-theme-quartz .ag-rtl .ag-compact-menu-option-icon, .ag-theme-quartz-dark .ag-rtl .ag-menu-option-icon, .ag-theme-quartz-dark .ag-rtl .ag-compact-menu-option-icon, .ag-theme-quartz-auto-dark .ag-rtl .ag-menu-option-icon, .ag-theme-quartz-auto-dark .ag-rtl .ag-compact-menu-option-icon {\n  padding-right: calc(var(--ag-grid-size) * 1.5);\n}\n\n.ag-theme-quartz .ag-chart-settings-card-item.ag-not-selected:hover,\n.ag-theme-quartz-dark .ag-chart-settings-card-item.ag-not-selected:hover,\n.ag-theme-quartz-auto-dark .ag-chart-settings-card-item.ag-not-selected:hover {\n  opacity: 0.35;\n}\n.ag-theme-quartz .ag-ltr .ag-panel-title-bar-button, .ag-theme-quartz-dark .ag-ltr .ag-panel-title-bar-button, .ag-theme-quartz-auto-dark .ag-ltr .ag-panel-title-bar-button {\n  margin-left: calc(var(--ag-grid-size) * 2);\n  margin-right: var(--ag-grid-size);\n}\n\n.ag-theme-quartz .ag-rtl .ag-panel-title-bar-button, .ag-theme-quartz-dark .ag-rtl .ag-panel-title-bar-button, .ag-theme-quartz-auto-dark .ag-rtl .ag-panel-title-bar-button {\n  margin-right: calc(var(--ag-grid-size) * 2);\n  margin-left: var(--ag-grid-size);\n}\n\n.ag-theme-quartz .ag-multi-filter-group-title-bar,\n.ag-theme-quartz-dark .ag-multi-filter-group-title-bar,\n.ag-theme-quartz-auto-dark .ag-multi-filter-group-title-bar {\n  padding: calc(var(--ag-grid-size) * 1.5) var(--ag-grid-size);\n}\n.ag-theme-quartz .ag-ltr .ag-filter-toolpanel-instance-body, .ag-theme-quartz-dark .ag-ltr .ag-filter-toolpanel-instance-body, .ag-theme-quartz-auto-dark .ag-ltr .ag-filter-toolpanel-instance-body {\n  padding-left: var(--ag-grid-size);\n}\n\n.ag-theme-quartz .ag-rtl .ag-filter-toolpanel-instance-body, .ag-theme-quartz-dark .ag-rtl .ag-filter-toolpanel-instance-body, .ag-theme-quartz-auto-dark .ag-rtl .ag-filter-toolpanel-instance-body {\n  padding-right: var(--ag-grid-size);\n}\n\n.ag-theme-quartz .ag-filter-toolpanel-instance-filter,\n.ag-theme-quartz-dark .ag-filter-toolpanel-instance-filter,\n.ag-theme-quartz-auto-dark .ag-filter-toolpanel-instance-filter {\n  border: none;\n  background-color: var(--ag-control-panel-background-color);\n}\n.ag-theme-quartz .ag-ltr .ag-filter-toolpanel-instance-filter, .ag-theme-quartz-dark .ag-ltr .ag-filter-toolpanel-instance-filter, .ag-theme-quartz-auto-dark .ag-ltr .ag-filter-toolpanel-instance-filter {\n  margin-left: calc(var(--ag-icon-size) * 0.5);\n}\n\n.ag-theme-quartz .ag-rtl .ag-filter-toolpanel-instance-filter, .ag-theme-quartz-dark .ag-rtl .ag-filter-toolpanel-instance-filter, .ag-theme-quartz-auto-dark .ag-rtl .ag-filter-toolpanel-instance-filter {\n  margin-right: calc(var(--ag-icon-size) * 0.5);\n}\n\n.ag-theme-quartz .ag-filter-toolpanel-group-level-0,\n.ag-theme-quartz-dark .ag-filter-toolpanel-group-level-0,\n.ag-theme-quartz-auto-dark .ag-filter-toolpanel-group-level-0 {\n  border-top: none;\n}\n.ag-theme-quartz .ag-filter-toolpanel-header,\n.ag-theme-quartz-dark .ag-filter-toolpanel-header,\n.ag-theme-quartz-auto-dark .ag-filter-toolpanel-header {\n  height: initial;\n  padding-top: var(--ag-grid-size);\n  padding-bottom: var(--ag-grid-size);\n}\n.ag-theme-quartz .ag-filter-toolpanel-group-item,\n.ag-theme-quartz-dark .ag-filter-toolpanel-group-item,\n.ag-theme-quartz-auto-dark .ag-filter-toolpanel-group-item {\n  margin: 0;\n}\n.ag-theme-quartz .ag-layout-auto-height .ag-center-cols-viewport,\n.ag-theme-quartz .ag-layout-auto-height .ag-center-cols-container,\n.ag-theme-quartz .ag-layout-print .ag-center-cols-viewport,\n.ag-theme-quartz .ag-layout-print .ag-center-cols-container,\n.ag-theme-quartz-dark .ag-layout-auto-height .ag-center-cols-viewport,\n.ag-theme-quartz-dark .ag-layout-auto-height .ag-center-cols-container,\n.ag-theme-quartz-dark .ag-layout-print .ag-center-cols-viewport,\n.ag-theme-quartz-dark .ag-layout-print .ag-center-cols-container,\n.ag-theme-quartz-auto-dark .ag-layout-auto-height .ag-center-cols-viewport,\n.ag-theme-quartz-auto-dark .ag-layout-auto-height .ag-center-cols-container,\n.ag-theme-quartz-auto-dark .ag-layout-print .ag-center-cols-viewport,\n.ag-theme-quartz-auto-dark .ag-layout-print .ag-center-cols-container {\n  min-height: 150px;\n}\n.ag-theme-quartz .ag-date-time-list-page-entry-is-current,\n.ag-theme-quartz-dark .ag-date-time-list-page-entry-is-current,\n.ag-theme-quartz-auto-dark .ag-date-time-list-page-entry-is-current {\n  background-color: var(--ag-active-color);\n}\n.ag-theme-quartz .ag-advanced-filter-builder-button,\n.ag-theme-quartz-dark .ag-advanced-filter-builder-button,\n.ag-theme-quartz-auto-dark .ag-advanced-filter-builder-button {\n  padding: var(--ag-grid-size);\n  font-weight: 600;\n}\n.ag-theme-quartz .ag-advanced-filter-builder-item-button-disabled .ag-icon,\n.ag-theme-quartz .ag-disabled .ag-icon,\n.ag-theme-quartz .ag-column-select-column-group-readonly .ag-icon,\n.ag-theme-quartz [disabled] .ag-icon,\n.ag-theme-quartz-dark .ag-advanced-filter-builder-item-button-disabled .ag-icon,\n.ag-theme-quartz-dark .ag-disabled .ag-icon,\n.ag-theme-quartz-dark .ag-column-select-column-group-readonly .ag-icon,\n.ag-theme-quartz-dark [disabled] .ag-icon,\n.ag-theme-quartz-auto-dark .ag-advanced-filter-builder-item-button-disabled .ag-icon,\n.ag-theme-quartz-auto-dark .ag-disabled .ag-icon,\n.ag-theme-quartz-auto-dark .ag-column-select-column-group-readonly .ag-icon,\n.ag-theme-quartz-auto-dark [disabled] .ag-icon {\n  opacity: 0.6;\n}\n.ag-theme-quartz .ag-icon-grip,\n.ag-theme-quartz-dark .ag-icon-grip,\n.ag-theme-quartz-auto-dark .ag-icon-grip {\n  opacity: 0.7;\n}\n.ag-theme-quartz .ag-column-select-column-readonly.ag-icon-grip,\n.ag-theme-quartz .ag-column-select-column-readonly .ag-icon-grip,\n.ag-theme-quartz-dark .ag-column-select-column-readonly.ag-icon-grip,\n.ag-theme-quartz-dark .ag-column-select-column-readonly .ag-icon-grip,\n.ag-theme-quartz-auto-dark .ag-column-select-column-readonly.ag-icon-grip,\n.ag-theme-quartz-auto-dark .ag-column-select-column-readonly .ag-icon-grip {\n  opacity: 0.35;\n}\n.ag-theme-quartz .ag-column-select-header-filter-wrapper .ag-input-wrapper::before,\n.ag-theme-quartz .ag-filter-toolpanel-search .ag-input-wrapper::before,\n.ag-theme-quartz .ag-mini-filter .ag-input-wrapper::before,\n.ag-theme-quartz .ag-filter-filter .ag-input-wrapper::before,\n.ag-theme-quartz .ag-filter-add-select .ag-input-wrapper::before,\n.ag-theme-quartz-dark .ag-column-select-header-filter-wrapper .ag-input-wrapper::before,\n.ag-theme-quartz-dark .ag-filter-toolpanel-search .ag-input-wrapper::before,\n.ag-theme-quartz-dark .ag-mini-filter .ag-input-wrapper::before,\n.ag-theme-quartz-dark .ag-filter-filter .ag-input-wrapper::before,\n.ag-theme-quartz-dark .ag-filter-add-select .ag-input-wrapper::before,\n.ag-theme-quartz-auto-dark .ag-column-select-header-filter-wrapper .ag-input-wrapper::before,\n.ag-theme-quartz-auto-dark .ag-filter-toolpanel-search .ag-input-wrapper::before,\n.ag-theme-quartz-auto-dark .ag-mini-filter .ag-input-wrapper::before,\n.ag-theme-quartz-auto-dark .ag-filter-filter .ag-input-wrapper::before,\n.ag-theme-quartz-auto-dark .ag-filter-add-select .ag-input-wrapper::before {\n  position: absolute;\n  display: block;\n  width: 12px;\n  height: 12px;\n  background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_1___ + ");\n  background-position: 50% 50%;\n  background-size: contain;\n  opacity: 40%;\n  content: \"\";\n  filter: var(--ag-icon-filter);\n}\n.ag-theme-quartz .ag-ltr .ag-column-select-header-filter-wrapper .ag-input-wrapper::before, .ag-theme-quartz .ag-ltr .ag-filter-toolpanel-search .ag-input-wrapper::before, .ag-theme-quartz .ag-ltr .ag-mini-filter .ag-input-wrapper::before, .ag-theme-quartz .ag-ltr .ag-filter-filter .ag-input-wrapper::before, .ag-theme-quartz .ag-ltr .ag-filter-add-select .ag-input-wrapper::before, .ag-theme-quartz-dark .ag-ltr .ag-column-select-header-filter-wrapper .ag-input-wrapper::before, .ag-theme-quartz-dark .ag-ltr .ag-filter-toolpanel-search .ag-input-wrapper::before, .ag-theme-quartz-dark .ag-ltr .ag-mini-filter .ag-input-wrapper::before, .ag-theme-quartz-dark .ag-ltr .ag-filter-filter .ag-input-wrapper::before, .ag-theme-quartz-dark .ag-ltr .ag-filter-add-select .ag-input-wrapper::before, .ag-theme-quartz-auto-dark .ag-ltr .ag-column-select-header-filter-wrapper .ag-input-wrapper::before, .ag-theme-quartz-auto-dark .ag-ltr .ag-filter-toolpanel-search .ag-input-wrapper::before, .ag-theme-quartz-auto-dark .ag-ltr .ag-mini-filter .ag-input-wrapper::before, .ag-theme-quartz-auto-dark .ag-ltr .ag-filter-filter .ag-input-wrapper::before, .ag-theme-quartz-auto-dark .ag-ltr .ag-filter-add-select .ag-input-wrapper::before {\n  margin-left: var(--ag-grid-size);\n}\n\n.ag-theme-quartz .ag-rtl .ag-column-select-header-filter-wrapper .ag-input-wrapper::before, .ag-theme-quartz .ag-rtl .ag-filter-toolpanel-search .ag-input-wrapper::before, .ag-theme-quartz .ag-rtl .ag-mini-filter .ag-input-wrapper::before, .ag-theme-quartz .ag-rtl .ag-filter-filter .ag-input-wrapper::before, .ag-theme-quartz .ag-rtl .ag-filter-add-select .ag-input-wrapper::before, .ag-theme-quartz-dark .ag-rtl .ag-column-select-header-filter-wrapper .ag-input-wrapper::before, .ag-theme-quartz-dark .ag-rtl .ag-filter-toolpanel-search .ag-input-wrapper::before, .ag-theme-quartz-dark .ag-rtl .ag-mini-filter .ag-input-wrapper::before, .ag-theme-quartz-dark .ag-rtl .ag-filter-filter .ag-input-wrapper::before, .ag-theme-quartz-dark .ag-rtl .ag-filter-add-select .ag-input-wrapper::before, .ag-theme-quartz-auto-dark .ag-rtl .ag-column-select-header-filter-wrapper .ag-input-wrapper::before, .ag-theme-quartz-auto-dark .ag-rtl .ag-filter-toolpanel-search .ag-input-wrapper::before, .ag-theme-quartz-auto-dark .ag-rtl .ag-mini-filter .ag-input-wrapper::before, .ag-theme-quartz-auto-dark .ag-rtl .ag-filter-filter .ag-input-wrapper::before, .ag-theme-quartz-auto-dark .ag-rtl .ag-filter-add-select .ag-input-wrapper::before {\n  margin-right: var(--ag-grid-size);\n}\n\n.ag-theme-quartz .ag-ltr .ag-column-select-header-filter-wrapper input.ag-text-field-input, .ag-theme-quartz .ag-ltr .ag-column-select-header-filter-wrapper input.ag-number-field-input, .ag-theme-quartz .ag-ltr .ag-filter-toolpanel-search input.ag-text-field-input, .ag-theme-quartz .ag-ltr .ag-filter-toolpanel-search input.ag-number-field-input, .ag-theme-quartz .ag-ltr .ag-mini-filter input.ag-text-field-input, .ag-theme-quartz .ag-ltr .ag-mini-filter input.ag-number-field-input, .ag-theme-quartz .ag-ltr .ag-filter-filter input.ag-text-field-input, .ag-theme-quartz .ag-ltr .ag-filter-filter input.ag-number-field-input, .ag-theme-quartz .ag-ltr .ag-filter-add-select input.ag-text-field-input, .ag-theme-quartz .ag-ltr .ag-filter-add-select input.ag-number-field-input, .ag-theme-quartz-dark .ag-ltr .ag-column-select-header-filter-wrapper input.ag-text-field-input, .ag-theme-quartz-dark .ag-ltr .ag-column-select-header-filter-wrapper input.ag-number-field-input, .ag-theme-quartz-dark .ag-ltr .ag-filter-toolpanel-search input.ag-text-field-input, .ag-theme-quartz-dark .ag-ltr .ag-filter-toolpanel-search input.ag-number-field-input, .ag-theme-quartz-dark .ag-ltr .ag-mini-filter input.ag-text-field-input, .ag-theme-quartz-dark .ag-ltr .ag-mini-filter input.ag-number-field-input, .ag-theme-quartz-dark .ag-ltr .ag-filter-filter input.ag-text-field-input, .ag-theme-quartz-dark .ag-ltr .ag-filter-filter input.ag-number-field-input, .ag-theme-quartz-dark .ag-ltr .ag-filter-add-select input.ag-text-field-input, .ag-theme-quartz-dark .ag-ltr .ag-filter-add-select input.ag-number-field-input, .ag-theme-quartz-auto-dark .ag-ltr .ag-column-select-header-filter-wrapper input.ag-text-field-input, .ag-theme-quartz-auto-dark .ag-ltr .ag-column-select-header-filter-wrapper input.ag-number-field-input, .ag-theme-quartz-auto-dark .ag-ltr .ag-filter-toolpanel-search input.ag-text-field-input, .ag-theme-quartz-auto-dark .ag-ltr .ag-filter-toolpanel-search input.ag-number-field-input, .ag-theme-quartz-auto-dark .ag-ltr .ag-mini-filter input.ag-text-field-input, .ag-theme-quartz-auto-dark .ag-ltr .ag-mini-filter input.ag-number-field-input, .ag-theme-quartz-auto-dark .ag-ltr .ag-filter-filter input.ag-text-field-input, .ag-theme-quartz-auto-dark .ag-ltr .ag-filter-filter input.ag-number-field-input, .ag-theme-quartz-auto-dark .ag-ltr .ag-filter-add-select input.ag-text-field-input, .ag-theme-quartz-auto-dark .ag-ltr .ag-filter-add-select input.ag-number-field-input {\n  padding-left: 26px;\n}\n\n.ag-theme-quartz .ag-rtl .ag-column-select-header-filter-wrapper input.ag-text-field-input, .ag-theme-quartz .ag-rtl .ag-column-select-header-filter-wrapper input.ag-number-field-input, .ag-theme-quartz .ag-rtl .ag-filter-toolpanel-search input.ag-text-field-input, .ag-theme-quartz .ag-rtl .ag-filter-toolpanel-search input.ag-number-field-input, .ag-theme-quartz .ag-rtl .ag-mini-filter input.ag-text-field-input, .ag-theme-quartz .ag-rtl .ag-mini-filter input.ag-number-field-input, .ag-theme-quartz .ag-rtl .ag-filter-filter input.ag-text-field-input, .ag-theme-quartz .ag-rtl .ag-filter-filter input.ag-number-field-input, .ag-theme-quartz .ag-rtl .ag-filter-add-select input.ag-text-field-input, .ag-theme-quartz .ag-rtl .ag-filter-add-select input.ag-number-field-input, .ag-theme-quartz-dark .ag-rtl .ag-column-select-header-filter-wrapper input.ag-text-field-input, .ag-theme-quartz-dark .ag-rtl .ag-column-select-header-filter-wrapper input.ag-number-field-input, .ag-theme-quartz-dark .ag-rtl .ag-filter-toolpanel-search input.ag-text-field-input, .ag-theme-quartz-dark .ag-rtl .ag-filter-toolpanel-search input.ag-number-field-input, .ag-theme-quartz-dark .ag-rtl .ag-mini-filter input.ag-text-field-input, .ag-theme-quartz-dark .ag-rtl .ag-mini-filter input.ag-number-field-input, .ag-theme-quartz-dark .ag-rtl .ag-filter-filter input.ag-text-field-input, .ag-theme-quartz-dark .ag-rtl .ag-filter-filter input.ag-number-field-input, .ag-theme-quartz-dark .ag-rtl .ag-filter-add-select input.ag-text-field-input, .ag-theme-quartz-dark .ag-rtl .ag-filter-add-select input.ag-number-field-input, .ag-theme-quartz-auto-dark .ag-rtl .ag-column-select-header-filter-wrapper input.ag-text-field-input, .ag-theme-quartz-auto-dark .ag-rtl .ag-column-select-header-filter-wrapper input.ag-number-field-input, .ag-theme-quartz-auto-dark .ag-rtl .ag-filter-toolpanel-search input.ag-text-field-input, .ag-theme-quartz-auto-dark .ag-rtl .ag-filter-toolpanel-search input.ag-number-field-input, .ag-theme-quartz-auto-dark .ag-rtl .ag-mini-filter input.ag-text-field-input, .ag-theme-quartz-auto-dark .ag-rtl .ag-mini-filter input.ag-number-field-input, .ag-theme-quartz-auto-dark .ag-rtl .ag-filter-filter input.ag-text-field-input, .ag-theme-quartz-auto-dark .ag-rtl .ag-filter-filter input.ag-number-field-input, .ag-theme-quartz-auto-dark .ag-rtl .ag-filter-add-select input.ag-text-field-input, .ag-theme-quartz-auto-dark .ag-rtl .ag-filter-add-select input.ag-number-field-input {\n  padding-right: 26px;\n}\n\n.ag-theme-quartz .ag-ltr .ag-column-select-add-group-indent, .ag-theme-quartz-dark .ag-ltr .ag-column-select-add-group-indent, .ag-theme-quartz-auto-dark .ag-ltr .ag-column-select-add-group-indent {\n  margin-left: calc(var(--ag-icon-size) + var(--ag-grid-size) * 1.5);\n}\n\n.ag-theme-quartz .ag-rtl .ag-column-select-add-group-indent, .ag-theme-quartz-dark .ag-rtl .ag-column-select-add-group-indent, .ag-theme-quartz-auto-dark .ag-rtl .ag-column-select-add-group-indent {\n  margin-right: calc(var(--ag-icon-size) + var(--ag-grid-size) * 1.5);\n}\n\n.ag-theme-quartz .ag-text-field-input[disabled],\n.ag-theme-quartz .ag-menu-option-disabled,\n.ag-theme-quartz-dark .ag-text-field-input[disabled],\n.ag-theme-quartz-dark .ag-menu-option-disabled,\n.ag-theme-quartz-auto-dark .ag-text-field-input[disabled],\n.ag-theme-quartz-auto-dark .ag-menu-option-disabled {\n  cursor: not-allowed;\n}\n.ag-theme-quartz .ag-checkbox-input-wrapper.ag-checked.ag-disabled,\n.ag-theme-quartz-dark .ag-checkbox-input-wrapper.ag-checked.ag-disabled,\n.ag-theme-quartz-auto-dark .ag-checkbox-input-wrapper.ag-checked.ag-disabled {\n  --ag-checkbox-checked-color: var(--ag-checkbox-unchecked-color);\n}\n.ag-theme-quartz .ag-checkbox-input,\n.ag-theme-quartz .ag-toggle-button-input,\n.ag-theme-quartz .ag-radio-button-input,\n.ag-theme-quartz input[class^=ag-][type=range],\n.ag-theme-quartz-dark .ag-checkbox-input,\n.ag-theme-quartz-dark .ag-toggle-button-input,\n.ag-theme-quartz-dark .ag-radio-button-input,\n.ag-theme-quartz-dark input[class^=ag-][type=range],\n.ag-theme-quartz-auto-dark .ag-checkbox-input,\n.ag-theme-quartz-auto-dark .ag-toggle-button-input,\n.ag-theme-quartz-auto-dark .ag-radio-button-input,\n.ag-theme-quartz-auto-dark input[class^=ag-][type=range] {\n  cursor: pointer;\n}\n.ag-theme-quartz .ag-details-row,\n.ag-theme-quartz-dark .ag-details-row,\n.ag-theme-quartz-auto-dark .ag-details-row {\n  padding: calc(var(--ag-grid-size) * 3.75);\n}\n.ag-theme-quartz .ag-list-item-hovered::after,\n.ag-theme-quartz-dark .ag-list-item-hovered::after,\n.ag-theme-quartz-auto-dark .ag-list-item-hovered::after {\n  background-color: var(--ag-active-color);\n}\n.ag-theme-quartz .ag-pill .ag-pill-button:hover,\n.ag-theme-quartz-dark .ag-pill .ag-pill-button:hover,\n.ag-theme-quartz-auto-dark .ag-pill .ag-pill-button:hover {\n  color: var(--ag-active-color);\n}\n.ag-theme-quartz .ag-header-highlight-before::after,\n.ag-theme-quartz .ag-header-highlight-after::after,\n.ag-theme-quartz-dark .ag-header-highlight-before::after,\n.ag-theme-quartz-dark .ag-header-highlight-after::after,\n.ag-theme-quartz-auto-dark .ag-header-highlight-before::after,\n.ag-theme-quartz-auto-dark .ag-header-highlight-after::after {\n  background-color: var(--ag-active-color);\n}\n\n.ag-theme-quartz-dark .ag-column-select-header-filter-wrapper .ag-input-wrapper::before,\n.ag-theme-quartz-dark .ag-filter-toolpanel-search .ag-input-wrapper::before,\n.ag-theme-quartz-dark .ag-mini-filter .ag-input-wrapper::before,\n.ag-theme-quartz-dark .ag-filter-filter .ag-input-wrapper::before {\n  opacity: 66%;\n  filter: invert(100%);\n}\n.ag-theme-quartz-dark .ag-chart-menu {\n  background-color: color-mix(in srgb, rgba(24, 39, 50, 0.3), var(--ag-background-color) 30%);\n}\n.ag-theme-quartz-dark .ag-text-field-input::placeholder {\n  color: var(--ag-data-color);\n  opacity: 0.8;\n}\n", ""]);
// Exports
/* harmony default export */ __webpack_exports__.A = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 6049:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(36758);
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40935);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20062);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(50221), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, "@font-face {\n  font-family: \"agGridAlpine\";\n  src: url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ");\n  font-weight: normal;\n  font-style: normal;\n}\n", ""]);
// Exports
/* harmony default export */ __webpack_exports__.A = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 71365:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(36758);
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40935);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20062);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(38906), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, "@font-face {\n  font-family: \"agGridBalham\";\n  src: url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ");\n  font-weight: normal;\n  font-style: normal;\n}\n", ""]);
// Exports
/* harmony default export */ __webpack_exports__.A = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 492:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(36758);
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40935);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20062);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(61142), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, "@font-face {\n  font-family: \"agGridClassic\";\n  src: url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ");\n  font-weight: normal;\n  font-style: normal;\n}\n", ""]);
// Exports
/* harmony default export */ __webpack_exports__.A = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 31:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(36758);
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40935);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20062);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(80902), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, "@font-face {\n  font-family: \"agGridMaterial\";\n  src: url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ");\n  font-weight: normal;\n  font-style: normal;\n}\n", ""]);
// Exports
/* harmony default export */ __webpack_exports__.A = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 72229:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(36758);
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40935);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20062);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(43545), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, "@font-face {\n  font-family: \"agGridQuartz\";\n  src: url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ");\n  font-weight: normal;\n  font-style: normal;\n}\n", ""]);
// Exports
/* harmony default export */ __webpack_exports__.A = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 40935:
/***/ (function(module) {



/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = [];

  // return the list of modules as css string
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };

  // import a list of modules into the list
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),

/***/ 20062:
/***/ (function(module) {



module.exports = function (url, options) {
  if (!options) {
    options = {};
  }
  if (!url) {
    return url;
  }
  url = String(url.__esModule ? url.default : url);

  // If url is already wrapped in quotes, remove them
  if (/^['"].*['"]$/.test(url)) {
    url = url.slice(1, -1);
  }
  if (options.hash) {
    url += options.hash;
  }

  // Should url be wrapped?
  // See https://drafts.csswg.org/css-values-3/#urls
  if (/["'() \t\n]|(%20)/.test(url) || options.needQuotes) {
    return "\"".concat(url.replace(/"/g, '\\"').replace(/\n/g, "\\n"), "\"");
  }
  return url;
};

/***/ }),

/***/ 36758:
/***/ (function(module) {



module.exports = function (i) {
  return i[1];
};

/***/ }),

/***/ 18510:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(72591);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1740);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(88128);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(18021);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(93051);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(73656);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ag_grid_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(52974);

      
      
      
      
      
      
      
      
      

var options = {"attributes":{"data-ag-scope":"legacy"}};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_ag_grid_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A, options);




       /* harmony default export */ __webpack_exports__["default"] = (_node_modules_css_loader_dist_cjs_js_ag_grid_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A && _node_modules_css_loader_dist_cjs_js_ag_grid_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals ? _node_modules_css_loader_dist_cjs_js_ag_grid_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals : undefined);


/***/ }),

/***/ 22685:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(72591);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1740);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(88128);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(18021);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(93051);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(73656);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ag_theme_alpine_no_font_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(71229);

      
      
      
      
      
      
      
      
      

var options = {"attributes":{"data-ag-scope":"legacy"}};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_ag_theme_alpine_no_font_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A, options);




       /* harmony default export */ __webpack_exports__["default"] = (_node_modules_css_loader_dist_cjs_js_ag_theme_alpine_no_font_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A && _node_modules_css_loader_dist_cjs_js_ag_theme_alpine_no_font_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals ? _node_modules_css_loader_dist_cjs_js_ag_theme_alpine_no_font_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals : undefined);


/***/ }),

/***/ 95151:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(72591);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1740);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(88128);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(18021);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(93051);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(73656);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ag_theme_alpine_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(93871);

      
      
      
      
      
      
      
      
      

var options = {"attributes":{"data-ag-scope":"legacy"}};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_ag_theme_alpine_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A, options);




       /* harmony default export */ __webpack_exports__["default"] = (_node_modules_css_loader_dist_cjs_js_ag_theme_alpine_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A && _node_modules_css_loader_dist_cjs_js_ag_theme_alpine_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals ? _node_modules_css_loader_dist_cjs_js_ag_theme_alpine_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals : undefined);


/***/ }),

/***/ 99681:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(72591);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1740);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(88128);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(18021);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(93051);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(73656);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ag_theme_balham_no_font_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(48225);

      
      
      
      
      
      
      
      
      

var options = {"attributes":{"data-ag-scope":"legacy"}};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_ag_theme_balham_no_font_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A, options);




       /* harmony default export */ __webpack_exports__["default"] = (_node_modules_css_loader_dist_cjs_js_ag_theme_balham_no_font_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A && _node_modules_css_loader_dist_cjs_js_ag_theme_balham_no_font_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals ? _node_modules_css_loader_dist_cjs_js_ag_theme_balham_no_font_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals : undefined);


/***/ }),

/***/ 72883:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(72591);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1740);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(88128);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(18021);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(93051);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(73656);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ag_theme_balham_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(55251);

      
      
      
      
      
      
      
      
      

var options = {"attributes":{"data-ag-scope":"legacy"}};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_ag_theme_balham_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A, options);




       /* harmony default export */ __webpack_exports__["default"] = (_node_modules_css_loader_dist_cjs_js_ag_theme_balham_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A && _node_modules_css_loader_dist_cjs_js_ag_theme_balham_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals ? _node_modules_css_loader_dist_cjs_js_ag_theme_balham_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals : undefined);


/***/ }),

/***/ 63543:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(72591);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1740);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(88128);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(18021);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(93051);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(73656);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ag_theme_material_no_font_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(64023);

      
      
      
      
      
      
      
      
      

var options = {"attributes":{"data-ag-scope":"legacy"}};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_ag_theme_material_no_font_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A, options);




       /* harmony default export */ __webpack_exports__["default"] = (_node_modules_css_loader_dist_cjs_js_ag_theme_material_no_font_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A && _node_modules_css_loader_dist_cjs_js_ag_theme_material_no_font_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals ? _node_modules_css_loader_dist_cjs_js_ag_theme_material_no_font_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals : undefined);


/***/ }),

/***/ 71109:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(72591);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1740);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(88128);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(18021);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(93051);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(73656);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ag_theme_material_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(83973);

      
      
      
      
      
      
      
      
      

var options = {"attributes":{"data-ag-scope":"legacy"}};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_ag_theme_material_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A, options);




       /* harmony default export */ __webpack_exports__["default"] = (_node_modules_css_loader_dist_cjs_js_ag_theme_material_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A && _node_modules_css_loader_dist_cjs_js_ag_theme_material_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals ? _node_modules_css_loader_dist_cjs_js_ag_theme_material_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals : undefined);


/***/ }),

/***/ 81601:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(72591);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1740);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(88128);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(18021);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(93051);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(73656);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ag_theme_quartz_no_font_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(30145);

      
      
      
      
      
      
      
      
      

var options = {"attributes":{"data-ag-scope":"legacy"}};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_ag_theme_quartz_no_font_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A, options);




       /* harmony default export */ __webpack_exports__["default"] = (_node_modules_css_loader_dist_cjs_js_ag_theme_quartz_no_font_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A && _node_modules_css_loader_dist_cjs_js_ag_theme_quartz_no_font_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals ? _node_modules_css_loader_dist_cjs_js_ag_theme_quartz_no_font_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals : undefined);


/***/ }),

/***/ 48755:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(72591);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1740);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(88128);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(18021);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(93051);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(73656);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ag_theme_quartz_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(31123);

      
      
      
      
      
      
      
      
      

var options = {"attributes":{"data-ag-scope":"legacy"}};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_ag_theme_quartz_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A, options);




       /* harmony default export */ __webpack_exports__["default"] = (_node_modules_css_loader_dist_cjs_js_ag_theme_quartz_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A && _node_modules_css_loader_dist_cjs_js_ag_theme_quartz_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals ? _node_modules_css_loader_dist_cjs_js_ag_theme_quartz_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals : undefined);


/***/ }),

/***/ 23713:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(72591);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1740);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(88128);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(18021);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(93051);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(73656);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_agGridAlpineFont_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6049);

      
      
      
      
      
      
      
      
      

var options = {"attributes":{"data-ag-scope":"legacy"}};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_agGridAlpineFont_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A, options);




       /* harmony default export */ __webpack_exports__["default"] = (_node_modules_css_loader_dist_cjs_js_agGridAlpineFont_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A && _node_modules_css_loader_dist_cjs_js_agGridAlpineFont_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals ? _node_modules_css_loader_dist_cjs_js_agGridAlpineFont_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals : undefined);


/***/ }),

/***/ 89029:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(72591);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1740);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(88128);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(18021);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(93051);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(73656);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_agGridBalhamFont_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(71365);

      
      
      
      
      
      
      
      
      

var options = {"attributes":{"data-ag-scope":"legacy"}};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_agGridBalhamFont_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A, options);




       /* harmony default export */ __webpack_exports__["default"] = (_node_modules_css_loader_dist_cjs_js_agGridBalhamFont_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A && _node_modules_css_loader_dist_cjs_js_agGridBalhamFont_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals ? _node_modules_css_loader_dist_cjs_js_agGridBalhamFont_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals : undefined);


/***/ }),

/***/ 87628:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(72591);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1740);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(88128);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(18021);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(93051);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(73656);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_agGridClassicFont_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(492);

      
      
      
      
      
      
      
      
      

var options = {"attributes":{"data-ag-scope":"legacy"}};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_agGridClassicFont_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A, options);




       /* harmony default export */ __webpack_exports__["default"] = (_node_modules_css_loader_dist_cjs_js_agGridClassicFont_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A && _node_modules_css_loader_dist_cjs_js_agGridClassicFont_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals ? _node_modules_css_loader_dist_cjs_js_agGridClassicFont_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals : undefined);


/***/ }),

/***/ 2559:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(72591);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1740);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(88128);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(18021);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(93051);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(73656);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_agGridMaterialFont_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(31);

      
      
      
      
      
      
      
      
      

var options = {"attributes":{"data-ag-scope":"legacy"}};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_agGridMaterialFont_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A, options);




       /* harmony default export */ __webpack_exports__["default"] = (_node_modules_css_loader_dist_cjs_js_agGridMaterialFont_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A && _node_modules_css_loader_dist_cjs_js_agGridMaterialFont_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals ? _node_modules_css_loader_dist_cjs_js_agGridMaterialFont_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals : undefined);


/***/ }),

/***/ 89893:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(72591);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1740);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(88128);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(18021);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(93051);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(73656);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_agGridQuartzFont_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(72229);

      
      
      
      
      
      
      
      
      

var options = {"attributes":{"data-ag-scope":"legacy"}};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithAttributesAndNonce_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_agGridQuartzFont_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A, options);




       /* harmony default export */ __webpack_exports__["default"] = (_node_modules_css_loader_dist_cjs_js_agGridQuartzFont_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A && _node_modules_css_loader_dist_cjs_js_agGridQuartzFont_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals ? _node_modules_css_loader_dist_cjs_js_agGridQuartzFont_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals : undefined);


/***/ }),

/***/ 72591:
/***/ (function(module) {



var stylesInDOM = [];
function getIndexByIdentifier(identifier) {
  var result = -1;
  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }
  return result;
}
function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };
    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }
    identifiers.push(identifier);
  }
  return identifiers;
}
function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);
  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }
      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };
  return updater;
}
module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];
    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }
    var newLastIdentifiers = modulesToDom(newList, options);
    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];
      var _index = getIndexByIdentifier(_identifier);
      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();
        stylesInDOM.splice(_index, 1);
      }
    }
    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ 88128:
/***/ (function(module) {



var memo = {};

/* istanbul ignore next  */
function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target);

    // Special case to return head of iframe instead of iframe itself
    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }
    memo[target] = styleTarget;
  }
  return memo[target];
}

/* istanbul ignore next  */
function insertBySelector(insert, style) {
  var target = getTarget(insert);
  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }
  target.appendChild(style);
}
module.exports = insertBySelector;

/***/ }),

/***/ 93051:
/***/ (function(module) {



/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}
module.exports = insertStyleElement;

/***/ }),

/***/ 18021:
/***/ (function(module) {



/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement, attributes) {
  Object.keys(attributes).forEach(function (key) {
    styleElement.setAttribute(key, attributes[key]);
  });
}
module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ 1740:
/***/ (function(module) {



/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";
  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }
  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }
  var needLayer = typeof obj.layer !== "undefined";
  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }
  css += obj.css;
  if (needLayer) {
    css += "}";
  }
  if (obj.media) {
    css += "}";
  }
  if (obj.supports) {
    css += "}";
  }
  var sourceMap = obj.sourceMap;
  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  }

  // For old IE
  /* istanbul ignore if  */
  options.styleTagTransform(css, styleElement, options.options);
}
function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }
  styleElement.parentNode.removeChild(styleElement);
}

/* istanbul ignore next  */
function domAPI(options) {
  if (typeof document === "undefined") {
    return {
      update: function update() {},
      remove: function remove() {}
    };
  }
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}
module.exports = domAPI;

/***/ }),

/***/ 73656:
/***/ (function(module) {



/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }
    styleElement.appendChild(document.createTextNode(css));
  }
}
module.exports = styleTagTransform;

/***/ }),

/***/ 22074:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AlignedGridsModule = void 0;
const version_1 = __webpack_require__(97205);
const alignedGridsService_1 = __webpack_require__(98963);
/**
 * @feature Other -> Aligned Grids
 * @gridOption alignedGrids
 */
exports.AlignedGridsModule = {
    moduleName: 'AlignedGrids',
    version: version_1.VERSION,
    beans: [alignedGridsService_1.AlignedGridsService],
};


/***/ }),

/***/ 98963:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AlignedGridsService = void 0;
const columnStateUtils_1 = __webpack_require__(2885);
const beanStub_1 = __webpack_require__(68731);
const logging_1 = __webpack_require__(47764);
class AlignedGridsService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'alignedGridsSvc';
        // flag to mark if we are consuming. to avoid cyclic events (ie other grid firing back to master
        // while processing a master event) we mark this if consuming an event, and if we are, then
        // we don't fire back any events.
        this.consuming = false;
    }
    getAlignedGridApis() {
        let alignedGrids = this.gos.get('alignedGrids') ?? [];
        const isCallbackConfig = typeof alignedGrids === 'function';
        if (typeof alignedGrids === 'function') {
            alignedGrids = alignedGrids();
        }
        const apis = alignedGrids
            .map((alignedGrid) => {
            if (!alignedGrid) {
                (0, logging_1._error)(18);
                if (!isCallbackConfig) {
                    (0, logging_1._error)(20);
                }
                return;
            }
            if (this.isGridApi(alignedGrid)) {
                return alignedGrid;
            }
            // Extract the GridApi from a ref or component
            const refOrComp = alignedGrid;
            if ('current' in refOrComp) {
                return refOrComp.current?.api;
            }
            if (!refOrComp.api) {
                (0, logging_1._error)(19);
            }
            return refOrComp.api;
        })
            .filter((api) => !!api && !api.isDestroyed());
        return apis;
    }
    isGridApi(ref) {
        return !!ref && !!ref.dispatchEvent;
    }
    postConstruct() {
        const fireColumnEvent = this.fireColumnEvent.bind(this);
        this.addManagedEventListeners({
            columnMoved: fireColumnEvent,
            columnVisible: fireColumnEvent,
            columnPinned: fireColumnEvent,
            columnGroupOpened: fireColumnEvent,
            columnResized: fireColumnEvent,
            bodyScroll: this.fireScrollEvent.bind(this),
            alignedGridColumn: ({ event }) => this.onColumnEvent(event),
            alignedGridScroll: ({ event }) => this.onScrollEvent(event),
        });
    }
    // common logic across all the fire methods
    fireEvent(event) {
        // if we are already consuming, then we are acting on an event from a master,
        // so we don't cause a cyclic firing of events
        if (this.consuming) {
            return;
        }
        this.getAlignedGridApis().forEach((api) => {
            if (api.isDestroyed()) {
                return;
            }
            api.dispatchEvent(event);
        });
    }
    // common logic across all consume methods. very little common logic, however extracting
    // guarantees consistency across the methods.
    onEvent(callback) {
        this.consuming = true;
        callback();
        this.consuming = false;
    }
    fireColumnEvent(columnEvent) {
        this.fireEvent({
            type: 'alignedGridColumn',
            event: columnEvent,
        });
    }
    fireScrollEvent(scrollEvent) {
        if (scrollEvent.direction !== 'horizontal') {
            return;
        }
        this.fireEvent({
            type: 'alignedGridScroll',
            event: scrollEvent,
        });
    }
    onScrollEvent(event) {
        this.onEvent(() => {
            this.beans.ctrlsSvc.getScrollFeature().setHorizontalScrollPosition(event.left, true);
        });
    }
    extractDataFromEvent(event, func) {
        const result = [];
        if (event.columns) {
            event.columns.forEach((column) => {
                result.push(func(column));
            });
        }
        else if (event.column) {
            result.push(func(event.column));
        }
        return result;
    }
    getMasterColumns(event) {
        return this.extractDataFromEvent(event, (col) => col);
    }
    getColumnIds(event) {
        return this.extractDataFromEvent(event, (col) => col.getColId());
    }
    onColumnEvent(event) {
        this.onEvent(() => {
            switch (event.type) {
                case 'columnMoved':
                case 'columnVisible':
                case 'columnPinned':
                case 'columnResized': {
                    this.processColumnEvent(event);
                    break;
                }
                case 'columnGroupOpened': {
                    this.processGroupOpenedEvent(event);
                    break;
                }
                case 'columnPivotChanged':
                    // we cannot support pivoting with aligned grids as the columns will be out of sync as the
                    // grids will have columns created based on the row data of the grid.
                    (0, logging_1._warn)(21);
                    break;
            }
        });
    }
    processGroupOpenedEvent(groupOpenedEvent) {
        const { colGroupSvc } = this.beans;
        if (!colGroupSvc) {
            return;
        }
        groupOpenedEvent.columnGroups.forEach((masterGroup) => {
            // likewise for column group
            let otherColumnGroup = null;
            if (masterGroup) {
                otherColumnGroup = colGroupSvc.getProvidedColGroup(masterGroup.getGroupId());
            }
            if (masterGroup && !otherColumnGroup) {
                return;
            }
            colGroupSvc.setColumnGroupOpened(otherColumnGroup, masterGroup.isExpanded(), 'alignedGridChanged');
        });
    }
    processColumnEvent(colEvent) {
        // the column in the event is from the master grid. need to
        // look up the equivalent from this (other) grid
        const masterColumn = colEvent.column;
        let otherColumn = null;
        const beans = this.beans;
        const { colResize, ctrlsSvc, colModel } = beans;
        if (masterColumn) {
            otherColumn = colModel.getColDefCol(masterColumn.getColId());
        }
        // if event was with respect to a master column, that is not present in this
        // grid, then we ignore the event
        if (masterColumn && !otherColumn) {
            return;
        }
        // in time, all the methods below should use the column ids, it's a more generic way
        // of handling columns, and also allows for single or multi column events
        const masterColumns = this.getMasterColumns(colEvent);
        switch (colEvent.type) {
            case 'columnMoved':
                // when the user moves columns via applyColumnState, we can't depend on moving specific columns
                // to an index, as there maybe be many indexes columns moved to (as wasn't result of a mouse drag).
                // so only way to be sure is match the order of all columns using Column State.
                {
                    const srcColState = colEvent.api.getColumnState();
                    const destColState = srcColState.map((s) => ({ colId: s.colId }));
                    (0, columnStateUtils_1._applyColumnState)(beans, { state: destColState, applyOrder: true }, 'alignedGridChanged');
                }
                break;
            case 'columnVisible':
                // when the user changes visibility via applyColumnState, we can't depend on visibility flag in event
                // as there maybe be mix of true/false (as wasn't result of a mouse click to set visiblity).
                // so only way to be sure is match the visibility of all columns using Column State.
                {
                    const srcColState = colEvent.api.getColumnState();
                    const destColState = srcColState.map((s) => ({ colId: s.colId, hide: s.hide }));
                    (0, columnStateUtils_1._applyColumnState)(beans, { state: destColState }, 'alignedGridChanged');
                }
                break;
            case 'columnPinned':
                {
                    const srcColState = colEvent.api.getColumnState();
                    const destColState = srcColState.map((s) => ({ colId: s.colId, pinned: s.pinned }));
                    (0, columnStateUtils_1._applyColumnState)(beans, { state: destColState }, 'alignedGridChanged');
                }
                break;
            case 'columnResized': {
                const resizedEvent = colEvent;
                const columnWidths = {};
                masterColumns.forEach((column) => {
                    columnWidths[column.getId()] = { key: column.getColId(), newWidth: column.getActualWidth() };
                });
                // don't set flex columns width
                resizedEvent.flexColumns?.forEach((col) => {
                    if (columnWidths[col.getId()]) {
                        delete columnWidths[col.getId()];
                    }
                });
                colResize?.setColumnWidths(Object.values(columnWidths), false, resizedEvent.finished, 'alignedGridChanged');
                break;
            }
        }
        const gridBodyCon = ctrlsSvc.getGridBodyCtrl();
        const isVerticalScrollShowing = gridBodyCon.isVerticalScrollShowing();
        this.getAlignedGridApis().forEach((api) => {
            api.setGridOption('alwaysShowVerticalScroll', isVerticalScrollShowing);
        });
    }
}
exports.AlignedGridsService = AlignedGridsService;


/***/ }),

/***/ 51621:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AllCommunityModule = void 0;
const alignedGridsModule_1 = __webpack_require__(22074);
const apiModule_1 = __webpack_require__(59642);
const clientSideRowModelModule_1 = __webpack_require__(89722);
const clientSideRowModelModule_2 = __webpack_require__(89722);
const columnAutosizeModule_1 = __webpack_require__(63856);
const columnHoverModule_1 = __webpack_require__(41690);
const columnModule_1 = __webpack_require__(52027);
const csvExportModule_1 = __webpack_require__(59734);
const dragModule_1 = __webpack_require__(24388);
const editModule_1 = __webpack_require__(84652);
const filterModule_1 = __webpack_require__(45432);
const infiniteRowModelModule_1 = __webpack_require__(44002);
const apiEventModule_1 = __webpack_require__(99410);
const localeModule_1 = __webpack_require__(89519);
const stateModule_1 = __webpack_require__(6989);
const paginationModule_1 = __webpack_require__(71824);
const pinnedRowModule_1 = __webpack_require__(15423);
const highlightChangesModule_1 = __webpack_require__(83498);
const renderModule_1 = __webpack_require__(66964);
const rowAutoHeightModule_1 = __webpack_require__(4577);
const cellSpanModule_1 = __webpack_require__(4265);
const rowSelectionModule_1 = __webpack_require__(43352);
const stylingModule_1 = __webpack_require__(68594);
const tooltipModule_1 = __webpack_require__(34658);
const validationModule_1 = __webpack_require__(15010);
const valueModule_1 = __webpack_require__(76431);
const version_1 = __webpack_require__(97205);
/**
 * @feature All Community Features
 */
exports.AllCommunityModule = {
    moduleName: 'AllCommunity',
    version: version_1.VERSION,
    dependsOn: [
        clientSideRowModelModule_1.ClientSideRowModelModule,
        csvExportModule_1.CsvExportModule,
        infiniteRowModelModule_1.InfiniteRowModelModule,
        validationModule_1.ValidationModule,
        editModule_1.TextEditorModule,
        editModule_1.NumberEditorModule,
        editModule_1.DateEditorModule,
        editModule_1.CheckboxEditorModule,
        editModule_1.SelectEditorModule,
        editModule_1.LargeTextEditorModule,
        editModule_1.CustomEditorModule,
        editModule_1.UndoRedoEditModule,
        filterModule_1.TextFilterModule,
        filterModule_1.NumberFilterModule,
        filterModule_1.DateFilterModule,
        filterModule_1.CustomFilterModule,
        filterModule_1.QuickFilterModule,
        filterModule_1.ExternalFilterModule,
        stateModule_1.GridStateModule,
        alignedGridsModule_1.AlignedGridsModule,
        paginationModule_1.PaginationModule,
        columnModule_1.ColumnApiModule,
        apiModule_1.RowApiModule,
        apiModule_1.ScrollApiModule,
        renderModule_1.RenderApiModule,
        columnAutosizeModule_1.ColumnAutoSizeModule,
        dragModule_1.RowDragModule,
        pinnedRowModule_1.PinnedRowModule,
        rowSelectionModule_1.RowSelectionModule,
        valueModule_1.ValueCacheModule,
        stylingModule_1.CellStyleModule,
        columnHoverModule_1.ColumnHoverModule,
        stylingModule_1.RowStyleModule,
        apiEventModule_1.EventApiModule,
        valueModule_1.CellApiModule,
        highlightChangesModule_1.HighlightChangesModule,
        tooltipModule_1.TooltipModule,
        localeModule_1.LocaleModule,
        rowAutoHeightModule_1.RowAutoHeightModule,
        dragModule_1.DragAndDropModule,
        clientSideRowModelModule_2.ClientSideRowModelApiModule,
        cellSpanModule_1.CellSpanModule,
    ],
};


/***/ }),

/***/ 33907:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApiFunctionService = void 0;
const beanStub_1 = __webpack_require__(68731);
const logging_1 = __webpack_require__(47764);
const gridApiFunctions_1 = __webpack_require__(87689);
const defaultFns = {
    isDestroyed: () => true,
    destroy() { },
    preConstruct() { },
    postConstruct() { },
    preWireBeans() { },
    wireBeans() { },
};
const dispatchEvent = (beans, event) => beans.eventSvc.dispatchEvent(event);
// We use a class for AGGridApi so in stack traces calling grid.api.xxx() if an error is thrown it will print "GridApi.xxx"
class GridApiClass {
}
Reflect.defineProperty(GridApiClass, 'name', { value: 'GridApi' });
class ApiFunctionService extends beanStub_1.BeanStub {
    constructor() {
        super();
        this.beanName = 'apiFunctionSvc';
        this.api = new GridApiClass();
        this.fns = {
            ...defaultFns,
            // dispatchEvent is used by frameworks, also used by aligned grids to identify a grid api instance
            dispatchEvent,
        };
        this.preDestroyLink = '';
        const { api } = this;
        for (const key of Object.keys(gridApiFunctions_1.gridApiFunctionsMap)) {
            api[key] = this.makeApi(key)[key];
        }
    }
    postConstruct() {
        this.preDestroyLink = this.beans.frameworkOverrides.getDocLink('grid-lifecycle/#grid-pre-destroyed');
    }
    addFunction(functionName, func) {
        const { fns, beans } = this;
        if (fns !== defaultFns) {
            fns[functionName] = beans?.validation?.validateApiFunction(functionName, func) ?? func;
        }
    }
    makeApi(apiName) {
        // We return an object here to be sure the function name is properly applied,
        // in this way error stack trace are correct and gridApi.xxx.name === 'xxx'
        // This is generally faster than using Object.defineProperty(gridApi, apiName, { value: apiName, configurable: true });
        // Keep this function as light and simple as possible.
        return {
            [apiName]: (...args) => {
                const { beans, fns: { [apiName]: fn }, } = this;
                return fn ? fn(beans, ...args) : this.apiNotFound(apiName);
            },
        };
    }
    apiNotFound(fnName) {
        const { beans, gos, preDestroyLink } = this;
        if (!beans) {
            (0, logging_1._warn)(26, { fnName, preDestroyLink });
        }
        else {
            const module = gridApiFunctions_1.gridApiFunctionsMap[fnName];
            if (gos.assertModuleRegistered(module, `api.${fnName}`)) {
                (0, logging_1._warn)(27, { fnName, module });
            }
        }
    }
    destroy() {
        super.destroy();
        this.fns = defaultFns;
        this.beans = null;
    }
}
exports.ApiFunctionService = ApiFunctionService;


/***/ }),

/***/ 59642:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScrollApiModule = exports.RowApiModule = void 0;
const version_1 = __webpack_require__(97205);
const rowApi_1 = __webpack_require__(18192);
const scrollApi_1 = __webpack_require__(11765);
/**
 * @feature Rows
 */
exports.RowApiModule = {
    moduleName: 'RowApi',
    version: version_1.VERSION,
    apiFunctions: {
        redrawRows: rowApi_1.redrawRows,
        setRowNodeExpanded: rowApi_1.setRowNodeExpanded,
        getRowNode: rowApi_1.getRowNode,
        addRenderedRowListener: rowApi_1.addRenderedRowListener,
        getRenderedNodes: rowApi_1.getRenderedNodes,
        forEachNode: rowApi_1.forEachNode,
        getFirstDisplayedRowIndex: rowApi_1.getFirstDisplayedRowIndex,
        getLastDisplayedRowIndex: rowApi_1.getLastDisplayedRowIndex,
        getDisplayedRowAtIndex: rowApi_1.getDisplayedRowAtIndex,
        getDisplayedRowCount: rowApi_1.getDisplayedRowCount,
    },
};
/**
 * @feature Scrolling
 */
exports.ScrollApiModule = {
    moduleName: 'ScrollApi',
    version: version_1.VERSION,
    apiFunctions: {
        getVerticalPixelRange: scrollApi_1.getVerticalPixelRange,
        getHorizontalPixelRange: scrollApi_1.getHorizontalPixelRange,
        ensureColumnVisible: scrollApi_1.ensureColumnVisible,
        ensureIndexVisible: scrollApi_1.ensureIndexVisible,
        ensureNodeVisible: scrollApi_1.ensureNodeVisible,
    },
};


/***/ }),

/***/ 46433:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createGridApi = void 0;
function createGridApi(context) {
    return {
        beanName: 'gridApi',
        bean: context.getBean('apiFunctionSvc').api,
    };
}
exports.createGridApi = createGridApi;


/***/ }),

/***/ 69875:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isModuleRegistered = exports.updateGridOptions = exports.setGridOption = exports.getGridOption = exports.isDestroyed = exports.destroy = exports.getGridId = void 0;
function getGridId(beans) {
    return beans.context.getGridId();
}
exports.getGridId = getGridId;
function destroy(beans) {
    beans.gridDestroySvc.destroy();
}
exports.destroy = destroy;
function isDestroyed(beans) {
    return beans.gridDestroySvc.destroyCalled;
}
exports.isDestroyed = isDestroyed;
function getGridOption(beans, key) {
    return beans.gos.get(key);
}
exports.getGridOption = getGridOption;
function setGridOption(beans, key, value) {
    updateGridOptions(beans, { [key]: value });
}
exports.setGridOption = setGridOption;
function updateGridOptions(beans, options) {
    // NOTE: The TDataUpdate generic is used to ensure that the update options match the generic passed into the GridApi above as TData.
    // This is required because if we just use TData directly then Typescript will get into an infinite loop due to callbacks which recursively include the GridApi.
    beans.gos.updateGridOptions({ options });
}
exports.updateGridOptions = updateGridOptions;
function isModuleRegistered(beans, moduleName) {
    const withoutSuffix = moduleName.replace(/Module$/, '');
    return beans.gos.isModuleRegistered(withoutSuffix);
}
exports.isModuleRegistered = isModuleRegistered;


/***/ }),

/***/ 79513:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.onRowHeightChanged = exports.collapseAll = exports.expandAll = void 0;
const rowModelApiUtils_1 = __webpack_require__(66876);
function expandAll(beans) {
    beans.expansionSvc?.expandAll(true);
}
exports.expandAll = expandAll;
function collapseAll(beans) {
    beans.expansionSvc?.expandAll(false);
}
exports.collapseAll = collapseAll;
function onRowHeightChanged(beans) {
    const clientSideRowModel = (0, rowModelApiUtils_1._getClientSideRowModel)(beans);
    const serverSideRowModel = (0, rowModelApiUtils_1._getServerSideRowModel)(beans);
    if (clientSideRowModel) {
        clientSideRowModel.onRowHeightChanged();
    }
    else if (serverSideRowModel) {
        serverSideRowModel.onRowHeightChanged();
    }
}
exports.onRowHeightChanged = onRowHeightChanged;


/***/ }),

/***/ 87689:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.gridApiFunctionsMap = void 0;
const mod = (moduleName, input) => {
    for (const key of Object.keys(input)) {
        input[key] = moduleName;
    }
    return input;
};
exports.gridApiFunctionsMap = {
    dispatchEvent: 'CommunityCore',
    ...mod('CommunityCore', {
        destroy: 0,
        getGridId: 0,
        getGridOption: 0,
        isDestroyed: 0,
        setGridOption: 0,
        updateGridOptions: 0,
        isModuleRegistered: 0,
    }),
    ...mod('GridState', {
        getState: 0,
        setState: 0,
    }),
    ...mod('SharedRowSelection', {
        setNodesSelected: 0,
        selectAll: 0,
        deselectAll: 0,
        selectAllFiltered: 0,
        deselectAllFiltered: 0,
        selectAllOnCurrentPage: 0,
        deselectAllOnCurrentPage: 0,
        getSelectedNodes: 0,
        getSelectedRows: 0,
    }),
    ...mod('RowApi', {
        redrawRows: 0,
        setRowNodeExpanded: 0,
        getRowNode: 0,
        addRenderedRowListener: 0,
        getRenderedNodes: 0,
        forEachNode: 0,
        getFirstDisplayedRowIndex: 0,
        getLastDisplayedRowIndex: 0,
        getDisplayedRowAtIndex: 0,
        getDisplayedRowCount: 0,
    }),
    ...mod('ScrollApi', {
        getVerticalPixelRange: 0,
        getHorizontalPixelRange: 0,
        ensureColumnVisible: 0,
        ensureIndexVisible: 0,
        ensureNodeVisible: 0,
    }),
    ...mod('KeyboardNavigation', {
        getFocusedCell: 0,
        clearFocusedCell: 0,
        setFocusedCell: 0,
        tabToNextCell: 0,
        tabToPreviousCell: 0,
        setFocusedHeader: 0,
    }),
    ...mod('EventApi', {
        addEventListener: 0,
        addGlobalListener: 0,
        removeEventListener: 0,
        removeGlobalListener: 0,
    }),
    ...mod('ValueCache', {
        expireValueCache: 0,
    }),
    ...mod('CellApi', {
        getCellValue: 0,
    }),
    ...mod('SharedMenu', {
        showColumnMenu: 0,
        hidePopupMenu: 0,
    }),
    ...mod('Sort', {
        onSortChanged: 0,
    }),
    ...mod('PinnedRow', {
        getPinnedTopRowCount: 0,
        getPinnedBottomRowCount: 0,
        getPinnedTopRow: 0,
        getPinnedBottomRow: 0,
        forEachPinnedRow: 0,
    }),
    ...mod('Overlay', {
        showLoadingOverlay: 0,
        showNoRowsOverlay: 0,
        hideOverlay: 0,
    }),
    ...mod('RenderApi', {
        setGridAriaProperty: 0,
        refreshCells: 0,
        refreshHeader: 0,
        isAnimationFrameQueueEmpty: 0,
        flushAllAnimationFrames: 0,
        getSizesForCurrentTheme: 0,
        getCellRendererInstances: 0,
    }),
    ...mod('HighlightChanges', {
        flashCells: 0,
    }),
    ...mod('RowDrag', {
        addRowDropZone: 0,
        removeRowDropZone: 0,
        getRowDropZoneParams: 0,
        getRowDropPositionIndicator: 0,
        setRowDropPositionIndicator: 0,
    }),
    ...mod('ColumnApi', {
        getColumnDefs: 0,
        getColumnDef: 0,
        getDisplayNameForColumn: 0,
        getColumn: 0,
        getColumns: 0,
        applyColumnState: 0,
        getColumnState: 0,
        resetColumnState: 0,
        isPinning: 0,
        isPinningLeft: 0,
        isPinningRight: 0,
        getDisplayedColAfter: 0,
        getDisplayedColBefore: 0,
        setColumnsVisible: 0,
        setColumnsPinned: 0,
        getAllGridColumns: 0,
        getDisplayedLeftColumns: 0,
        getDisplayedCenterColumns: 0,
        getDisplayedRightColumns: 0,
        getAllDisplayedColumns: 0,
        getAllDisplayedVirtualColumns: 0,
    }),
    ...mod('ColumnAutoSize', {
        sizeColumnsToFit: 0,
        autoSizeColumns: 0,
        autoSizeAllColumns: 0,
    }),
    ...mod('ColumnGroup', {
        setColumnGroupOpened: 0,
        getColumnGroup: 0,
        getProvidedColumnGroup: 0,
        getDisplayNameForColumnGroup: 0,
        getColumnGroupState: 0,
        setColumnGroupState: 0,
        resetColumnGroupState: 0,
        getLeftDisplayedColumnGroups: 0,
        getCenterDisplayedColumnGroups: 0,
        getRightDisplayedColumnGroups: 0,
        getAllDisplayedColumnGroups: 0,
    }),
    ...mod('ColumnMove', {
        moveColumnByIndex: 0,
        moveColumns: 0,
    }),
    ...mod('ColumnResize', {
        setColumnWidths: 0,
    }),
    ...mod('ColumnHover', {
        isColumnHovered: 0,
    }),
    ...mod('EditCore', {
        getCellEditorInstances: 0,
        getEditingCells: 0,
        stopEditing: 0,
        startEditingCell: 0,
        isEditing: 0,
        validateEdit: 0,
    }),
    ...mod('BatchEdit', {
        startBatchEdit: 0,
        cancelBatchEdit: 0,
        commitBatchEdit: 0,
        isBatchEditing: 0,
    }),
    ...mod('UndoRedoEdit', {
        undoCellEditing: 0,
        redoCellEditing: 0,
        getCurrentUndoSize: 0,
        getCurrentRedoSize: 0,
    }),
    ...mod('FilterCore', {
        isAnyFilterPresent: 0,
        onFilterChanged: 0,
    }),
    ...mod('ColumnFilter', {
        isColumnFilterPresent: 0,
        getColumnFilterInstance: 0,
        destroyFilter: 0,
        setFilterModel: 0,
        getFilterModel: 0,
        getColumnFilterModel: 0,
        setColumnFilterModel: 0,
        showColumnFilter: 0,
        getColumnFilterHandler: 0,
        doFilterAction: 0,
    }),
    ...mod('QuickFilter', {
        isQuickFilterPresent: 0,
        getQuickFilter: 0,
        resetQuickFilter: 0,
    }),
    ...mod('Find', {
        findGetActiveMatch: 0,
        findGetTotalMatches: 0,
        findGoTo: 0,
        findNext: 0,
        findPrevious: 0,
        findGetNumMatches: 0,
        findGetParts: 0,
        findClearActive: 0,
        findRefresh: 0,
    }),
    ...mod('Pagination', {
        paginationIsLastPageFound: 0,
        paginationGetPageSize: 0,
        paginationGetCurrentPage: 0,
        paginationGetTotalPages: 0,
        paginationGetRowCount: 0,
        paginationGoToNextPage: 0,
        paginationGoToPreviousPage: 0,
        paginationGoToFirstPage: 0,
        paginationGoToLastPage: 0,
        paginationGoToPage: 0,
    }),
    ...mod('CsrmSsrmSharedApi', {
        expandAll: 0,
        collapseAll: 0,
        onRowHeightChanged: 0,
    }),
    ...mod('SsrmInfiniteSharedApi', {
        setRowCount: 0,
        getCacheBlockState: 0,
        isLastRowIndexKnown: 0,
    }),
    ...mod('ClientSideRowModelApi', {
        onGroupExpandedOrCollapsed: 0,
        refreshClientSideRowModel: 0,
        isRowDataEmpty: 0,
        forEachLeafNode: 0,
        forEachNodeAfterFilter: 0,
        forEachNodeAfterFilterAndSort: 0,
        resetRowHeights: 0,
        applyTransaction: 0,
        applyTransactionAsync: 0,
        flushAsyncTransactions: 0,
        getBestCostNodeSelection: 0,
    }),
    ...mod('CsvExport', {
        getDataAsCsv: 0,
        exportDataAsCsv: 0,
    }),
    ...mod('InfiniteRowModel', {
        refreshInfiniteCache: 0,
        purgeInfiniteCache: 0,
        getInfiniteRowCount: 0,
    }),
    ...mod('AdvancedFilter', {
        getAdvancedFilterModel: 0,
        setAdvancedFilterModel: 0,
        showAdvancedFilterBuilder: 0,
        hideAdvancedFilterBuilder: 0,
    }),
    ...mod('IntegratedCharts', {
        getChartModels: 0,
        getChartRef: 0,
        getChartImageDataURL: 0,
        downloadChart: 0,
        openChartToolPanel: 0,
        closeChartToolPanel: 0,
        createRangeChart: 0,
        createPivotChart: 0,
        createCrossFilterChart: 0,
        updateChart: 0,
        restoreChart: 0,
    }),
    ...mod('Clipboard', {
        copyToClipboard: 0,
        cutToClipboard: 0,
        copySelectedRowsToClipboard: 0,
        copySelectedRangeToClipboard: 0,
        copySelectedRangeDown: 0,
        pasteFromClipboard: 0,
    }),
    ...mod('ExcelExport', {
        getDataAsExcel: 0,
        exportDataAsExcel: 0,
        getSheetDataForExcel: 0,
        getMultipleSheetsAsExcel: 0,
        exportMultipleSheetsAsExcel: 0,
    }),
    ...mod('SharedMasterDetail', {
        addDetailGridInfo: 0,
        removeDetailGridInfo: 0,
        getDetailGridInfo: 0,
        forEachDetailGridInfo: 0,
    }),
    ...mod('ContextMenu', {
        showContextMenu: 0,
    }),
    ...mod('ColumnMenu', {
        showColumnChooser: 0,
        hideColumnChooser: 0,
    }),
    ...mod('CellSelection', {
        getCellRanges: 0,
        addCellRange: 0,
        clearRangeSelection: 0,
        clearCellSelection: 0,
    }),
    ...mod('SharedRowGrouping', {
        setRowGroupColumns: 0,
        removeRowGroupColumns: 0,
        addRowGroupColumns: 0,
        getRowGroupColumns: 0,
        moveRowGroupColumn: 0,
    }),
    ...mod('SharedAggregation', {
        addAggFuncs: 0,
        clearAggFuncs: 0,
        setColumnAggFunc: 0,
    }),
    ...mod('SharedPivot', {
        isPivotMode: 0,
        getPivotResultColumn: 0,
        setValueColumns: 0,
        getValueColumns: 0,
        removeValueColumns: 0,
        addValueColumns: 0,
        setPivotColumns: 0,
        removePivotColumns: 0,
        addPivotColumns: 0,
        getPivotColumns: 0,
        setPivotResultColumns: 0,
        getPivotResultColumns: 0,
    }),
    ...mod('ServerSideRowModelApi', {
        getServerSideSelectionState: 0,
        setServerSideSelectionState: 0,
        applyServerSideTransaction: 0,
        applyServerSideTransactionAsync: 0,
        applyServerSideRowData: 0,
        retryServerSideLoads: 0,
        flushServerSideAsyncTransactions: 0,
        refreshServerSide: 0,
        getServerSideGroupLevelState: 0,
    }),
    ...mod('SideBar', {
        isSideBarVisible: 0,
        setSideBarVisible: 0,
        setSideBarPosition: 0,
        openToolPanel: 0,
        closeToolPanel: 0,
        getOpenedToolPanel: 0,
        refreshToolPanel: 0,
        isToolPanelShowing: 0,
        getToolPanelInstance: 0,
        getSideBar: 0,
    }),
    ...mod('StatusBar', {
        getStatusPanel: 0,
    }),
};


/***/ }),

/***/ 18192:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getDisplayedRowCount = exports.getDisplayedRowAtIndex = exports.getLastDisplayedRowIndex = exports.getFirstDisplayedRowIndex = exports.forEachNode = exports.getRenderedNodes = exports.addRenderedRowListener = exports.getRowNode = exports.setRowNodeExpanded = exports.redrawRows = void 0;
function redrawRows(beans, params = {}) {
    const rowNodes = params ? params.rowNodes : undefined;
    beans.frameworkOverrides.wrapIncoming(() => beans.rowRenderer.redrawRows(rowNodes));
}
exports.redrawRows = redrawRows;
function setRowNodeExpanded(beans, rowNode, expanded, expandParents, forceSync) {
    if (rowNode) {
        // expand all parents recursively, except root node.
        if (expandParents && rowNode.parent && rowNode.parent.level !== -1) {
            setRowNodeExpanded(beans, rowNode.parent, expanded, expandParents, forceSync);
        }
        rowNode.setExpanded(expanded, undefined, forceSync);
    }
}
exports.setRowNodeExpanded = setRowNodeExpanded;
function getRowNode(beans, id) {
    return beans.rowModel.getRowNode(id);
}
exports.getRowNode = getRowNode;
function addRenderedRowListener(beans, eventName, rowIndex, callback) {
    beans.rowRenderer.addRenderedRowListener(eventName, rowIndex, callback);
}
exports.addRenderedRowListener = addRenderedRowListener;
function getRenderedNodes(beans) {
    return beans.rowRenderer.getRenderedNodes();
}
exports.getRenderedNodes = getRenderedNodes;
function forEachNode(beans, callback, includeFooterNodes) {
    beans.rowModel.forEachNode(callback, includeFooterNodes);
}
exports.forEachNode = forEachNode;
function getFirstDisplayedRowIndex(beans) {
    return beans.rowRenderer.firstRenderedRow;
}
exports.getFirstDisplayedRowIndex = getFirstDisplayedRowIndex;
function getLastDisplayedRowIndex(beans) {
    return beans.rowRenderer.lastRenderedRow;
}
exports.getLastDisplayedRowIndex = getLastDisplayedRowIndex;
function getDisplayedRowAtIndex(beans, index) {
    return beans.rowModel.getRow(index);
}
exports.getDisplayedRowAtIndex = getDisplayedRowAtIndex;
function getDisplayedRowCount(beans) {
    return beans.rowModel.getRowCount();
}
exports.getDisplayedRowCount = getDisplayedRowCount;


/***/ }),

/***/ 66876:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._getServerSideRowModel = exports._getInfiniteRowModel = exports._getClientSideRowModel = void 0;
function _getClientSideRowModel(beans) {
    const rowModel = beans.rowModel;
    return rowModel.getType() === 'clientSide' ? rowModel : undefined;
}
exports._getClientSideRowModel = _getClientSideRowModel;
function _getInfiniteRowModel(beans) {
    const rowModel = beans.rowModel;
    return rowModel.getType() === 'infinite' ? rowModel : undefined;
}
exports._getInfiniteRowModel = _getInfiniteRowModel;
function _getServerSideRowModel(beans) {
    const rowModel = beans.rowModel;
    return rowModel.getType() === 'serverSide' ? rowModel : undefined;
}
exports._getServerSideRowModel = _getServerSideRowModel;


/***/ }),

/***/ 11765:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ensureNodeVisible = exports.ensureIndexVisible = exports.ensureColumnVisible = exports.getHorizontalPixelRange = exports.getVerticalPixelRange = void 0;
function getVerticalPixelRange(beans) {
    return beans.ctrlsSvc.getScrollFeature().getVScrollPosition();
}
exports.getVerticalPixelRange = getVerticalPixelRange;
function getHorizontalPixelRange(beans) {
    return beans.ctrlsSvc.getScrollFeature().getHScrollPosition();
}
exports.getHorizontalPixelRange = getHorizontalPixelRange;
function ensureColumnVisible(beans, key, position = 'auto') {
    beans.frameworkOverrides.wrapIncoming(() => beans.ctrlsSvc.getScrollFeature().ensureColumnVisible(key, position), 'ensureVisible');
}
exports.ensureColumnVisible = ensureColumnVisible;
function ensureIndexVisible(beans, index, position) {
    beans.frameworkOverrides.wrapIncoming(() => beans.ctrlsSvc.getScrollFeature().ensureIndexVisible(index, position), 'ensureVisible');
}
exports.ensureIndexVisible = ensureIndexVisible;
function ensureNodeVisible(beans, nodeSelector, position = null) {
    beans.frameworkOverrides.wrapIncoming(() => beans.ctrlsSvc.getScrollFeature().ensureNodeVisible(nodeSelector, position), 'ensureVisible');
}
exports.ensureNodeVisible = ensureNodeVisible;


/***/ }),

/***/ 36437:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SsrmInfiniteSharedApiModule = exports.CsrmSsrmSharedApiModule = void 0;
const version_1 = __webpack_require__(97205);
const csrmSsrmSharedApi_1 = __webpack_require__(79513);
const ssrmInfiniteSharedApi_1 = __webpack_require__(68496);
// these modules are not used in core, but are shared between multiple other modules
/**
 * @internal
 */
exports.CsrmSsrmSharedApiModule = {
    moduleName: 'CsrmSsrmSharedApi',
    version: version_1.VERSION,
    apiFunctions: {
        expandAll: csrmSsrmSharedApi_1.expandAll,
        collapseAll: csrmSsrmSharedApi_1.collapseAll,
        onRowHeightChanged: csrmSsrmSharedApi_1.onRowHeightChanged,
    },
};
/**
 * @internal
 */
exports.SsrmInfiniteSharedApiModule = {
    moduleName: 'SsrmInfiniteSharedApi',
    version: version_1.VERSION,
    apiFunctions: {
        setRowCount: ssrmInfiniteSharedApi_1.setRowCount,
        getCacheBlockState: ssrmInfiniteSharedApi_1.getCacheBlockState,
        isLastRowIndexKnown: ssrmInfiniteSharedApi_1.isLastRowIndexKnown,
    },
};


/***/ }),

/***/ 68496:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isLastRowIndexKnown = exports.getCacheBlockState = exports.setRowCount = void 0;
const gridOptionsUtils_1 = __webpack_require__(67274);
const logging_1 = __webpack_require__(47764);
const rowModelApiUtils_1 = __webpack_require__(66876);
function setRowCount(beans, rowCount, maxRowFound) {
    const serverSideRowModel = (0, rowModelApiUtils_1._getServerSideRowModel)(beans);
    if (serverSideRowModel) {
        if (beans.rowGroupColsSvc?.columns.length === 0) {
            if (rowCount < 0) {
                (0, logging_1._error)(238);
                return;
            }
            serverSideRowModel.setRowCount(rowCount, maxRowFound);
            return;
        }
        (0, logging_1._error)(28);
        return;
    }
    const infiniteRowModel = (0, rowModelApiUtils_1._getInfiniteRowModel)(beans);
    if (infiniteRowModel) {
        infiniteRowModel.setRowCount(rowCount, maxRowFound);
        return;
    }
}
exports.setRowCount = setRowCount;
function getCacheBlockState(beans) {
    if ((0, gridOptionsUtils_1._isServerSideRowModel)(beans.gos)) {
        const ssrm = beans.rowModel;
        return ssrm.getBlockStates();
    }
    return beans.rowNodeBlockLoader?.getBlockState() ?? {};
}
exports.getCacheBlockState = getCacheBlockState;
function isLastRowIndexKnown(beans) {
    return beans.rowModel.isLastRowIndexKnown();
}
exports.isLastRowIndexKnown = isLastRowIndexKnown;


/***/ }),

/***/ 35628:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AutoScrollService = void 0;
class AutoScrollService {
    constructor(params) {
        this.tickingInterval = null;
        this.onScrollCallback = null;
        this.scrollContainer = params.scrollContainer;
        this.scrollHorizontally = params.scrollAxis.indexOf('x') !== -1;
        this.scrollVertically = params.scrollAxis.indexOf('y') !== -1;
        this.scrollByTick = params.scrollByTick != null ? params.scrollByTick : 20;
        if (params.onScrollCallback) {
            this.onScrollCallback = params.onScrollCallback;
        }
        if (this.scrollVertically) {
            this.getVerticalPosition = params.getVerticalPosition;
            this.setVerticalPosition = params.setVerticalPosition;
        }
        if (this.scrollHorizontally) {
            this.getHorizontalPosition = params.getHorizontalPosition;
            this.setHorizontalPosition = params.setHorizontalPosition;
        }
        this.shouldSkipVerticalScroll = params.shouldSkipVerticalScroll || (() => false);
        this.shouldSkipHorizontalScroll = params.shouldSkipHorizontalScroll || (() => false);
    }
    check(mouseEvent, forceSkipVerticalScroll = false) {
        const skipVerticalScroll = forceSkipVerticalScroll || this.shouldSkipVerticalScroll();
        if (skipVerticalScroll && this.shouldSkipHorizontalScroll()) {
            return;
        }
        const rect = this.scrollContainer.getBoundingClientRect();
        const scrollTick = this.scrollByTick;
        this.tickLeft = mouseEvent.clientX < rect.left + scrollTick;
        this.tickRight = mouseEvent.clientX > rect.right - scrollTick;
        this.tickUp = mouseEvent.clientY < rect.top + scrollTick && !skipVerticalScroll;
        this.tickDown = mouseEvent.clientY > rect.bottom - scrollTick && !skipVerticalScroll;
        if (this.tickLeft || this.tickRight || this.tickUp || this.tickDown) {
            this.ensureTickingStarted();
        }
        else {
            this.ensureCleared();
        }
    }
    ensureTickingStarted() {
        if (this.tickingInterval === null) {
            this.tickingInterval = window.setInterval(this.doTick.bind(this), 100);
            this.tickCount = 0;
        }
    }
    doTick() {
        this.tickCount++;
        const tickAmount = this.tickCount > 20 ? 200 : this.tickCount > 10 ? 80 : 40;
        if (this.scrollVertically) {
            const vScrollPosition = this.getVerticalPosition();
            if (this.tickUp) {
                this.setVerticalPosition(vScrollPosition - tickAmount);
            }
            if (this.tickDown) {
                this.setVerticalPosition(vScrollPosition + tickAmount);
            }
        }
        if (this.scrollHorizontally) {
            const hScrollPosition = this.getHorizontalPosition();
            if (this.tickLeft) {
                this.setHorizontalPosition(hScrollPosition - tickAmount);
            }
            if (this.tickRight) {
                this.setHorizontalPosition(hScrollPosition + tickAmount);
            }
        }
        if (this.onScrollCallback) {
            this.onScrollCallback();
        }
    }
    ensureCleared() {
        if (this.tickingInterval) {
            window.clearInterval(this.tickingInterval);
            this.tickingInterval = null;
        }
    }
}
exports.AutoScrollService = AutoScrollService;


/***/ }),

/***/ 83263:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BASE_URL = void 0;
// DO NOT UPDATE MANUALLY: Generated from script during build time
exports.BASE_URL = 'https://www.ag-grid.com';


/***/ }),

/***/ 31954:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractClientSideNodeManager = void 0;
const beanStub_1 = __webpack_require__(68731);
const rowNode_1 = __webpack_require__(3373);
const gridOptionsUtils_1 = __webpack_require__(67274);
const logging_1 = __webpack_require__(47764);
const ROOT_NODE_ID = 'ROOT_NODE_ID';
class AbstractClientSideNodeManager extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.nextId = 0;
        this.allNodesMap = {};
        this.rootNode = null;
    }
    getRowNode(id) {
        return this.allNodesMap[id];
    }
    extractRowData() {
        return this.rootNode?.allLeafChildren?.map((node) => node.data);
    }
    activate(rootNode) {
        this.rootNode = rootNode;
        rootNode.group = true;
        rootNode.level = -1;
        rootNode.id = ROOT_NODE_ID;
        rootNode.allLeafChildren = [];
        rootNode.childrenAfterGroup = [];
        rootNode.childrenAfterSort = [];
        rootNode.childrenAfterAggFilter = [];
        rootNode.childrenAfterFilter = [];
        this.updateRootSiblingArrays(rootNode);
    }
    deactivate() {
        if (this.rootNode) {
            this.allNodesMap = {};
            this.rootNode = null;
        }
    }
    destroy() {
        super.destroy();
        // Forcefully deallocate memory
        this.allNodesMap = {};
        this.rootNode = null;
    }
    setNewRowData(rowData) {
        const rootNode = this.rootNode;
        if (!rootNode) {
            return;
        }
        this.dispatchRowDataUpdateStartedEvent(rowData);
        rootNode.childrenAfterFilter = null;
        rootNode.childrenAfterGroup = null;
        rootNode.childrenAfterAggFilter = null;
        rootNode.childrenAfterSort = null;
        rootNode.childrenMapped = null;
        rootNode.updateHasChildren();
        // Clear internal maps
        this.allNodesMap = {};
        this.nextId = 0;
        this.loadNewRowData(rowData);
        this.updateRootSiblingArrays(rootNode);
    }
    updateRootSiblingArrays(rootNode) {
        const sibling = rootNode.sibling;
        if (sibling) {
            sibling.childrenAfterFilter = rootNode.childrenAfterFilter;
            sibling.childrenAfterGroup = rootNode.childrenAfterGroup;
            sibling.childrenAfterAggFilter = rootNode.childrenAfterAggFilter;
            sibling.childrenAfterSort = rootNode.childrenAfterSort;
            sibling.childrenMapped = rootNode.childrenMapped;
            sibling.allLeafChildren = rootNode.allLeafChildren;
        }
    }
    loadNewRowData(rowData) {
        this.rootNode.allLeafChildren = rowData?.map((dataItem, index) => this.createRowNode(dataItem, index)) ?? [];
    }
    setImmutableRowData(params, rowData) {
        const getRowIdFunc = (0, gridOptionsUtils_1._getRowIdCallback)(this.gos);
        const reorder = !this.gos.get('suppressMaintainUnsortedOrder');
        const changedRowNodes = params.changedRowNodes;
        const processedNodes = new Set();
        const rootNode = this.rootNode;
        const oldAllLeafChildren = rootNode.allLeafChildren;
        const oldAllLeafChildrenLen = oldAllLeafChildren.length;
        let nodesAdded = false;
        let nodesRemoved = false;
        let nodesUpdated = false;
        let orderChanged = false;
        for (let i = 0, prevSourceRowIndex = -1, len = rowData.length; i < len; i++) {
            const data = rowData[i];
            let node = this.getRowNode(getRowIdFunc({ data, level: 0 }));
            if (!node) {
                nodesAdded = true;
                node = this.createRowNode(data, -1);
                changedRowNodes.add(node);
            }
            else {
                if (reorder) {
                    const sourceRowIndex = node.sourceRowIndex;
                    orderChanged || (orderChanged = sourceRowIndex <= prevSourceRowIndex || // A node was moved up, so order changed
                        nodesAdded); // A node was inserted not at the end
                    prevSourceRowIndex = sourceRowIndex;
                }
                if (node.data !== data) {
                    nodesUpdated = true;
                    node.updateData(data);
                    changedRowNodes.update(node);
                }
            }
            processedNodes.add(node);
        }
        // Destroy the remaining unprocessed node and collect the removed that were selected.
        const nodesToUnselect = [];
        for (let i = 0; i < oldAllLeafChildrenLen; i++) {
            const node = oldAllLeafChildren[i];
            if (!processedNodes.has(node)) {
                nodesRemoved = true;
                if (node.isSelected()) {
                    nodesToUnselect.push(node);
                }
                if (node.pinnedSibling) {
                    this.beans.pinnedRowModel?.pinRow(node.pinnedSibling, null);
                }
                this.rowNodeDeleted(node);
                changedRowNodes.remove(node);
            }
        }
        if (nodesAdded || nodesRemoved || orderChanged) {
            const newAllLeafChildren = new Array(processedNodes.size); // Preallocate
            let writeIdx = 0;
            if (!reorder) {
                // All the old nodes will be in the new array in the order they were in the old array
                // At the end of this loop, processedNodes will contain only the new appended nodes
                for (let i = 0; i < oldAllLeafChildrenLen; ++i) {
                    const node = oldAllLeafChildren[i];
                    if (processedNodes.delete(node)) {
                        node.sourceRowIndex = writeIdx;
                        newAllLeafChildren[writeIdx++] = node;
                    }
                }
            }
            for (const node of processedNodes) {
                node.sourceRowIndex = writeIdx;
                newAllLeafChildren[writeIdx++] = node;
            }
            rootNode.allLeafChildren = newAllLeafChildren;
            const sibling = rootNode.sibling;
            if (sibling) {
                sibling.allLeafChildren = newAllLeafChildren;
            }
            params.rowNodesOrderChanged || (params.rowNodesOrderChanged = orderChanged);
        }
        if (nodesAdded || nodesRemoved || orderChanged || nodesUpdated) {
            this.deselectNodes(nodesToUnselect);
            params.rowDataUpdated = true;
        }
    }
    /** Called when a node needs to be deleted */
    rowNodeDeleted(node) {
        node.clearRowTopAndRowIndex(); // so row renderer knows to fade row out (and not reposition it)
        const id = node.id;
        const allNodesMap = this.allNodesMap;
        if (allNodesMap[id] === node) {
            delete allNodesMap[id];
        }
    }
    updateRowData(rowDataTran, changedRowNodes) {
        this.dispatchRowDataUpdateStartedEvent(rowDataTran.add);
        const updateRowDataResult = {
            changedRowNodes,
            rowNodeTransaction: { remove: [], update: [], add: [] },
            rowsInserted: false,
        };
        const nodesToUnselect = [];
        const getRowIdFunc = (0, gridOptionsUtils_1._getRowIdCallback)(this.gos);
        this.executeRemove(getRowIdFunc, rowDataTran, updateRowDataResult, nodesToUnselect);
        this.executeUpdate(getRowIdFunc, rowDataTran, updateRowDataResult, nodesToUnselect);
        this.executeAdd(rowDataTran, updateRowDataResult);
        this.deselectNodes(nodesToUnselect);
        return updateRowDataResult;
    }
    executeAdd(rowDataTran, result) {
        const add = rowDataTran.add;
        if (!add?.length) {
            return;
        }
        let allLeafChildren = this.rootNode.allLeafChildren;
        let addIndex = allLeafChildren.length;
        if (typeof rowDataTran.addIndex === 'number') {
            addIndex = this.sanitizeAddIndex(rowDataTran.addIndex);
            if (addIndex > 0) {
                // TODO: this code should not be here, see AG-12602
                // This was a fix for AG-6231, but is not the correct fix
                // We enable it only for trees that use getDataPath and not the new children field
                const getDataPath = this.gos.get('treeData') && this.gos.get('getDataPath');
                if (getDataPath) {
                    for (let i = 0; i < allLeafChildren.length; i++) {
                        const node = allLeafChildren[i];
                        if (node?.rowIndex == addIndex - 1) {
                            addIndex = i + 1;
                            break;
                        }
                    }
                }
            }
        }
        const addLength = add.length;
        const changedRowNodes = result.changedRowNodes;
        // create new row nodes for each data item
        const newNodes = new Array(addLength);
        for (let i = 0; i < addLength; i++) {
            const newNode = this.createRowNode(add[i], addIndex + i);
            changedRowNodes.add(newNode);
            newNodes[i] = newNode;
        }
        const rootNode = this.rootNode;
        if (addIndex < allLeafChildren.length) {
            // Insert at the specified index
            const nodesBeforeIndex = allLeafChildren.slice(0, addIndex);
            const nodesAfterIndex = allLeafChildren.slice(addIndex, allLeafChildren.length);
            // update latter row indexes
            const nodesAfterIndexFirstIndex = nodesBeforeIndex.length + newNodes.length;
            for (let index = 0, length = nodesAfterIndex.length; index < length; ++index) {
                nodesAfterIndex[index].sourceRowIndex = nodesAfterIndexFirstIndex + index;
            }
            allLeafChildren = [...nodesBeforeIndex, ...newNodes, ...nodesAfterIndex];
            // Mark the result as rows inserted
            result.rowsInserted = true;
        }
        else {
            // Just append at the end
            allLeafChildren = allLeafChildren.concat(newNodes);
        }
        rootNode.allLeafChildren = allLeafChildren;
        const sibling = rootNode.sibling;
        if (sibling) {
            sibling.allLeafChildren = allLeafChildren;
        }
        // add new row nodes to the transaction add items
        result.rowNodeTransaction.add = newNodes;
    }
    executeRemove(getRowIdFunc, rowDataTran, { changedRowNodes, rowNodeTransaction }, nodesToUnselect) {
        const { remove } = rowDataTran;
        if (!remove?.length) {
            return;
        }
        const rowIdsRemoved = {};
        remove.forEach((item) => {
            const rowNode = this.lookupRowNode(getRowIdFunc, item);
            if (!rowNode) {
                return;
            }
            if (rowNode.isSelected()) {
                nodesToUnselect.push(rowNode);
            }
            // If a row has been manually pinned, ensure its sibling is also removed
            if (rowNode.pinnedSibling) {
                this.beans.pinnedRowModel?.pinRow(rowNode.pinnedSibling, null);
            }
            // so row renderer knows to fade row out (and not reposition it)
            rowNode.clearRowTopAndRowIndex();
            // NOTE: were we could remove from allLeaveChildren, however removeFromArray() is expensive, especially
            // if called multiple times (eg deleting lots of rows) and if allLeafChildren is a large list
            rowIdsRemoved[rowNode.id] = true;
            // removeFromArray(this.rootNode.allLeafChildren, rowNode);
            delete this.allNodesMap[rowNode.id];
            rowNodeTransaction.remove.push(rowNode);
            changedRowNodes.remove(rowNode);
        });
        const rootNode = this.rootNode;
        rootNode.allLeafChildren = rootNode.allLeafChildren?.filter((rowNode) => !rowIdsRemoved[rowNode.id]) ?? null;
        // after rows have been removed, all following rows need the position index updated
        rootNode.allLeafChildren?.forEach((node, idx) => {
            node.sourceRowIndex = idx;
        });
        const sibling = rootNode.sibling;
        if (sibling) {
            sibling.allLeafChildren = rootNode.allLeafChildren;
        }
    }
    executeUpdate(getRowIdFunc, rowDataTran, { changedRowNodes, rowNodeTransaction }, nodesToUnselect) {
        const { update } = rowDataTran;
        if (!update?.length) {
            return;
        }
        update.forEach((item) => {
            const rowNode = this.lookupRowNode(getRowIdFunc, item);
            if (!rowNode) {
                return;
            }
            rowNode.updateData(item);
            if (!rowNode.selectable && rowNode.isSelected()) {
                nodesToUnselect.push(rowNode);
            }
            rowNodeTransaction.update.push(rowNode);
            changedRowNodes.update(rowNode);
        });
    }
    dispatchRowDataUpdateStartedEvent(rowData) {
        this.eventSvc.dispatchEvent({
            type: 'rowDataUpdateStarted',
            firstRowData: rowData?.length ? rowData[0] : null,
        });
    }
    deselectNodes(nodesToUnselect) {
        const source = 'rowDataChanged';
        const selectionSvc = this.beans.selectionSvc;
        const selectionChanged = nodesToUnselect.length > 0;
        if (selectionChanged) {
            selectionSvc?.setNodesSelected({
                newValue: false,
                nodes: nodesToUnselect,
                suppressFinishActions: true,
                source,
            });
        }
        // we do this regardless of nodes to unselect or not, as it's possible
        // a new node was inserted, so a parent that was previously selected (as all
        // children were selected) should not be tri-state (as new one unselected against
        // all other selected children).
        selectionSvc?.updateGroupsFromChildrenSelections?.(source);
        if (selectionChanged) {
            this.eventSvc.dispatchEvent({
                type: 'selectionChanged',
                source: source,
                selectedNodes: selectionSvc?.getSelectedNodes() ?? null,
                serverSideState: null,
            });
        }
    }
    sanitizeAddIndex(addIndex) {
        const allChildrenCount = this.rootNode.allLeafChildren?.length ?? 0;
        if (addIndex < 0 || addIndex >= allChildrenCount || Number.isNaN(addIndex)) {
            return allChildrenCount; // Append. Also for negative values, as it was historically the behavior.
        }
        // Ensure index is a whole number and not a floating point.
        // Use case: the user want to add a row in the middle, doing addIndex = array.length / 2.
        // If the array has an odd number of elements, the addIndex need to be rounded up.
        // Consider that array.slice does round up internally, but we are setting this value to node.sourceRowIndex.
        return Math.ceil(addIndex);
    }
    createRowNode(data, sourceRowIndex) {
        const node = new rowNode_1.RowNode(this.beans);
        node.parent = this.rootNode;
        node.level = 0;
        node.group = false;
        node.expanded = false;
        node.sourceRowIndex = sourceRowIndex;
        node.setDataAndId(data, String(this.nextId));
        if (this.allNodesMap[node.id]) {
            (0, logging_1._warn)(2, { nodeId: node.id });
        }
        this.allNodesMap[node.id] = node;
        this.nextId++;
        return node;
    }
    lookupRowNode(getRowIdFunc, data) {
        let rowNode;
        if (getRowIdFunc) {
            // find rowNode using id
            const id = getRowIdFunc({ data, level: 0 });
            rowNode = this.allNodesMap[id];
            if (!rowNode) {
                (0, logging_1._error)(4, { id });
                return null;
            }
        }
        else {
            // find rowNode using object references
            rowNode = this.rootNode?.allLeafChildren?.find((node) => node.data === data);
            if (!rowNode) {
                (0, logging_1._error)(5, { data });
                return null;
            }
        }
        return rowNode || null;
    }
}
exports.AbstractClientSideNodeManager = AbstractClientSideNodeManager;


/***/ }),

/***/ 32106:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChangedRowNodes = void 0;
class ChangedRowNodes {
    constructor() {
        this.removals = new Set();
        this.updates = new Set();
        this.adds = new Set();
    }
    /** Marks a row as removed. Order of operations is: remove, update, add */
    remove(node) {
        if (!this.adds.delete(node)) {
            this.updates.delete(node);
            this.removals.add(node);
        }
    }
    /** Marks a row as updated. Order of operations is: remove, update, add */
    update(node) {
        if (!this.adds.has(node)) {
            this.updates.add(node);
        }
    }
    /** Marks a row as added. Order of operation is: remove, update, add */
    add(node) {
        this.adds.add(node);
    }
}
exports.ChangedRowNodes = ChangedRowNodes;


/***/ }),

/***/ 28128:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClientSideNodeManager = void 0;
const abstractClientSideNodeManager_1 = __webpack_require__(31954);
class ClientSideNodeManager extends abstractClientSideNodeManager_1.AbstractClientSideNodeManager {
    constructor() {
        super(...arguments);
        this.beanName = 'csrmNodeSvc';
    }
}
exports.ClientSideNodeManager = ClientSideNodeManager;


/***/ }),

/***/ 83278:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClientSideRowModel = void 0;
const beanStub_1 = __webpack_require__(68731);
const rowNode_1 = __webpack_require__(3373);
const gridOptionsUtils_1 = __webpack_require__(67274);
const array_1 = __webpack_require__(31502);
const changedPath_1 = __webpack_require__(76800);
const function_1 = __webpack_require__(92043);
const logging_1 = __webpack_require__(47764);
const changedRowNodes_1 = __webpack_require__(32106);
const filterStage_1 = __webpack_require__(48287);
const sortStage_1 = __webpack_require__(19849);
class ClientSideRowModel extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'rowModel';
        // top most node of the tree. the children are the user provided data.
        this.rootNode = null;
        this.rowsToDisplay = []; // the rows mapped to rows to display
        this.lastHighlightedRow = null;
        /** Has the start method been called */
        this.started = false;
        /**
         * This is to prevent refresh model being called when it's already being called.
         * E.g. the group stage can trigger initial state filter model to be applied. This fires onFilterChanged,
         * which then triggers the listener here that calls refresh model again but at the filter stage
         * (which is about to be run by the original call).
         */
        this.isRefreshingModel = false;
        this.rowNodesCountReady = false;
        this.rowCountReady = false;
        this.onRowHeightChanged_debounced = (0, function_1._debounce)(this, this.onRowHeightChanged.bind(this), 100);
    }
    wireBeans(beans) {
        this.colModel = beans.colModel;
        this.valueCache = beans.valueCache;
        this.filterStage = beans.filterStage;
        this.sortStage = beans.sortStage;
        this.flattenStage = beans.flattenStage;
        this.groupStage = beans.groupStage;
        this.aggStage = beans.aggStage;
        this.pivotStage = beans.pivotStage;
        this.filterAggStage = beans.filterAggStage;
    }
    postConstruct() {
        this.orderedStages = [
            this.groupStage,
            this.filterStage,
            this.pivotStage,
            this.aggStage,
            this.sortStage,
            this.filterAggStage,
            this.flattenStage,
        ].filter((stage) => !!stage);
        const refreshEverythingFunc = this.refreshModel.bind(this, { step: 'group' });
        const refreshEverythingAfterColsChangedFunc = this.refreshModel.bind(this, {
            step: 'group',
            afterColumnsChanged: true,
            keepRenderedRows: true,
            // we want animations cos sorting or filtering could be applied
            animate: !this.gos.get('suppressAnimationFrame'),
        });
        this.addManagedEventListeners({
            newColumnsLoaded: refreshEverythingAfterColsChangedFunc,
            columnRowGroupChanged: refreshEverythingFunc,
            columnValueChanged: this.onValueChanged.bind(this),
            columnPivotChanged: this.refreshModel.bind(this, { step: 'pivot' }),
            filterChanged: this.onFilterChanged.bind(this),
            sortChanged: this.onSortChanged.bind(this),
            columnPivotModeChanged: refreshEverythingFunc,
            gridStylesChanged: this.onGridStylesChanges.bind(this),
            gridReady: this.onGridReady.bind(this),
        });
        // doesn't need done if doing full reset
        // Property listeners which call `refreshModel` at different stages
        this.addPropertyListeners();
        this.rootNode = new rowNode_1.RowNode(this.beans);
        const nodeManager = this.getNewNodeManager();
        this.nodeManager = nodeManager;
        nodeManager.activate(this.rootNode);
    }
    getNewNodeManager() {
        const { gos, beans } = this;
        return ((0, gridOptionsUtils_1._getGroupingApproach)(gos) === 'treeNested' && beans.csrmChildrenTreeNodeSvc) || beans.csrmNodeSvc;
    }
    addPropertyListeners() {
        // Omitted Properties
        //
        // We do not act reactively on all functional properties, as it's possible the application is React and
        // has not memoised the property and it's getting set every render.
        //
        // ** LIST OF NON REACTIVE, NO ARGUMENT
        //
        // getDataPath, getRowId -- these are called once for each Node when the Node is created.
        //                       -- these are immutable Node properties (ie a Node ID cannot be changed)
        //
        // isRowMaster           -- called when masterDetail is true and the Node is created or the property was changed
        //
        // getRowHeight - this is called once when Node is created, if a new getRowHeight function is provided,
        //              - we do not revisit the heights of each node.
        //
        // pivotDefaultExpanded - relevant for initial pivot column creation, no impact on existing pivot columns.
        //
        // deltaSort - this changes the type of algorithm used only, it doesn't change the sort order. so no point
        //           - in doing the sort again as the same result will be got. the new Prop will be used next time we sort.
        //
        // ** LIST OF NON REACTIVE, SOME ARGUMENT
        // ** For these, they could be reactive, but not convinced the business argument is strong enough,
        // ** so leaving as non-reactive for now, and see if anyone complains.
        //
        // processPivotResultColDef, processPivotResultColGroupDef
        //                       - there is an argument for having these reactive, that if the application changes
        //                       - these props, we should re-create the Pivot Columns, however it's highly unlikely
        //                       - the application would change these functions, far more likely the functions were
        //                       - non memoised correctly.
        const allProps = [
            'treeData',
            'treeDataChildrenField',
            ...this.orderedStages.flatMap(({ refreshProps }) => [...refreshProps]),
        ];
        this.addManagedPropertyListeners(allProps, (params) => {
            const properties = params.changeSet?.properties;
            if (properties) {
                this.onPropChange(properties);
            }
        });
        // TODO: HACK: rowData should be in the list of allProps instead of being registered separately.
        // but due to AG-13498, the columnModel will execute AFTER the previous listeners if properties
        // the column model listen to together with the previous listener are changed together.
        // So this is a temporary solution to make sure rowData is processed after the columnModel is ready.
        // Unfortunately this can result in double refresh when multiple properties are changed together, as it was before version 33.
        this.addManagedPropertyListener('rowData', () => this.onPropChange(['rowData']));
        this.addManagedPropertyListener('rowHeight', () => this.resetRowHeights());
    }
    start() {
        this.started = true;
        if (this.rowNodesCountReady) {
            this.refreshModel({ step: 'group', rowDataUpdated: true, newData: true });
        }
        else {
            this.setInitialData();
        }
    }
    setInitialData() {
        const rowData = this.gos.get('rowData');
        if (rowData) {
            this.onPropChange(['rowData']);
        }
    }
    ensureRowHeightsValid(startPixel, endPixel, startLimitIndex, endLimitIndex) {
        let atLeastOneChange;
        let res = false;
        // we do this multiple times as changing the row heights can also change the first and last rows,
        // so the first pass can make lots of rows smaller, which means the second pass we end up changing
        // more rows.
        do {
            atLeastOneChange = false;
            const rowAtStartPixel = this.getRowIndexAtPixel(startPixel);
            const rowAtEndPixel = this.getRowIndexAtPixel(endPixel);
            // keep check to current page if doing pagination
            const firstRow = Math.max(rowAtStartPixel, startLimitIndex);
            const lastRow = Math.min(rowAtEndPixel, endLimitIndex);
            for (let rowIndex = firstRow; rowIndex <= lastRow; rowIndex++) {
                const rowNode = this.getRow(rowIndex);
                if (rowNode.rowHeightEstimated) {
                    const rowHeight = (0, gridOptionsUtils_1._getRowHeightForNode)(this.beans, rowNode);
                    rowNode.setRowHeight(rowHeight.height);
                    atLeastOneChange = true;
                    res = true;
                }
            }
            if (atLeastOneChange) {
                this.setRowTopAndRowIndex();
            }
        } while (atLeastOneChange);
        return res;
    }
    onPropChange(properties) {
        if (!this.rootNode) {
            return; // Destroyed.
        }
        const gos = this.gos;
        const changedProps = new Set(properties);
        const params = {
            step: 'nothing',
            changedProps,
        };
        const rowDataChanged = changedProps.has('rowData');
        const oldNodeManager = this.nodeManager;
        const nodeManager = this.getNewNodeManager();
        const reset = oldNodeManager !== nodeManager ||
            (rowDataChanged && changedProps.has('treeData') && gos.get('treeData')) ||
            (changedProps.has('treeDataChildrenField') && gos.get('treeData'));
        let newRowData;
        if (reset || rowDataChanged) {
            newRowData = gos.get('rowData');
            if (newRowData != null && !Array.isArray(newRowData)) {
                newRowData = null;
                (0, logging_1._warn)(1);
            }
        }
        if (reset) {
            // If we are here, it means that the row manager need to be changed or fully reloaded
            if (!rowDataChanged) {
                // No new rowData was passed, so to include user executed transaction we need to extract
                // the row data from the node manager as it might be different from the original rowData
                newRowData = oldNodeManager?.extractRowData() ?? newRowData;
            }
            if (oldNodeManager !== nodeManager) {
                oldNodeManager?.deactivate();
                this.nodeManager = nodeManager;
            }
            nodeManager.activate(this.rootNode);
        }
        if (newRowData) {
            const immutable = !reset &&
                !this.isEmpty() &&
                newRowData.length > 0 &&
                gos.exists('getRowId') &&
                // this property is a backwards compatibility property, for those who want
                // the old behaviour of Row IDs but NOT Immutable Data.
                !gos.get('resetRowDataOnUpdate');
            if (immutable) {
                params.keepRenderedRows = true;
                params.animate = !this.gos.get('suppressAnimationFrame');
                params.changedRowNodes = new changedRowNodes_1.ChangedRowNodes();
                nodeManager.setImmutableRowData(params, newRowData);
            }
            else {
                params.rowDataUpdated = true;
                params.newData = true;
                // no need to invalidate cache, as the cache is stored on the rowNode,
                // so new rowNodes means the cache is wiped anyway.
                const { selectionSvc, pinnedRowModel } = this.beans;
                // - clears selection, done before we set row data to ensure it isn't readded via `selectionSvc.syncInOldRowNode`
                selectionSvc?.reset('rowDataChanged');
                // only clear pinned rows if using manual pinning
                if (pinnedRowModel?.isManual()) {
                    pinnedRowModel.reset();
                }
                this.rowNodesCountReady = true;
                nodeManager.setNewRowData(newRowData);
            }
        }
        if (params.rowDataUpdated) {
            params.step = 'group';
        }
        else if (params.step === 'nothing') {
            for (const { refreshProps, step } of this.orderedStages) {
                if (properties.some((prop) => refreshProps.has(prop))) {
                    params.step = step;
                    break;
                }
            }
        }
        if (params.step !== 'nothing') {
            this.refreshModel(params);
        }
    }
    setRowTopAndRowIndex() {
        const { beans, rowsToDisplay } = this;
        const defaultRowHeight = beans.environment.getDefaultRowHeight();
        let nextRowTop = 0;
        // mapping displayed rows is not needed for this method, however it's used in
        // clearRowTopAndRowIndex(), and given we are looping through this.rowsToDisplay here,
        // we create the map here for performance reasons, so we don't loop a second time
        // in clearRowTopAndRowIndex()
        const displayedRowsMapped = new Set();
        // we don't estimate if doing fullHeight or autoHeight, as all rows get rendered all the time
        // with these two layouts.
        const allowEstimate = (0, gridOptionsUtils_1._isDomLayout)(this.gos, 'normal');
        for (let i = 0, len = rowsToDisplay.length; i < len; ++i) {
            const rowNode = rowsToDisplay[i];
            if (rowNode.id != null) {
                displayedRowsMapped.add(rowNode.id);
            }
            if (rowNode.rowHeight == null) {
                const rowHeight = (0, gridOptionsUtils_1._getRowHeightForNode)(beans, rowNode, allowEstimate, defaultRowHeight);
                rowNode.setRowHeight(rowHeight.height, rowHeight.estimated);
            }
            rowNode.setRowTop(nextRowTop);
            rowNode.setRowIndex(i);
            nextRowTop += rowNode.rowHeight;
        }
        return displayedRowsMapped;
    }
    clearRowTopAndRowIndex(changedPath, displayedRowsMapped) {
        const changedPathActive = changedPath.active;
        const clearIfNotDisplayed = (rowNode) => {
            if (rowNode && rowNode.id != null && !displayedRowsMapped.has(rowNode.id)) {
                rowNode.clearRowTopAndRowIndex();
            }
        };
        const recurse = (rowNode) => {
            if (rowNode === null) {
                return;
            }
            clearIfNotDisplayed(rowNode);
            clearIfNotDisplayed(rowNode.detailNode);
            clearIfNotDisplayed(rowNode.sibling);
            if (rowNode.hasChildren()) {
                if (rowNode.childrenAfterGroup) {
                    // if a changedPath is active, it means we are here because of a transaction update or
                    // a change detection. neither of these impacts the open/closed state of groups. so if
                    // a group is not open this time, it was not open last time. so we know all closed groups
                    // already have their top positions cleared. so there is no need to traverse all the way
                    // when changedPath is active and the rowNode is not expanded.
                    const isRootNode = rowNode.level == -1; // we need to give special consideration for root node,
                    // as expanded=undefined for root node
                    const skipChildren = changedPathActive && !isRootNode && !rowNode.expanded;
                    if (!skipChildren) {
                        rowNode.childrenAfterGroup.forEach(recurse);
                    }
                }
            }
        };
        recurse(this.rootNode);
    }
    isLastRowIndexKnown() {
        return true;
    }
    getRowCount() {
        if (this.rowsToDisplay) {
            return this.rowsToDisplay.length;
        }
        return 0;
    }
    /**
     * Returns the number of rows with level === 1
     */
    getTopLevelRowCount() {
        const rootNode = this.rootNode;
        if (!rootNode) {
            return 0;
        }
        if (this.rowsToDisplay.length === 0) {
            return 0;
        }
        // exception to func comment, if showing root node, then we return that
        const showingRootNode = this.rowsToDisplay && this.rowsToDisplay[0] === rootNode;
        if (showingRootNode) {
            return 1;
        }
        // we use the childrenAfterSort as postSortRows is occasionally used to reduce row count.
        const filteredChildren = rootNode.childrenAfterSort;
        const totalFooterInc = rootNode.sibling ? 1 : 0;
        return (filteredChildren ? filteredChildren.length : 0) + totalFooterInc;
    }
    /**
     * Get the row display index by the top level index
     * top level index is the index of rows with level === 1
     */
    getTopLevelRowDisplayedIndex(topLevelIndex) {
        const { rootNode, rowsToDisplay } = this;
        const showingRootNode = !rootNode || !rowsToDisplay.length || rowsToDisplay[0] === rootNode;
        // exception to function comment, if showing footer node (level === -1) return 0.
        if (showingRootNode) {
            return topLevelIndex;
        }
        const { childrenAfterSort } = rootNode;
        const getDefaultIndex = (adjustedIndex) => {
            let rowNode = childrenAfterSort[adjustedIndex];
            if (this.gos.get('groupHideOpenParents')) {
                // if hideOpenParents, then get lowest displayed descendent
                while (rowNode.expanded && rowNode.childrenAfterSort && rowNode.childrenAfterSort.length > 0) {
                    rowNode = rowNode.childrenAfterSort[0];
                }
            }
            return rowNode.rowIndex;
        };
        const { footerSvc } = this.beans;
        if (footerSvc) {
            return footerSvc.getTopDisplayIndex(rowsToDisplay, topLevelIndex, childrenAfterSort, getDefaultIndex);
        }
        else {
            return getDefaultIndex(topLevelIndex);
        }
    }
    /**
     * The opposite of `getTopLevelRowDisplayedIndex`
     */
    getTopLevelIndexFromDisplayedIndex(displayedIndex) {
        const { rootNode, rowsToDisplay } = this;
        const showingRootNode = !rootNode || !rowsToDisplay.length || rowsToDisplay[0] === rootNode;
        if (showingRootNode) {
            return displayedIndex;
        }
        let node = this.getRow(displayedIndex);
        if (node.footer) {
            node = node.sibling;
        }
        // find the top level node
        while (node.parent && node.parent !== rootNode) {
            node = node.parent;
        }
        const topLevelIndex = rootNode.childrenAfterSort?.findIndex((childNode) => childNode === node);
        return topLevelIndex === -1 ? displayedIndex : topLevelIndex ?? displayedIndex;
    }
    getRowBounds(index) {
        const rowNode = this.rowsToDisplay[index];
        if (rowNode) {
            return {
                rowTop: rowNode.rowTop,
                rowHeight: rowNode.rowHeight,
            };
        }
        return null;
    }
    onRowGroupOpened() {
        const animate = (0, gridOptionsUtils_1._isAnimateRows)(this.gos);
        this.refreshModel({ step: 'map', keepRenderedRows: true, animate: animate });
    }
    onFilterChanged(event) {
        if (event.afterDataChange) {
            return;
        }
        const animate = (0, gridOptionsUtils_1._isAnimateRows)(this.gos);
        const primaryOrQuickFilterChanged = event.columns.length === 0 || event.columns.some((col) => col.isPrimary());
        const step = primaryOrQuickFilterChanged ? 'filter' : 'filter_aggregates';
        this.refreshModel({ step: step, keepRenderedRows: true, animate: animate });
    }
    onSortChanged() {
        const animate = (0, gridOptionsUtils_1._isAnimateRows)(this.gos);
        this.refreshModel({
            step: 'sort',
            keepRenderedRows: true,
            animate: animate,
        });
    }
    getType() {
        return 'clientSide';
    }
    onValueChanged() {
        this.refreshModel({ step: this.colModel.isPivotActive() ? 'pivot' : 'aggregate' });
    }
    createChangePath(enabled) {
        // for updates, if the row is updated at all, then we re-calc all the values
        // in that row. we could compare each value to each old value, however if we
        // did this, we would be calling the valueSvc twice, once on the old value
        // and once on the new value. so it's less valueGetter calls if we just assume
        // each column is different. that way the changedPath is used so that only
        // the impacted parent rows are recalculated, parents who's children have
        // not changed are not impacted.
        const changedPath = new changedPath_1.ChangedPath(false, this.rootNode);
        if (!enabled) {
            changedPath.active = false;
        }
        return changedPath;
    }
    isSuppressModelUpdateAfterUpdateTransaction(params) {
        if (!this.gos.get('suppressModelUpdateAfterUpdateTransaction')) {
            return false; // Not suppressed
        }
        const { changedRowNodes, newData, rowDataUpdated } = params;
        if (!changedRowNodes || newData || !rowDataUpdated) {
            return false; // Not a transaction update
        }
        if (changedRowNodes.removals.size || changedRowNodes.adds.size) {
            return false; // There are added rows or removed rows, not just updates
        }
        return true; // Nothing changed, or only updates with no new rows and no removals
    }
    beforeRefreshModel(params, groupsChanged = false) {
        this.eventSvc.dispatchEvent({ type: 'beforeRefreshModel', params, groupsChanged });
        if (this.started && params.rowDataUpdated) {
            this.eventSvc.dispatchEvent({ type: 'rowDataUpdated' });
        }
    }
    refreshModel(params) {
        if (!this.rootNode) {
            return; // Destroyed
        }
        // this goes through the pipeline of stages. what's in my head is similar
        // to the diagram on this page:
        // http://commons.apache.org/sandbox/commons-pipeline/pipeline_basics.html
        // however we want to keep the results of each stage, hence we manually call
        // each step rather than have them chain each other.
        // fallthrough in below switch is on purpose,
        // eg if STEP_FILTER, then all steps below this
        // step get done
        // let start: number;
        // console.log('======= start =======');
        const changedPath = (params.changedPath ?? (params.changedPath = this.createChangePath(!params.newData && !!params.rowDataUpdated)));
        if (!this.started ||
            this.isRefreshingModel ||
            this.colModel.changeEventsDispatching ||
            this.isSuppressModelUpdateAfterUpdateTransaction(params)) {
            this.beforeRefreshModel(params);
            return;
        }
        this.isRefreshingModel = true;
        if (params.step !== 'group') {
            this.beforeRefreshModel(params);
        }
        /* eslint-disable no-fallthrough */
        switch (params.step) {
            case 'group': {
                const groupingChanged = this.doRowGrouping(params);
                this.beforeRefreshModel(params, groupingChanged); // Do this after grouping, so the parent field is correct
                if (params.step === 'group' && this.rowNodesCountReady) {
                    this.rowCountReady = true; // only if row data has been set
                    this.eventSvc.dispatchEventOnce({ type: 'rowCountReady' });
                }
            }
            case 'filter':
                this.doFilter(changedPath);
            case 'pivot':
                this.doPivot(changedPath);
            case 'aggregate': // depends on agg fields
                this.doAggregate(changedPath);
            case 'filter_aggregates':
                this.doFilterAggregates(changedPath);
            case 'sort':
                this.doSort(params.changedRowNodes, changedPath);
            case 'map':
                this.doRowsToDisplay();
        }
        /* eslint-enable no-fallthrough */
        // set all row tops to null, then set row tops on all visible rows. if we don't
        // do this, then the algorithm below only sets row tops, old row tops from old rows
        // will still lie around
        const displayedNodesMapped = this.setRowTopAndRowIndex();
        this.clearRowTopAndRowIndex(changedPath, displayedNodesMapped);
        this.isRefreshingModel = false;
        this.eventSvc.dispatchEvent({
            type: 'modelUpdated',
            animate: params.animate,
            keepRenderedRows: params.keepRenderedRows,
            newData: params.newData,
            newPage: false,
            keepUndoRedoStack: params.keepUndoRedoStack,
        });
    }
    isEmpty() {
        return !this.rootNode?.allLeafChildren?.length || !this.colModel?.ready;
    }
    isRowsToRender() {
        return this.rowsToDisplay.length > 0;
    }
    getNodesInRangeForSelection(firstInRange, lastInRange) {
        let started = false;
        let finished = false;
        const result = [];
        const groupsSelectChildren = (0, gridOptionsUtils_1._getGroupSelectsDescendants)(this.gos);
        this.forEachNodeAfterFilterAndSort((rowNode) => {
            // range has been closed, skip till end
            if (finished) {
                return;
            }
            if (started) {
                if (rowNode === lastInRange || rowNode === firstInRange) {
                    // check if this is the last node we're going to be adding
                    finished = true;
                    // if the final node was a group node, and we're doing groupSelectsChildren
                    // make the exception to select all of it's descendants too
                    if (rowNode.group && groupsSelectChildren) {
                        result.push(...rowNode.allLeafChildren);
                        return;
                    }
                }
            }
            if (!started) {
                if (rowNode !== lastInRange && rowNode !== firstInRange) {
                    // still haven't hit a boundary node, keep searching
                    return;
                }
                started = true;
            }
            // only select leaf nodes if groupsSelectChildren
            const includeThisNode = !rowNode.group || !groupsSelectChildren;
            if (includeThisNode) {
                result.push(rowNode);
                return;
            }
        });
        return result;
    }
    getTopLevelNodes() {
        return this.rootNode?.childrenAfterGroup ?? null;
    }
    getRow(index) {
        return this.rowsToDisplay[index];
    }
    isRowPresent(rowNode) {
        return this.rowsToDisplay.indexOf(rowNode) >= 0;
    }
    getRowIndexAtPixel(pixelToMatch) {
        const rowsToDisplay = this.rowsToDisplay;
        if (this.isEmpty() || rowsToDisplay.length === 0) {
            return -1;
        }
        // do binary search of tree
        // http://oli.me.uk/2013/06/08/searching-javascript-arrays-with-a-binary-search/
        let bottomPointer = 0;
        let topPointer = rowsToDisplay.length - 1;
        // quick check, if the pixel is out of bounds, then return last row
        if (pixelToMatch <= 0) {
            // if pixel is less than or equal zero, it's always the first row
            return 0;
        }
        const lastNode = (0, array_1._last)(rowsToDisplay);
        if (lastNode.rowTop <= pixelToMatch) {
            return rowsToDisplay.length - 1;
        }
        let oldBottomPointer = -1;
        let oldTopPointer = -1;
        while (true) {
            const midPointer = Math.floor((bottomPointer + topPointer) / 2);
            const currentRowNode = rowsToDisplay[midPointer];
            if (this.isRowInPixel(currentRowNode, pixelToMatch)) {
                return midPointer;
            }
            if (currentRowNode.rowTop < pixelToMatch) {
                bottomPointer = midPointer + 1;
            }
            else if (currentRowNode.rowTop > pixelToMatch) {
                topPointer = midPointer - 1;
            }
            // infinite loops happen when there is space between rows. this can happen
            // when Auto Height is active, cos we re-calculate row tops asynchronously
            // when row heights change, which can temporarily result in gaps between rows.
            const caughtInInfiniteLoop = oldBottomPointer === bottomPointer && oldTopPointer === topPointer;
            if (caughtInInfiniteLoop) {
                return midPointer;
            }
            oldBottomPointer = bottomPointer;
            oldTopPointer = topPointer;
        }
    }
    isRowInPixel(rowNode, pixelToMatch) {
        const topPixel = rowNode.rowTop;
        const bottomPixel = rowNode.rowTop + rowNode.rowHeight;
        const pixelInRow = topPixel <= pixelToMatch && bottomPixel > pixelToMatch;
        return pixelInRow;
    }
    forEachLeafNode(callback) {
        this.rootNode?.allLeafChildren?.forEach((rowNode, index) => callback(rowNode, index));
    }
    forEachNode(callback, includeFooterNodes = false) {
        this.depthFirstSearchRowNodes(callback, includeFooterNodes);
    }
    forEachDisplayedNode(callback) {
        this.rowsToDisplay.forEach(callback);
    }
    forEachNodeAfterFilter(callback, includeFooterNodes = false) {
        this.depthFirstSearchRowNodes(callback, includeFooterNodes, (node) => node.childrenAfterAggFilter);
    }
    forEachNodeAfterFilterAndSort(callback, includeFooterNodes = false) {
        this.depthFirstSearchRowNodes(callback, includeFooterNodes, (node) => node.childrenAfterSort);
    }
    forEachPivotNode(callback, includeFooterNodes = false, afterSort = false) {
        const { colModel, rowGroupColsSvc } = this.beans;
        if (!colModel.isPivotMode()) {
            return;
        }
        // if no row grouping, then only row is root node
        if (!rowGroupColsSvc?.columns.length) {
            callback(this.rootNode, 0);
            return;
        }
        const childrenField = afterSort ? 'childrenAfterSort' : 'childrenAfterGroup';
        // for pivot, we don't go below leafGroup levels
        this.depthFirstSearchRowNodes(callback, includeFooterNodes, (node) => !node.leafGroup ? node[childrenField] : null);
    }
    /**
     * Iterate through each node and all of its children
     * @param callback the function to execute for each node
     * @param includeFooterNodes whether to also iterate over footer nodes
     * @param nodes the nodes to start iterating over
     * @param getChildren a function to determine the recursion strategy
     * @param startIndex the index to start from
     * @returns the index ended at
     */
    depthFirstSearchRowNodes(callback, includeFooterNodes = false, getChildren = (node) => node.childrenAfterGroup, node = this.rootNode, startIndex = 0) {
        let index = startIndex;
        if (!node) {
            return index;
        }
        const isRootNode = node === this.rootNode;
        if (!isRootNode) {
            callback(node, index++);
        }
        const { footerSvc } = this.beans;
        if (node.hasChildren() && !node.footer) {
            const children = getChildren(node);
            if (children) {
                index = footerSvc?.addTotalRows(index, node, callback, includeFooterNodes, isRootNode, 'top') ?? index;
                for (const node of children) {
                    index = this.depthFirstSearchRowNodes(callback, includeFooterNodes, getChildren, node, index);
                }
                return (footerSvc?.addTotalRows(index, node, callback, includeFooterNodes, isRootNode, 'bottom') ?? index);
            }
        }
        return index;
    }
    // it's possible to recompute the aggregate without doing the other parts
    // + api.refreshClientSideRowModel('aggregate')
    doAggregate(changedPath) {
        const rootNode = this.rootNode;
        if (rootNode) {
            this.aggStage?.execute({ rowNode: rootNode, changedPath: changedPath });
        }
    }
    doFilterAggregates(changedPath) {
        const rootNode = this.rootNode;
        if (this.filterAggStage) {
            this.filterAggStage.execute({ rowNode: rootNode, changedPath: changedPath });
        }
        else {
            // If filterAggStage is undefined, then so is the grouping stage, so all children should be on the rootNode.
            rootNode.childrenAfterAggFilter = rootNode.childrenAfterFilter;
        }
    }
    doSort(changedRowNodes, changedPath) {
        if (this.sortStage) {
            this.sortStage.execute({
                rowNode: this.rootNode,
                changedRowNodes,
                changedPath: changedPath,
            });
        }
        else {
            changedPath.forEachChangedNodeDepthFirst((rowNode) => {
                rowNode.childrenAfterSort = rowNode.childrenAfterAggFilter.slice(0);
                (0, sortStage_1.updateRowNodeAfterSort)(rowNode);
            });
        }
    }
    doRowGrouping(params) {
        const rootNode = this.rootNode;
        const groupStageExecuted = this.groupStage?.execute({
            rowNode: rootNode,
            changedRowNodes: params.changedRowNodes,
            changedPath: params.changedPath,
            rowNodesOrderChanged: !!params.rowNodesOrderChanged,
            afterColumnsChanged: !!params.afterColumnsChanged,
        });
        if (groupStageExecuted !== undefined) {
            return groupStageExecuted;
        }
        const sibling = rootNode.sibling;
        rootNode.childrenAfterGroup = rootNode.allLeafChildren;
        if (sibling) {
            sibling.childrenAfterGroup = rootNode.childrenAfterGroup;
        }
        rootNode.updateHasChildren();
        return false;
    }
    doFilter(changedPath) {
        if (this.filterStage) {
            this.filterStage.execute({ rowNode: this.rootNode, changedPath: changedPath });
        }
        else {
            changedPath.forEachChangedNodeDepthFirst((rowNode) => {
                rowNode.childrenAfterFilter = rowNode.childrenAfterGroup;
                (0, filterStage_1.updateRowNodeAfterFilter)(rowNode);
            }, true);
        }
    }
    doPivot(changedPath) {
        this.pivotStage?.execute({ rowNode: this.rootNode, changedPath: changedPath });
    }
    getRowNode(id) {
        const found = this.nodeManager.getRowNode(id);
        if (typeof found === 'object') {
            return found; // we check for typeof object to avoid returning things from Object.prototype
        }
        // although id is typed a string, this could be called by the user, and they could have passed a number
        const idIsGroup = typeof id == 'string' && id.indexOf(rowNode_1.ROW_ID_PREFIX_ROW_GROUP) === 0;
        return idIsGroup ? this.groupStage?.getNode(id) : undefined;
    }
    batchUpdateRowData(rowDataTransaction, callback) {
        if (this.applyAsyncTransactionsTimeout == null) {
            this.rowDataTransactionBatch = [];
            const waitMillis = this.gos.get('asyncTransactionWaitMillis');
            this.applyAsyncTransactionsTimeout = window.setTimeout(() => {
                if (this.isAlive()) {
                    // Handle case where grid is destroyed before timeout is triggered
                    this.executeBatchUpdateRowData();
                }
            }, waitMillis);
        }
        this.rowDataTransactionBatch.push({ rowDataTransaction: rowDataTransaction, callback });
    }
    flushAsyncTransactions() {
        if (this.applyAsyncTransactionsTimeout != null) {
            clearTimeout(this.applyAsyncTransactionsTimeout);
            this.executeBatchUpdateRowData();
        }
    }
    executeBatchUpdateRowData() {
        this.valueCache?.onDataChanged();
        const callbackFuncsBound = [];
        const rowNodeTrans = [];
        const changedRowNodes = new changedRowNodes_1.ChangedRowNodes();
        let orderChanged = false;
        this.rowDataTransactionBatch?.forEach((tranItem) => {
            this.rowNodesCountReady = true;
            const { rowNodeTransaction, rowsInserted } = this.nodeManager.updateRowData(tranItem.rowDataTransaction, changedRowNodes);
            if (rowsInserted) {
                orderChanged = true;
            }
            rowNodeTrans.push(rowNodeTransaction);
            if (tranItem.callback) {
                callbackFuncsBound.push(tranItem.callback.bind(null, rowNodeTransaction));
            }
        });
        this.commitTransactions(orderChanged, changedRowNodes);
        // do callbacks in next VM turn so it's async
        if (callbackFuncsBound.length > 0) {
            window.setTimeout(() => {
                callbackFuncsBound.forEach((func) => func());
            }, 0);
        }
        if (rowNodeTrans.length > 0) {
            this.eventSvc.dispatchEvent({
                type: 'asyncTransactionsFlushed',
                results: rowNodeTrans,
            });
        }
        this.rowDataTransactionBatch = null;
        this.applyAsyncTransactionsTimeout = undefined;
    }
    /**
     * Used to apply transaction changes.
     * Called by gridApi & rowDragFeature
     */
    updateRowData(rowDataTran) {
        this.valueCache?.onDataChanged();
        this.rowNodesCountReady = true;
        const changedRowNodes = new changedRowNodes_1.ChangedRowNodes();
        const { rowNodeTransaction, rowsInserted } = this.nodeManager.updateRowData(rowDataTran, changedRowNodes);
        this.commitTransactions(rowsInserted, changedRowNodes);
        return rowNodeTransaction;
    }
    /**
     * Common to:
     * - executeBatchUpdateRowData (batch transactions)
     * - updateRowData (single transaction)
     * - setImmutableRowData (generated transaction)
     *
     * @param rowNodeTrans - the transactions to apply
     * @param orderChanged - whether the order of the rows has changed, either via generated transaction or user provided addIndex
     */
    commitTransactions(rowNodesOrderChanged, changedRowNodes) {
        this.refreshModel({
            step: 'group',
            rowDataUpdated: true,
            rowNodesOrderChanged,
            keepRenderedRows: true,
            animate: !this.gos.get('suppressAnimationFrame'),
            changedRowNodes,
            changedPath: this.createChangePath(true),
        });
    }
    doRowsToDisplay() {
        const { flattenStage, rootNode } = this;
        let rowsToDisplay;
        if (flattenStage) {
            rowsToDisplay = flattenStage.execute({ rowNode: rootNode });
        }
        else {
            rowsToDisplay = rootNode?.childrenAfterSort ?? [];
            for (const row of rowsToDisplay) {
                row.setUiLevel(0);
            }
        }
        this.rowsToDisplay = rowsToDisplay;
    }
    onRowHeightChanged() {
        this.refreshModel({
            step: 'map',
            keepRenderedRows: true,
            keepUndoRedoStack: true,
        });
    }
    resetRowHeights() {
        const rootNode = this.rootNode;
        if (!rootNode) {
            return;
        }
        const atLeastOne = this.resetRowHeightsForAllRowNodes();
        rootNode.setRowHeight(rootNode.rowHeight, true);
        if (rootNode.sibling) {
            rootNode.sibling.setRowHeight(rootNode.sibling.rowHeight, true);
        }
        // when pivotMode but pivot not active, root node is displayed on its own
        // because it's only ever displayed alone, refreshing the model (onRowHeightChanged) is not required
        if (atLeastOne) {
            this.onRowHeightChanged();
        }
    }
    resetRowHeightsForAllRowNodes() {
        let atLeastOne = false;
        this.forEachNode((rowNode) => {
            rowNode.setRowHeight(rowNode.rowHeight, true);
            // we keep the height each row is at, however we set estimated=true rather than clear the height.
            // this means the grid will not reset the row heights back to defaults, rather it will re-calc
            // the height for each row as the row is displayed. otherwise the scroll will jump when heights are reset.
            const detailNode = rowNode.detailNode;
            if (detailNode) {
                detailNode.setRowHeight(detailNode.rowHeight, true);
            }
            if (rowNode.sibling) {
                rowNode.sibling.setRowHeight(rowNode.sibling.rowHeight, true);
            }
            atLeastOne = true;
        });
        return atLeastOne;
    }
    onGridStylesChanges(e) {
        if (e.rowHeightChanged) {
            if (this.beans.rowAutoHeight?.active) {
                return;
            }
            this.resetRowHeights();
        }
    }
    onGridReady() {
        if (!this.started) {
            // App can start using API to add transactions, so need to add data into the node manager if not started
            this.setInitialData();
        }
    }
    isRowDataLoaded() {
        return this.rowCountReady;
    }
    destroy() {
        super.destroy();
        // Forcefully deallocate memory
        this.started = false;
        this.rootNode = null;
        this.nodeManager = null;
        this.rowDataTransactionBatch = null;
        this.orderedStages = array_1._EmptyArray;
        this.rowsToDisplay = array_1._EmptyArray;
    }
    /**
     * @deprecated v33.1
     */
    onRowHeightChangedDebounced() {
        this.onRowHeightChanged_debounced();
    }
}
exports.ClientSideRowModel = ClientSideRowModel;


/***/ }),

/***/ 34452:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getBestCostNodeSelection = exports.flushAsyncTransactions = exports.applyTransactionAsync = exports.applyTransaction = exports.resetRowHeights = exports.forEachNodeAfterFilterAndSort = exports.forEachNodeAfterFilter = exports.forEachLeafNode = exports.isRowDataEmpty = exports.refreshClientSideRowModel = exports.onGroupExpandedOrCollapsed = void 0;
const rowModelApiUtils_1 = __webpack_require__(66876);
const logging_1 = __webpack_require__(47764);
function onGroupExpandedOrCollapsed(beans) {
    beans.expansionSvc?.onGroupExpandedOrCollapsed();
}
exports.onGroupExpandedOrCollapsed = onGroupExpandedOrCollapsed;
function refreshClientSideRowModel(beans, step) {
    const clientSideRowModel = (0, rowModelApiUtils_1._getClientSideRowModel)(beans);
    if (clientSideRowModel) {
        if (!step || step === 'everything') {
            step = 'group';
        }
        clientSideRowModel.refreshModel({
            step,
            keepRenderedRows: true,
            animate: !beans.gos.get('suppressAnimationFrame'),
        });
    }
}
exports.refreshClientSideRowModel = refreshClientSideRowModel;
function isRowDataEmpty(beans) {
    return (0, rowModelApiUtils_1._getClientSideRowModel)(beans)?.isEmpty() ?? true;
}
exports.isRowDataEmpty = isRowDataEmpty;
function forEachLeafNode(beans, callback) {
    (0, rowModelApiUtils_1._getClientSideRowModel)(beans)?.forEachLeafNode(callback);
}
exports.forEachLeafNode = forEachLeafNode;
function forEachNodeAfterFilter(beans, callback) {
    (0, rowModelApiUtils_1._getClientSideRowModel)(beans)?.forEachNodeAfterFilter(callback);
}
exports.forEachNodeAfterFilter = forEachNodeAfterFilter;
function forEachNodeAfterFilterAndSort(beans, callback) {
    (0, rowModelApiUtils_1._getClientSideRowModel)(beans)?.forEachNodeAfterFilterAndSort(callback);
}
exports.forEachNodeAfterFilterAndSort = forEachNodeAfterFilterAndSort;
function resetRowHeights(beans) {
    if (beans.rowAutoHeight?.active) {
        (0, logging_1._warn)(3);
        return;
    }
    (0, rowModelApiUtils_1._getClientSideRowModel)(beans)?.resetRowHeights();
}
exports.resetRowHeights = resetRowHeights;
function applyTransaction(beans, rowDataTransaction) {
    return beans.frameworkOverrides.wrapIncoming(() => (0, rowModelApiUtils_1._getClientSideRowModel)(beans)?.updateRowData(rowDataTransaction));
}
exports.applyTransaction = applyTransaction;
function applyTransactionAsync(beans, rowDataTransaction, callback) {
    beans.frameworkOverrides.wrapIncoming(() => (0, rowModelApiUtils_1._getClientSideRowModel)(beans)?.batchUpdateRowData(rowDataTransaction, callback));
}
exports.applyTransactionAsync = applyTransactionAsync;
function flushAsyncTransactions(beans) {
    beans.frameworkOverrides.wrapIncoming(() => (0, rowModelApiUtils_1._getClientSideRowModel)(beans)?.flushAsyncTransactions());
}
exports.flushAsyncTransactions = flushAsyncTransactions;
function getBestCostNodeSelection(beans) {
    return beans.selectionSvc?.getBestCostNodeSelection();
}
exports.getBestCostNodeSelection = getBestCostNodeSelection;


/***/ }),

/***/ 89722:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClientSideRowModelApiModule = exports.ClientSideRowModelModule = void 0;
const sharedApiModule_1 = __webpack_require__(36437);
const sortModule_1 = __webpack_require__(96620);
const version_1 = __webpack_require__(97205);
const clientSideNodeManager_1 = __webpack_require__(28128);
const clientSideRowModel_1 = __webpack_require__(83278);
const clientSideRowModelApi_1 = __webpack_require__(34452);
const sortStage_1 = __webpack_require__(19849);
/**
 * @feature Client-Side Row Model
 */
exports.ClientSideRowModelModule = {
    moduleName: 'ClientSideRowModel',
    version: version_1.VERSION,
    rowModels: ['clientSide'],
    beans: [clientSideNodeManager_1.ClientSideNodeManager, clientSideRowModel_1.ClientSideRowModel, sortStage_1.SortStage],
    dependsOn: [sortModule_1.SortModule],
};
/**
 * @feature Client-Side Row Model
 */
exports.ClientSideRowModelApiModule = {
    moduleName: 'ClientSideRowModelApi',
    version: version_1.VERSION,
    apiFunctions: {
        onGroupExpandedOrCollapsed: clientSideRowModelApi_1.onGroupExpandedOrCollapsed,
        refreshClientSideRowModel: clientSideRowModelApi_1.refreshClientSideRowModel,
        isRowDataEmpty: clientSideRowModelApi_1.isRowDataEmpty,
        forEachLeafNode: clientSideRowModelApi_1.forEachLeafNode,
        forEachNodeAfterFilter: clientSideRowModelApi_1.forEachNodeAfterFilter,
        forEachNodeAfterFilterAndSort: clientSideRowModelApi_1.forEachNodeAfterFilterAndSort,
        resetRowHeights: clientSideRowModelApi_1.resetRowHeights,
        applyTransaction: clientSideRowModelApi_1.applyTransaction,
        applyTransactionAsync: clientSideRowModelApi_1.applyTransactionAsync,
        flushAsyncTransactions: clientSideRowModelApi_1.flushAsyncTransactions,
        getBestCostNodeSelection: clientSideRowModelApi_1.getBestCostNodeSelection,
    },
    dependsOn: [sharedApiModule_1.CsrmSsrmSharedApiModule],
};


/***/ }),

/***/ 48287:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FilterStage = exports.updateRowNodeAfterFilter = void 0;
const beanStub_1 = __webpack_require__(68731);
function updateRowNodeAfterFilter(rowNode) {
    if (rowNode.sibling) {
        rowNode.sibling.childrenAfterFilter = rowNode.childrenAfterFilter;
    }
}
exports.updateRowNodeAfterFilter = updateRowNodeAfterFilter;
class FilterStage extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'filterStage';
        this.refreshProps = new Set(['excludeChildrenWhenTreeDataFiltering']);
        this.step = 'filter';
    }
    wireBeans(beans) {
        this.filterManager = beans.filterManager;
    }
    execute(params) {
        const { changedPath } = params;
        this.filter(changedPath);
    }
    filter(changedPath) {
        const filterActive = !!this.filterManager?.isChildFilterPresent();
        this.filterNodes(filterActive, changedPath);
    }
    filterNodes(filterActive, changedPath) {
        const filterCallback = (rowNode, includeChildNodes) => {
            // recursively get all children that are groups to also filter
            if (rowNode.hasChildren()) {
                // result of filter for this node. when filtering tree data, includeChildNodes = true when parent passes
                if (filterActive && !includeChildNodes) {
                    rowNode.childrenAfterFilter = rowNode.childrenAfterGroup.filter((childNode) => {
                        // a group is included in the result if it has any children of it's own.
                        // by this stage, the child groups are already filtered
                        const passBecauseChildren = childNode.childrenAfterFilter && childNode.childrenAfterFilter.length > 0;
                        // both leaf level nodes and tree data nodes have data. these get added if
                        // the data passes the filter
                        const passBecauseDataPasses = childNode.data && this.filterManager.doesRowPassFilter({ rowNode: childNode });
                        // note - tree data nodes pass either if a) they pass themselves or b) any children of that node pass
                        return passBecauseChildren || passBecauseDataPasses;
                    });
                }
                else {
                    // if not filtering, the result is the original list
                    rowNode.childrenAfterFilter = rowNode.childrenAfterGroup;
                }
            }
            else {
                rowNode.childrenAfterFilter = rowNode.childrenAfterGroup;
            }
            updateRowNodeAfterFilter(rowNode);
        };
        if (this.doingTreeDataFiltering()) {
            const treeDataDepthFirstFilter = (rowNode, alreadyFoundInParent) => {
                // tree data filter traverses the hierarchy depth first and includes child nodes if parent passes
                // filter, and parent nodes will be include if any children exist.
                if (rowNode.childrenAfterGroup) {
                    for (let i = 0; i < rowNode.childrenAfterGroup.length; i++) {
                        const childNode = rowNode.childrenAfterGroup[i];
                        // first check if current node passes filter before invoking child nodes
                        const foundInParent = alreadyFoundInParent || this.filterManager.doesRowPassFilter({ rowNode: childNode });
                        if (childNode.childrenAfterGroup) {
                            treeDataDepthFirstFilter(rowNode.childrenAfterGroup[i], foundInParent);
                        }
                        else {
                            filterCallback(childNode, foundInParent);
                        }
                    }
                }
                filterCallback(rowNode, alreadyFoundInParent);
            };
            const treeDataFilterCallback = (rowNode) => treeDataDepthFirstFilter(rowNode, false);
            changedPath.executeFromRootNode(treeDataFilterCallback);
        }
        else {
            const defaultFilterCallback = (rowNode) => filterCallback(rowNode, false);
            changedPath.forEachChangedNodeDepthFirst(defaultFilterCallback, true);
        }
    }
    doingTreeDataFiltering() {
        return this.gos.get('treeData') && !this.gos.get('excludeChildrenWhenTreeDataFiltering');
    }
}
exports.FilterStage = FilterStage;


/***/ }),

/***/ 19849:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SortStage = exports.updateRowNodeAfterSort = void 0;
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const generic_1 = __webpack_require__(34422);
function updateChildIndexes(rowNode) {
    if ((0, generic_1._missing)(rowNode.childrenAfterSort)) {
        return;
    }
    const listToSort = rowNode.childrenAfterSort;
    for (let i = 0; i < listToSort.length; i++) {
        const child = listToSort[i];
        const firstChild = i === 0;
        const lastChild = i === rowNode.childrenAfterSort.length - 1;
        child.setFirstChild(firstChild);
        if (child.lastChild !== lastChild) {
            child.lastChild = lastChild;
            child.dispatchRowEvent('lastChildChanged');
        }
        if (child.childIndex !== i) {
            child.childIndex = i;
            child.dispatchRowEvent('childIndexChanged');
        }
    }
}
function updateRowNodeAfterSort(rowNode) {
    if (rowNode.sibling) {
        rowNode.sibling.childrenAfterSort = rowNode.childrenAfterSort;
    }
    updateChildIndexes(rowNode);
}
exports.updateRowNodeAfterSort = updateRowNodeAfterSort;
class SortStage extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'sortStage';
        this.refreshProps = new Set(['postSortRows', 'groupDisplayType', 'accentedSort']);
        this.step = 'sort';
    }
    execute(params) {
        const beans = this.beans;
        const sortOptions = beans.sortSvc.getSortOptions();
        const sortActive = (0, generic_1._exists)(sortOptions) && sortOptions.length > 0;
        const deltaSort = sortActive &&
            !!params.changedRowNodes &&
            // in time we can remove this check, so that delta sort is always
            // on if transactions are present. it's off for now so that we can
            // selectively turn it on and test it with some select users before
            // rolling out to everyone.
            this.gos.get('deltaSort');
        const sortContainsGroupColumns = sortOptions.some(({ column }) => {
            const isSortingCoupled = (0, gridOptionsUtils_1._isColumnsSortingCoupledToGroup)(beans.gos);
            if (isSortingCoupled) {
                return column.isPrimary() && column.isRowGroupActive();
            }
            return !!column.getColDef().showRowGroup;
        });
        this.sort(beans, sortOptions, sortActive, deltaSort, params.changedRowNodes, params.changedPath, sortContainsGroupColumns);
    }
    sort(beans, sortOptions, sortActive, useDeltaSort, changedRowNodes, changedPath, sortContainsGroupColumns) {
        const { gos, colModel, rowGroupColsSvc, rowNodeSorter, rowRenderer, showRowGroupCols } = beans;
        const groupMaintainOrder = gos.get('groupMaintainOrder');
        const groupColumnsPresent = colModel.getCols().some((c) => c.isRowGroupActive());
        const isPivotMode = colModel.isPivotMode();
        const postSortFunc = gos.getCallback('postSortRows');
        let hasAnyFirstChildChanged = false;
        const callback = (rowNode) => {
            // It's pointless to sort rows which aren't being displayed. in pivot mode we don't need to sort the leaf group children.
            const skipSortingPivotLeafs = isPivotMode && rowNode.leafGroup;
            // Javascript sort is non deterministic when all the array items are equals, ie Comparator always returns 0,
            // so to ensure the array keeps its order, add an additional sorting condition manually, in this case we
            // are going to inspect the original array position. This is what sortedRowNodes is for.
            const skipSortingGroups = groupMaintainOrder && groupColumnsPresent && !rowNode.leafGroup && !sortContainsGroupColumns;
            let newChildrenAfterSort;
            if (skipSortingGroups) {
                const nextGroup = rowGroupColsSvc?.columns?.[rowNode.level + 1];
                // if the sort is null, then sort was explicitly removed, so remove sort from this group.
                const wasSortExplicitlyRemoved = nextGroup?.getSort() === null;
                const childrenToBeSorted = rowNode.childrenAfterAggFilter.slice(0);
                if (rowNode.childrenAfterSort && !wasSortExplicitlyRemoved) {
                    const indexedOrders = {};
                    rowNode.childrenAfterSort.forEach((node, idx) => {
                        indexedOrders[node.id] = idx;
                    });
                    childrenToBeSorted.sort((row1, row2) => (indexedOrders[row1.id] ?? 0) - (indexedOrders[row2.id] ?? 0));
                }
                newChildrenAfterSort = childrenToBeSorted;
            }
            else if (!sortActive || skipSortingPivotLeafs) {
                // if there's no sort to make, skip this step
                newChildrenAfterSort = rowNode.childrenAfterAggFilter.slice(0);
            }
            else if (useDeltaSort && changedRowNodes) {
                newChildrenAfterSort = doDeltaSort(rowNodeSorter, rowNode, changedRowNodes, changedPath, sortOptions);
            }
            else {
                newChildrenAfterSort = rowNodeSorter.doFullSort(rowNode.childrenAfterAggFilter, sortOptions);
            }
            hasAnyFirstChildChanged || (hasAnyFirstChildChanged = rowNode.childrenAfterSort?.[0] !== newChildrenAfterSort[0]);
            rowNode.childrenAfterSort = newChildrenAfterSort;
            updateRowNodeAfterSort(rowNode);
            if (postSortFunc) {
                const params = { nodes: rowNode.childrenAfterSort };
                postSortFunc(params);
            }
        };
        changedPath?.forEachChangedNodeDepthFirst(callback);
        // if using group hide open parents and a sort has happened, refresh the group cells as the first child
        // displays the parent grouping - it's cheaper here to refresh all cells in col rather than fire events for every potential
        // child cell
        if (hasAnyFirstChildChanged && this.gos.get('groupHideOpenParents')) {
            const columns = showRowGroupCols?.getShowRowGroupCols();
            if (columns?.length) {
                rowRenderer.refreshCells({ columns, force: true });
            }
        }
    }
}
exports.SortStage = SortStage;
function doDeltaSort(rowNodeSorter, rowNode, changedRowNodes, changedPath, sortOptions) {
    const unsortedRows = rowNode.childrenAfterAggFilter;
    const oldSortedRows = rowNode.childrenAfterSort;
    if (!oldSortedRows) {
        return rowNodeSorter.doFullSort(unsortedRows, sortOptions);
    }
    const untouchedRows = new Set();
    const touchedRows = [];
    const { updates, adds } = changedRowNodes;
    for (let i = 0, len = unsortedRows.length; i < len; ++i) {
        const row = unsortedRows[i];
        if (updates.has(row) || adds.has(row) || (changedPath && !changedPath.canSkip(row))) {
            touchedRows.push({
                currentPos: touchedRows.length,
                rowNode: row,
            });
        }
        else {
            untouchedRows.add(row.id);
        }
    }
    const sortedUntouchedRows = oldSortedRows
        .filter((child) => untouchedRows.has(child.id))
        .map((rowNode, currentPos) => ({ currentPos, rowNode }));
    touchedRows.sort((a, b) => rowNodeSorter.compareRowNodes(sortOptions, a, b));
    return mergeSortedArrays(rowNodeSorter, sortOptions, touchedRows, sortedUntouchedRows);
}
// Merge two sorted arrays into each other
function mergeSortedArrays(rowNodeSorter, sortOptions, arr1, arr2) {
    const res = [];
    let i = 0;
    let j = 0;
    const arr1Length = arr1.length;
    const arr2Length = arr2.length;
    // Traverse both array, adding them in order
    while (i < arr1Length && j < arr2Length) {
        const a = arr1[i];
        const b = arr2[j];
        // Check if current element of first array is smaller than current element
        // of second array. If yes, store first array element and increment first array index.
        // Otherwise do same with second array
        const compareResult = rowNodeSorter.compareRowNodes(sortOptions, a, b);
        let chosen;
        if (compareResult < 0) {
            chosen = a;
            ++i;
        }
        else {
            chosen = b;
            ++j;
        }
        res.push(chosen.rowNode);
    }
    // add remaining from arr1
    while (i < arr1Length) {
        res.push(arr1[i++].rowNode);
    }
    // add remaining from arr2
    while (j < arr2Length) {
        res.push(arr2[j++].rowNode);
    }
    return res;
}


/***/ }),

/***/ 43218:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.autoSizeAllColumns = exports.autoSizeColumns = exports.sizeColumnsToFit = void 0;
function sizeColumnsToFit(beans, paramsOrGridWidth) {
    if (typeof paramsOrGridWidth === 'number') {
        beans.colAutosize?.sizeColumnsToFit(paramsOrGridWidth, 'api');
    }
    else {
        beans.colAutosize?.sizeColumnsToFitGridBody(paramsOrGridWidth);
    }
}
exports.sizeColumnsToFit = sizeColumnsToFit;
function autoSizeColumns({ colAutosize, visibleCols }, keysOrParams, skipHeader) {
    if (Array.isArray(keysOrParams)) {
        colAutosize?.autoSizeCols({ colKeys: keysOrParams, skipHeader, source: 'api' });
    }
    else {
        colAutosize?.autoSizeCols({
            colKeys: keysOrParams.colIds ?? visibleCols.allCols,
            skipHeader: keysOrParams.skipHeader,
            defaultMaxWidth: keysOrParams.defaultMaxWidth,
            defaultMinWidth: keysOrParams.defaultMinWidth,
            columnLimits: keysOrParams.columnLimits,
            source: 'api',
        });
    }
}
exports.autoSizeColumns = autoSizeColumns;
function autoSizeAllColumns(beans, paramsOrSkipHeader) {
    if (paramsOrSkipHeader && typeof paramsOrSkipHeader === 'object') {
        autoSizeColumns(beans, paramsOrSkipHeader);
    }
    else {
        beans.colAutosize?.autoSizeAllColumns({ source: 'api', skipHeader: paramsOrSkipHeader });
    }
}
exports.autoSizeAllColumns = autoSizeAllColumns;


/***/ }),

/***/ 63856:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColumnAutoSizeModule = void 0;
const autoWidthModule_1 = __webpack_require__(40447);
const version_1 = __webpack_require__(97205);
const columnAutosizeApi_1 = __webpack_require__(43218);
const columnAutosizeService_1 = __webpack_require__(44817);
/**
 * @feature Columns -> Column Sizing
 * @gridOption autoSizeStrategy
 */
exports.ColumnAutoSizeModule = {
    moduleName: 'ColumnAutoSize',
    version: version_1.VERSION,
    beans: [columnAutosizeService_1.ColumnAutosizeService],
    apiFunctions: {
        sizeColumnsToFit: columnAutosizeApi_1.sizeColumnsToFit,
        autoSizeColumns: columnAutosizeApi_1.autoSizeColumns,
        autoSizeAllColumns: columnAutosizeApi_1.autoSizeAllColumns,
    },
    dependsOn: [autoWidthModule_1.AutoWidthModule],
};


/***/ }),

/***/ 44817:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColumnAutosizeService = void 0;
const columnEventUtils_1 = __webpack_require__(72934);
const columnUtils_1 = __webpack_require__(73146);
const beanStub_1 = __webpack_require__(68731);
const array_1 = __webpack_require__(31502);
const dom_1 = __webpack_require__(33507);
const logging_1 = __webpack_require__(47764);
const touchListener_1 = __webpack_require__(99644);
class ColumnAutosizeService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'colAutosize';
        this.timesDelayed = 0;
        // when we're waiting for cell data types to be inferred, we need to defer column resizing
        this.shouldQueueResizeOperations = false;
        this.resizeOperationQueue = [];
    }
    postConstruct() {
        this.addManagedEventListeners({ firstDataRendered: () => this.onFirstDataRendered() });
    }
    autoSizeCols(params) {
        if (this.shouldQueueResizeOperations) {
            this.pushResizeOperation(() => this.autoSizeCols(params));
            return;
        }
        const { colKeys, skipHeader, skipHeaderGroups, stopAtGroup, defaultMaxWidth, defaultMinWidth, columnLimits = [], source = 'api', } = params;
        // because of column virtualisation, we can only do this function on columns that are
        // actually rendered, as non-rendered columns (outside the viewport and not rendered
        // due to column virtualisation) are not present. this can result in all rendered columns
        // getting narrowed, which in turn introduces more rendered columns on the RHS which
        // did not get autoSized in the original run, leaving the visible grid with columns on
        // the LHS sized, but RHS no. so we keep looping through the visible columns until
        // no more cols are available (rendered) to be resized
        const { animationFrameSvc, renderStatus, colModel, autoWidthCalc, visibleCols } = this.beans;
        // we autosize after animation frames finish in case any cell renderers need to complete first. this can
        // happen eg if client code is calling api.autoSizeAllColumns() straight after grid is initialised, but grid
        // hasn't fully drawn out all the cells yet (due to cell renderers in animation frames).
        animationFrameSvc?.flushAllFrames();
        if (this.timesDelayed < 5 && renderStatus && !renderStatus.areHeaderCellsRendered()) {
            // This is needed for React, as it doesn't render the headers synchronously all the time.
            // Added a defensive check to avoid infinite loop in case headers are never rendered.
            this.timesDelayed++;
            setTimeout(() => {
                if (this.isAlive()) {
                    this.autoSizeCols(params);
                }
            });
            return;
        }
        this.timesDelayed = 0;
        // keep track of which cols we have resized in here
        const columnsAutoSized = [];
        // initialise with anything except 0 so that while loop executes at least once
        let changesThisTimeAround = -1;
        const columnLimitsIndex = Object.fromEntries(columnLimits.map(({ colId, maxWidth, minWidth }) => [colId, { maxWidth, minWidth }]));
        const shouldSkipHeader = skipHeader != null ? skipHeader : this.gos.get('skipHeaderOnAutoSize');
        const shouldSkipHeaderGroups = skipHeaderGroups != null ? skipHeaderGroups : shouldSkipHeader;
        while (changesThisTimeAround !== 0) {
            changesThisTimeAround = 0;
            const updatedColumns = [];
            colKeys.forEach((key) => {
                if (!key || (0, columnUtils_1.isColumnSelectionCol)(key)) {
                    return;
                }
                const column = colModel.getCol(key);
                if (!column || (0, columnUtils_1.isRowNumberCol)(column)) {
                    return;
                }
                // if already autoSized, skip it
                if (columnsAutoSized.indexOf(column) >= 0) {
                    return;
                }
                // get how wide this col should be
                const preferredWidth = autoWidthCalc.getPreferredWidthForColumn(column, shouldSkipHeader);
                // preferredWidth = -1 if this col is not on the screen
                if (preferredWidth > 0) {
                    const columnLimit = columnLimitsIndex[column.colId] ?? {};
                    columnLimit.minWidth ?? (columnLimit.minWidth = defaultMinWidth);
                    columnLimit.maxWidth ?? (columnLimit.maxWidth = defaultMaxWidth);
                    const newWidth = normaliseColumnWidth(column, preferredWidth, columnLimit);
                    column.setActualWidth(newWidth, source);
                    columnsAutoSized.push(column);
                    changesThisTimeAround++;
                }
                updatedColumns.push(column);
            });
            if (!updatedColumns.length) {
                continue;
            }
            visibleCols.refresh(source);
        }
        if (!shouldSkipHeaderGroups) {
            this.autoSizeColumnGroupsByColumns(colKeys, source, stopAtGroup);
        }
        (0, columnEventUtils_1.dispatchColumnResizedEvent)(this.eventSvc, columnsAutoSized, true, 'autosizeColumns');
    }
    autoSizeColumn(key, source, skipHeader) {
        if (key) {
            this.autoSizeCols({ colKeys: [key], skipHeader, skipHeaderGroups: true, source });
        }
    }
    autoSizeColumnGroupsByColumns(keys, source, stopAtGroup) {
        const { colModel, ctrlsSvc } = this.beans;
        const columnGroups = new Set();
        const columns = colModel.getColsForKeys(keys);
        columns.forEach((col) => {
            let parent = col.getParent();
            while (parent && parent != stopAtGroup) {
                if (!parent.isPadding()) {
                    columnGroups.add(parent);
                }
                parent = parent.getParent();
            }
        });
        let headerGroupCtrl;
        const resizedColumns = [];
        for (const columnGroup of columnGroups) {
            for (const headerContainerCtrl of ctrlsSvc.getHeaderRowContainerCtrls()) {
                headerGroupCtrl = headerContainerCtrl.getHeaderCtrlForColumn(columnGroup);
                if (headerGroupCtrl) {
                    break;
                }
            }
            if (headerGroupCtrl) {
                headerGroupCtrl.resizeLeafColumnsToFit(source);
            }
        }
        return resizedColumns;
    }
    autoSizeAllColumns(params) {
        if (this.shouldQueueResizeOperations) {
            this.pushResizeOperation(() => this.autoSizeAllColumns(params));
            return;
        }
        const allDisplayedColumns = this.beans.visibleCols.allCols;
        this.autoSizeCols({ colKeys: allDisplayedColumns, ...params });
    }
    addColumnAutosize(element, column) {
        const skipHeaderOnAutoSize = this.gos.get('skipHeaderOnAutoSize');
        const autoSizeColListener = () => {
            this.autoSizeColumn(column, 'uiColumnResized', skipHeaderOnAutoSize);
        };
        element.addEventListener('dblclick', autoSizeColListener);
        const touchListener = new touchListener_1.TouchListener(element);
        touchListener.addEventListener('doubleTap', autoSizeColListener);
        return () => {
            element.removeEventListener('dblclick', autoSizeColListener);
            touchListener.removeEventListener('doubleTap', autoSizeColListener);
            touchListener.destroy();
        };
    }
    addColumnGroupResize(element, columnGroup, callback) {
        const skipHeaderOnAutoSize = this.gos.get('skipHeaderOnAutoSize');
        const listener = () => {
            // get list of all the column keys we are responsible for
            const keys = [];
            const leafCols = columnGroup.getDisplayedLeafColumns();
            leafCols.forEach((column) => {
                // not all cols in the group may be participating with auto-resize
                if (!column.getColDef().suppressAutoSize) {
                    keys.push(column.getColId());
                }
            });
            if (keys.length > 0) {
                this.autoSizeCols({
                    colKeys: keys,
                    skipHeader: skipHeaderOnAutoSize,
                    stopAtGroup: columnGroup,
                    source: 'uiColumnResized',
                });
            }
            callback();
        };
        element.addEventListener('dblclick', listener);
        return () => element.removeEventListener('dblclick', listener);
    }
    // method will call itself if no available width. this covers if the grid
    // isn't visible, but is just about to be visible.
    sizeColumnsToFitGridBody(params, nextTimeout) {
        if (!this.isAlive()) {
            return;
        }
        const { ctrlsSvc, scrollVisibleSvc } = this.beans;
        const gridBodyCtrl = ctrlsSvc.getGridBodyCtrl();
        const removeScrollWidth = gridBodyCtrl.isVerticalScrollShowing();
        const scrollWidthToRemove = removeScrollWidth ? scrollVisibleSvc.getScrollbarWidth() : 0;
        // bodyViewportWidth should be calculated from eGridBody, not eBodyViewport
        // because we change the width of the bodyViewport to hide the real browser scrollbar
        const bodyViewportWidth = (0, dom_1._getInnerWidth)(gridBodyCtrl.eGridBody);
        const availableWidth = bodyViewportWidth - scrollWidthToRemove;
        if (availableWidth > 0) {
            this.sizeColumnsToFit(availableWidth, 'sizeColumnsToFit', false, params);
            return;
        }
        if (nextTimeout === undefined) {
            window.setTimeout(() => {
                this.sizeColumnsToFitGridBody(params, 100);
            }, 0);
        }
        else if (nextTimeout === 100) {
            window.setTimeout(() => {
                this.sizeColumnsToFitGridBody(params, 500);
            }, 100);
        }
        else if (nextTimeout === 500) {
            window.setTimeout(() => {
                this.sizeColumnsToFitGridBody(params, -1);
            }, 500);
        }
        else {
            // Grid coming back with zero width, maybe the grid is not visible yet on the screen?
            (0, logging_1._warn)(29);
        }
    }
    // called from api
    sizeColumnsToFit(gridWidth, source = 'sizeColumnsToFit', silent, params) {
        if (this.shouldQueueResizeOperations) {
            this.pushResizeOperation(() => this.sizeColumnsToFit(gridWidth, source, silent, params));
            return;
        }
        const limitsMap = {};
        if (params) {
            params?.columnLimits?.forEach(({ key, ...dimensions }) => {
                limitsMap[typeof key === 'string' ? key : key.getColId()] = dimensions;
            });
        }
        // avoid divide by zero
        const allDisplayedColumns = this.beans.visibleCols.allCols;
        if (gridWidth <= 0 || !allDisplayedColumns.length) {
            return;
        }
        const doColumnsAlreadyFit = gridWidth === (0, columnUtils_1.getWidthOfColsInList)(allDisplayedColumns);
        if (doColumnsAlreadyFit) {
            // if all columns fit, check they are within the min and max widths - if so, can quit early.
            const doAllColumnsSatisfyConstraints = allDisplayedColumns.every((column) => {
                if (column.colDef.suppressSizeToFit) {
                    return true;
                }
                const widthOverride = limitsMap?.[column.getId()];
                const minWidth = widthOverride?.minWidth ?? params?.defaultMinWidth;
                const maxWidth = widthOverride?.maxWidth ?? params?.defaultMaxWidth;
                const colWidth = column.getActualWidth();
                return (minWidth == null || colWidth >= minWidth) && (maxWidth == null || colWidth <= maxWidth);
            });
            if (doAllColumnsSatisfyConstraints) {
                return;
            }
        }
        const colsToSpread = [];
        const colsToNotSpread = [];
        allDisplayedColumns.forEach((column) => {
            if (column.getColDef().suppressSizeToFit === true) {
                colsToNotSpread.push(column);
            }
            else {
                colsToSpread.push(column);
            }
        });
        // make a copy of the cols that are going to be resized
        const colsToDispatchEventFor = colsToSpread.slice(0);
        let finishedResizing = false;
        const moveToNotSpread = (column) => {
            (0, array_1._removeFromArray)(colsToSpread, column);
            colsToNotSpread.push(column);
        };
        // resetting cols to their original width makes the sizeColumnsToFit more deterministic,
        // rather than depending on the current size of the columns. most users call sizeColumnsToFit
        // immediately after grid is created, so will make no difference. however if application is calling
        // sizeColumnsToFit repeatedly (eg after column group is opened / closed repeatedly) we don't want
        // the columns to start shrinking / growing over time.
        //
        // NOTE: the process below will assign values to `this.actualWidth` of each column without firing events
        // for this reason we need to manually dispatch resize events after the resize has been done for each column.
        colsToSpread.forEach((column) => {
            column.resetActualWidth(source);
            const widthOverride = limitsMap?.[column.getId()];
            const minOverride = widthOverride?.minWidth ?? params?.defaultMinWidth;
            const maxOverride = widthOverride?.maxWidth ?? params?.defaultMaxWidth;
            const colWidth = column.getActualWidth();
            if (typeof minOverride === 'number' && colWidth < minOverride) {
                column.setActualWidth(minOverride, source, true);
            }
            else if (typeof maxOverride === 'number' && colWidth > maxOverride) {
                column.setActualWidth(maxOverride, source, true);
            }
        });
        while (!finishedResizing) {
            finishedResizing = true;
            const availablePixels = gridWidth - (0, columnUtils_1.getWidthOfColsInList)(colsToNotSpread);
            if (availablePixels <= 0) {
                // no width, set everything to minimum
                colsToSpread.forEach((column) => {
                    const widthOverride = limitsMap?.[column.getId()]?.minWidth ?? params?.defaultMinWidth;
                    if (typeof widthOverride === 'number') {
                        column.setActualWidth(widthOverride, source, true);
                        return;
                    }
                    column.setActualWidth(column.minWidth, source);
                });
            }
            else {
                const scale = availablePixels / (0, columnUtils_1.getWidthOfColsInList)(colsToSpread);
                // we set the pixels for the last col based on what's left, as otherwise
                // we could be a pixel or two short or extra because of rounding errors.
                let pixelsForLastCol = availablePixels;
                // backwards through loop, as we are removing items as we go
                for (let i = colsToSpread.length - 1; i >= 0; i--) {
                    const column = colsToSpread[i];
                    const widthOverride = limitsMap?.[column.getId()];
                    const minOverride = widthOverride?.minWidth ?? params?.defaultMinWidth;
                    const maxOverride = widthOverride?.maxWidth ?? params?.defaultMaxWidth;
                    const colMinWidth = column.getMinWidth();
                    const colMaxWidth = column.getMaxWidth();
                    const minWidth = typeof minOverride === 'number' && minOverride > colMinWidth ? minOverride : colMinWidth;
                    const maxWidth = typeof maxOverride === 'number' && maxOverride < colMaxWidth ? maxOverride : colMaxWidth;
                    let newWidth = Math.round(column.getActualWidth() * scale);
                    if (newWidth < minWidth) {
                        newWidth = minWidth;
                        moveToNotSpread(column);
                        finishedResizing = false;
                    }
                    else if (newWidth > maxWidth) {
                        newWidth = maxWidth;
                        moveToNotSpread(column);
                        finishedResizing = false;
                    }
                    else if (i === 0) {
                        // if this is the last column
                        newWidth = pixelsForLastCol;
                    }
                    column.setActualWidth(newWidth, source, true);
                    pixelsForLastCol -= newWidth;
                }
            }
        }
        // see notes above
        colsToDispatchEventFor.forEach((col) => {
            col.fireColumnWidthChangedEvent(source);
        });
        const visibleCols = this.beans.visibleCols;
        visibleCols.setLeftValues(source);
        visibleCols.updateBodyWidths();
        if (silent) {
            return;
        }
        (0, columnEventUtils_1.dispatchColumnResizedEvent)(this.eventSvc, colsToDispatchEventFor, true, source);
    }
    applyAutosizeStrategy() {
        const autoSizeStrategy = this.gos.get('autoSizeStrategy');
        if (!autoSizeStrategy) {
            return;
        }
        const { type } = autoSizeStrategy;
        // ensure things like aligned grids have linked first
        setTimeout(() => {
            if (type === 'fitGridWidth') {
                const { columnLimits: propColumnLimits, defaultMinWidth, defaultMaxWidth } = autoSizeStrategy;
                const columnLimits = propColumnLimits?.map(({ colId: key, minWidth, maxWidth }) => ({
                    key,
                    minWidth,
                    maxWidth,
                }));
                this.sizeColumnsToFitGridBody({
                    defaultMinWidth,
                    defaultMaxWidth,
                    columnLimits,
                });
            }
            else if (type === 'fitProvidedWidth') {
                this.sizeColumnsToFit(autoSizeStrategy.width, 'sizeColumnsToFit');
            }
        });
    }
    onFirstDataRendered() {
        const autoSizeStrategy = this.gos.get('autoSizeStrategy');
        if (autoSizeStrategy?.type !== 'fitCellContents') {
            return;
        }
        const { colIds: columns, skipHeader, defaultMaxWidth, defaultMinWidth, columnLimits } = autoSizeStrategy;
        // ensure render has finished
        setTimeout(() => {
            const params = {
                skipHeader,
                source: 'autosizeColumns',
                defaultMaxWidth,
                defaultMinWidth,
                columnLimits,
            };
            if (columns) {
                this.autoSizeCols({ colKeys: columns, ...params });
            }
            else {
                this.autoSizeAllColumns(params);
            }
        });
    }
    processResizeOperations() {
        this.shouldQueueResizeOperations = false;
        this.resizeOperationQueue.forEach((resizeOperation) => resizeOperation());
        this.resizeOperationQueue = [];
    }
    pushResizeOperation(func) {
        this.resizeOperationQueue.push(func);
    }
    destroy() {
        this.resizeOperationQueue.length = 0;
        super.destroy();
    }
}
exports.ColumnAutosizeService = ColumnAutosizeService;
/** returns the width we can set to this col, taking into consideration min and max widths */
function normaliseColumnWidth(column, newWidth, limits = {}) {
    const minWidth = limits.minWidth ?? column.getMinWidth();
    if (newWidth < minWidth) {
        newWidth = minWidth;
    }
    const maxWidth = limits.maxWidth ?? column.getMaxWidth();
    if (newWidth > maxWidth) {
        newWidth = maxWidth;
    }
    return newWidth;
}


/***/ }),

/***/ 9607:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.columnMovingCSS = void 0;
exports.columnMovingCSS = `:where(.ag-ltr) :where(.ag-column-moving){.ag-cell,.ag-header-cell,.ag-spanned-cell-wrapper{transition:left .2s}.ag-header-group-cell{transition:left .2s,width .2s}}:where(.ag-rtl) :where(.ag-column-moving){.ag-cell,.ag-header-cell,.ag-spanned-cell-wrapper{transition:right .2s}.ag-header-group-cell{transition:right .2s,width .2s}}`;


/***/ }),

/***/ 19122:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColumnAnimationService = void 0;
const beanStub_1 = __webpack_require__(68731);
class ColumnAnimationService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'colAnimation';
        this.executeNextFuncs = [];
        this.executeLaterFuncs = [];
        this.active = false;
        // activeNext starts with active but it is reset earlier after the nextFuncs are cleared
        // to prevent calls made to executeNextVMTurn from queuing functions after executeNextFuncs has already been flushed,
        this.activeNext = false;
        this.suppressAnimation = false;
        this.animationThreadCount = 0;
    }
    postConstruct() {
        this.beans.ctrlsSvc.whenReady(this, (p) => (this.gridBodyCtrl = p.gridBodyCtrl));
    }
    isActive() {
        return this.active && !this.suppressAnimation;
    }
    setSuppressAnimation(suppress) {
        this.suppressAnimation = suppress;
    }
    start() {
        if (this.active) {
            return;
        }
        const { gos } = this;
        if (gos.get('suppressColumnMoveAnimation')) {
            return;
        }
        // if doing RTL, we don't animate open / close as due to how the pixels are inverted,
        // the animation moves all the row the the right rather than to the left (ie it's the static
        // columns that actually get their coordinates updated)
        if (gos.get('enableRtl')) {
            return;
        }
        this.ensureAnimationCssClassPresent();
        this.active = true;
        this.activeNext = true;
    }
    finish() {
        if (!this.active) {
            return;
        }
        this.flush(() => (this.activeNext = false), () => (this.active = false));
    }
    executeNextVMTurn(func) {
        if (this.activeNext) {
            this.executeNextFuncs.push(func);
        }
        else {
            func();
        }
    }
    executeLaterVMTurn(func) {
        if (this.active) {
            this.executeLaterFuncs.push(func);
        }
        else {
            func();
        }
    }
    ensureAnimationCssClassPresent() {
        // up the count, so we can tell if someone else has updated the count
        // by the time the 'wait' func executes
        this.animationThreadCount++;
        const animationThreadCountCopy = this.animationThreadCount;
        const { gridBodyCtrl } = this;
        gridBodyCtrl.setColumnMovingCss(true);
        this.executeLaterFuncs.push(() => {
            // only remove the class if this thread was the last one to update it
            if (this.animationThreadCount === animationThreadCountCopy) {
                gridBodyCtrl.setColumnMovingCss(false);
            }
        });
    }
    flush(callbackNext, callbackLater) {
        const { executeNextFuncs, executeLaterFuncs } = this;
        if (executeNextFuncs.length === 0 && executeLaterFuncs.length === 0) {
            callbackNext();
            callbackLater();
            return;
        }
        const runFuncs = (queue) => {
            while (queue.length) {
                const func = queue.pop();
                if (func) {
                    func();
                }
            }
        };
        this.beans.frameworkOverrides.wrapIncoming(() => {
            window.setTimeout(() => {
                callbackNext();
                runFuncs(executeNextFuncs);
            }, 0);
            window.setTimeout(() => {
                // run the callback before executeLaterFuncs
                // because some functions being executed later
                // check if this service is `active`.
                callbackLater();
                runFuncs(executeLaterFuncs);
            }, 200);
        });
    }
}
exports.ColumnAnimationService = ColumnAnimationService;


/***/ }),

/***/ 43052:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BodyDropPivotTarget = void 0;
const beanStub_1 = __webpack_require__(68731);
class BodyDropPivotTarget extends beanStub_1.BeanStub {
    constructor(pinned) {
        super();
        this.pinned = pinned;
        this.columnsToAggregate = [];
        this.columnsToGroup = [];
        this.columnsToPivot = [];
    }
    /** Callback for when drag enters */
    onDragEnter(draggingEvent) {
        this.clearColumnsList();
        // in pivot mode, we don't accept any drops if functions are read only
        if (this.gos.get('functionsReadOnly')) {
            return;
        }
        const dragColumns = draggingEvent.dragItem.columns;
        if (!dragColumns) {
            return;
        }
        dragColumns.forEach((column) => {
            // we don't allow adding secondary columns
            if (!column.isPrimary()) {
                return;
            }
            if (column.isAnyFunctionActive()) {
                return;
            }
            if (column.isAllowValue()) {
                this.columnsToAggregate.push(column);
            }
            else if (column.isAllowRowGroup()) {
                this.columnsToGroup.push(column);
            }
            else if (column.isAllowPivot()) {
                this.columnsToPivot.push(column);
            }
        });
    }
    getIconName() {
        const totalColumns = this.columnsToAggregate.length + this.columnsToGroup.length + this.columnsToPivot.length;
        if (totalColumns > 0) {
            return this.pinned ? 'pinned' : 'move';
        }
        return null;
    }
    /** Callback for when drag leaves */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onDragLeave(draggingEvent) {
        // if we are taking columns out of the center, then we remove them from the report
        this.clearColumnsList();
    }
    clearColumnsList() {
        this.columnsToAggregate.length = 0;
        this.columnsToGroup.length = 0;
        this.columnsToPivot.length = 0;
    }
    /** Callback for when dragging */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onDragging(draggingEvent) { }
    /** Callback for when drag stops */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onDragStop(draggingEvent) {
        const { valueColsSvc, rowGroupColsSvc, pivotColsSvc } = this.beans;
        if (this.columnsToAggregate.length > 0) {
            valueColsSvc?.addColumns(this.columnsToAggregate, 'toolPanelDragAndDrop');
        }
        if (this.columnsToGroup.length > 0) {
            rowGroupColsSvc?.addColumns(this.columnsToGroup, 'toolPanelDragAndDrop');
        }
        if (this.columnsToPivot.length > 0) {
            pivotColsSvc?.addColumns(this.columnsToPivot, 'toolPanelDragAndDrop');
        }
    }
    onDragCancel() {
        this.clearColumnsList();
    }
}
exports.BodyDropPivotTarget = BodyDropPivotTarget;


/***/ }),

/***/ 57912:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BodyDropTarget = void 0;
const beanStub_1 = __webpack_require__(68731);
const dragAndDropService_1 = __webpack_require__(12903);
const bodyDropPivotTarget_1 = __webpack_require__(43052);
const moveColumnFeature_1 = __webpack_require__(92909);
class BodyDropTarget extends beanStub_1.BeanStub {
    constructor(pinned, eContainer) {
        super();
        this.pinned = pinned;
        this.eContainer = eContainer;
    }
    postConstruct() {
        const { ctrlsSvc, dragAndDrop } = this.beans;
        const pinned = this.pinned;
        ctrlsSvc.whenReady(this, (p) => {
            let eSecondaryContainers;
            const eBodyViewport = p.gridBodyCtrl.eBodyViewport;
            switch (pinned) {
                case 'left':
                    eSecondaryContainers = [
                        [eBodyViewport, p.left.eContainer],
                        [p.bottomLeft.eContainer],
                        [p.topLeft.eContainer],
                    ];
                    break;
                case 'right':
                    eSecondaryContainers = [
                        [eBodyViewport, p.right.eContainer],
                        [p.bottomRight.eContainer],
                        [p.topRight.eContainer],
                    ];
                    break;
                default:
                    eSecondaryContainers = [
                        [eBodyViewport, p.center.eViewport],
                        [p.bottomCenter.eViewport],
                        [p.topCenter.eViewport],
                    ];
                    break;
            }
            this.eSecondaryContainers = eSecondaryContainers;
        });
        this.moveColumnFeature = this.createManagedBean(new moveColumnFeature_1.MoveColumnFeature(pinned));
        this.bodyDropPivotTarget = this.createManagedBean(new bodyDropPivotTarget_1.BodyDropPivotTarget(pinned));
        dragAndDrop.addDropTarget(this);
        this.addDestroyFunc(() => dragAndDrop.removeDropTarget(this));
    }
    isInterestedIn(type) {
        return (type === dragAndDropService_1.DragSourceType.HeaderCell ||
            (type === dragAndDropService_1.DragSourceType.ToolPanel && this.gos.get('allowDragFromColumnsToolPanel')));
    }
    getSecondaryContainers() {
        return this.eSecondaryContainers;
    }
    getContainer() {
        return this.eContainer;
    }
    getIconName() {
        return this.currentDropListener.getIconName();
    }
    // we want to use the bodyPivotTarget if the user is dragging columns in from the toolPanel
    // and we are in pivot mode, as it has to logic to set pivot/value/group on the columns when
    // dropped into the grid's body.
    isDropColumnInPivotMode(draggingEvent) {
        // in pivot mode, then if moving a column (ie didn't come from toolpanel) then it's
        // a standard column move, however if it came from the toolpanel, then we are introducing
        // dimensions or values to the grid
        return this.beans.colModel.isPivotMode() && draggingEvent.dragSource.type === dragAndDropService_1.DragSourceType.ToolPanel;
    }
    onDragEnter(draggingEvent) {
        // we pick the drop listener depending on whether we are in pivot mode are not. if we are
        // in pivot mode, then dropping cols changes the row group, pivot, value stats. otherwise
        // we change visibility state and position.
        this.currentDropListener = this.isDropColumnInPivotMode(draggingEvent)
            ? this.bodyDropPivotTarget
            : this.moveColumnFeature;
        this.currentDropListener.onDragEnter(draggingEvent);
    }
    onDragLeave(params) {
        this.currentDropListener.onDragLeave(params);
    }
    onDragging(params) {
        this.currentDropListener.onDragging(params);
    }
    onDragStop(params) {
        this.currentDropListener.onDragStop(params);
    }
    onDragCancel() {
        this.currentDropListener.onDragCancel();
    }
}
exports.BodyDropTarget = BodyDropTarget;


/***/ }),

/***/ 92909:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MoveColumnFeature = void 0;
const beanStub_1 = __webpack_require__(68731);
const dragAndDropService_1 = __webpack_require__(12903);
const iColumn_1 = __webpack_require__(62783);
const array_1 = __webpack_require__(31502);
const generic_1 = __webpack_require__(34422);
const internalColumnMoveUtils_1 = __webpack_require__(45446);
const MOVE_FAIL_THRESHOLD = 7;
const SCROLL_MOVE_WIDTH = 100;
const SCROLL_GAP_NEEDED_BEFORE_MOVE = SCROLL_MOVE_WIDTH / 2;
const SCROLL_ACCELERATION_RATE = 5;
const SCROLL_TIME_INTERVAL = 100;
class MoveColumnFeature extends beanStub_1.BeanStub {
    constructor(pinned) {
        super();
        this.pinned = pinned;
        this.needToMoveLeft = false;
        this.needToMoveRight = false;
        this.lastMovedInfo = null;
        this.isCenterContainer = !(0, generic_1._exists)(pinned);
    }
    postConstruct() {
        this.beans.ctrlsSvc.whenReady(this, (p) => {
            this.gridBodyCon = p.gridBodyCtrl;
        });
    }
    getIconName() {
        const { pinned, lastDraggingEvent } = this;
        const { dragItem } = lastDraggingEvent || {};
        const columns = dragItem?.columns ?? [];
        for (const col of columns) {
            const colPinned = col.getPinned();
            // when the column is lockPinned, only moves within pinned section
            if (col.getColDef().lockPinned) {
                if (colPinned == pinned) {
                    return 'move';
                }
                continue;
            }
            // if the column pinned state is the same as the container's, or
            // when `unpinning` a column, set the icon to move
            const initialPinnedState = dragItem?.containerType;
            if (initialPinnedState === pinned || !pinned) {
                return 'move';
            }
            // moving an unpinned column to a pinned container
            // set the icon to pinned
            if (pinned && (!colPinned || initialPinnedState !== pinned)) {
                return 'pinned';
            }
        }
        return 'notAllowed';
    }
    onDragEnter(draggingEvent) {
        // we do dummy drag, so make sure column appears in the right location when first placed
        const dragItem = draggingEvent.dragItem;
        const columns = dragItem.columns;
        const dragCameFromToolPanel = draggingEvent.dragSource.type === dragAndDropService_1.DragSourceType.ToolPanel;
        if (dragCameFromToolPanel) {
            // the if statement doesn't work if drag leaves grid, then enters again
            this.setColumnsVisible(columns, true, 'uiColumnDragged');
        }
        else {
            // restore previous state of visible columns upon re-entering. this means if the user drags
            // a group out, and then drags the group back in, only columns that were originally visible
            // will be visible again. otherwise a group with three columns (but only two visible) could
            // be dragged out, then when it's dragged in again, all three are visible. this stops that.
            const visibleState = dragItem.visibleState;
            const visibleColumns = (columns || []).filter((column) => visibleState[column.getId()]);
            this.setColumnsVisible(visibleColumns, true, 'uiColumnDragged');
        }
        if (!this.gos.get('suppressMoveWhenColumnDragging')) {
            this.attemptToPinColumns(columns, this.pinned);
        }
        this.onDragging(draggingEvent, true, true);
    }
    onDragging(draggingEvent = this.lastDraggingEvent, fromEnter = false, fakeEvent = false, finished = false) {
        const { gos, ctrlsSvc } = this.beans;
        const isSuppressMoveWhenDragging = gos.get('suppressMoveWhenColumnDragging');
        if (finished && !isSuppressMoveWhenDragging) {
            this.finishColumnMoving();
            return;
        }
        this.lastDraggingEvent = draggingEvent;
        // if moving up or down (ie not left or right) then do nothing
        if (!draggingEvent || (!finished && (0, generic_1._missing)(draggingEvent.hDirection))) {
            return;
        }
        const mouseX = (0, internalColumnMoveUtils_1.normaliseX)({
            x: draggingEvent.x,
            pinned: this.pinned,
            gos,
            ctrlsSvc,
        });
        // if the user is dragging into the panel, ie coming from the side panel into the main grid,
        // we don't want to scroll the grid this time, it would appear like the table is jumping
        // each time a column is dragged in.
        if (!fromEnter) {
            this.checkCenterForScrolling(mouseX);
        }
        if (isSuppressMoveWhenDragging) {
            this.handleColumnDragWhileSuppressingMovement(draggingEvent, fromEnter, fakeEvent, mouseX, finished);
        }
        else {
            this.handleColumnDragWhileAllowingMovement(draggingEvent, fromEnter, fakeEvent, mouseX, finished);
        }
    }
    onDragLeave() {
        this.ensureIntervalCleared();
        this.clearHighlighted();
        this.updateDragItemContainerType();
        this.lastMovedInfo = null;
    }
    onDragStop() {
        this.onDragging(this.lastDraggingEvent, false, true, true);
        this.ensureIntervalCleared();
        this.lastMovedInfo = null;
    }
    onDragCancel() {
        this.clearHighlighted();
        this.ensureIntervalCleared();
        this.lastMovedInfo = null;
    }
    setColumnsVisible(columns, visible, source) {
        if (!columns) {
            return;
        }
        const allowedCols = columns.filter((c) => !c.getColDef().lockVisible);
        this.beans.colModel.setColsVisible(allowedCols, visible, source);
    }
    finishColumnMoving() {
        this.clearHighlighted();
        const lastMovedInfo = this.lastMovedInfo;
        if (!lastMovedInfo) {
            return;
        }
        const { columns, toIndex } = lastMovedInfo;
        this.beans.colMoves.moveColumns(columns, toIndex, 'uiColumnMoved', true);
    }
    updateDragItemContainerType() {
        const { lastDraggingEvent } = this;
        if (this.gos.get('suppressMoveWhenColumnDragging') || !lastDraggingEvent) {
            return;
        }
        const dragItem = lastDraggingEvent.dragItem;
        if (!dragItem) {
            return;
        }
        dragItem.containerType = this.pinned;
    }
    handleColumnDragWhileSuppressingMovement(draggingEvent, fromEnter, fakeEvent, mouseX, finished) {
        const allMovingColumns = this.getAllMovingColumns(draggingEvent, true);
        if (finished) {
            // first we handle pinning, then move columns
            const isAttemptingToPin = this.isAttemptingToPin(allMovingColumns);
            if (isAttemptingToPin) {
                this.attemptToPinColumns(allMovingColumns, undefined, true);
            }
            const { fromLeft, xPosition } = this.getNormalisedXPositionInfo(allMovingColumns, isAttemptingToPin) || {};
            if (fromLeft == null || xPosition == null) {
                this.finishColumnMoving();
                return;
            }
            this.moveColumnsAfterHighlight({
                allMovingColumns,
                xPosition,
                fromEnter,
                fakeEvent,
                fromLeft,
            });
        }
        else {
            if (!this.beans.dragAndDrop.isDropZoneWithinThisGrid(draggingEvent)) {
                return;
            }
            this.highlightHoveredColumn(allMovingColumns, mouseX);
        }
    }
    handleColumnDragWhileAllowingMovement(draggingEvent, fromEnter, fakeEvent, mouseX, finished) {
        const allMovingColumns = this.getAllMovingColumns(draggingEvent);
        const fromLeft = this.normaliseDirection(draggingEvent.hDirection) === 'right';
        const isFromHeader = draggingEvent.dragSource.type === dragAndDropService_1.DragSourceType.HeaderCell;
        const params = this.getMoveColumnParams({
            allMovingColumns,
            isFromHeader,
            xPosition: mouseX,
            fromLeft,
            fromEnter,
            fakeEvent,
        });
        const lastMovedInfo = (0, internalColumnMoveUtils_1.attemptMoveColumns)({ ...params, finished });
        if (lastMovedInfo) {
            this.lastMovedInfo = lastMovedInfo;
        }
    }
    getAllMovingColumns(draggingEvent, useSplit = false) {
        const dragItem = draggingEvent.dragSource.getDragItem();
        let columns = null;
        if (useSplit) {
            columns = dragItem.columnsInSplit;
            if (!columns) {
                columns = dragItem.columns;
            }
        }
        else {
            columns = dragItem.columns;
        }
        // if locked return true only if both col and container are same pin type.
        // double equals (==) here on purpose so that null==undefined is true (for not pinned options)
        // if not pin locked, then always allowed to be in this container
        const conditionCallback = (col) => col.getColDef().lockPinned ? col.getPinned() == this.pinned : true;
        if (!columns) {
            return [];
        }
        return columns.filter(conditionCallback);
    }
    getMoveColumnParams(params) {
        const { allMovingColumns, isFromHeader, xPosition, fromLeft, fromEnter, fakeEvent } = params;
        const { gos, colModel, colMoves, visibleCols } = this.beans;
        return {
            allMovingColumns,
            isFromHeader,
            fromLeft,
            xPosition,
            pinned: this.pinned,
            fromEnter,
            fakeEvent,
            gos,
            colModel,
            colMoves: colMoves,
            visibleCols,
        };
    }
    highlightHoveredColumn(movingColumns, mouseX) {
        const { gos, colModel } = this.beans;
        const isRtl = gos.get('enableRtl');
        const consideredColumns = colModel
            .getCols()
            .filter((col) => col.isVisible() && col.getPinned() === this.pinned);
        let start = null;
        let width = null;
        let targetColumn = null;
        for (const col of consideredColumns) {
            width = col.getActualWidth();
            start = this.getNormalisedColumnLeft(col, 0, isRtl);
            if (start != null) {
                const end = start + width;
                if (start <= mouseX && end >= mouseX) {
                    targetColumn = col;
                    break;
                }
            }
            start = null;
            width = null;
        }
        if (!targetColumn) {
            // we fall into this condition if no columns are being hover
            // (e.g. hovering an empty area of the column header beyond all columns)
            for (let i = consideredColumns.length - 1; i >= 0; i--) {
                const currentColumn = consideredColumns[i];
                const parent = consideredColumns[i].getParent();
                if (!parent) {
                    targetColumn = currentColumn;
                    break;
                }
                const leafDisplayedCols = parent?.getDisplayedLeafColumns();
                if (leafDisplayedCols.length) {
                    targetColumn = (0, array_1._last)(leafDisplayedCols);
                    break;
                }
            }
            if (!targetColumn) {
                return;
            }
            start = this.getNormalisedColumnLeft(targetColumn, 0, isRtl);
            width = targetColumn.getActualWidth();
        }
        else if (movingColumns.indexOf(targetColumn) !== -1) {
            targetColumn = null;
        }
        if (this.lastHighlightedColumn?.column !== targetColumn) {
            this.clearHighlighted();
        }
        if (targetColumn == null || start == null || width == null) {
            return;
        }
        let position;
        if (mouseX - start < width / 2 !== isRtl) {
            position = iColumn_1.ColumnHighlightPosition.Before;
        }
        else {
            position = iColumn_1.ColumnHighlightPosition.After;
        }
        setColumnHighlighted(targetColumn, position);
        this.lastHighlightedColumn = { column: targetColumn, position };
    }
    getNormalisedXPositionInfo(allMovingColumns, isAttemptingToPin) {
        const { gos, visibleCols } = this.beans;
        const isRtl = gos.get('enableRtl');
        const { firstMovingCol, column, position } = this.getColumnMoveAndTargetInfo(allMovingColumns, isAttemptingToPin, isRtl);
        if (!firstMovingCol || !column || position == null) {
            return;
        }
        const visibleColumns = visibleCols.allCols;
        const movingColIndex = visibleColumns.indexOf(firstMovingCol);
        const targetIndex = visibleColumns.indexOf(column);
        const isBefore = (position === iColumn_1.ColumnHighlightPosition.Before) !== isRtl;
        const fromLeft = movingColIndex < targetIndex || (movingColIndex === targetIndex && !isBefore);
        let diff = 0;
        if (isBefore) {
            if (fromLeft) {
                diff -= 1;
            }
        }
        else {
            if (!fromLeft) {
                diff += 1;
            }
        }
        if (targetIndex + diff === movingColIndex) {
            return;
        }
        const targetColumn = visibleColumns[targetIndex + diff];
        if (!targetColumn) {
            return;
        }
        const xPosition = this.getNormalisedColumnLeft(targetColumn, 20, isRtl);
        return { fromLeft, xPosition };
    }
    getColumnMoveAndTargetInfo(allMovingColumns, isAttemptingToPin, isRtl) {
        const lastHighlightedColumn = this.lastHighlightedColumn || {};
        const { firstMovingCol, lastMovingCol } = findFirstAndLastMovingColumns(allMovingColumns);
        if (!firstMovingCol || !lastMovingCol || lastHighlightedColumn.column || !isAttemptingToPin) {
            return {
                firstMovingCol,
                ...lastHighlightedColumn,
            };
        }
        const pinned = this.getPinDirection();
        const isLeft = pinned === 'left';
        return {
            firstMovingCol,
            position: isLeft ? iColumn_1.ColumnHighlightPosition.After : iColumn_1.ColumnHighlightPosition.Before,
            column: isLeft !== isRtl ? firstMovingCol : lastMovingCol,
        };
    }
    normaliseDirection(hDirection) {
        if (this.gos.get('enableRtl')) {
            switch (hDirection) {
                case 'left':
                    return 'right';
                case 'right':
                    return 'left';
            }
        }
        return hDirection;
    }
    getNormalisedColumnLeft(col, padding, isRtl) {
        const { gos, ctrlsSvc } = this.beans;
        const left = col.getLeft();
        if (left == null) {
            return null;
        }
        const width = col.getActualWidth();
        return (0, internalColumnMoveUtils_1.normaliseX)({
            x: isRtl ? left + width - padding : left + padding,
            pinned: col.getPinned(),
            useHeaderRow: isRtl,
            skipScrollPadding: true,
            gos,
            ctrlsSvc,
        });
    }
    isAttemptingToPin(columns) {
        const isMovingHorizontally = this.needToMoveLeft || this.needToMoveRight;
        const isFailedMoreThanThreshold = this.failedMoveAttempts > MOVE_FAIL_THRESHOLD;
        return ((isMovingHorizontally && isFailedMoreThanThreshold) ||
            columns.some((col) => col.getPinned() !== this.pinned));
    }
    moveColumnsAfterHighlight(params) {
        const { allMovingColumns, xPosition, fromEnter, fakeEvent, fromLeft } = params;
        const columnMoveParams = this.getMoveColumnParams({
            allMovingColumns,
            isFromHeader: true,
            xPosition,
            fromLeft,
            fromEnter,
            fakeEvent,
        });
        const { columns, toIndex } = (0, internalColumnMoveUtils_1.getBestColumnMoveIndexFromXPosition)(columnMoveParams) || {};
        if (columns && toIndex != null) {
            this.lastMovedInfo = {
                columns,
                toIndex,
            };
        }
        this.finishColumnMoving();
    }
    clearHighlighted() {
        const { lastHighlightedColumn } = this;
        if (!lastHighlightedColumn) {
            return;
        }
        setColumnHighlighted(lastHighlightedColumn.column, null);
        this.lastHighlightedColumn = null;
    }
    checkCenterForScrolling(xAdjustedForScroll) {
        if (!this.isCenterContainer) {
            return;
        }
        // scroll if the mouse has gone outside the grid (or just outside the scrollable part if pinning)
        // putting in 50 buffer, so even if user gets to edge of grid, a scroll will happen
        const centerCtrl = this.beans.ctrlsSvc.get('center');
        const firstVisiblePixel = centerCtrl.getCenterViewportScrollLeft();
        const lastVisiblePixel = firstVisiblePixel + centerCtrl.getCenterWidth();
        let needToMoveRight;
        let needToMoveLeft;
        if (this.gos.get('enableRtl')) {
            needToMoveRight = xAdjustedForScroll < firstVisiblePixel + SCROLL_GAP_NEEDED_BEFORE_MOVE;
            needToMoveLeft = xAdjustedForScroll > lastVisiblePixel - SCROLL_GAP_NEEDED_BEFORE_MOVE;
        }
        else {
            needToMoveLeft = xAdjustedForScroll < firstVisiblePixel + SCROLL_GAP_NEEDED_BEFORE_MOVE;
            needToMoveRight = xAdjustedForScroll > lastVisiblePixel - SCROLL_GAP_NEEDED_BEFORE_MOVE;
        }
        this.needToMoveRight = needToMoveRight;
        this.needToMoveLeft = needToMoveLeft;
        if (needToMoveLeft || needToMoveRight) {
            this.ensureIntervalStarted();
        }
        else {
            this.ensureIntervalCleared();
        }
    }
    ensureIntervalStarted() {
        if (this.movingIntervalId) {
            return;
        }
        this.intervalCount = 0;
        this.failedMoveAttempts = 0;
        this.movingIntervalId = window.setInterval(this.moveInterval.bind(this), SCROLL_TIME_INTERVAL);
        this.beans.dragAndDrop.getDragAndDropImageComponent()?.setIcon(this.needToMoveLeft ? 'left' : 'right', true);
    }
    ensureIntervalCleared() {
        if (!this.movingIntervalId) {
            return;
        }
        window.clearInterval(this.movingIntervalId);
        this.movingIntervalId = null;
        this.failedMoveAttempts = 0;
        this.beans.dragAndDrop.getDragAndDropImageComponent()?.setIcon(this.getIconName(), false);
    }
    moveInterval() {
        // the amounts we move get bigger at each interval, so the speed accelerates, starting a bit slow
        // and getting faster. this is to give smoother user experience. we max at `SCROLL_MOVE_WIDTH` to limit the speed.
        let pixelsToMove;
        this.intervalCount++;
        pixelsToMove = 10 + this.intervalCount * SCROLL_ACCELERATION_RATE;
        if (pixelsToMove > SCROLL_MOVE_WIDTH) {
            pixelsToMove = SCROLL_MOVE_WIDTH;
        }
        let pixelsMoved = null;
        const scrollFeature = this.gridBodyCon.scrollFeature;
        if (this.needToMoveLeft) {
            pixelsMoved = scrollFeature.scrollHorizontally(-pixelsToMove);
        }
        else if (this.needToMoveRight) {
            pixelsMoved = scrollFeature.scrollHorizontally(pixelsToMove);
        }
        if (pixelsMoved !== 0) {
            this.onDragging(this.lastDraggingEvent);
            this.failedMoveAttempts = 0;
        }
        else {
            // we count the failed move attempts. if we fail to move `MOVE_FAIL_THRESHOLD` times, then we pin the column.
            // this is how we achieve pining by dragging the column to the edge of the grid.
            this.failedMoveAttempts++;
            const { pinnedCols, dragAndDrop, gos } = this.beans;
            if (this.failedMoveAttempts <= MOVE_FAIL_THRESHOLD + 1 || !pinnedCols) {
                return;
            }
            dragAndDrop.getDragAndDropImageComponent()?.setIcon('pinned', false);
            if (!gos.get('suppressMoveWhenColumnDragging')) {
                const columns = this.lastDraggingEvent?.dragItem.columns;
                this.attemptToPinColumns(columns, undefined, true);
            }
        }
    }
    getPinDirection() {
        if (this.needToMoveLeft || this.pinned === 'left') {
            return 'left';
        }
        if (this.needToMoveRight || this.pinned === 'right') {
            return 'right';
        }
    }
    attemptToPinColumns(columns, pinned, fromMoving = false) {
        const allowedCols = (columns || []).filter((c) => !c.getColDef().lockPinned);
        if (!allowedCols.length) {
            return 0;
        }
        if (fromMoving) {
            pinned = this.getPinDirection();
        }
        const { pinnedCols, dragAndDrop } = this.beans;
        pinnedCols?.setColsPinned(allowedCols, pinned, 'uiColumnDragged');
        if (fromMoving) {
            dragAndDrop.nudge();
        }
        return allowedCols.length;
    }
    destroy() {
        super.destroy();
        this.lastDraggingEvent = null;
        this.clearHighlighted();
        this.lastMovedInfo = null;
    }
}
exports.MoveColumnFeature = MoveColumnFeature;
function setColumnHighlighted(column, highlighted) {
    if (column.highlighted === highlighted) {
        return;
    }
    column.highlighted = highlighted;
    column.dispatchColEvent('headerHighlightChanged', 'uiColumnMoved');
}
function findFirstAndLastMovingColumns(allMovingColumns) {
    const moveLen = allMovingColumns.length;
    let firstMovingCol;
    let lastMovingCol;
    for (let i = 0; i < moveLen; i++) {
        if (!firstMovingCol) {
            const leftCol = allMovingColumns[i];
            if (leftCol.getLeft() != null) {
                firstMovingCol = leftCol;
            }
        }
        if (!lastMovingCol) {
            const rightCol = allMovingColumns[moveLen - 1 - i];
            if (rightCol.getLeft() != null) {
                lastMovingCol = rightCol;
            }
        }
        if (firstMovingCol && lastMovingCol) {
            break;
        }
    }
    return { firstMovingCol, lastMovingCol };
}


/***/ }),

/***/ 10852:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.moveColumns = exports.moveColumnByIndex = void 0;
function moveColumnByIndex(beans, fromIndex, toIndex) {
    beans.colMoves?.moveColumnByIndex(fromIndex, toIndex, 'api');
}
exports.moveColumnByIndex = moveColumnByIndex;
function moveColumns(beans, columnsToMoveKeys, toIndex) {
    beans.colMoves?.moveColumns(columnsToMoveKeys, toIndex, 'api');
}
exports.moveColumns = moveColumns;


/***/ }),

/***/ 64074:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColumnMoveModule = void 0;
const dragModule_1 = __webpack_require__(24388);
const version_1 = __webpack_require__(97205);
const column_moving_css_GENERATED_1 = __webpack_require__(9607);
const columnAnimationService_1 = __webpack_require__(19122);
const columnMoveApi_1 = __webpack_require__(10852);
const columnMoveService_1 = __webpack_require__(24067);
/**
 * @feature Columns -> Column Moving
 */
exports.ColumnMoveModule = {
    moduleName: 'ColumnMove',
    version: version_1.VERSION,
    beans: [columnMoveService_1.ColumnMoveService, columnAnimationService_1.ColumnAnimationService],
    apiFunctions: {
        moveColumnByIndex: columnMoveApi_1.moveColumnByIndex,
        moveColumns: columnMoveApi_1.moveColumns,
    },
    dependsOn: [dragModule_1.SharedDragAndDropModule],
    css: [column_moving_css_GENERATED_1.columnMovingCSS],
};


/***/ }),

/***/ 24067:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColumnMoveService = void 0;
const beanStub_1 = __webpack_require__(68731);
const dragAndDropService_1 = __webpack_require__(12903);
const agColumnGroup_1 = __webpack_require__(56908);
const array_1 = __webpack_require__(31502);
const logging_1 = __webpack_require__(47764);
const bodyDropTarget_1 = __webpack_require__(57912);
const columnMoveUtils_1 = __webpack_require__(23505);
const internalColumnMoveUtils_1 = __webpack_require__(45446);
var MoveDirection;
(function (MoveDirection) {
    MoveDirection[MoveDirection["LEFT"] = -1] = "LEFT";
    MoveDirection[MoveDirection["NONE"] = 0] = "NONE";
    MoveDirection[MoveDirection["RIGHT"] = 1] = "RIGHT";
})(MoveDirection || (MoveDirection = {}));
class ColumnMoveService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'colMoves';
    }
    moveColumnByIndex(fromIndex, toIndex, source) {
        const gridColumns = this.beans.colModel.getCols();
        if (!gridColumns) {
            return;
        }
        const column = gridColumns[fromIndex];
        this.moveColumns([column], toIndex, source);
    }
    moveColumns(columnsToMoveKeys, toIndex, source, finished = true) {
        const { colModel, colAnimation, visibleCols, eventSvc } = this.beans;
        const gridColumns = colModel.getCols();
        if (!gridColumns) {
            return;
        }
        if (toIndex > gridColumns.length - columnsToMoveKeys.length) {
            // Trying to insert in invalid position
            (0, logging_1._warn)(30, { toIndex });
            return;
        }
        colAnimation?.start();
        // we want to pull all the columns out first and put them into an ordered list
        const movedColumns = colModel.getColsForKeys(columnsToMoveKeys);
        if (this.doesMovePassRules(movedColumns, toIndex)) {
            (0, array_1._moveInArray)(colModel.getCols(), movedColumns, toIndex);
            visibleCols.refresh(source);
            eventSvc.dispatchEvent({
                type: 'columnMoved',
                columns: movedColumns,
                column: movedColumns.length === 1 ? movedColumns[0] : null,
                toIndex,
                finished,
                source,
            });
        }
        colAnimation?.finish();
    }
    doesMovePassRules(columnsToMove, toIndex) {
        // make a copy of what the grid columns would look like after the move
        const proposedColumnOrder = this.getProposedColumnOrder(columnsToMove, toIndex);
        return this.doesOrderPassRules(proposedColumnOrder);
    }
    doesOrderPassRules(gridOrder) {
        const { colModel, gos } = this.beans;
        if (!(0, columnMoveUtils_1.doesMovePassMarryChildren)(gridOrder, colModel.getColTree())) {
            return false;
        }
        const doesMovePassLockedPositions = (proposedColumnOrder) => {
            const lockPositionToPlacement = (position) => {
                if (!position) {
                    return MoveDirection.NONE;
                }
                return position === 'left' || position === true ? MoveDirection.LEFT : MoveDirection.RIGHT;
            };
            const isRtl = gos.get('enableRtl');
            let lastPlacement = isRtl ? MoveDirection.RIGHT : MoveDirection.LEFT;
            let rulePassed = true;
            proposedColumnOrder.forEach((col) => {
                const placement = lockPositionToPlacement(col.getColDef().lockPosition);
                if (isRtl) {
                    if (placement > lastPlacement) {
                        // If placement goes up, we're not in the correct order
                        rulePassed = false;
                    }
                }
                else {
                    if (placement < lastPlacement) {
                        // If placement goes down, we're not in the correct order
                        rulePassed = false;
                    }
                }
                lastPlacement = placement;
            });
            return rulePassed;
        };
        if (!doesMovePassLockedPositions(gridOrder)) {
            return false;
        }
        return true;
    }
    getProposedColumnOrder(columnsToMove, toIndex) {
        const gridColumns = this.beans.colModel.getCols();
        const proposedColumnOrder = gridColumns.slice();
        (0, array_1._moveInArray)(proposedColumnOrder, columnsToMove, toIndex);
        return proposedColumnOrder;
    }
    createBodyDropTarget(pinned, dropContainer) {
        return new bodyDropTarget_1.BodyDropTarget(pinned, dropContainer);
    }
    moveHeader(hDirection, eGui, column, pinned, bean) {
        const { ctrlsSvc, gos, colModel, visibleCols, focusSvc } = this.beans;
        const rect = eGui.getBoundingClientRect();
        const left = rect.left;
        const isGroup = (0, agColumnGroup_1.isColumnGroup)(column);
        const width = isGroup ? rect.width : column.getActualWidth();
        const isLeft = (hDirection === 'left') !== gos.get('enableRtl');
        const xPosition = (0, internalColumnMoveUtils_1.normaliseX)({
            x: isLeft ? left - 20 : left + width + 20,
            pinned,
            fromKeyboard: true,
            gos,
            ctrlsSvc,
        });
        const headerPosition = focusSvc.focusedHeader;
        (0, internalColumnMoveUtils_1.attemptMoveColumns)({
            allMovingColumns: isGroup ? column.getLeafColumns() : [column],
            isFromHeader: true,
            fromLeft: hDirection === 'right',
            xPosition,
            pinned,
            fromEnter: false,
            fakeEvent: false,
            gos,
            colModel,
            colMoves: this,
            visibleCols,
            finished: true,
        });
        let targetColumn;
        if (isGroup) {
            const displayedLeafColumns = column.getDisplayedLeafColumns();
            targetColumn = isLeft ? displayedLeafColumns[0] : (0, array_1._last)(displayedLeafColumns);
        }
        else {
            targetColumn = column;
        }
        ctrlsSvc.getScrollFeature().ensureColumnVisible(targetColumn, 'auto');
        if ((!bean.isAlive() || gos.get('ensureDomOrder')) && headerPosition) {
            let restoreFocusColumn;
            if (isGroup) {
                const groupId = column.getGroupId();
                const leafCols = column.getLeafColumns();
                if (!leafCols.length) {
                    return;
                }
                const parent = leafCols[0].getParent();
                if (!parent) {
                    return;
                }
                restoreFocusColumn = findGroupWidthId(parent, groupId);
            }
            else {
                restoreFocusColumn = column;
            }
            if (restoreFocusColumn) {
                focusSvc.focusHeaderPosition({
                    headerPosition: {
                        ...headerPosition,
                        column: restoreFocusColumn,
                    },
                });
            }
        }
    }
    setDragSourceForHeader(eSource, column, displayName) {
        const { gos, colModel, dragAndDrop, visibleCols } = this.beans;
        let hideColumnOnExit = !gos.get('suppressDragLeaveHidesColumns');
        const isGroup = (0, agColumnGroup_1.isColumnGroup)(column);
        const columns = isGroup ? column.getProvidedColumnGroup().getLeafColumns() : [column];
        const getDragItem = isGroup
            ? () => createDragItemForGroup(column, visibleCols.allCols)
            : () => createDragItem(column);
        const dragSource = {
            type: dragAndDropService_1.DragSourceType.HeaderCell,
            eElement: eSource,
            getDefaultIconName: () => (hideColumnOnExit ? 'hide' : 'notAllowed'),
            getDragItem,
            dragItemName: displayName,
            onDragStarted: () => {
                hideColumnOnExit = !gos.get('suppressDragLeaveHidesColumns');
                (0, internalColumnMoveUtils_1.setColumnsMoving)(columns, true);
            },
            onDragStopped: () => (0, internalColumnMoveUtils_1.setColumnsMoving)(columns, false),
            onDragCancelled: () => (0, internalColumnMoveUtils_1.setColumnsMoving)(columns, false),
            onGridEnter: (dragItem) => {
                if (hideColumnOnExit) {
                    const { columns = [], visibleState } = dragItem ?? {};
                    const hasVisibleState = isGroup
                        ? (col) => !visibleState || visibleState[col.getColId()]
                        : () => true;
                    const unlockedColumns = columns.filter((col) => !col.getColDef().lockVisible && hasVisibleState(col));
                    colModel.setColsVisible(unlockedColumns, true, 'uiColumnMoved');
                }
            },
            onGridExit: (dragItem) => {
                if (hideColumnOnExit) {
                    const unlockedColumns = dragItem?.columns?.filter((col) => !col.getColDef().lockVisible) || [];
                    colModel.setColsVisible(unlockedColumns, false, 'uiColumnMoved');
                }
            },
        };
        dragAndDrop.addDragSource(dragSource, true);
        return dragSource;
    }
}
exports.ColumnMoveService = ColumnMoveService;
function findGroupWidthId(columnGroup, id) {
    while (columnGroup) {
        if (columnGroup.getGroupId() === id) {
            return columnGroup;
        }
        columnGroup = columnGroup.getParent();
    }
    return undefined;
}
function createDragItem(column) {
    const visibleState = {};
    visibleState[column.getId()] = column.isVisible();
    return {
        columns: [column],
        visibleState: visibleState,
        containerType: column.pinned,
    };
}
// when moving the columns, we want to move all the columns (contained within the DragItem) in this group in one go,
// and in the order they are currently in the screen.
function createDragItemForGroup(columnGroup, allCols) {
    const allColumnsOriginalOrder = columnGroup.getProvidedColumnGroup().getLeafColumns();
    // capture visible state, used when re-entering grid to dictate which columns should be visible
    const visibleState = {};
    allColumnsOriginalOrder.forEach((column) => (visibleState[column.getId()] = column.isVisible()));
    const allColumnsCurrentOrder = [];
    allCols.forEach((column) => {
        if (allColumnsOriginalOrder.indexOf(column) >= 0) {
            allColumnsCurrentOrder.push(column);
            (0, array_1._removeFromArray)(allColumnsOriginalOrder, column);
        }
    });
    // we are left with non-visible columns, stick these in at the end
    allColumnsOriginalOrder.forEach((column) => allColumnsCurrentOrder.push(column));
    const columnsInSplit = [];
    const columnGroupColumns = columnGroup.getLeafColumns();
    for (const col of allColumnsCurrentOrder) {
        if (columnGroupColumns.indexOf(col) !== -1) {
            columnsInSplit.push(col);
        }
    }
    // create and return dragItem
    return {
        columns: allColumnsCurrentOrder,
        columnsInSplit,
        visibleState: visibleState,
        containerType: columnsInSplit[0]?.pinned,
    };
}


/***/ }),

/***/ 23505:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.doesMovePassMarryChildren = exports.placeLockedColumns = void 0;
const columnFactoryUtils_1 = __webpack_require__(82716);
const agProvidedColumnGroup_1 = __webpack_require__(79409);
function placeLockedColumns(cols, gos) {
    const left = [];
    const normal = [];
    const right = [];
    cols.forEach((col) => {
        const position = col.getColDef().lockPosition;
        if (position === 'right') {
            right.push(col);
        }
        else if (position === 'left' || position === true) {
            left.push(col);
        }
        else {
            normal.push(col);
        }
    });
    const isRtl = gos.get('enableRtl');
    if (isRtl) {
        return [...right, ...normal, ...left];
    }
    return [...left, ...normal, ...right];
}
exports.placeLockedColumns = placeLockedColumns;
function doesMovePassMarryChildren(allColumnsCopy, gridBalancedTree) {
    let rulePassed = true;
    (0, columnFactoryUtils_1.depthFirstOriginalTreeSearch)(null, gridBalancedTree, (child) => {
        if (!(0, agProvidedColumnGroup_1.isProvidedColumnGroup)(child)) {
            return;
        }
        const columnGroup = child;
        const colGroupDef = columnGroup.getColGroupDef();
        const marryChildren = colGroupDef && colGroupDef.marryChildren;
        if (!marryChildren) {
            return;
        }
        const newIndexes = [];
        columnGroup.getLeafColumns().forEach((col) => {
            const newColIndex = allColumnsCopy.indexOf(col);
            newIndexes.push(newColIndex);
        });
        // eslint-disable-next-line prefer-spread
        const maxIndex = Math.max.apply(Math, newIndexes);
        // eslint-disable-next-line prefer-spread
        const minIndex = Math.min.apply(Math, newIndexes);
        // spread is how far the first column in this group is away from the last column
        const spread = maxIndex - minIndex;
        const maxSpread = columnGroup.getLeafColumns().length - 1;
        // if the columns
        if (spread > maxSpread) {
            rulePassed = false;
        }
        // console.log(`maxIndex = ${maxIndex}, minIndex = ${minIndex}, spread = ${spread}, maxSpread = ${maxSpread}, fail = ${spread > (count-1)}`)
        // console.log(allColumnsCopy.map( col => col.getColDef().field).join(','));
    });
    return rulePassed;
}
exports.doesMovePassMarryChildren = doesMovePassMarryChildren;


/***/ }),

/***/ 45446:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setColumnsMoving = exports.normaliseX = exports.attemptMoveColumns = exports.getBestColumnMoveIndexFromXPosition = void 0;
const array_1 = __webpack_require__(31502);
// returns the provided cols sorted in same order as they appear in this.cols, eg if this.cols
// contains [a,b,c,d,e] and col passed is [e,a] then the passed cols are sorted into [a,e]
function sortColsLikeCols(colsList, cols) {
    if (!cols || cols.length <= 1) {
        return;
    }
    const notAllColsPresent = cols.filter((c) => colsList.indexOf(c) < 0).length > 0;
    if (notAllColsPresent) {
        return;
    }
    cols.sort((a, b) => {
        const indexA = colsList.indexOf(a);
        const indexB = colsList.indexOf(b);
        return indexA - indexB;
    });
}
function getBestColumnMoveIndexFromXPosition(params) {
    const { isFromHeader, fromLeft, xPosition, fromEnter, fakeEvent, pinned, gos, colModel, colMoves, visibleCols } = params;
    let { allMovingColumns } = params;
    if (isFromHeader) {
        // If the columns we're dragging are the only visible columns of their group, move the hidden ones too
        const newCols = [];
        allMovingColumns.forEach((col) => {
            let movingGroup = null;
            let parent = col.getParent();
            while (parent != null && parent.getDisplayedLeafColumns().length === 1) {
                movingGroup = parent;
                parent = parent.getParent();
            }
            if (movingGroup != null) {
                const isMarryChildren = !!movingGroup.getColGroupDef()?.marryChildren;
                const columnsToMove = isMarryChildren
                    ? // when marry children is true, we also have to move hidden
                        // columns within the group, so grab them from the `providedColumnGroup`
                        movingGroup.getProvidedColumnGroup().getLeafColumns()
                    : movingGroup.getLeafColumns();
                columnsToMove.forEach((newCol) => {
                    if (!newCols.includes(newCol)) {
                        newCols.push(newCol);
                    }
                });
            }
            else if (!newCols.includes(col)) {
                newCols.push(col);
            }
        });
        allMovingColumns = newCols;
    }
    // it is important to sort the moving columns as they are in grid columns, as the list of moving columns
    // could themselves be part of 'married children' groups, which means we need to maintain the order within
    // the moving list.
    const allMovingColumnsOrdered = allMovingColumns.slice();
    sortColsLikeCols(colModel.getCols(), allMovingColumnsOrdered);
    const validMoves = calculateValidMoves({
        movingCols: allMovingColumnsOrdered,
        draggingRight: fromLeft,
        xPosition,
        pinned,
        gos,
        colModel,
        visibleCols,
    });
    // if cols are not adjacent, then this returns null. when moving, we constrain the direction of the move
    // (ie left or right) to the mouse direction. however
    const oldIndex = calculateOldIndex(allMovingColumnsOrdered, colModel);
    if (validMoves.length === 0) {
        return;
    }
    const firstValidMove = validMoves[0];
    // the two check below stop an error when the user grabs a group my a middle column, then
    // it is possible the mouse pointer is to the right of a column while been dragged left.
    // so we need to make sure that the mouse pointer is actually left of the left most column
    // if moving left, and right of the right most column if moving right
    // we check 'fromEnter' below so we move the column to the new spot if the mouse is coming from
    // outside the grid, eg if the column is moving from side panel, mouse is moving left, then we should
    // place the column to the RHS even if the mouse is moving left and the column is already on
    // the LHS. otherwise we stick to the rule described above.
    let constrainDirection = oldIndex !== null && !fromEnter;
    // don't consider 'fromEnter' when dragging header cells, otherwise group can jump to opposite direction of drag
    if (isFromHeader) {
        constrainDirection = oldIndex !== null;
    }
    // if the event was faked by a change in column pin state, then the original location of the column
    // is not reliable for dictating where the column may now be placed.
    if (constrainDirection && !fakeEvent) {
        // only allow left drag if this column is moving left
        if (!fromLeft && firstValidMove >= oldIndex) {
            return;
        }
        // only allow right drag if this column is moving right
        if (fromLeft && firstValidMove <= oldIndex) {
            return;
        }
    }
    // From when we find a move that passes all the rules
    // Remember what that move would look like in terms of displayed cols
    // keep going with further moves until we find a different result in displayed output
    // In this way potentialMoves contains all potential moves over 'hidden' columns
    const displayedCols = visibleCols.allCols;
    const potentialMoves = [];
    let targetOrder = null;
    for (let i = 0; i < validMoves.length; i++) {
        const move = validMoves[i];
        const order = colMoves.getProposedColumnOrder(allMovingColumnsOrdered, move);
        if (!colMoves.doesOrderPassRules(order)) {
            continue;
        }
        const displayedOrder = order.filter((col) => displayedCols.includes(col));
        if (targetOrder === null) {
            targetOrder = displayedOrder;
        }
        else if (!(0, array_1._areEqual)(displayedOrder, targetOrder)) {
            break; // Stop looking for potential moves if the displayed result changes from the target
        }
        const fragCount = groupFragCount(order);
        potentialMoves.push({ move, fragCount });
    }
    if (potentialMoves.length === 0) {
        return;
    }
    // The best move is the move with least group fragmentation
    potentialMoves.sort((a, b) => a.fragCount - b.fragCount);
    const toIndex = potentialMoves[0].move;
    if (toIndex > colModel.getCols().length - allMovingColumns.length) {
        return;
    }
    return { columns: allMovingColumns, toIndex };
}
exports.getBestColumnMoveIndexFromXPosition = getBestColumnMoveIndexFromXPosition;
function attemptMoveColumns(params) {
    const { columns, toIndex } = getBestColumnMoveIndexFromXPosition(params) || {};
    const { finished, colMoves } = params;
    if (!columns || toIndex == null) {
        return null;
    }
    colMoves.moveColumns(columns, toIndex, 'uiColumnMoved', finished);
    return finished ? null : { columns, toIndex };
}
exports.attemptMoveColumns = attemptMoveColumns;
// returns the index of the first column in the list ONLY if the cols are all beside
// each other. if the cols are not beside each other, then returns null
function calculateOldIndex(movingCols, colModel) {
    const gridCols = colModel.getCols();
    const indexes = movingCols.map((col) => gridCols.indexOf(col)).sort((a, b) => a - b);
    const firstIndex = indexes[0];
    const lastIndex = (0, array_1._last)(indexes);
    const spread = lastIndex - firstIndex;
    const gapsExist = spread !== indexes.length - 1;
    return gapsExist ? null : firstIndex;
}
// A measure of how fragmented in terms of groups an order of columns is
function groupFragCount(columns) {
    function parents(col) {
        const result = [];
        let parent = col.getOriginalParent();
        while (parent != null) {
            result.push(parent);
            parent = parent.getOriginalParent();
        }
        return result;
    }
    let count = 0;
    for (let i = 0; i < columns.length - 1; i++) {
        let a = parents(columns[i]);
        let b = parents(columns[i + 1]);
        // iterate over the longest one
        [a, b] = a.length > b.length ? [a, b] : [b, a];
        a.forEach((parent) => {
            if (b.indexOf(parent) === -1) {
                count++; // More fragmented if other column doesn't share the parent
            }
        });
    }
    return count;
}
function getDisplayedColumns(visibleCols, type) {
    switch (type) {
        case 'left':
            return visibleCols.leftCols;
        case 'right':
            return visibleCols.rightCols;
        default:
            return visibleCols.centerCols;
    }
}
function calculateValidMoves(params) {
    const { movingCols, draggingRight, xPosition, pinned, gos, colModel, visibleCols } = params;
    const isMoveBlocked = gos.get('suppressMovableColumns') || movingCols.some((col) => col.getColDef().suppressMovable);
    if (isMoveBlocked) {
        return [];
    }
    // this is the list of cols on the screen, so it's these we use when comparing the x mouse position
    const allDisplayedCols = getDisplayedColumns(visibleCols, pinned);
    // but this list is the list of all cols, when we move a col it's the index within this list that gets used,
    // so the result we return has to be and index location for this list
    const allGridCols = colModel.getCols();
    const movingDisplayedCols = allDisplayedCols.filter((col) => movingCols.includes(col));
    const otherDisplayedCols = allDisplayedCols.filter((col) => !movingCols.includes(col));
    const otherGridCols = allGridCols.filter((col) => !movingCols.includes(col));
    // work out how many DISPLAYED columns fit before the 'x' position. this gives us the displayIndex.
    // for example, if cols are a,b,c,d and we find a,b fit before 'x', then we want to place the moving
    // col between b and c (so that it is under the mouse position).
    let displayIndex = 0;
    let availableWidth = xPosition;
    // if we are dragging right, then the columns will be to the left of the mouse, so we also want to
    // include the width of the moving columns
    if (draggingRight) {
        let widthOfMovingDisplayedCols = 0;
        movingDisplayedCols.forEach((col) => (widthOfMovingDisplayedCols += col.getActualWidth()));
        availableWidth -= widthOfMovingDisplayedCols;
    }
    if (availableWidth > 0) {
        // now count how many of the displayed columns will fit to the left
        for (let i = 0; i < otherDisplayedCols.length; i++) {
            const col = otherDisplayedCols[i];
            availableWidth -= col.getActualWidth();
            if (availableWidth < 0) {
                break;
            }
            displayIndex++;
        }
        // trial and error, if going right, we adjust by one, i didn't manage to quantify why, but it works
        if (draggingRight) {
            displayIndex++;
        }
    }
    // the display index is with respect to all the showing columns, however when we move, it's with
    // respect to all grid columns, so we need to translate from display index to grid index
    let firstValidMove;
    if (displayIndex > 0) {
        const leftColumn = otherDisplayedCols[displayIndex - 1];
        firstValidMove = otherGridCols.indexOf(leftColumn) + 1;
    }
    else {
        firstValidMove = otherGridCols.indexOf(otherDisplayedCols[0]);
        if (firstValidMove === -1) {
            firstValidMove = 0;
        }
    }
    const validMoves = [firstValidMove];
    const numberComparator = (a, b) => a - b;
    // add in other valid moves due to hidden columns and married children. for example, a particular
    // move might break a group that has married children (so move isn't valid), however there could
    // be hidden columns (not displayed) that we could jump over to make the move valid. because
    // they are hidden, user doesn't see any different, however it allows moves that would otherwise
    // not work. for example imagine a group with 9 columns and all columns are hidden except the
    // middle one (so 4 hidden to left, 4 hidden to right), then when moving 'firstValidMove' will
    // be relative to the not-shown column, however we need to consider the move jumping over all the
    // hidden children. if we didn't do this, then if the group just described was at the end (RHS) of the
    // grid, there would be no way to put a column after it (as the grid would only consider beside the
    // visible column, which would fail valid move rules).
    if (draggingRight) {
        // if dragging right, then we add all the additional moves to the right. so in other words
        // if the next move is not valid, find the next move to the right that is valid.
        let pointer = firstValidMove + 1;
        const lastIndex = allGridCols.length - 1;
        while (pointer <= lastIndex) {
            validMoves.push(pointer);
            pointer++;
        }
        // adding columns here means the order is now messed up
        validMoves.sort(numberComparator);
    }
    else {
        // if dragging left we do the reverse of dragging right, we add in all the valid moves to the
        // left. however we also have to consider moves to the right for all hidden columns first.
        // (this logic is hard to reason with, it was worked out with trial and error,
        // more observation rather than science).
        // add moves to the right
        let pointer = firstValidMove;
        const lastIndex = allGridCols.length - 1;
        let displacedCol = allGridCols[pointer];
        // takes into account visible=false and group=closed, ie it is not displayed
        while (pointer <= lastIndex && allDisplayedCols.indexOf(displacedCol) < 0) {
            pointer++;
            validMoves.push(pointer);
            displacedCol = allGridCols[pointer];
        }
        // add moves to the left
        pointer = firstValidMove - 1;
        const firstDisplayIndex = 0;
        while (pointer >= firstDisplayIndex) {
            validMoves.push(pointer);
            pointer--;
        }
        // adding columns here means the order is now messed up
        validMoves.sort(numberComparator).reverse();
    }
    return validMoves;
}
function normaliseX(params) {
    const { pinned, fromKeyboard, gos, ctrlsSvc, useHeaderRow, skipScrollPadding } = params;
    let eViewport = ctrlsSvc.getHeaderRowContainerCtrl(pinned)?.eViewport;
    let { x } = params;
    if (!eViewport) {
        return 0;
    }
    if (fromKeyboard) {
        x -= eViewport.getBoundingClientRect().left;
    }
    // flip the coordinate if doing RTL
    if (gos.get('enableRtl')) {
        if (useHeaderRow) {
            eViewport = eViewport.querySelector('.ag-header-row');
        }
        x = eViewport.clientWidth - x;
    }
    // adjust for scroll only if centre container (the pinned containers don't scroll)
    if (pinned == null && !skipScrollPadding) {
        x += ctrlsSvc.get('center').getCenterViewportScrollLeft();
    }
    return x;
}
exports.normaliseX = normaliseX;
function setColumnsMoving(columns, isMoving) {
    for (const column of columns) {
        column.moving = isMoving;
        column.dispatchColEvent('movingChanged', 'uiColumnMoved');
    }
}
exports.setColumnsMoving = setColumnsMoving;


/***/ }),

/***/ 19686:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setColumnWidths = void 0;
function setColumnWidths(beans, columnWidths, finished = true, source = 'api') {
    beans.colResize?.setColumnWidths(columnWidths, false, finished, source);
}
exports.setColumnWidths = setColumnWidths;


/***/ }),

/***/ 96924:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColumnResizeModule = void 0;
const dragModule_1 = __webpack_require__(24388);
const autoWidthModule_1 = __webpack_require__(40447);
const version_1 = __webpack_require__(97205);
const columnResizeApi_1 = __webpack_require__(19686);
const columnResizeService_1 = __webpack_require__(69677);
/**
 * @feature Columns -> Column Sizing
 */
exports.ColumnResizeModule = {
    moduleName: 'ColumnResize',
    version: version_1.VERSION,
    beans: [columnResizeService_1.ColumnResizeService],
    apiFunctions: {
        setColumnWidths: columnResizeApi_1.setColumnWidths,
    },
    dependsOn: [dragModule_1.HorizontalResizeModule, autoWidthModule_1.AutoWidthModule],
};


/***/ }),

/***/ 69677:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColumnResizeService = void 0;
const columnEventUtils_1 = __webpack_require__(72934);
const beanStub_1 = __webpack_require__(68731);
const logging_1 = __webpack_require__(47764);
const groupResizeFeature_1 = __webpack_require__(79033);
const resizeFeature_1 = __webpack_require__(67438);
class ColumnResizeService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'colResize';
    }
    setColumnWidths(columnWidths, shiftKey, // @takeFromAdjacent - if user has 'shift' pressed, then pixels are taken from adjacent column
    finished, // @finished - ends up in the event, tells the user if more events are to come
    source) {
        const sets = [];
        const { colModel, gos, visibleCols } = this.beans;
        columnWidths.forEach((columnWidth) => {
            const col = colModel.getColDefCol(columnWidth.key) || colModel.getCol(columnWidth.key);
            if (!col) {
                return;
            }
            sets.push({
                width: columnWidth.newWidth,
                ratios: [1],
                columns: [col],
            });
            // if user wants to do shift resize by default, then we invert the shift operation
            const defaultIsShift = gos.get('colResizeDefault') === 'shift';
            if (defaultIsShift) {
                shiftKey = !shiftKey;
            }
            if (shiftKey) {
                const otherCol = visibleCols.getColAfter(col);
                if (!otherCol) {
                    return;
                }
                const widthDiff = col.getActualWidth() - columnWidth.newWidth;
                const otherColWidth = otherCol.getActualWidth() + widthDiff;
                sets.push({
                    width: otherColWidth,
                    ratios: [1],
                    columns: [otherCol],
                });
            }
        });
        if (sets.length === 0) {
            return;
        }
        this.resizeColumnSets({
            resizeSets: sets,
            finished,
            source,
        });
    }
    // method takes sets of columns and resizes them. either all sets will be resized, or nothing
    // be resized. this is used for example when user tries to resize a group and holds shift key,
    // then both the current group (grows), and the adjacent group (shrinks), will get resized,
    // so that's two sets for this method.
    resizeColumnSets(params) {
        const { resizeSets, finished, source } = params;
        const passMinMaxCheck = !resizeSets || resizeSets.every((columnResizeSet) => checkMinAndMaxWidthsForSet(columnResizeSet));
        if (!passMinMaxCheck) {
            // even though we are not going to resize beyond min/max size, we still need to dispatch event when finished
            if (finished) {
                const columns = resizeSets && resizeSets.length > 0 ? resizeSets[0].columns : null;
                (0, columnEventUtils_1.dispatchColumnResizedEvent)(this.eventSvc, columns, finished, source);
            }
            return; // don't resize!
        }
        const changedCols = [];
        const allResizedCols = [];
        resizeSets.forEach((set) => {
            const { width, columns, ratios } = set;
            // keep track of pixels used, and last column gets the remaining,
            // to cater for rounding errors, and min width adjustments
            const newWidths = {};
            const finishedCols = {};
            columns.forEach((col) => allResizedCols.push(col));
            // the loop below goes through each col. if a col exceeds it's min/max width,
            // it then gets set to its min/max width and the column is removed marked as 'finished'
            // and the calculation is done again leaving this column out. take for example columns
            // {A, width: 50, maxWidth: 100}
            // {B, width: 50}
            // {C, width: 50}
            // and then the set is set to width 600 - on the first pass the grid tries to set each column
            // to 200. it checks A and sees 200 > 100 and so sets the width to 100. col A is then marked
            // as 'finished' and the calculation is done again with the remaining cols B and C, which end up
            // splitting the remaining 500 pixels.
            let finishedColsGrew = true;
            let loopCount = 0;
            while (finishedColsGrew) {
                loopCount++;
                if (loopCount > 1000) {
                    // this should never happen, but in the future, someone might introduce a bug here,
                    // so we stop the browser from hanging and report bug properly
                    (0, logging_1._error)(31);
                    break;
                }
                finishedColsGrew = false;
                const subsetCols = [];
                let subsetRatioTotal = 0;
                let pixelsToDistribute = width;
                columns.forEach((col, index) => {
                    const thisColFinished = finishedCols[col.getId()];
                    if (thisColFinished) {
                        pixelsToDistribute -= newWidths[col.getId()];
                    }
                    else {
                        subsetCols.push(col);
                        const ratioThisCol = ratios[index];
                        subsetRatioTotal += ratioThisCol;
                    }
                });
                // because we are not using all of the ratios (cols can be missing),
                // we scale the ratio. if all columns are included, then subsetRatioTotal=1,
                // and so the ratioScale will be 1.
                const ratioScale = 1 / subsetRatioTotal;
                subsetCols.forEach((col, index) => {
                    const lastCol = index === subsetCols.length - 1;
                    let colNewWidth;
                    if (lastCol) {
                        colNewWidth = pixelsToDistribute;
                    }
                    else {
                        colNewWidth = Math.round(ratios[index] * width * ratioScale);
                        pixelsToDistribute -= colNewWidth;
                    }
                    const minWidth = col.getMinWidth();
                    const maxWidth = col.getMaxWidth();
                    if (colNewWidth < minWidth) {
                        colNewWidth = minWidth;
                        finishedCols[col.getId()] = true;
                        finishedColsGrew = true;
                    }
                    else if (maxWidth > 0 && colNewWidth > maxWidth) {
                        colNewWidth = maxWidth;
                        finishedCols[col.getId()] = true;
                        finishedColsGrew = true;
                    }
                    newWidths[col.getId()] = colNewWidth;
                });
            }
            columns.forEach((col) => {
                const newWidth = newWidths[col.getId()];
                const actualWidth = col.getActualWidth();
                if (actualWidth !== newWidth) {
                    col.setActualWidth(newWidth, source);
                    changedCols.push(col);
                }
            });
        });
        // if no cols changed, then no need to update more or send event.
        const atLeastOneColChanged = changedCols.length > 0;
        let flexedCols = [];
        if (atLeastOneColChanged) {
            const { colFlex, visibleCols, colViewport } = this.beans;
            flexedCols =
                colFlex?.refreshFlexedColumns({
                    resizingCols: allResizedCols,
                    skipSetLeft: true,
                }) ?? [];
            visibleCols.setLeftValues(source);
            visibleCols.updateBodyWidths();
            colViewport.checkViewportColumns();
        }
        // check for change first, to avoid unnecessary firing of events
        // however we always dispatch 'finished' events. this is important
        // when groups are resized, as if the group is changing slowly,
        // eg 1 pixel at a time, then each change will dispatch change events
        // in all the columns in the group, but only one with get the pixel.
        const colsForEvent = allResizedCols.concat(flexedCols);
        if (atLeastOneColChanged || finished) {
            (0, columnEventUtils_1.dispatchColumnResizedEvent)(this.eventSvc, colsForEvent, finished, source, flexedCols);
        }
    }
    resizeHeader(column, delta, shiftKey) {
        if (!column.isResizable()) {
            return;
        }
        const actualWidth = column.getActualWidth();
        const minWidth = column.getMinWidth();
        const maxWidth = column.getMaxWidth();
        const newWidth = Math.min(Math.max(actualWidth + delta, minWidth), maxWidth);
        this.setColumnWidths([{ key: column, newWidth }], shiftKey, true, 'uiColumnResized');
    }
    createResizeFeature(pinned, column, eResize, comp, ctrl) {
        return new resizeFeature_1.ResizeFeature(pinned, column, eResize, comp, ctrl);
    }
    createGroupResizeFeature(comp, eResize, pinned, columnGroup) {
        return new groupResizeFeature_1.GroupResizeFeature(comp, eResize, pinned, columnGroup);
    }
}
exports.ColumnResizeService = ColumnResizeService;
function checkMinAndMaxWidthsForSet(columnResizeSet) {
    const { columns, width } = columnResizeSet;
    // every col has a min width, so sum them all up and see if we have enough room
    // for all the min widths
    let minWidthAccumulated = 0;
    let maxWidthAccumulated = 0;
    let maxWidthActive = true;
    columns.forEach((col) => {
        const minWidth = col.getMinWidth();
        minWidthAccumulated += minWidth || 0;
        const maxWidth = col.getMaxWidth();
        if (maxWidth > 0) {
            maxWidthAccumulated += maxWidth;
        }
        else {
            // if at least one columns has no max width, it means the group of columns
            // then has no max width, as at least one column can take as much width as possible
            maxWidthActive = false;
        }
    });
    const minWidthPasses = width >= minWidthAccumulated;
    const maxWidthPasses = !maxWidthActive || width <= maxWidthAccumulated;
    return minWidthPasses && maxWidthPasses;
}


/***/ }),

/***/ 79033:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GroupResizeFeature = void 0;
const beanStub_1 = __webpack_require__(68731);
class GroupResizeFeature extends beanStub_1.BeanStub {
    constructor(comp, eResize, pinned, columnGroup) {
        super();
        this.comp = comp;
        this.eResize = eResize;
        this.pinned = pinned;
        this.columnGroup = columnGroup;
    }
    postConstruct() {
        if (!this.columnGroup.isResizable()) {
            this.comp.setResizableDisplayed(false);
            return;
        }
        const { horizontalResizeSvc, gos, colAutosize } = this.beans;
        const finishedWithResizeFunc = horizontalResizeSvc.addResizeBar({
            eResizeBar: this.eResize,
            onResizeStart: this.onResizeStart.bind(this),
            onResizing: this.onResizing.bind(this, false),
            onResizeEnd: this.onResizing.bind(this, true),
        });
        this.addDestroyFunc(finishedWithResizeFunc);
        if (!gos.get('suppressAutoSize') && colAutosize) {
            this.addDestroyFunc(colAutosize.addColumnGroupResize(this.eResize, this.columnGroup, () => this.resizeLeafColumnsToFit('uiColumnResized')));
        }
    }
    onResizeStart(shiftKey) {
        const { columnsToResize, resizeStartWidth, resizeRatios, groupAfterColumns, groupAfterStartWidth, groupAfterRatios, } = this.getInitialValues(shiftKey);
        this.resizeCols = columnsToResize;
        this.resizeStartWidth = resizeStartWidth;
        this.resizeRatios = resizeRatios;
        this.resizeTakeFromCols = groupAfterColumns;
        this.resizeTakeFromStartWidth = groupAfterStartWidth;
        this.resizeTakeFromRatios = groupAfterRatios;
        this.toggleColumnResizing(true);
    }
    onResizing(finished, resizeAmount, source = 'uiColumnResized') {
        const resizeAmountNormalised = this.normaliseDragChange(resizeAmount);
        const width = this.resizeStartWidth + resizeAmountNormalised;
        this.resizeColumnsFromLocalValues(width, source, finished);
    }
    getInitialValues(shiftKey) {
        const getInitialSizeOfColumns = (columns) => columns.reduce((totalWidth, column) => totalWidth + column.getActualWidth(), 0);
        const getSizeRatiosOfColumns = (columns, initialSizeOfColumns) => columns.map((column) => column.getActualWidth() / initialSizeOfColumns);
        const columnsToResize = this.getColumnsToResize();
        const resizeStartWidth = getInitialSizeOfColumns(columnsToResize);
        const resizeRatios = getSizeRatiosOfColumns(columnsToResize, resizeStartWidth);
        const columnSizeAndRatios = {
            columnsToResize,
            resizeStartWidth,
            resizeRatios,
        };
        let groupAfter = null;
        if (shiftKey) {
            groupAfter = this.beans.colGroupSvc?.getGroupAtDirection(this.columnGroup, 'After') ?? null;
        }
        if (groupAfter) {
            const takeFromLeafCols = groupAfter.getDisplayedLeafColumns();
            const groupAfterColumns = (columnSizeAndRatios.groupAfterColumns = takeFromLeafCols.filter((col) => col.isResizable()));
            const groupAfterStartWidth = (columnSizeAndRatios.groupAfterStartWidth =
                getInitialSizeOfColumns(groupAfterColumns));
            columnSizeAndRatios.groupAfterRatios = getSizeRatiosOfColumns(groupAfterColumns, groupAfterStartWidth);
        }
        else {
            columnSizeAndRatios.groupAfterColumns = undefined;
            columnSizeAndRatios.groupAfterStartWidth = undefined;
            columnSizeAndRatios.groupAfterRatios = undefined;
        }
        return columnSizeAndRatios;
    }
    resizeLeafColumnsToFit(source) {
        const preferredSize = this.beans.autoWidthCalc.getPreferredWidthForColumnGroup(this.columnGroup);
        const initialValues = this.getInitialValues();
        if (preferredSize > initialValues.resizeStartWidth) {
            this.resizeColumns(initialValues, preferredSize, source, true);
        }
    }
    resizeColumnsFromLocalValues(totalWidth, source, finished = true) {
        if (!this.resizeCols || !this.resizeRatios) {
            return;
        }
        const initialValues = {
            columnsToResize: this.resizeCols,
            resizeStartWidth: this.resizeStartWidth,
            resizeRatios: this.resizeRatios,
            groupAfterColumns: this.resizeTakeFromCols,
            groupAfterStartWidth: this.resizeTakeFromStartWidth,
            groupAfterRatios: this.resizeTakeFromRatios,
        };
        this.resizeColumns(initialValues, totalWidth, source, finished);
    }
    resizeColumns(initialValues, totalWidth, source, finished = true) {
        const { columnsToResize, resizeStartWidth, resizeRatios, groupAfterColumns, groupAfterStartWidth, groupAfterRatios, } = initialValues;
        const resizeSets = [];
        resizeSets.push({
            columns: columnsToResize,
            ratios: resizeRatios,
            width: totalWidth,
        });
        if (groupAfterColumns) {
            const diff = totalWidth - resizeStartWidth;
            resizeSets.push({
                columns: groupAfterColumns,
                ratios: groupAfterRatios,
                width: groupAfterStartWidth - diff,
            });
        }
        this.beans.colResize?.resizeColumnSets({
            resizeSets,
            finished,
            source: source,
        });
        if (finished) {
            this.toggleColumnResizing(false);
        }
    }
    toggleColumnResizing(resizing) {
        this.comp.toggleCss('ag-column-resizing', resizing);
    }
    getColumnsToResize() {
        const leafCols = this.columnGroup.getDisplayedLeafColumns();
        return leafCols.filter((col) => col.isResizable());
    }
    // optionally inverts the drag, depending on pinned and RTL
    // note - this method is duplicated in RenderedHeaderCell - should refactor out?
    normaliseDragChange(dragChange) {
        let result = dragChange;
        if (this.gos.get('enableRtl')) {
            // for RTL, dragging left makes the col bigger, except when pinning left
            if (this.pinned !== 'left') {
                result *= -1;
            }
        }
        else if (this.pinned === 'right') {
            // for LTR (ie normal), dragging left makes the col smaller, except when pinning right
            result *= -1;
        }
        return result;
    }
    destroy() {
        super.destroy();
        this.resizeCols = undefined;
        this.resizeRatios = undefined;
        this.resizeTakeFromCols = undefined;
        this.resizeTakeFromRatios = undefined;
    }
}
exports.GroupResizeFeature = GroupResizeFeature;


/***/ }),

/***/ 67438:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ResizeFeature = void 0;
const beanStub_1 = __webpack_require__(68731);
const dom_1 = __webpack_require__(33507);
class ResizeFeature extends beanStub_1.BeanStub {
    constructor(pinned, column, eResize, comp, ctrl) {
        super();
        this.pinned = pinned;
        this.column = column;
        this.eResize = eResize;
        this.comp = comp;
        this.ctrl = ctrl;
    }
    postConstruct() {
        const destroyResizeFuncs = [];
        let canResize;
        let canAutosize;
        const addResize = () => {
            (0, dom_1._setDisplayed)(this.eResize, canResize);
            if (!canResize) {
                return;
            }
            const { horizontalResizeSvc, colAutosize } = this.beans;
            const finishedWithResizeFunc = horizontalResizeSvc.addResizeBar({
                eResizeBar: this.eResize,
                onResizeStart: this.onResizeStart.bind(this),
                onResizing: this.onResizing.bind(this, false),
                onResizeEnd: this.onResizing.bind(this, true),
            });
            destroyResizeFuncs.push(finishedWithResizeFunc);
            if (canAutosize && colAutosize) {
                destroyResizeFuncs.push(colAutosize.addColumnAutosize(this.eResize, this.column));
            }
        };
        const removeResize = () => {
            destroyResizeFuncs.forEach((f) => f());
            destroyResizeFuncs.length = 0;
        };
        const refresh = () => {
            const resize = this.column.isResizable();
            const autoSize = !this.gos.get('suppressAutoSize') && !this.column.getColDef().suppressAutoSize;
            const propertyChange = resize !== canResize || autoSize !== canAutosize;
            if (propertyChange) {
                canResize = resize;
                canAutosize = autoSize;
                removeResize();
                addResize();
            }
        };
        refresh();
        this.addDestroyFunc(removeResize);
        this.ctrl.setRefreshFunction('resize', refresh);
    }
    onResizing(finished, resizeAmount) {
        const { column: key, lastResizeAmount, resizeStartWidth, beans } = this;
        const resizeAmountNormalised = this.normaliseResizeAmount(resizeAmount);
        const newWidth = resizeStartWidth + resizeAmountNormalised;
        const columnWidths = [{ key, newWidth }];
        const { pinnedCols, ctrlsSvc, colResize } = beans;
        if (this.column.getPinned()) {
            const leftWidth = pinnedCols?.leftWidth ?? 0;
            const rightWidth = pinnedCols?.rightWidth ?? 0;
            const bodyWidth = (0, dom_1._getInnerWidth)(ctrlsSvc.getGridBodyCtrl().eBodyViewport) - 50;
            if (leftWidth + rightWidth + (resizeAmountNormalised - lastResizeAmount) > bodyWidth) {
                return;
            }
        }
        this.lastResizeAmount = resizeAmountNormalised;
        colResize?.setColumnWidths(columnWidths, this.resizeWithShiftKey, finished, 'uiColumnResized');
        if (finished) {
            this.toggleColumnResizing(false);
        }
    }
    onResizeStart(shiftKey) {
        this.resizeStartWidth = this.column.getActualWidth();
        this.lastResizeAmount = 0;
        this.resizeWithShiftKey = shiftKey;
        this.toggleColumnResizing(true);
    }
    toggleColumnResizing(resizing) {
        this.comp.toggleCss('ag-column-resizing', resizing);
    }
    // optionally inverts the drag, depending on pinned and RTL
    // note - this method is duplicated in RenderedHeaderGroupCell - should refactor out?
    normaliseResizeAmount(dragChange) {
        let result = dragChange;
        const notPinningLeft = this.pinned !== 'left';
        const pinningRight = this.pinned === 'right';
        if (this.gos.get('enableRtl')) {
            // for RTL, dragging left makes the col bigger, except when pinning left
            if (notPinningLeft) {
                result *= -1;
            }
        }
        else {
            // for LTR (ie normal), dragging left makes the col smaller, except when pinning right
            if (pinningRight) {
                result *= -1;
            }
        }
        return result;
    }
}
exports.ResizeFeature = ResizeFeature;


/***/ }),

/***/ 73600:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseColsService = void 0;
const beanStub_1 = __webpack_require__(68731);
const array_1 = __webpack_require__(31502);
const generic_1 = __webpack_require__(34422);
const columnEventUtils_1 = __webpack_require__(72934);
class BaseColsService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.dispatchColumnChangedEvent = columnEventUtils_1.dispatchColumnChangedEvent;
        this.columns = [];
        this.columnIndexMap = {};
        this.updateIndexMap = () => {
            this.columnIndexMap = {};
            this.columns.forEach((col, index) => (this.columnIndexMap[col.getId()] = index));
        };
    }
    wireBeans(beans) {
        this.colModel = beans.colModel;
        this.aggFuncSvc = beans.aggFuncSvc;
        this.visibleCols = beans.visibleCols;
    }
    sortColumns(compareFn) {
        this.columns.sort(compareFn);
        this.updateIndexMap();
    }
    setColumns(colKeys, source) {
        this.setColList(colKeys, this.columns, this.eventName, true, true, this.columnProcessors.set, source);
    }
    addColumns(colKeys, source) {
        this.updateColList(colKeys, this.columns, true, true, this.columnProcessors.add, this.eventName, source);
    }
    removeColumns(colKeys, source) {
        this.updateColList(colKeys, this.columns, false, true, this.columnProcessors.remove, this.eventName, source);
    }
    getColumnIndex(colId) {
        return this.columnIndexMap[colId];
    }
    setColList(colKeys = [], masterList, eventName, detectOrderChange, autoGroupsNeedBuilding, columnCallback, source) {
        const gridColumns = this.colModel.getCols();
        if (!gridColumns || gridColumns.length === 0) {
            return;
        }
        const changes = new Map();
        // store all original cols and their index.
        masterList.forEach((col, idx) => changes.set(col, idx));
        masterList.length = 0;
        if ((0, generic_1._exists)(colKeys)) {
            colKeys.forEach((key) => {
                const column = this.colModel.getColDefCol(key);
                if (column) {
                    masterList.push(column);
                }
            });
        }
        masterList.forEach((col, idx) => {
            const oldIndex = changes.get(col);
            // if the column was not in the list, we add it as it's a change
            // idx is irrelevant now.
            if (oldIndex === undefined) {
                changes.set(col, 0);
                return;
            }
            if (detectOrderChange && oldIndex !== idx) {
                // if we're detecting order changes, and the indexes differ, we retain this as it's changed
                return;
            }
            // otherwise remove this col, as it's unchanged.
            changes.delete(col);
        });
        this.updateIndexMap();
        const primaryCols = this.colModel.getColDefCols();
        (primaryCols || []).forEach((column) => {
            const added = masterList.indexOf(column) >= 0;
            columnCallback(column, added, source);
        });
        autoGroupsNeedBuilding && this.colModel.refreshCols(false);
        this.visibleCols.refresh(source);
        this.dispatchColumnChangedEvent(this.eventSvc, eventName, [...changes.keys()], source);
    }
    updateColList(keys = [], masterList, actionIsAdd, autoGroupsNeedBuilding, columnCallback, eventType, source) {
        if (!keys || keys.length === 0) {
            return;
        }
        let atLeastOne = false;
        const updatedCols = new Set();
        keys.forEach((key) => {
            if (!key) {
                return;
            }
            const columnToAdd = this.colModel.getColDefCol(key);
            if (!columnToAdd) {
                return;
            }
            updatedCols.add(columnToAdd);
            if (actionIsAdd) {
                if (masterList.indexOf(columnToAdd) >= 0) {
                    return;
                }
                masterList.push(columnToAdd);
            }
            else {
                const currentIndex = masterList.indexOf(columnToAdd);
                if (currentIndex < 0) {
                    return;
                }
                for (let i = currentIndex + 1; i < masterList.length; i++) {
                    // row indexes of subsequent columns have changed
                    updatedCols.add(masterList[i]);
                }
                (0, array_1._removeFromArray)(masterList, columnToAdd);
            }
            columnCallback(columnToAdd, actionIsAdd, source);
            atLeastOne = true;
        });
        if (!atLeastOne) {
            return;
        }
        this.updateIndexMap();
        if (autoGroupsNeedBuilding) {
            this.colModel.refreshCols(false);
        }
        this.visibleCols.refresh(source);
        const eventColumns = Array.from(updatedCols);
        this.eventSvc.dispatchEvent({
            type: eventType,
            columns: eventColumns,
            column: eventColumns.length === 1 ? eventColumns[0] : null,
            source,
        });
    }
    extractCols(source, oldProvidedCols = []) {
        const previousCols = this.columns;
        const colsWithIndex = [];
        const colsWithValue = [];
        const { setFlagFunc, getIndexFunc, getInitialIndexFunc, getValueFunc, getInitialValueFunc } = this.columnExtractors;
        const primaryCols = this.colModel.getColDefCols() || [];
        // go though all cols.
        // if value, change
        // if default only, change only if new
        primaryCols.forEach((col) => {
            const colIsNew = oldProvidedCols.indexOf(col) < 0;
            const colDef = col.getColDef();
            const value = getValueFunc(colDef);
            const initialValue = getInitialValueFunc(colDef);
            const index = getIndexFunc(colDef);
            const initialIndex = getInitialIndexFunc(colDef);
            let include;
            const valuePresent = value !== undefined;
            const indexPresent = index !== undefined;
            const initialValuePresent = initialValue !== undefined;
            const initialIndexPresent = initialIndex !== undefined;
            if (valuePresent) {
                include = value; // boolean value is guaranteed as attrToBoolean() is used above
            }
            else if (indexPresent) {
                if (index === null) {
                    // if col is new we don't want to use the default / initial if index is set to null. Similarly,
                    // we don't want to include the property for existing columns, i.e. we want to 'clear' it.
                    include = false;
                }
                else {
                    // note that 'null >= 0' evaluates to true which means 'rowGroupIndex = null' would enable row
                    // grouping if the null check didn't exist above.
                    include = index >= 0;
                }
            }
            else {
                if (colIsNew) {
                    // as no value or index is 'present' we use the default / initial when col is new
                    if (initialValuePresent) {
                        include = initialValue;
                    }
                    else if (initialIndexPresent) {
                        include = initialIndex != null && initialIndex >= 0;
                    }
                    else {
                        include = false;
                    }
                }
                else {
                    // otherwise include it if included last time, e.g. if we are extracting row group cols and this col
                    // is an existing row group col (i.e. it exists in 'previousCols') then we should include it.
                    include = previousCols.indexOf(col) >= 0;
                }
            }
            if (include) {
                const useIndex = colIsNew ? index != null || initialIndex != null : index != null;
                useIndex ? colsWithIndex.push(col) : colsWithValue.push(col);
            }
        });
        const getIndexForCol = (col) => {
            const index = getIndexFunc(col.getColDef());
            const defaultIndex = getInitialIndexFunc(col.getColDef());
            return index != null ? index : defaultIndex;
        };
        // sort cols with index, and add these first
        colsWithIndex.sort((colA, colB) => {
            const indexA = getIndexForCol(colA);
            const indexB = getIndexForCol(colB);
            if (indexA === indexB) {
                return 0;
            }
            if (indexA < indexB) {
                return -1;
            }
            return 1;
        });
        const res = [].concat(colsWithIndex);
        // second add columns that were there before and in the same order as they were before,
        // so we are preserving order of current grouping of columns that simply have rowGroup=true
        previousCols.forEach((col) => {
            if (colsWithValue.indexOf(col) >= 0) {
                res.push(col);
            }
        });
        // lastly put in all remaining cols
        colsWithValue.forEach((col) => {
            if (res.indexOf(col) < 0) {
                res.push(col);
            }
        });
        // set flag=false for removed cols
        previousCols.forEach((col) => {
            if (res.indexOf(col) < 0) {
                setFlagFunc(col, false, source);
            }
        });
        // set flag=true for newly added cols
        res.forEach((col) => {
            if (previousCols.indexOf(col) < 0) {
                setFlagFunc(col, true, source);
            }
        });
        this.columns = res;
        this.updateIndexMap();
        return this.columns;
    }
    restoreColumnOrder(columnStateAccumulator, incomingColumnState) {
        const colList = this.columns;
        const primaryCols = this.colModel.getColDefCols();
        if (!colList.length || !primaryCols) {
            return columnStateAccumulator;
        }
        const updatedColIdArray = Object.keys(incomingColumnState);
        const updatedColIds = new Set(updatedColIdArray);
        const newColIds = new Set(updatedColIdArray);
        const allColIds = new Set(colList
            .map((column) => {
            const colId = column.getColId();
            newColIds.delete(colId);
            return colId;
        })
            .concat(updatedColIdArray));
        const colIdsInOriginalOrder = [];
        const originalOrderMap = {};
        let orderIndex = 0;
        for (let i = 0; i < primaryCols.length; i++) {
            const colId = primaryCols[i].getColId();
            if (allColIds.has(colId)) {
                colIdsInOriginalOrder.push(colId);
                originalOrderMap[colId] = orderIndex++;
            }
        }
        // follow approach in `resetColumnState`
        let index = 1000;
        let hasAddedNewCols = false;
        let lastIndex = 0;
        const enableProp = this.columnOrdering.enableProp;
        const initialEnableProp = this.columnOrdering.initialEnableProp;
        const indexProp = this.columnOrdering.indexProp;
        const initialIndexProp = this.columnOrdering.initialIndexProp;
        const processPrecedingNewCols = (colId) => {
            const originalOrderIndex = originalOrderMap[colId];
            for (let i = lastIndex; i < originalOrderIndex; i++) {
                const newColId = colIdsInOriginalOrder[i];
                if (newColIds.has(newColId)) {
                    incomingColumnState[newColId][indexProp] = index++;
                    newColIds.delete(newColId);
                }
            }
            lastIndex = originalOrderIndex;
        };
        colList.forEach((column) => {
            const colId = column.getColId();
            if (updatedColIds.has(colId)) {
                // New col already exists. Add any other new cols that should be before it.
                processPrecedingNewCols(colId);
                incomingColumnState[colId][indexProp] = index++;
            }
            else {
                const colDef = column.getColDef();
                const missingIndex = colDef[indexProp] === null || (colDef[indexProp] === undefined && colDef[initialIndexProp] == null);
                if (missingIndex) {
                    if (!hasAddedNewCols) {
                        const propEnabled = colDef[enableProp] || (colDef[enableProp] === undefined && colDef[initialEnableProp]);
                        if (propEnabled) {
                            processPrecedingNewCols(colId);
                        }
                        else {
                            // Reached the first manually added column. Add all the new columns now.
                            newColIds.forEach((newColId) => {
                                // Rather than increment the index, just use the original order index - doesn't need to be contiguous.
                                incomingColumnState[newColId][indexProp] = index + originalOrderMap[newColId];
                            });
                            index += colIdsInOriginalOrder.length;
                            hasAddedNewCols = true;
                        }
                    }
                    if (!columnStateAccumulator[colId]) {
                        columnStateAccumulator[colId] = { colId };
                    }
                    columnStateAccumulator[colId][indexProp] = index++;
                }
            }
        });
        return columnStateAccumulator;
    }
}
exports.BaseColsService = BaseColsService;


/***/ }),

/***/ 68763:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAllDisplayedVirtualColumns = exports.getAllDisplayedColumns = exports.getDisplayedRightColumns = exports.getDisplayedCenterColumns = exports.getDisplayedLeftColumns = exports.getAllGridColumns = exports.setColumnsPinned = exports.setColumnsVisible = exports.getDisplayedColBefore = exports.getDisplayedColAfter = exports.isPinningRight = exports.isPinningLeft = exports.isPinning = exports.resetColumnState = exports.getColumnState = exports.applyColumnState = exports.getColumns = exports.getColumn = exports.getDisplayNameForColumn = exports.getColumnDefs = exports.getColumnDef = void 0;
const columnStateUtils_1 = __webpack_require__(2885);
function getColumnDef(beans, key) {
    const column = beans.colModel.getColDefCol(key);
    if (column) {
        return column.getColDef();
    }
    return null;
}
exports.getColumnDef = getColumnDef;
function getColumnDefs(beans) {
    return beans.colModel.getColumnDefs();
}
exports.getColumnDefs = getColumnDefs;
function getDisplayNameForColumn(beans, column, location) {
    return beans.colNames.getDisplayNameForColumn(column, location) || '';
}
exports.getDisplayNameForColumn = getDisplayNameForColumn;
function getColumn(beans, key) {
    return beans.colModel.getColDefCol(key);
}
exports.getColumn = getColumn;
function getColumns(beans) {
    return beans.colModel.getColDefCols();
}
exports.getColumns = getColumns;
function applyColumnState(beans, params) {
    return (0, columnStateUtils_1._applyColumnState)(beans, params, 'api');
}
exports.applyColumnState = applyColumnState;
function getColumnState(beans) {
    return (0, columnStateUtils_1._getColumnState)(beans);
}
exports.getColumnState = getColumnState;
function resetColumnState(beans) {
    (0, columnStateUtils_1._resetColumnState)(beans, 'api');
}
exports.resetColumnState = resetColumnState;
function isPinning(beans) {
    return beans.visibleCols.isPinningLeft() || beans.visibleCols.isPinningRight();
}
exports.isPinning = isPinning;
function isPinningLeft(beans) {
    return beans.visibleCols.isPinningLeft();
}
exports.isPinningLeft = isPinningLeft;
function isPinningRight(beans) {
    return beans.visibleCols.isPinningRight();
}
exports.isPinningRight = isPinningRight;
function getDisplayedColAfter(beans, col) {
    return beans.visibleCols.getColAfter(col);
}
exports.getDisplayedColAfter = getDisplayedColAfter;
function getDisplayedColBefore(beans, col) {
    return beans.visibleCols.getColBefore(col);
}
exports.getDisplayedColBefore = getDisplayedColBefore;
function setColumnsVisible(beans, keys, visible) {
    beans.colModel.setColsVisible(keys, visible, 'api');
}
exports.setColumnsVisible = setColumnsVisible;
function setColumnsPinned(beans, keys, pinned) {
    beans.pinnedCols?.setColsPinned(keys, pinned, 'api');
}
exports.setColumnsPinned = setColumnsPinned;
function getAllGridColumns(beans) {
    return beans.colModel.getCols();
}
exports.getAllGridColumns = getAllGridColumns;
function getDisplayedLeftColumns(beans) {
    return beans.visibleCols.leftCols;
}
exports.getDisplayedLeftColumns = getDisplayedLeftColumns;
function getDisplayedCenterColumns(beans) {
    return beans.visibleCols.centerCols;
}
exports.getDisplayedCenterColumns = getDisplayedCenterColumns;
function getDisplayedRightColumns(beans) {
    return beans.visibleCols.rightCols;
}
exports.getDisplayedRightColumns = getDisplayedRightColumns;
function getAllDisplayedColumns(beans) {
    return beans.visibleCols.allCols;
}
exports.getAllDisplayedColumns = getAllDisplayedColumns;
function getAllDisplayedVirtualColumns(beans) {
    return beans.colViewport.getViewportColumns();
}
exports.getAllDisplayedVirtualColumns = getAllDisplayedVirtualColumns;


/***/ }),

/***/ 44604:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColumnDefFactory = exports._deepCloneDefinition = void 0;
const beanStub_1 = __webpack_require__(68731);
const object_1 = __webpack_require__(6996);
// returns copy of an object, doing a deep clone of any objects with that object.
// this is used for eg creating copies of Column Definitions, where we want to
// deep copy all objects, but do not want to deep copy functions (eg when user provides
// a function or class for colDef.cellRenderer)
function _deepCloneDefinition(object, keysToSkip) {
    if (!object) {
        return;
    }
    const obj = object;
    const res = {};
    Object.keys(obj).forEach((key) => {
        if ((keysToSkip && keysToSkip.indexOf(key) >= 0) || object_1.SKIP_JS_BUILTINS.has(key)) {
            return;
        }
        const value = obj[key];
        // 'simple object' means a bunch of key/value pairs, eg {filter: 'myFilter'}. it does
        // NOT include the following:
        // 1) arrays
        // 2) functions or classes (eg api instance)
        const sourceIsSimpleObject = typeof value === 'object' && value !== null && value.constructor === Object;
        if (sourceIsSimpleObject) {
            res[key] = _deepCloneDefinition(value);
        }
        else {
            res[key] = value;
        }
    });
    return res;
}
exports._deepCloneDefinition = _deepCloneDefinition;
class ColumnDefFactory extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'colDefFactory';
    }
    wireBeans(beans) {
        this.rowGroupColsSvc = beans.rowGroupColsSvc;
        this.pivotColsSvc = beans.pivotColsSvc;
    }
    getColumnDefs(colDefColsList, showingPivotResult, lastOrder, colsList) {
        const cols = colDefColsList.slice();
        if (showingPivotResult) {
            cols.sort((a, b) => lastOrder.indexOf(a) - lastOrder.indexOf(b));
        }
        else if (lastOrder) {
            cols.sort((a, b) => colsList.indexOf(a) - colsList.indexOf(b));
        }
        const rowGroupColumns = this.rowGroupColsSvc?.columns;
        const pivotColumns = this.pivotColsSvc?.columns;
        return this.buildColumnDefs(cols, rowGroupColumns, pivotColumns);
    }
    buildColumnDefs(cols, rowGroupColumns = [], pivotColumns = []) {
        const res = [];
        const colGroupDefs = {};
        cols.forEach((col) => {
            const colDef = this.createDefFromColumn(col, rowGroupColumns, pivotColumns);
            let addToResult = true;
            let childDef = colDef;
            let pointer = col.getOriginalParent();
            let lastPointer = null;
            while (pointer) {
                let parentDef = null;
                // we don't include padding groups, as the column groups provided
                // by application didn't have these. the whole point of padding groups
                // is to balance the column tree that the user provided.
                if (pointer.isPadding()) {
                    pointer = pointer.getOriginalParent();
                    continue;
                }
                // if colDef for this group already exists, use it
                const existingParentDef = colGroupDefs[pointer.getGroupId()];
                if (existingParentDef) {
                    existingParentDef.children.push(childDef);
                    // if we added to result, it would be the second time we did it
                    addToResult = false;
                    // we don't want to continue up the tree, as it has already been
                    // done for this group
                    break;
                }
                parentDef = this.createDefFromGroup(pointer);
                if (parentDef) {
                    parentDef.children = [childDef];
                    colGroupDefs[parentDef.groupId] = parentDef;
                    childDef = parentDef;
                    pointer = pointer.getOriginalParent();
                }
                if (pointer != null && lastPointer === pointer) {
                    addToResult = false;
                    break;
                }
                // Ensure we don't get stuck in an infinite loop
                lastPointer = pointer;
            }
            if (addToResult) {
                res.push(childDef);
            }
        });
        return res;
    }
    createDefFromGroup(group) {
        const defCloned = _deepCloneDefinition(group.getColGroupDef(), ['children']);
        if (defCloned) {
            defCloned.groupId = group.getGroupId();
        }
        return defCloned;
    }
    createDefFromColumn(col, rowGroupColumns, pivotColumns) {
        const colDefCloned = _deepCloneDefinition(col.getColDef());
        colDefCloned.colId = col.getColId();
        colDefCloned.width = col.getActualWidth();
        colDefCloned.rowGroup = col.isRowGroupActive();
        colDefCloned.rowGroupIndex = col.isRowGroupActive() ? rowGroupColumns.indexOf(col) : null;
        colDefCloned.pivot = col.isPivotActive();
        colDefCloned.pivotIndex = col.isPivotActive() ? pivotColumns.indexOf(col) : null;
        colDefCloned.aggFunc = col.isValueActive() ? col.getAggFunc() : null;
        colDefCloned.hide = col.isVisible() ? undefined : true;
        colDefCloned.pinned = col.isPinned() ? col.getPinned() : null;
        colDefCloned.sort = col.getSort() ? col.getSort() : null;
        colDefCloned.sortIndex = col.getSortIndex() != null ? col.getSortIndex() : null;
        return colDefCloned;
    }
}
exports.ColumnDefFactory = ColumnDefFactory;


/***/ }),

/***/ 72934:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dispatchColumnResizedEvent = exports.dispatchColumnChangedEvent = exports.dispatchColumnVisibleEvent = exports.dispatchColumnPinnedEvent = void 0;
function getCommonValue(cols, valueGetter) {
    if (!cols || cols.length == 0) {
        return undefined;
    }
    // compare each value to the first value. if nothing differs, then value is common so return it.
    const firstValue = valueGetter(cols[0]);
    for (let i = 1; i < cols.length; i++) {
        if (firstValue !== valueGetter(cols[i])) {
            // values differ, no common value
            return undefined;
        }
    }
    return firstValue;
}
function dispatchColumnPinnedEvent(eventSvc, changedColumns, source) {
    if (!changedColumns.length) {
        return;
    }
    // if just one column, we use this, otherwise we don't include the col
    const column = changedColumns.length === 1 ? changedColumns[0] : null;
    // only include pinned if it's common in all columns
    const pinned = getCommonValue(changedColumns, (col) => col.getPinned());
    eventSvc.dispatchEvent({
        type: 'columnPinned',
        // mistake in typing, 'undefined' should be allowed, as 'null' means 'not pinned'
        pinned: pinned != null ? pinned : null,
        columns: changedColumns,
        column,
        source,
    });
}
exports.dispatchColumnPinnedEvent = dispatchColumnPinnedEvent;
function dispatchColumnVisibleEvent(eventSvc, changedColumns, source) {
    if (!changedColumns.length) {
        return;
    }
    // if just one column, we use this, otherwise we don't include the col
    const column = changedColumns.length === 1 ? changedColumns[0] : null;
    // only include visible if it's common in all columns
    const visible = getCommonValue(changedColumns, (col) => col.isVisible());
    eventSvc.dispatchEvent({
        type: 'columnVisible',
        visible,
        columns: changedColumns,
        column,
        source,
    });
}
exports.dispatchColumnVisibleEvent = dispatchColumnVisibleEvent;
function dispatchColumnChangedEvent(eventSvc, type, columns, source) {
    eventSvc.dispatchEvent({
        type,
        columns,
        column: columns && columns.length == 1 ? columns[0] : null,
        source,
    });
}
exports.dispatchColumnChangedEvent = dispatchColumnChangedEvent;
function dispatchColumnResizedEvent(eventSvc, columns, finished, source, flexColumns = null) {
    if (columns?.length) {
        eventSvc.dispatchEvent({
            type: 'columnResized',
            columns,
            column: columns.length === 1 ? columns[0] : null,
            flexColumns,
            finished,
            source,
        });
    }
}
exports.dispatchColumnResizedEvent = dispatchColumnResizedEvent;


/***/ }),

/***/ 82716:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.depthFirstOriginalTreeSearch = exports._addColumnDefaultAndTypes = exports._updateColumnState = exports.updateSomeColumnState = exports._recursivelyCreateColumns = exports._createColumnTree = exports._createColumnTreeWithIds = void 0;
const agColumn_1 = __webpack_require__(13355);
const agProvidedColumnGroup_1 = __webpack_require__(79409);
const defaultColumnTypes_1 = __webpack_require__(35449);
const gridOptionsUtils_1 = __webpack_require__(67274);
const object_1 = __webpack_require__(6996);
const logging_1 = __webpack_require__(47764);
const columnGroupUtils_1 = __webpack_require__(70820);
const columnKeyCreator_1 = __webpack_require__(2294);
const columnUtils_1 = __webpack_require__(73146);
/**
 * A performant approach to _createColumnTree where the function assumes all defs have an ID.
 * Used for Pivoting.
 */
function _createColumnTreeWithIds(beans, defs = null, primaryColumns, existingTree, source) {
    const { existingCols, existingGroups } = extractExistingTreeData(existingTree);
    const colIdMap = new Map(existingCols.map((col) => [col.getId(), col]));
    const colGroupIdMap = new Map(existingGroups.map((group) => [group.getId(), group]));
    let maxDepth = 0;
    const recursivelyProcessColDef = (def, level) => {
        maxDepth = Math.max(maxDepth, level);
        if (isColumnGroupDef(def)) {
            if (!beans.colGroupSvc) {
                return null;
            }
            const groupId = def.groupId;
            const group = colGroupIdMap.get(groupId);
            const colGroupDef = (0, columnGroupUtils_1.createMergedColGroupDef)(beans, def, groupId);
            const newGroup = new agProvidedColumnGroup_1.AgProvidedColumnGroup(colGroupDef, groupId, false, level);
            beans.context.createBean(newGroup);
            if (group) {
                newGroup.setExpanded(group.isExpanded());
            }
            newGroup.setChildren(def.children.map((child) => recursivelyProcessColDef(child, level + 1)));
            return newGroup;
        }
        const colId = def.colId;
        let column = colIdMap.get(colId);
        if (!column) {
            // no existing column, need to create one
            const colDefMerged = _addColumnDefaultAndTypes(beans, def, colId);
            column = new agColumn_1.AgColumn(colDefMerged, def, colId, primaryColumns);
            beans.context.createBean(column);
        }
        else {
            const colDefMerged = _addColumnDefaultAndTypes(beans, def, column.getColId());
            column.setColDef(colDefMerged, def, source);
            _updateColumnState(beans, column, colDefMerged, source);
        }
        beans.dataTypeSvc?.addColumnListeners(column);
        return column;
    };
    const root = defs?.map((def) => recursivelyProcessColDef(def, 0)) ?? [];
    let counter = 0;
    const keyCreator = {
        getUniqueKey: (_colId, _field) => String(++counter),
    };
    const columnTree = beans.colGroupSvc ? beans.colGroupSvc.balanceColumnTree(root, 0, maxDepth, keyCreator) : root;
    const depthFirstCallback = (child, parent) => {
        if ((0, agProvidedColumnGroup_1.isProvidedColumnGroup)(child)) {
            child.setupExpandable();
        }
        // we set the original parents at the end, rather than when we go along, as balancing the tree
        // adds extra levels into the tree. so we can only set parents when balancing is done.
        child.originalParent = parent;
    };
    depthFirstOriginalTreeSearch(null, columnTree, depthFirstCallback);
    return {
        columnTree,
        treeDepth: maxDepth,
    };
}
exports._createColumnTreeWithIds = _createColumnTreeWithIds;
function _createColumnTree(beans, defs = null, primaryColumns, existingTree, source) {
    // column key creator dishes out unique column id's in a deterministic way,
    // so if we have two grids (that could be master/slave) with same column definitions,
    // then this ensures the two grids use identical id's.
    const columnKeyCreator = new columnKeyCreator_1.ColumnKeyCreator();
    const { existingCols, existingGroups, existingColKeys } = extractExistingTreeData(existingTree);
    columnKeyCreator.addExistingKeys(existingColKeys);
    // create am unbalanced tree that maps the provided definitions
    const unbalancedTree = _recursivelyCreateColumns(beans, defs, 0, primaryColumns, existingCols, columnKeyCreator, existingGroups, source);
    const { colGroupSvc } = beans;
    const treeDepth = colGroupSvc?.findMaxDepth(unbalancedTree, 0) ?? 0;
    const columnTree = colGroupSvc
        ? colGroupSvc.balanceColumnTree(unbalancedTree, 0, treeDepth, columnKeyCreator)
        : unbalancedTree;
    const depthFirstCallback = (child, parent) => {
        if ((0, agProvidedColumnGroup_1.isProvidedColumnGroup)(child)) {
            child.setupExpandable();
        }
        // we set the original parents at the end, rather than when we go along, as balancing the tree
        // adds extra levels into the tree. so we can only set parents when balancing is done.
        child.originalParent = parent;
    };
    depthFirstOriginalTreeSearch(null, columnTree, depthFirstCallback);
    return {
        columnTree,
        treeDepth,
    };
}
exports._createColumnTree = _createColumnTree;
function extractExistingTreeData(existingTree) {
    const existingCols = [];
    const existingGroups = [];
    const existingColKeys = [];
    if (existingTree) {
        depthFirstOriginalTreeSearch(null, existingTree, (item) => {
            if ((0, agProvidedColumnGroup_1.isProvidedColumnGroup)(item)) {
                const group = item;
                existingGroups.push(group);
            }
            else {
                const col = item;
                existingColKeys.push(col.getId());
                existingCols.push(col);
            }
        });
    }
    return { existingCols, existingGroups, existingColKeys };
}
function _recursivelyCreateColumns(beans, defs, level, primaryColumns, existingColsCopy, columnKeyCreator, existingGroups, source) {
    if (!defs)
        return [];
    const { colGroupSvc } = beans;
    const result = new Array(defs.length);
    for (let i = 0; i < result.length; i++) {
        const def = defs[i];
        if (colGroupSvc && isColumnGroupDef(def)) {
            result[i] = colGroupSvc.createProvidedColumnGroup(primaryColumns, def, level, existingColsCopy, columnKeyCreator, existingGroups, source);
        }
        else {
            result[i] = createColumn(beans, primaryColumns, def, existingColsCopy, columnKeyCreator, source);
        }
    }
    return result;
}
exports._recursivelyCreateColumns = _recursivelyCreateColumns;
function createColumn(beans, primaryColumns, colDef, existingColsCopy, columnKeyCreator, source) {
    // see if column already exists
    const existingColAndIndex = findExistingColumn(colDef, existingColsCopy);
    // make sure we remove, so if user provided duplicate id, then we don't have more than
    // one column instance for colDef with common id
    if (existingColAndIndex) {
        existingColsCopy?.splice(existingColAndIndex.idx, 1);
    }
    let column = existingColAndIndex?.column;
    if (!column) {
        // no existing column, need to create one
        const colId = columnKeyCreator.getUniqueKey(colDef.colId, colDef.field);
        const colDefMerged = _addColumnDefaultAndTypes(beans, colDef, colId);
        column = new agColumn_1.AgColumn(colDefMerged, colDef, colId, primaryColumns);
        beans.context.createBean(column);
    }
    else {
        const colDefMerged = _addColumnDefaultAndTypes(beans, colDef, column.getColId());
        column.setColDef(colDefMerged, colDef, source);
        _updateColumnState(beans, column, colDefMerged, source);
    }
    beans.dataTypeSvc?.addColumnListeners(column);
    return column;
}
/** Updates hide, sort, sortIndex, pinned and flex */
function updateSomeColumnState(beans, column, hide, sort, sortIndex, pinned, flex, source) {
    const { sortSvc, pinnedCols, colFlex } = beans;
    // hide - anything but undefined, thus null will clear the hide
    if (hide !== undefined) {
        column.setVisible(!hide, source);
    }
    if (sortSvc) {
        // sort - anything but undefined will set sort, thus null or empty string will clear the sort
        sortSvc.updateColSort(column, sort, source);
        // sorted at - anything but undefined, thus null will clear the sortIndex
        if (sortIndex !== undefined) {
            sortSvc.setColSortIndex(column, sortIndex);
        }
    }
    // pinned - anything but undefined, thus null or empty string will remove pinned
    if (pinned !== undefined) {
        pinnedCols?.setColPinned(column, pinned);
    }
    // flex
    if (flex !== undefined) {
        colFlex?.setColFlex(column, flex);
    }
}
exports.updateSomeColumnState = updateSomeColumnState;
function _updateColumnState(beans, column, colDef, source) {
    updateSomeColumnState(beans, column, colDef.hide, colDef.sort, colDef.sortIndex, colDef.pinned, colDef.flex, source);
    const colFlex = column.getFlex();
    // width - we only set width if column is not flexing
    if (colFlex != null && colFlex > 0) {
        return;
    }
    // both null and undefined means we skip, as it's not possible to 'clear' width (a column must have a width)
    if (colDef.width != null) {
        column.setActualWidth(colDef.width, source);
    }
    else {
        // otherwise set the width again, in case min or max width has changed,
        // and width needs to be adjusted.
        const widthBeforeUpdate = column.getActualWidth();
        column.setActualWidth(widthBeforeUpdate, source);
    }
}
exports._updateColumnState = _updateColumnState;
function findExistingColumn(newColDef, existingColsCopy) {
    if (!existingColsCopy)
        return undefined;
    for (let i = 0; i < existingColsCopy.length; i++) {
        const def = existingColsCopy[i].getUserProvidedColDef();
        if (!def)
            continue;
        const newHasId = newColDef.colId != null;
        if (newHasId) {
            if (existingColsCopy[i].getId() === newColDef.colId) {
                return { idx: i, column: existingColsCopy[i] };
            }
            continue;
        }
        const newHasField = newColDef.field != null;
        if (newHasField) {
            if (def.field === newColDef.field) {
                return { idx: i, column: existingColsCopy[i] };
            }
            continue;
        }
        if (def === newColDef) {
            return { idx: i, column: existingColsCopy[i] };
        }
    }
    return undefined;
}
function _addColumnDefaultAndTypes(beans, colDef, colId, isAutoCol) {
    const { gos, dataTypeSvc } = beans;
    // start with empty merged definition
    const res = {};
    // merge properties from default column definitions
    const defaultColDef = gos.get('defaultColDef');
    (0, object_1._mergeDeep)(res, defaultColDef, false, true);
    const columnType = updateColDefAndGetColumnType(beans, res, colDef, colId);
    if (columnType) {
        assignColumnTypes(beans, columnType, res);
    }
    // merge properties from column definitions
    (0, object_1._mergeDeep)(res, colDef, false, true);
    const autoGroupColDef = gos.get('autoGroupColumnDef');
    const isSortingCoupled = (0, gridOptionsUtils_1._isColumnsSortingCoupledToGroup)(gos);
    if (colDef.rowGroup && autoGroupColDef && isSortingCoupled) {
        // override the sort for row group columns where the autoGroupColDef defines these values.
        (0, object_1._mergeDeep)(res, { sort: autoGroupColDef.sort, initialSort: autoGroupColDef.initialSort }, false, true);
    }
    if (dataTypeSvc) {
        dataTypeSvc.postProcess(res);
        dataTypeSvc.validateColDef(res);
    }
    gos.validateColDef(res, colId, isAutoCol);
    return res;
}
exports._addColumnDefaultAndTypes = _addColumnDefaultAndTypes;
function updateColDefAndGetColumnType(beans, colDef, userColDef, colId) {
    const dataTypeDefinitionColumnType = beans.dataTypeSvc?.updateColDefAndGetColumnType(colDef, userColDef, colId);
    const columnTypes = userColDef.type ?? dataTypeDefinitionColumnType ?? colDef.type;
    colDef.type = columnTypes;
    return columnTypes ? (0, columnUtils_1.convertColumnTypes)(columnTypes) : undefined;
}
function assignColumnTypes(beans, typeKeys, colDefMerged) {
    if (!typeKeys.length) {
        return;
    }
    // merge user defined with default column types
    const allColumnTypes = Object.assign({}, defaultColumnTypes_1.DefaultColumnTypes);
    const userTypes = beans.gos.get('columnTypes') || {};
    for (const key of Object.keys(userTypes)) {
        const value = userTypes[key];
        if (key in allColumnTypes) {
            // default column types cannot be overridden
            (0, logging_1._warn)(34, { key });
        }
        else {
            const colType = value;
            if (colType.type) {
                // type should not be defined in column types
                (0, logging_1._warn)(35);
            }
            allColumnTypes[key] = value;
        }
    }
    typeKeys.forEach((t) => {
        const typeColDef = allColumnTypes[t.trim()];
        if (typeColDef) {
            (0, object_1._mergeDeep)(colDefMerged, typeColDef, false, true);
        }
        else {
            (0, logging_1._warn)(36, { t });
        }
    });
}
// if object has children, we assume it's a group
function isColumnGroupDef(abstractColDef) {
    return abstractColDef.children !== undefined;
}
function depthFirstOriginalTreeSearch(parent, tree, callback) {
    if (!tree) {
        return;
    }
    for (let i = 0; i < tree.length; i++) {
        const child = tree[i];
        if ((0, agProvidedColumnGroup_1.isProvidedColumnGroup)(child)) {
            depthFirstOriginalTreeSearch(child, child.getChildren(), callback);
        }
        callback(child, parent);
    }
}
exports.depthFirstOriginalTreeSearch = depthFirstOriginalTreeSearch;


/***/ }),

/***/ 82849:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColumnFlexService = void 0;
const beanStub_1 = __webpack_require__(68731);
const columnEventUtils_1 = __webpack_require__(72934);
class ColumnFlexService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'colFlex';
    }
    refreshFlexedColumns(params = {}) {
        const source = params.source ?? 'flex';
        if (params.viewportWidth != null) {
            this.flexViewportWidth = params.viewportWidth;
        }
        const totalSpace = this.flexViewportWidth;
        if (!totalSpace) {
            return [];
        }
        const { visibleCols } = this.beans;
        const visibleCenterCols = visibleCols.centerCols;
        let flexAfterDisplayIndex = -1;
        if (params.resizingCols) {
            const allResizingCols = new Set(params.resizingCols);
            // find the last resizing col, as only cols after this one are affected by the resizing
            for (let i = visibleCenterCols.length - 1; i >= 0; i--) {
                if (allResizingCols.has(visibleCenterCols[i])) {
                    flexAfterDisplayIndex = i;
                    break;
                }
            }
        }
        // NOTE this is an implementation of the "Resolve Flexible Lengths" part
        // of the flex spec, simplified because we only support flex growing not
        // shrinking, and don't support flex-basis.
        // https://www.w3.org/TR/css-flexbox-1/#resolve-flexible-lengths
        let hasFlexItems = false;
        const items = visibleCenterCols.map((col, i) => {
            const flex = col.getFlex();
            const isFlex = flex != null && flex > 0 && i > flexAfterDisplayIndex;
            hasFlexItems || (hasFlexItems = isFlex);
            return {
                col,
                isFlex,
                flex: Math.max(0, flex ?? 0),
                initialSize: col.getActualWidth(),
                min: col.getMinWidth(),
                max: col.getMaxWidth(),
                targetSize: 0,
            };
        });
        if (!hasFlexItems) {
            return [];
        }
        let unfrozenItemCount = items.length;
        let unfrozenFlex = items.reduce((acc, item) => acc + item.flex, 0);
        let unfrozenSpace = totalSpace;
        const freeze = (item, width) => {
            item.frozenSize = width;
            item.col.setActualWidth(width, source);
            unfrozenSpace -= width;
            unfrozenFlex -= item.flex;
            unfrozenItemCount -= 1;
        };
        const isFrozen = (item) => item.frozenSize != null;
        // Freeze inflexible columns
        for (const item of items) {
            if (!item.isFlex) {
                freeze(item, item.initialSize);
            }
        }
        // a. Check for flexible items. If all the flex items on the line are
        // frozen, free space has been distributed; exit this loop.
        while (unfrozenItemCount > 0) {
            // b. Calculate the remaining free space as for initial free space,
            // above. If the sum of the unfrozen flex items flex factors is
            // less than one, multiply the initial free space by this sum.
            const spaceToFill = Math.round(unfrozenFlex < 1 ? unfrozenSpace * unfrozenFlex : unfrozenSpace);
            // c. Distribute free space proportional to the flex factors.
            let lastUnfrozenItem;
            let actualLeft = 0;
            let idealRight = 0;
            for (const item of items) {
                if (isFrozen(item)) {
                    continue;
                }
                lastUnfrozenItem = item;
                idealRight += spaceToFill * (item.flex / unfrozenFlex);
                const idealSize = idealRight - actualLeft;
                const roundedSize = Math.round(idealSize);
                item.targetSize = roundedSize;
                actualLeft += roundedSize;
            }
            if (lastUnfrozenItem) {
                // Correct cumulative rounding errors: adjust the size of the
                // last item to fill any remaining space
                lastUnfrozenItem.targetSize += spaceToFill - actualLeft;
            }
            // d. Fix min/max violations. Clamp each non-frozen items target
            // main size by its used min and max main sizes... If the items
            // target main size was made smaller by this, its a max violation.
            // If the items target main size was made larger by this, its a
            // min violation.
            let totalViolation = 0;
            for (const item of items) {
                if (isFrozen(item)) {
                    continue;
                }
                const unclampedSize = item.targetSize;
                const clampedSize = Math.min(Math.max(unclampedSize, item.min), item.max);
                totalViolation += clampedSize - unclampedSize;
                item.violationType =
                    clampedSize === unclampedSize ? undefined : clampedSize < unclampedSize ? 'max' : 'min';
                item.targetSize = clampedSize;
            }
            // e. Freeze over-flexed items. The total violation is the sum of
            // the adjustments from the previous step.
            // If the total violation is:
            //     - Zero, Freeze all items
            //     - Positive, Freeze all the items with min violations
            //     - Negative, Freeze all the items with max violations
            const freezeType = totalViolation === 0 ? 'all' : totalViolation > 0 ? 'min' : 'max';
            for (const item of items) {
                if (isFrozen(item)) {
                    continue;
                }
                if (freezeType === 'all' || item.violationType === freezeType) {
                    freeze(item, item.targetSize);
                }
            }
        }
        if (!params.skipSetLeft) {
            visibleCols.setLeftValues(source);
        }
        if (params.updateBodyWidths) {
            visibleCols.updateBodyWidths();
        }
        const unconstrainedFlexColumns = items
            .filter((item) => item.isFlex && !item.violationType)
            .map((item) => item.col);
        if (params.fireResizedEvent) {
            const changedColumns = items.filter((item) => item.initialSize !== item.frozenSize).map((item) => item.col);
            const flexingColumns = items.filter((item) => item.flex).map((item) => item.col);
            (0, columnEventUtils_1.dispatchColumnResizedEvent)(this.eventSvc, changedColumns, true, source, flexingColumns);
        }
        return unconstrainedFlexColumns;
    }
    initCol(column) {
        const { flex, initialFlex } = column.colDef;
        if (flex !== undefined) {
            column.flex = flex;
        }
        else if (initialFlex !== undefined) {
            column.flex = initialFlex;
        }
    }
    // this method should only be used by the colModel to
    // change flex when required by the applyColumnState method.
    setColFlex(column, flex) {
        column.flex = flex ?? null;
        column.dispatchStateUpdatedEvent('flex');
    }
}
exports.ColumnFlexService = ColumnFlexService;


/***/ }),

/***/ 66641:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAllDisplayedColumnGroups = exports.getRightDisplayedColumnGroups = exports.getCenterDisplayedColumnGroups = exports.getLeftDisplayedColumnGroups = exports.resetColumnGroupState = exports.setColumnGroupState = exports.getColumnGroupState = exports.getDisplayNameForColumnGroup = exports.getProvidedColumnGroup = exports.getColumnGroup = exports.setColumnGroupOpened = void 0;
function setColumnGroupOpened(beans, group, newValue) {
    beans.colGroupSvc?.setColumnGroupOpened(group, newValue, 'api');
}
exports.setColumnGroupOpened = setColumnGroupOpened;
function getColumnGroup(beans, name, instanceId) {
    return beans.colGroupSvc?.getColumnGroup(name, instanceId) ?? null;
}
exports.getColumnGroup = getColumnGroup;
function getProvidedColumnGroup(beans, name) {
    return beans.colGroupSvc?.getProvidedColGroup(name) ?? null;
}
exports.getProvidedColumnGroup = getProvidedColumnGroup;
function getDisplayNameForColumnGroup(beans, columnGroup, location) {
    return beans.colNames.getDisplayNameForColumnGroup(columnGroup, location) || '';
}
exports.getDisplayNameForColumnGroup = getDisplayNameForColumnGroup;
function getColumnGroupState(beans) {
    return beans.colGroupSvc?.getColumnGroupState() ?? [];
}
exports.getColumnGroupState = getColumnGroupState;
function setColumnGroupState(beans, stateItems) {
    beans.colGroupSvc?.setColumnGroupState(stateItems, 'api');
}
exports.setColumnGroupState = setColumnGroupState;
function resetColumnGroupState(beans) {
    beans.colGroupSvc?.resetColumnGroupState('api');
}
exports.resetColumnGroupState = resetColumnGroupState;
function getLeftDisplayedColumnGroups(beans) {
    return beans.visibleCols.treeLeft;
}
exports.getLeftDisplayedColumnGroups = getLeftDisplayedColumnGroups;
function getCenterDisplayedColumnGroups(beans) {
    return beans.visibleCols.treeCenter;
}
exports.getCenterDisplayedColumnGroups = getCenterDisplayedColumnGroups;
function getRightDisplayedColumnGroups(beans) {
    return beans.visibleCols.treeRight;
}
exports.getRightDisplayedColumnGroups = getRightDisplayedColumnGroups;
function getAllDisplayedColumnGroups(beans) {
    return beans.visibleCols.getAllTrees();
}
exports.getAllDisplayedColumnGroups = getAllDisplayedColumnGroups;


/***/ }),

/***/ 66041:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColumnGroupModule = void 0;
const headerGroupCellCtrl_1 = __webpack_require__(60084);
const version_1 = __webpack_require__(97205);
const columnGroupApi_1 = __webpack_require__(66641);
const columnGroupService_1 = __webpack_require__(66266);
/**
 * @feature Columns -> Column Groups
 * @colGroupDef
 */
exports.ColumnGroupModule = {
    moduleName: 'ColumnGroup',
    version: version_1.VERSION,
    dynamicBeans: { headerGroupCellCtrl: headerGroupCellCtrl_1.HeaderGroupCellCtrl },
    beans: [columnGroupService_1.ColumnGroupService],
    apiFunctions: {
        getAllDisplayedColumnGroups: columnGroupApi_1.getAllDisplayedColumnGroups,
        getCenterDisplayedColumnGroups: columnGroupApi_1.getCenterDisplayedColumnGroups,
        getColumnGroup: columnGroupApi_1.getColumnGroup,
        getColumnGroupState: columnGroupApi_1.getColumnGroupState,
        getDisplayNameForColumnGroup: columnGroupApi_1.getDisplayNameForColumnGroup,
        getLeftDisplayedColumnGroups: columnGroupApi_1.getLeftDisplayedColumnGroups,
        getProvidedColumnGroup: columnGroupApi_1.getProvidedColumnGroup,
        getRightDisplayedColumnGroups: columnGroupApi_1.getRightDisplayedColumnGroups,
        resetColumnGroupState: columnGroupApi_1.resetColumnGroupState,
        setColumnGroupOpened: columnGroupApi_1.setColumnGroupOpened,
        setColumnGroupState: columnGroupApi_1.setColumnGroupState,
    },
};


/***/ }),

/***/ 66266:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColumnGroupService = void 0;
const beanStub_1 = __webpack_require__(68731);
const agColumnGroup_1 = __webpack_require__(56908);
const agColumnGroup_2 = __webpack_require__(56908);
const agProvidedColumnGroup_1 = __webpack_require__(79409);
const agProvidedColumnGroup_2 = __webpack_require__(79409);
const array_1 = __webpack_require__(31502);
const generic_1 = __webpack_require__(34422);
const columnFactoryUtils_1 = __webpack_require__(82716);
const visibleColsService_1 = __webpack_require__(6869);
const columnGroupUtils_1 = __webpack_require__(70820);
class ColumnGroupService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'colGroupSvc';
    }
    getColumnGroupState() {
        const columnGroupState = [];
        const gridBalancedTree = this.beans.colModel.getColTree();
        (0, columnFactoryUtils_1.depthFirstOriginalTreeSearch)(null, gridBalancedTree, (node) => {
            if ((0, agProvidedColumnGroup_2.isProvidedColumnGroup)(node)) {
                columnGroupState.push({
                    groupId: node.getGroupId(),
                    open: node.isExpanded(),
                });
            }
        });
        return columnGroupState;
    }
    resetColumnGroupState(source) {
        const primaryColumnTree = this.beans.colModel.getColDefColTree();
        if (!primaryColumnTree) {
            return;
        }
        const stateItems = [];
        (0, columnFactoryUtils_1.depthFirstOriginalTreeSearch)(null, primaryColumnTree, (child) => {
            if ((0, agProvidedColumnGroup_2.isProvidedColumnGroup)(child)) {
                const colGroupDef = child.getColGroupDef();
                const groupState = {
                    groupId: child.getGroupId(),
                    open: !colGroupDef ? undefined : colGroupDef.openByDefault,
                };
                stateItems.push(groupState);
            }
        });
        this.setColumnGroupState(stateItems, source);
    }
    setColumnGroupState(stateItems, source) {
        const { colModel, colAnimation, visibleCols, eventSvc } = this.beans;
        const gridBalancedTree = colModel.getColTree();
        if (!gridBalancedTree.length) {
            return;
        }
        colAnimation?.start();
        const impactedGroups = [];
        stateItems.forEach((stateItem) => {
            const groupKey = stateItem.groupId;
            const newValue = stateItem.open;
            const providedColumnGroup = this.getProvidedColGroup(groupKey);
            if (!providedColumnGroup) {
                return;
            }
            if (providedColumnGroup.isExpanded() === newValue) {
                return;
            }
            providedColumnGroup.setExpanded(newValue);
            impactedGroups.push(providedColumnGroup);
        });
        visibleCols.refresh(source, true);
        if (impactedGroups.length) {
            eventSvc.dispatchEvent({
                type: 'columnGroupOpened',
                columnGroup: impactedGroups.length === 1 ? impactedGroups[0] : undefined,
                columnGroups: impactedGroups,
            });
        }
        colAnimation?.finish();
    }
    // called by headerRenderer - when a header is opened or closed
    setColumnGroupOpened(key, newValue, source) {
        let keyAsString;
        if ((0, agProvidedColumnGroup_2.isProvidedColumnGroup)(key)) {
            keyAsString = key.getId();
        }
        else {
            keyAsString = key || '';
        }
        this.setColumnGroupState([{ groupId: keyAsString, open: newValue }], source);
    }
    getProvidedColGroup(key) {
        let res = null;
        (0, columnFactoryUtils_1.depthFirstOriginalTreeSearch)(null, this.beans.colModel.getColTree(), (node) => {
            if ((0, agProvidedColumnGroup_2.isProvidedColumnGroup)(node)) {
                if (node.getId() === key) {
                    res = node;
                }
            }
        });
        return res;
    }
    getGroupAtDirection(columnGroup, direction) {
        // pick the last displayed column in this group
        const requiredLevel = columnGroup.getProvidedColumnGroup().getLevel() + columnGroup.getPaddingLevel();
        const colGroupLeafColumns = columnGroup.getDisplayedLeafColumns();
        const col = direction === 'After' ? (0, array_1._last)(colGroupLeafColumns) : colGroupLeafColumns[0];
        const getDisplayColMethod = `getCol${direction}`;
        while (true) {
            // keep moving to the next col, until we get to another group
            const column = this.beans.visibleCols[getDisplayColMethod](col);
            if (!column) {
                return null;
            }
            const groupPointer = this.getColGroupAtLevel(column, requiredLevel);
            if (groupPointer !== columnGroup) {
                return groupPointer;
            }
        }
    }
    getColGroupAtLevel(column, level) {
        // get group at same level as the one we are looking for
        let groupPointer = column.getParent();
        let originalGroupLevel;
        let groupPointerLevel;
        while (true) {
            const groupPointerProvidedColumnGroup = groupPointer.getProvidedColumnGroup();
            originalGroupLevel = groupPointerProvidedColumnGroup.getLevel();
            groupPointerLevel = groupPointer.getPaddingLevel();
            if (originalGroupLevel + groupPointerLevel <= level) {
                break;
            }
            groupPointer = groupPointer.getParent();
        }
        return groupPointer;
    }
    updateOpenClosedVisibility() {
        const allColumnGroups = this.beans.visibleCols.getAllTrees();
        (0, visibleColsService_1.depthFirstAllColumnTreeSearch)(allColumnGroups, false, (child) => {
            if ((0, agColumnGroup_1.isColumnGroup)(child)) {
                child.calculateDisplayedColumns();
            }
        });
    }
    // returns the group with matching colId and instanceId. If instanceId is missing,
    // matches only on the colId.
    getColumnGroup(colId, partId) {
        if (!colId) {
            return null;
        }
        if ((0, agColumnGroup_1.isColumnGroup)(colId)) {
            return colId;
        }
        const allColumnGroups = this.beans.visibleCols.getAllTrees();
        const checkPartId = typeof partId === 'number';
        let result = null;
        (0, visibleColsService_1.depthFirstAllColumnTreeSearch)(allColumnGroups, false, (child) => {
            if ((0, agColumnGroup_1.isColumnGroup)(child)) {
                const columnGroup = child;
                let matched;
                if (checkPartId) {
                    matched = colId === columnGroup.getGroupId() && partId === columnGroup.getPartId();
                }
                else {
                    matched = colId === columnGroup.getGroupId();
                }
                if (matched) {
                    result = columnGroup;
                }
            }
        });
        return result;
    }
    createColumnGroups(params) {
        const { columns, idCreator, pinned, oldDisplayedGroups, isStandaloneStructure } = params;
        const oldColumnsMapped = this.mapOldGroupsById(oldDisplayedGroups);
        /**
         * The following logic starts at the leaf level of columns, iterating through them to build their parent
         * groups when the parents match.
         *
         * The created groups are then added to an array, and similarly iterated on until we reach the top level.
         *
         * When row groups have no original parent, it's added to the result.
         */
        const topLevelResultCols = [];
        // this is an array of cols or col groups at one level of depth, starting from leaf and ending at root
        let groupsOrColsAtCurrentLevel = columns;
        while (groupsOrColsAtCurrentLevel.length) {
            // store what's currently iterating so the function can build the next level of col groups
            const currentlyIterating = groupsOrColsAtCurrentLevel;
            groupsOrColsAtCurrentLevel = [];
            // store the index of the last row which was different from the previous row, this is used as a slice
            // index for finding the children to group together
            let lastGroupedColIdx = 0;
            // create a group of children from lastGroupedColIdx to the provided `to` parameter
            const createGroupToIndex = (to) => {
                const from = lastGroupedColIdx;
                lastGroupedColIdx = to;
                const previousNode = currentlyIterating[from];
                const previousNodeProvided = (0, agColumnGroup_1.isColumnGroup)(previousNode)
                    ? previousNode.getProvidedColumnGroup()
                    : previousNode;
                const previousNodeParent = previousNodeProvided.getOriginalParent();
                if (previousNodeParent == null) {
                    // if the last node was different, and had a null parent, then we add all the nodes to the final
                    // results)
                    for (let i = from; i < to; i++) {
                        topLevelResultCols.push(currentlyIterating[i]);
                    }
                    return;
                }
                // the parent differs from the previous node, so we create a group from the previous node
                // and add all to the result array, except the current node.
                const newGroup = this.createColumnGroup(previousNodeParent, idCreator, oldColumnsMapped, pinned, isStandaloneStructure);
                for (let i = from; i < to; i++) {
                    newGroup.addChild(currentlyIterating[i]);
                }
                groupsOrColsAtCurrentLevel.push(newGroup);
            };
            for (let i = 1; i < currentlyIterating.length; i++) {
                const thisNode = currentlyIterating[i];
                const thisNodeProvided = (0, agColumnGroup_1.isColumnGroup)(thisNode) ? thisNode.getProvidedColumnGroup() : thisNode;
                const thisNodeParent = thisNodeProvided.getOriginalParent();
                const previousNode = currentlyIterating[lastGroupedColIdx];
                const previousNodeProvided = (0, agColumnGroup_1.isColumnGroup)(previousNode)
                    ? previousNode.getProvidedColumnGroup()
                    : previousNode;
                const previousNodeParent = previousNodeProvided.getOriginalParent();
                if (thisNodeParent !== previousNodeParent) {
                    createGroupToIndex(i);
                }
            }
            if (lastGroupedColIdx < currentlyIterating.length) {
                createGroupToIndex(currentlyIterating.length);
            }
        }
        if (!isStandaloneStructure) {
            this.setupParentsIntoCols(topLevelResultCols, null);
        }
        return topLevelResultCols;
    }
    createProvidedColumnGroup(primaryColumns, colGroupDef, level, existingColumns, columnKeyCreator, existingGroups, source) {
        const groupId = columnKeyCreator.getUniqueKey(colGroupDef.groupId || null, null);
        const colGroupDefMerged = (0, columnGroupUtils_1.createMergedColGroupDef)(this.beans, colGroupDef, groupId);
        const providedGroup = new agProvidedColumnGroup_1.AgProvidedColumnGroup(colGroupDefMerged, groupId, false, level);
        this.createBean(providedGroup);
        const existingGroupAndIndex = this.findExistingGroup(colGroupDef, existingGroups);
        // make sure we remove, so if user provided duplicate id, then we don't have more than
        // one column instance for colDef with common id
        if (existingGroupAndIndex) {
            existingGroups.splice(existingGroupAndIndex.idx, 1);
        }
        const existingGroup = existingGroupAndIndex?.group;
        if (existingGroup) {
            providedGroup.setExpanded(existingGroup.isExpanded());
        }
        const children = (0, columnFactoryUtils_1._recursivelyCreateColumns)(this.beans, colGroupDefMerged.children, level + 1, primaryColumns, existingColumns, columnKeyCreator, existingGroups, source);
        providedGroup.setChildren(children);
        return providedGroup;
    }
    balanceColumnTree(unbalancedTree, currentDepth, columnDepth, columnKeyCreator) {
        const result = [];
        // go through each child, for groups, recurse a level deeper,
        // for columns we need to pad
        for (let i = 0; i < unbalancedTree.length; i++) {
            const child = unbalancedTree[i];
            if ((0, agProvidedColumnGroup_2.isProvidedColumnGroup)(child)) {
                // child is a group, all we do is go to the next level of recursion
                const originalGroup = child;
                const newChildren = this.balanceColumnTree(originalGroup.getChildren(), currentDepth + 1, columnDepth, columnKeyCreator);
                originalGroup.setChildren(newChildren);
                result.push(originalGroup);
            }
            else {
                // child is a column - so here we add in the padded column groups if needed
                let firstPaddedGroup;
                let currentPaddedGroup;
                // this for loop will NOT run any loops if no padded column groups are needed
                for (let j = columnDepth - 1; j >= currentDepth; j--) {
                    const newColId = columnKeyCreator.getUniqueKey(null, null);
                    const colGroupDefMerged = (0, columnGroupUtils_1.createMergedColGroupDef)(this.beans, null, newColId);
                    const paddedGroup = new agProvidedColumnGroup_1.AgProvidedColumnGroup(colGroupDefMerged, newColId, true, currentDepth);
                    this.createBean(paddedGroup);
                    if (currentPaddedGroup) {
                        currentPaddedGroup.setChildren([paddedGroup]);
                    }
                    currentPaddedGroup = paddedGroup;
                    if (!firstPaddedGroup) {
                        firstPaddedGroup = currentPaddedGroup;
                    }
                }
                // likewise this if statement will not run if no padded groups
                if (firstPaddedGroup && currentPaddedGroup) {
                    result.push(firstPaddedGroup);
                    const hasGroups = unbalancedTree.some((leaf) => (0, agProvidedColumnGroup_2.isProvidedColumnGroup)(leaf));
                    if (hasGroups) {
                        currentPaddedGroup.setChildren([child]);
                        continue;
                    }
                    else {
                        currentPaddedGroup.setChildren(unbalancedTree);
                        break;
                    }
                }
                result.push(child);
            }
        }
        return result;
    }
    findDepth(balancedColumnTree) {
        let depth = 0;
        let pointer = balancedColumnTree;
        while (pointer && pointer[0] && (0, agProvidedColumnGroup_2.isProvidedColumnGroup)(pointer[0])) {
            depth++;
            pointer = pointer[0].getChildren();
        }
        return depth;
    }
    findMaxDepth(treeChildren, depth) {
        let maxDepthThisLevel = depth;
        for (let i = 0; i < treeChildren.length; i++) {
            const abstractColumn = treeChildren[i];
            if ((0, agProvidedColumnGroup_2.isProvidedColumnGroup)(abstractColumn)) {
                const originalGroup = abstractColumn;
                const newDepth = this.findMaxDepth(originalGroup.getChildren(), depth + 1);
                if (maxDepthThisLevel < newDepth) {
                    maxDepthThisLevel = newDepth;
                }
            }
        }
        return maxDepthThisLevel;
    }
    /**
     * Inserts dummy group columns in the hierarchy above auto-generated columns
     * in order to ensure auto-generated columns are leaf nodes (and therefore are
     * displayed correctly)
     */
    balanceTreeForAutoCols(autoCols, depth) {
        const tree = [];
        autoCols.forEach((col) => {
            // at the end, this will be the top of the tree item.
            let nextChild = col;
            for (let i = depth - 1; i >= 0; i--) {
                const autoGroup = new agProvidedColumnGroup_1.AgProvidedColumnGroup(null, `FAKE_PATH_${col.getId()}}_${i}`, true, i);
                this.createBean(autoGroup);
                autoGroup.setChildren([nextChild]);
                nextChild.originalParent = autoGroup;
                nextChild = autoGroup;
            }
            if (depth === 0) {
                col.originalParent = null;
            }
            // at this point, the nextChild is the top most item in the tree
            tree.push(nextChild);
        });
        return tree;
    }
    findExistingGroup(newGroupDef, existingGroups) {
        const newHasId = newGroupDef.groupId != null;
        if (!newHasId) {
            return undefined;
        }
        for (let i = 0; i < existingGroups.length; i++) {
            const existingGroup = existingGroups[i];
            const existingDef = existingGroup.getColGroupDef();
            if (!existingDef) {
                continue;
            }
            if (existingGroup.getId() === newGroupDef.groupId) {
                return { idx: i, group: existingGroup };
            }
        }
        return undefined;
    }
    createColumnGroup(providedGroup, groupInstanceIdCreator, oldColumnsMapped, pinned, isStandaloneStructure) {
        const groupId = providedGroup.getGroupId();
        const instanceId = groupInstanceIdCreator.getInstanceIdForKey(groupId);
        const uniqueId = (0, agColumnGroup_1.createUniqueColumnGroupId)(groupId, instanceId);
        let columnGroup = oldColumnsMapped[uniqueId];
        // if the user is setting new colDefs, it is possible that the id's overlap, and we
        // would have a false match from above. so we double check we are talking about the
        // same original column group.
        if (columnGroup && columnGroup.getProvidedColumnGroup() !== providedGroup) {
            columnGroup = null;
        }
        if ((0, generic_1._exists)(columnGroup)) {
            // clean out the old column group here, as we will be adding children into it again
            columnGroup.reset();
        }
        else {
            columnGroup = new agColumnGroup_2.AgColumnGroup(providedGroup, groupId, instanceId, pinned);
            if (!isStandaloneStructure) {
                this.createBean(columnGroup);
            }
        }
        return columnGroup;
    }
    // returns back a 2d map of ColumnGroup as follows: groupId -> instanceId -> ColumnGroup
    mapOldGroupsById(displayedGroups) {
        const result = {};
        const recursive = (columnsOrGroups) => {
            columnsOrGroups.forEach((columnOrGroup) => {
                if ((0, agColumnGroup_1.isColumnGroup)(columnOrGroup)) {
                    const columnGroup = columnOrGroup;
                    result[columnOrGroup.getUniqueId()] = columnGroup;
                    recursive(columnGroup.getChildren());
                }
            });
        };
        if (displayedGroups) {
            recursive(displayedGroups);
        }
        return result;
    }
    setupParentsIntoCols(columnsOrGroups, parent) {
        columnsOrGroups.forEach((columnsOrGroup) => {
            columnsOrGroup.parent = parent;
            if ((0, agColumnGroup_1.isColumnGroup)(columnsOrGroup)) {
                const columnGroup = columnsOrGroup;
                this.setupParentsIntoCols(columnGroup.getChildren(), columnGroup);
            }
        });
    }
}
exports.ColumnGroupService = ColumnGroupService;


/***/ }),

/***/ 70820:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createMergedColGroupDef = void 0;
function createMergedColGroupDef(beans, colGroupDef, groupId) {
    const colGroupDefMerged = {};
    const gos = beans.gos;
    Object.assign(colGroupDefMerged, gos.get('defaultColGroupDef'));
    Object.assign(colGroupDefMerged, colGroupDef);
    gos.validateColDef(colGroupDefMerged, groupId);
    return colGroupDefMerged;
}
exports.createMergedColGroupDef = createMergedColGroupDef;


/***/ }),

/***/ 3156:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isColumnHovered = void 0;
function isColumnHovered(beans, column) {
    return !!beans.colHover?.isHovered(column);
}
exports.isColumnHovered = isColumnHovered;


/***/ }),

/***/ 41690:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColumnHoverModule = void 0;
const version_1 = __webpack_require__(97205);
const columnHoverApi_1 = __webpack_require__(3156);
const columnHoverService_1 = __webpack_require__(57683);
/**
 * @feature Rows -> Styling Rows
 * @gridOption columnHoverHighlight
 */
exports.ColumnHoverModule = {
    moduleName: 'ColumnHover',
    version: version_1.VERSION,
    beans: [columnHoverService_1.ColumnHoverService],
    apiFunctions: {
        isColumnHovered: columnHoverApi_1.isColumnHovered,
    },
};


/***/ }),

/***/ 57683:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColumnHoverService = void 0;
const beanStub_1 = __webpack_require__(68731);
const hoverFeature_1 = __webpack_require__(75788);
const CSS_COLUMN_HOVER = 'ag-column-hover';
class ColumnHoverService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'colHover';
    }
    postConstruct() {
        this.addManagedPropertyListener('columnHoverHighlight', ({ currentValue }) => {
            if (!currentValue) {
                this.clearMouseOver();
            }
        });
    }
    setMouseOver(columns) {
        this.updateState(columns);
    }
    clearMouseOver() {
        this.updateState(null);
    }
    isHovered(column) {
        if (!this.gos.get('columnHoverHighlight')) {
            return false;
        }
        const selectedColumns = this.selectedColumns;
        return !!selectedColumns && selectedColumns.indexOf(column) >= 0;
    }
    addHeaderColumnHoverListener(compBean, comp, column) {
        const listener = () => {
            const isHovered = this.isHovered(column);
            comp.toggleCss('ag-column-hover', isHovered);
        };
        compBean.addManagedEventListeners({ columnHoverChanged: listener });
        listener();
    }
    onCellColumnHover(column, cellComp) {
        if (!cellComp) {
            return;
        }
        const isHovered = this.isHovered(column);
        cellComp.toggleCss(CSS_COLUMN_HOVER, isHovered);
    }
    addHeaderFilterColumnHoverListener(compBean, comp, column, eGui) {
        this.createHoverFeature(compBean, [column], eGui);
        const listener = () => {
            const hovered = this.isHovered(column);
            comp.toggleCss('ag-column-hover', hovered);
        };
        compBean.addManagedEventListeners({ columnHoverChanged: listener });
        listener();
    }
    createHoverFeature(compBean, columns, eGui) {
        compBean.createManagedBean(new hoverFeature_1.HoverFeature(columns, eGui));
    }
    updateState(columns) {
        this.selectedColumns = columns;
        this.eventSvc.dispatchEvent({
            type: 'columnHoverChanged',
        });
    }
}
exports.ColumnHoverService = ColumnHoverService;


/***/ }),

/***/ 75788:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HoverFeature = void 0;
const beanStub_1 = __webpack_require__(68731);
class HoverFeature extends beanStub_1.BeanStub {
    constructor(columns, element) {
        super();
        this.columns = columns;
        this.element = element;
        this.destroyManagedListeners = [];
        this.enableFeature = (enabled) => {
            const { beans, gos, element, columns } = this;
            const colHover = beans.colHover;
            const active = enabled ?? !!gos.get('columnHoverHighlight');
            if (active) {
                this.destroyManagedListeners = this.addManagedElementListeners(element, {
                    mouseover: colHover.setMouseOver.bind(colHover, columns),
                    mouseout: colHover.clearMouseOver.bind(colHover),
                });
            }
            else {
                this.destroyManagedListeners.forEach((fn) => fn());
                this.destroyManagedListeners = [];
            }
        };
    }
    postConstruct() {
        this.addManagedPropertyListener('columnHoverHighlight', ({ currentValue }) => {
            this.enableFeature(currentValue);
        });
        this.enableFeature();
    }
    destroy() {
        super.destroy();
        this.destroyManagedListeners = null;
    }
}
exports.HoverFeature = HoverFeature;


/***/ }),

/***/ 2294:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColumnKeyCreator = void 0;
// class returns a unique id to use for the column. it checks the existing columns, and if the requested
// id is already taken, it will start appending numbers until it gets a unique id.
// eg, if the col field is 'name', it will try ids: {name, name_1, name_2...}
// if no field or id provided in the col, it will try the ids of natural numbers
const generic_1 = __webpack_require__(34422);
const logging_1 = __webpack_require__(47764);
class ColumnKeyCreator {
    constructor() {
        this.existingKeys = {};
    }
    addExistingKeys(keys) {
        for (let i = 0; i < keys.length; i++) {
            this.existingKeys[keys[i]] = true;
        }
    }
    getUniqueKey(colId, colField) {
        // in case user passed in number for colId, convert to string
        colId = (0, generic_1._toStringOrNull)(colId);
        let count = 0;
        while (true) {
            let idToTry = colId ?? colField;
            if (idToTry) {
                if (count !== 0) {
                    idToTry += '_' + count;
                }
            }
            else {
                // no point in stringing this, object treats it the same anyway.
                idToTry = count;
            }
            if (!this.existingKeys[idToTry]) {
                const usedId = String(idToTry);
                if (colId && count > 0) {
                    (0, logging_1._warn)(273, { providedId: colId, usedId });
                }
                this.existingKeys[usedId] = true;
                return usedId;
            }
            count++;
        }
    }
}
exports.ColumnKeyCreator = ColumnKeyCreator;


/***/ }),

/***/ 72986:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColumnModel = void 0;
const columnMoveUtils_1 = __webpack_require__(23505);
const beanStub_1 = __webpack_require__(68731);
const agColumn_1 = __webpack_require__(13355);
const gridOptionsUtils_1 = __webpack_require__(67274);
const array_1 = __webpack_require__(31502);
const columnFactoryUtils_1 = __webpack_require__(82716);
const columnStateUtils_1 = __webpack_require__(2885);
const columnUtils_1 = __webpack_require__(73146);
class ColumnModel extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'colModel';
        // if pivotMode is on, however pivot results are NOT shown if no pivot columns are set
        this.pivotMode = false;
        this.ready = false;
        this.changeEventsDispatching = false;
    }
    postConstruct() {
        this.pivotMode = this.gos.get('pivotMode');
        this.addManagedPropertyListeners(['groupDisplayType', 'treeData', 'treeDataDisplayType', 'groupHideOpenParents'], (event) => this.refreshAll((0, columnUtils_1._convertColumnEventSourceType)(event.source)));
        this.addManagedPropertyListeners(['defaultColDef', 'defaultColGroupDef', 'columnTypes', 'suppressFieldDotNotation'], this.recreateColumnDefs.bind(this));
        this.addManagedPropertyListener('pivotMode', (event) => this.setPivotMode(this.gos.get('pivotMode'), (0, columnUtils_1._convertColumnEventSourceType)(event.source)));
    }
    // called from SyncService, when grid has finished initialising
    createColsFromColDefs(source) {
        const { beans } = this;
        const { valueCache, colAutosize, rowGroupColsSvc, pivotColsSvc, valueColsSvc, visibleCols, colViewport, eventSvc, } = beans;
        // only need to dispatch before/after events if updating columns, never if setting columns for first time
        const dispatchEventsFunc = this.colDefs ? (0, columnStateUtils_1._compareColumnStatesAndDispatchEvents)(beans, source) : undefined;
        // always invalidate cache on changing columns, as the column id's for the new columns
        // could overlap with the old id's, so the cache would return old values for new columns.
        valueCache?.expire();
        const oldCols = this.colDefCols?.list;
        const oldTree = this.colDefCols?.tree;
        const newTree = (0, columnFactoryUtils_1._createColumnTree)(beans, this.colDefs, true, oldTree, source);
        (0, columnUtils_1._destroyColumnTree)(beans, this.colDefCols?.tree, newTree.columnTree);
        const tree = newTree.columnTree;
        const treeDepth = newTree.treeDepth;
        const list = (0, columnUtils_1._getColumnsFromTree)(tree);
        const map = {};
        list.forEach((col) => (map[col.getId()] = col));
        this.colDefCols = { tree, treeDepth, list, map };
        rowGroupColsSvc?.extractCols(source, oldCols);
        pivotColsSvc?.extractCols(source, oldCols);
        valueColsSvc?.extractCols(source, oldCols);
        this.ready = true;
        this.refreshCols(true);
        visibleCols.refresh(source);
        colViewport.checkViewportColumns();
        // this event is not used by AG Grid, but left here for backwards compatibility,
        // in case applications use it
        eventSvc.dispatchEvent({
            type: 'columnEverythingChanged',
            source,
        });
        // Row Models react to all of these events as well as new columns loaded,
        // this flag instructs row model to ignore these events to reduce refreshes.
        if (dispatchEventsFunc) {
            this.changeEventsDispatching = true;
            dispatchEventsFunc();
            this.changeEventsDispatching = false;
        }
        eventSvc.dispatchEvent({
            type: 'newColumnsLoaded',
            source,
        });
        if (source === 'gridInitializing') {
            colAutosize?.applyAutosizeStrategy();
        }
    }
    // called from: buildAutoGroupColumns (events 'groupDisplayType', 'treeData', 'treeDataDisplayType', 'groupHideOpenParents')
    // createColsFromColDefs (recreateColumnDefs, setColumnsDefs),
    // setPivotMode, applyColumnState,
    // functionColsService.setPrimaryColList, functionColsService.updatePrimaryColList,
    // pivotResultCols.setPivotResultCols
    refreshCols(newColDefs) {
        if (!this.colDefCols) {
            return;
        }
        const prevColTree = this.cols?.tree;
        this.saveColOrder();
        const { autoColSvc, selectionColSvc, rowNumbersSvc, quickFilter, pivotResultCols, showRowGroupCols, rowAutoHeight, visibleCols, colViewport, eventSvc, } = this.beans;
        const cols = this.selectCols(pivotResultCols, this.colDefCols);
        this.createColumnsForService([autoColSvc, selectionColSvc, rowNumbersSvc], cols);
        const shouldSortNewColDefs = (0, gridOptionsUtils_1._shouldMaintainColumnOrder)(this.gos, this.showingPivotResult);
        if (!newColDefs || shouldSortNewColDefs) {
            this.restoreColOrder(cols);
        }
        this.positionLockedCols(cols);
        showRowGroupCols?.refresh();
        quickFilter?.refreshCols();
        this.setColSpanActive();
        rowAutoHeight?.setAutoHeightActive(cols);
        // make sure any part of the gui that tries to draw, eg the header,
        // will get empty lists of columns rather than stale columns.
        // for example, the header will received gridColumnsChanged event, so will try and draw,
        // but it will draw successfully when it acts on the virtualColumnsChanged event
        visibleCols.clear();
        colViewport.clear();
        const dispatchChangedEvent = !(0, array_1._areEqual)(prevColTree, this.cols.tree);
        if (dispatchChangedEvent) {
            eventSvc.dispatchEvent({
                type: 'gridColumnsChanged',
            });
        }
    }
    createColumnsForService(services, cols) {
        for (const service of services) {
            if (!service) {
                continue;
            }
            service.createColumns(cols, (updateOrder) => {
                this.lastOrder = updateOrder(this.lastOrder);
                this.lastPivotOrder = updateOrder(this.lastPivotOrder);
            });
            service.addColumns(cols);
        }
    }
    selectCols(pivotResultColsSvc, colDefCols) {
        const pivotResultCols = pivotResultColsSvc?.getPivotResultCols() ?? null;
        this.showingPivotResult = pivotResultCols != null;
        const { map, list, tree, treeDepth } = pivotResultCols ?? colDefCols;
        this.cols = {
            list: list.slice(),
            map: { ...map },
            tree: tree.slice(),
            treeDepth,
        };
        if (pivotResultCols) {
            // If the current columns are the same or a subset of the previous
            // we keep the previous order, otherwise we go back to the order the pivot
            // cols are generated in
            const hasSameColumns = pivotResultCols.list.some((col) => this.cols?.map[col.getColId()] !== undefined);
            if (!hasSameColumns) {
                this.lastPivotOrder = null;
            }
        }
        return this.cols;
    }
    getColsToShow() {
        if (!this.cols) {
            return [];
        }
        // pivot mode is on, but we are not pivoting, so we only
        // show columns we are aggregating on
        const showAutoGroupAndValuesOnly = this.isPivotMode() && !this.showingPivotResult;
        const valueColumns = this.beans.valueColsSvc?.columns;
        const res = this.cols.list.filter((col) => {
            const isAutoGroupCol = (0, columnUtils_1.isColumnGroupAutoCol)(col);
            if (showAutoGroupAndValuesOnly) {
                const isValueCol = valueColumns?.includes(col);
                return isAutoGroupCol || isValueCol;
            }
            else {
                // keep col if a) it's auto-group or b) it's visible
                return isAutoGroupCol || col.isVisible();
            }
        });
        return res;
    }
    // on events 'groupDisplayType', 'treeData', 'treeDataDisplayType', 'groupHideOpenParents'
    refreshAll(source) {
        if (!this.ready) {
            return;
        }
        this.refreshCols(false);
        this.beans.visibleCols.refresh(source);
    }
    setColsVisible(keys, visible = false, source) {
        (0, columnStateUtils_1._applyColumnState)(this.beans, {
            state: keys.map((key) => ({
                colId: typeof key === 'string' ? key : key.getColId(),
                hide: !visible,
            })),
        }, source);
    }
    /**
     * Restores provided columns order to the previous order in this.lastPivotOrder / this.lastOrder
     * If columns are not in the last order:
     *  - Check column groups, and apply column after the last column in the lowest shared group
     *  - If no sibling is found, apply the column at the end of the cols
     */
    restoreColOrder(cols) {
        const lastOrder = this.showingPivotResult ? this.lastPivotOrder : this.lastOrder;
        if (!lastOrder) {
            return;
        }
        // get the cols present in both new list and last order, according to the last order
        const preservedOrder = lastOrder.filter((col) => cols.map[col.getId()] != null);
        // if no cols in last order are in the new, then order is already correct
        if (preservedOrder.length === 0) {
            return;
        }
        // if after removing all the cols that are not in the new set, we have no cols left,
        // then we don't need to do anything further, as the new order is correct.
        if (preservedOrder.length === cols.list.length) {
            cols.list = preservedOrder;
            return;
        }
        const hasSiblings = (col) => {
            const ancestor = col.getOriginalParent();
            if (!ancestor) {
                return false;
            }
            const children = ancestor.getChildren();
            if (children.length > 1) {
                return true;
            }
            return hasSiblings(ancestor);
        };
        // if none of the preserved cols have siblings; shortcut, as all new cols can be added to the end
        // this is a common scenario due to generated cols.
        if (!preservedOrder.some((col) => hasSiblings(col))) {
            const preservedOrderSet = new Set(preservedOrder);
            for (const col of cols.list) {
                if (!preservedOrderSet.has(col)) {
                    preservedOrder.push(col);
                }
            }
            cols.list = preservedOrder;
            return;
        }
        // create map of known col positions and their indices
        const colPositionMap = new Map();
        for (let i = 0; i < preservedOrder.length; i++) {
            const col = preservedOrder[i];
            colPositionMap.set(col, i);
        }
        // find any cols that have been introduced that are not in the last order
        const additionalCols = cols.list.filter((col) => !colPositionMap.has(col));
        // no additional cols to be inserted, probably means cols were removed, but preserved order is correct.
        if (additionalCols.length === 0) {
            cols.list = preservedOrder;
            return;
        }
        // Function finds the sibling with the lowest shared parent and highest index in last order
        const getPreviousSibling = (col, group) => {
            const parent = group ? group.getOriginalParent() : col.getOriginalParent();
            if (!parent) {
                return null;
            }
            let highestIdx = null;
            let highestSibling = null;
            for (const child of parent.getChildren()) {
                // shortcut - skip the group that has already been processed
                if (child === group || child === col) {
                    continue;
                }
                if (child instanceof agColumn_1.AgColumn) {
                    const colIdx = colPositionMap.get(child);
                    // if col does not exist in last order, skip
                    if (colIdx == null) {
                        continue;
                    }
                    if (highestIdx == null || highestIdx < colIdx) {
                        highestIdx = colIdx;
                        highestSibling = child;
                    }
                    continue;
                }
                child.forEachLeafColumn((leafCol) => {
                    const colIdx = colPositionMap.get(leafCol);
                    // if col does not exist in last order, skip
                    if (colIdx == null) {
                        return;
                    }
                    if (highestIdx == null || highestIdx < colIdx) {
                        highestIdx = colIdx;
                        highestSibling = leafCol;
                    }
                });
            }
            if (highestSibling == null) {
                return getPreviousSibling(col, parent);
            }
            return highestSibling;
        };
        // array of cols that have no siblings in the last order, to be added at the tail of the results
        const noSiblingsAvailable = [];
        // map is keyed by cols in last order, and values are the cols that should be added after them
        // in results array
        const previousSiblingPosMap = new Map();
        // for each new col, find the col it needs inserted after and store for when array is constructed
        for (const col of additionalCols) {
            const prevSiblingIdx = getPreviousSibling(col, null);
            if (prevSiblingIdx == null) {
                noSiblingsAvailable.push(col);
                continue;
            }
            const prev = previousSiblingPosMap.get(prevSiblingIdx);
            if (prev === undefined) {
                previousSiblingPosMap.set(prevSiblingIdx, col);
            }
            else if (Array.isArray(prev)) {
                prev.push(col);
            }
            else {
                // if we have a single col, then we need to add the new col to the array
                previousSiblingPosMap.set(prevSiblingIdx, [prev, col]);
            }
        }
        // the following code starts at the tail of the array and works backwards.
        // first it applies all of the cols with no siblings (so no location in last order)
        // then it works backwards through the preserved order - when a col has siblings, it adds
        // them to the array and then adds the col itself.
        const result = new Array(cols.list.length);
        let resultPointer = result.length - 1;
        // work backwards, first adding no siblings to end
        for (let i = noSiblingsAvailable.length - 1; i >= 0; i--) {
            result[resultPointer--] = noSiblingsAvailable[i];
        }
        for (let i = preservedOrder.length - 1; i >= 0; i--) {
            const nextCol = preservedOrder[i];
            const extraCols = previousSiblingPosMap.get(nextCol);
            if (extraCols) {
                if (Array.isArray(extraCols)) {
                    // add the extra cols backwards.
                    for (let x = extraCols.length - 1; x >= 0; x--) {
                        const col = extraCols[x];
                        result[resultPointer--] = col;
                    }
                }
                else {
                    result[resultPointer--] = extraCols;
                }
            }
            result[resultPointer--] = nextCol;
        }
        cols.list = result;
    }
    positionLockedCols(cols) {
        cols.list = (0, columnMoveUtils_1.placeLockedColumns)(cols.list, this.gos);
    }
    saveColOrder() {
        if (this.showingPivotResult) {
            this.lastPivotOrder = this.cols?.list ?? null;
        }
        else {
            this.lastOrder = this.cols?.list ?? null;
        }
    }
    getColumnDefs() {
        return this.colDefCols
            ? this.beans.colDefFactory?.getColumnDefs(this.colDefCols.list, this.showingPivotResult, this.lastOrder, this.cols?.list ?? [])
            : undefined;
    }
    setColSpanActive() {
        this.colSpanActive = !!this.cols?.list.some((col) => col.getColDef().colSpan != null);
    }
    isPivotMode() {
        return this.pivotMode;
    }
    setPivotMode(pivotMode, source) {
        if (pivotMode === this.pivotMode) {
            return;
        }
        this.pivotMode = pivotMode;
        if (!this.ready) {
            return;
        }
        // we need to update grid columns to cover the scenario where user has groupDisplayType = 'custom', as
        // this means we don't use auto group column UNLESS we are in pivot mode (it's mandatory in pivot mode),
        // so need to updateCols() to check it autoGroupCol needs to be added / removed
        this.refreshCols(false);
        const { visibleCols, eventSvc } = this.beans;
        visibleCols.refresh(source);
        eventSvc.dispatchEvent({
            type: 'columnPivotModeChanged',
        });
    }
    // + clientSideRowModel
    isPivotActive() {
        const pivotColumns = this.beans.pivotColsSvc?.columns;
        return this.pivotMode && !!pivotColumns?.length;
    }
    // called when dataTypes change
    recreateColumnDefs(e) {
        if (!this.cols) {
            return;
        }
        // if we aren't going to force, update the auto cols in place
        this.beans.autoColSvc?.updateColumns(e);
        const source = (0, columnUtils_1._convertColumnEventSourceType)(e.source);
        this.createColsFromColDefs(source);
    }
    setColumnDefs(columnDefs, source) {
        this.colDefs = columnDefs;
        this.createColsFromColDefs(source);
    }
    destroy() {
        (0, columnUtils_1._destroyColumnTree)(this.beans, this.colDefCols?.tree);
        super.destroy();
    }
    getColTree() {
        return this.cols?.tree ?? [];
    }
    // + columnSelectPanel
    getColDefColTree() {
        return this.colDefCols?.tree ?? [];
    }
    // + clientSideRowController -> sorting, building quick filter text
    // + headerRenderer -> sorting (clearing icon)
    getColDefCols() {
        return this.colDefCols?.list ?? null;
    }
    // + moveColumnController
    getCols() {
        return this.cols?.list ?? [];
    }
    forAllCols(callback) {
        const { pivotResultCols, autoColSvc, selectionColSvc } = this.beans;
        (0, array_1._forAll)(this.colDefCols?.list, callback);
        (0, array_1._forAll)(autoColSvc?.columns?.list, callback);
        (0, array_1._forAll)(selectionColSvc?.columns?.list, callback);
        (0, array_1._forAll)(pivotResultCols?.getPivotResultCols()?.list, callback);
    }
    getColsForKeys(keys) {
        if (!keys) {
            return [];
        }
        return keys.map((key) => this.getCol(key)).filter((col) => col != null);
    }
    getColDefCol(key) {
        if (!this.colDefCols?.list) {
            return null;
        }
        return this.getColFromCollection(key, this.colDefCols);
    }
    getCol(key) {
        if (key == null) {
            return null;
        }
        return this.getColFromCollection(key, this.cols);
    }
    /**
     * Get column exclusively by ID.
     *
     * Note getCol/getColFromCollection have poor performance when col has been removed.
     */
    getColById(key) {
        return this.cols?.map[key] ?? null;
    }
    getColFromCollection(key, cols) {
        if (cols == null) {
            return null;
        }
        const { map, list } = cols;
        // most of the time this method gets called the key is a string, so we put this shortcut in
        // for performance reasons, to see if we can match for ID (it doesn't do auto columns, that's done below)
        if (typeof key == 'string' && map[key]) {
            return map[key];
        }
        for (let i = 0; i < list.length; i++) {
            if ((0, columnUtils_1._columnsMatch)(list[i], key)) {
                return list[i];
            }
        }
        return this.beans.autoColSvc?.getColumn(key) ?? this.beans.selectionColSvc?.getColumn(key) ?? null;
    }
}
exports.ColumnModel = ColumnModel;


/***/ }),

/***/ 52027:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColumnApiModule = exports.ColumnFlexModule = exports.DataTypeModule = void 0;
const cellRendererModule_1 = __webpack_require__(37358);
const version_1 = __webpack_require__(97205);
const columnApi_1 = __webpack_require__(68763);
const columnDefFactory_1 = __webpack_require__(44604);
const columnFlexService_1 = __webpack_require__(82849);
const dataTypeService_1 = __webpack_require__(96350);
/**
 * @internal
 */
exports.DataTypeModule = {
    moduleName: 'DataType',
    version: version_1.VERSION,
    beans: [dataTypeService_1.DataTypeService],
    dependsOn: [cellRendererModule_1.CheckboxCellRendererModule],
};
/**
 * @internal
 */
exports.ColumnFlexModule = {
    moduleName: 'ColumnFlex',
    version: version_1.VERSION,
    beans: [columnFlexService_1.ColumnFlexService],
};
/**
 * @feature Columns
 */
exports.ColumnApiModule = {
    moduleName: 'ColumnApi',
    version: version_1.VERSION,
    beans: [columnDefFactory_1.ColumnDefFactory],
    apiFunctions: {
        getColumnDef: columnApi_1.getColumnDef,
        getDisplayNameForColumn: columnApi_1.getDisplayNameForColumn,
        getColumn: columnApi_1.getColumn,
        getColumns: columnApi_1.getColumns,
        applyColumnState: columnApi_1.applyColumnState,
        getColumnState: columnApi_1.getColumnState,
        resetColumnState: columnApi_1.resetColumnState,
        isPinning: columnApi_1.isPinning,
        isPinningLeft: columnApi_1.isPinningLeft,
        isPinningRight: columnApi_1.isPinningRight,
        getDisplayedColAfter: columnApi_1.getDisplayedColAfter,
        getDisplayedColBefore: columnApi_1.getDisplayedColBefore,
        setColumnsVisible: columnApi_1.setColumnsVisible,
        setColumnsPinned: columnApi_1.setColumnsPinned,
        getAllGridColumns: columnApi_1.getAllGridColumns,
        getDisplayedLeftColumns: columnApi_1.getDisplayedLeftColumns,
        getDisplayedCenterColumns: columnApi_1.getDisplayedCenterColumns,
        getDisplayedRightColumns: columnApi_1.getDisplayedRightColumns,
        getAllDisplayedColumns: columnApi_1.getAllDisplayedColumns,
        getAllDisplayedVirtualColumns: columnApi_1.getAllDisplayedVirtualColumns,
        getColumnDefs: columnApi_1.getColumnDefs,
    },
};


/***/ }),

/***/ 48997:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColumnNameService = exports._camelCaseToHumanText = void 0;
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
/**
 * Converts a camelCase string into startCase
 * @param {string} camelCase
 * @returns {string}
 */
function _camelCaseToHumanText(camelCase) {
    if (!camelCase || camelCase == null) {
        return null;
    }
    // either split on a lowercase followed by uppercase ie  asHereTo -> as Here To
    const rex = /([a-z])([A-Z])/g;
    // or starts with uppercase and we take all expect the last which is assumed to be part of next word if followed by lowercase HEREToThere -> HERE To There
    const rexCaps = /([A-Z]+)([A-Z])([a-z])/g;
    const words = camelCase.replace(rex, '$1 $2').replace(rexCaps, '$1 $2$3').replace(/\./g, ' ').split(' ');
    return words
        .map((word) => word.substring(0, 1).toUpperCase() + (word.length > 1 ? word.substring(1, word.length) : ''))
        .join(' ');
}
exports._camelCaseToHumanText = _camelCaseToHumanText;
class ColumnNameService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'colNames';
    }
    getDisplayNameForColumn(column, location, includeAggFunc = false) {
        if (!column) {
            return null;
        }
        const headerName = this.getHeaderName(column.getColDef(), column, null, null, location);
        const { aggColNameSvc } = this.beans;
        if (includeAggFunc && aggColNameSvc) {
            return aggColNameSvc.getHeaderName(column, headerName);
        }
        return headerName;
    }
    getDisplayNameForProvidedColumnGroup(columnGroup, providedColumnGroup, location) {
        const colGroupDef = providedColumnGroup?.getColGroupDef();
        if (colGroupDef) {
            return this.getHeaderName(colGroupDef, null, columnGroup, providedColumnGroup, location);
        }
        return null;
    }
    getDisplayNameForColumnGroup(columnGroup, location) {
        return this.getDisplayNameForProvidedColumnGroup(columnGroup, columnGroup.getProvidedColumnGroup(), location);
    }
    // location is where the column is going to appear, ie who is calling us
    getHeaderName(colDef, column, columnGroup, providedColumnGroup, location) {
        const headerValueGetter = colDef.headerValueGetter;
        if (headerValueGetter) {
            const params = (0, gridOptionsUtils_1._addGridCommonParams)(this.gos, {
                colDef: colDef,
                column: column,
                columnGroup: columnGroup,
                providedColumnGroup: providedColumnGroup,
                location: location,
            });
            if (typeof headerValueGetter === 'function') {
                // valueGetter is a function, so just call it
                return headerValueGetter(params);
            }
            else if (typeof headerValueGetter === 'string') {
                // valueGetter is an expression, so execute the expression
                return this.beans.expressionSvc?.evaluate(headerValueGetter, params) ?? null;
            }
            return '';
        }
        else if (colDef.headerName != null) {
            return colDef.headerName;
        }
        else if (colDef.field) {
            return _camelCaseToHumanText(colDef.field);
        }
        return '';
    }
}
exports.ColumnNameService = ColumnNameService;


/***/ }),

/***/ 2885:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getColumnStateFromColDef = exports._getColumnState = exports._compareColumnStatesAndDispatchEvents = exports._resetColumnState = exports._applyColumnState = void 0;
const columnMoveUtils_1 = __webpack_require__(23505);
const gridOptionsUtils_1 = __webpack_require__(67274);
const array_1 = __webpack_require__(31502);
const generic_1 = __webpack_require__(34422);
const logging_1 = __webpack_require__(47764);
const columnEventUtils_1 = __webpack_require__(72934);
const columnFactoryUtils_1 = __webpack_require__(82716);
const columnUtils_1 = __webpack_require__(73146);
function _applyColumnState(beans, params, source) {
    const { colModel, rowGroupColsSvc, pivotColsSvc, autoColSvc, selectionColSvc, colAnimation, visibleCols, pivotResultCols, environment, valueColsSvc, eventSvc, gos, } = beans;
    const providedCols = colModel.getColDefCols() ?? [];
    const selectionCols = selectionColSvc?.getColumns();
    if (!providedCols?.length && !selectionCols?.length) {
        return false;
    }
    if (params?.state && !params.state.forEach) {
        // state is not an array
        (0, logging_1._warn)(32);
        return false;
    }
    const syncColumnWithStateItem = (column, stateItem, rowGroupIndexes, pivotIndexes, autoCol) => {
        if (!column) {
            return;
        }
        const getValue = (0, columnUtils_1.getValueFactory)(stateItem, params.defaultState);
        const flex = getValue('flex').value1;
        (0, columnFactoryUtils_1.updateSomeColumnState)(beans, column, getValue('hide').value1, getValue('sort').value1, getValue('sortIndex').value1, getValue('pinned').value1, flex, source);
        // if flex is null or undefined, fall back to setting width
        if (flex == null) {
            // if no flex, then use width if it's there
            const width = getValue('width').value1;
            if (width != null) {
                // if width provided and valid, use it, otherwise stick with the old width
                const minColWidth = column.getColDef().minWidth ?? environment.getDefaultColumnMinWidth();
                if (minColWidth != null && width >= minColWidth) {
                    column.setActualWidth(width, source);
                }
            }
        }
        // we do not do aggFunc, rowGroup or pivot for auto cols or secondary cols
        if (autoCol || !column.isPrimary()) {
            return;
        }
        valueColsSvc?.syncColumnWithState(column, source, getValue);
        rowGroupColsSvc?.syncColumnWithState(column, source, getValue, rowGroupIndexes);
        pivotColsSvc?.syncColumnWithState(column, source, getValue, pivotIndexes);
    };
    const applyStates = (states, existingColumns, getById) => {
        const dispatchEventsFunc = _compareColumnStatesAndDispatchEvents(beans, source);
        // at the end below, this list will have all columns we got no state for
        const columnsWithNoState = existingColumns.slice();
        const rowGroupIndexes = {};
        const pivotIndexes = {};
        const autoColStates = [];
        const selectionColStates = [];
        // If pivoting is modified, these are the states we try to reapply after
        // the pivot result cols are re-generated
        const unmatchedAndAutoStates = [];
        let unmatchedCount = 0;
        const previousRowGroupCols = rowGroupColsSvc?.columns.slice() ?? [];
        const previousPivotCols = pivotColsSvc?.columns.slice() ?? [];
        states.forEach((state) => {
            const colId = state.colId;
            // auto group columns are re-created so deferring syncing with ColumnState
            const isAutoGroupColumn = colId.startsWith(columnUtils_1.GROUP_AUTO_COLUMN_ID);
            if (isAutoGroupColumn) {
                autoColStates.push(state);
                unmatchedAndAutoStates.push(state);
                return;
            }
            if ((0, columnUtils_1.isColumnSelectionCol)(colId)) {
                selectionColStates.push(state);
                unmatchedAndAutoStates.push(state);
                return;
            }
            const column = getById(colId);
            if (!column) {
                unmatchedAndAutoStates.push(state);
                unmatchedCount += 1;
            }
            else {
                syncColumnWithStateItem(column, state, rowGroupIndexes, pivotIndexes, false);
                (0, array_1._removeFromArray)(columnsWithNoState, column);
            }
        });
        // anything left over, we got no data for, so add in the column as non-value, non-rowGroup and hidden
        const applyDefaultsFunc = (col) => syncColumnWithStateItem(col, null, rowGroupIndexes, pivotIndexes, false);
        columnsWithNoState.forEach(applyDefaultsFunc);
        rowGroupColsSvc?.sortColumns(comparatorByIndex.bind(rowGroupColsSvc, rowGroupIndexes, previousRowGroupCols));
        pivotColsSvc?.sortColumns(comparatorByIndex.bind(pivotColsSvc, pivotIndexes, previousPivotCols));
        colModel.refreshCols(false);
        const syncColStates = (getCol, colStates, columns = []) => {
            colStates.forEach((stateItem) => {
                const col = getCol(stateItem.colId);
                (0, array_1._removeFromArray)(columns, col);
                syncColumnWithStateItem(col, stateItem, null, null, true);
            });
            columns.forEach(applyDefaultsFunc);
        };
        // sync newly created auto group columns with ColumnState
        syncColStates((colId) => autoColSvc?.getColumn(colId) ?? null, autoColStates, autoColSvc?.getColumns()?.slice());
        // sync selection columns with ColumnState
        syncColStates((colId) => selectionColSvc?.getColumn(colId) ?? null, selectionColStates, selectionColSvc?.getColumns()?.slice());
        orderLiveColsLikeState(params, colModel, gos);
        visibleCols.refresh(source);
        eventSvc.dispatchEvent({
            type: 'columnEverythingChanged',
            source,
        });
        dispatchEventsFunc(); // Will trigger pivot result col changes if pivoting modified
        return { unmatchedAndAutoStates, unmatchedCount };
    };
    colAnimation?.start();
    let { unmatchedAndAutoStates, unmatchedCount } = applyStates(params.state || [], providedCols, (id) => colModel.getColDefCol(id));
    // If there are still states left over, see if we can apply them to newly generated
    // pivot result cols or auto cols. Also if defaults exist, ensure they are applied to pivot resul cols
    if (unmatchedAndAutoStates.length > 0 || (0, generic_1._exists)(params.defaultState)) {
        const pivotResultColsList = pivotResultCols?.getPivotResultCols()?.list ?? [];
        unmatchedCount = applyStates(unmatchedAndAutoStates, pivotResultColsList, (id) => pivotResultCols?.getPivotResultCol(id) ?? null).unmatchedCount;
    }
    colAnimation?.finish();
    return unmatchedCount === 0; // Successful if no states unaccounted for
}
exports._applyColumnState = _applyColumnState;
function _resetColumnState(beans, source) {
    const { colModel, autoColSvc, selectionColSvc, eventSvc, gos } = beans;
    const primaryCols = colModel.getColDefCols();
    if (!primaryCols?.length) {
        return;
    }
    // NOTE = there is one bug here that no customer has noticed - if a column has colDef.lockPosition,
    // this is ignored  below when ordering the cols. to work, we should always put lockPosition cols first.
    // As a work around, developers should just put lockPosition columns first in their colDef list.
    // we can't use 'allColumns' as the order might of messed up, so get the primary ordered list
    const primaryColumnTree = colModel.getColDefColTree();
    const primaryColumns = (0, columnUtils_1._getColumnsFromTree)(primaryColumnTree);
    const columnStates = [];
    // we start at 1000, so if user has mix of rowGroup and group specified, it will work with both.
    // eg IF user has ColA.rowGroupIndex=0, ColB.rowGroupIndex=1, ColC.rowGroup=true,
    // THEN result will be ColA.rowGroupIndex=0, ColB.rowGroupIndex=1, ColC.rowGroup=1000
    let letRowGroupIndex = 1000;
    let letPivotIndex = 1000;
    const addColState = (col) => {
        const stateItem = getColumnStateFromColDef(col);
        if ((0, generic_1._missing)(stateItem.rowGroupIndex) && stateItem.rowGroup) {
            stateItem.rowGroupIndex = letRowGroupIndex++;
        }
        if ((0, generic_1._missing)(stateItem.pivotIndex) && stateItem.pivot) {
            stateItem.pivotIndex = letPivotIndex++;
        }
        columnStates.push(stateItem);
    };
    autoColSvc?.getColumns()?.forEach(addColState);
    selectionColSvc?.getColumns()?.forEach(addColState);
    primaryColumns?.forEach(addColState);
    // apply state before ordering, as changes in row grouping will introduce new columns
    _applyColumnState(beans, { state: columnStates }, source);
    const autoCols = autoColSvc?.getColumns() ?? [];
    const selectionCols = selectionColSvc?.getColumns() ?? [];
    const orderedCols = [...selectionCols, ...autoCols, ...primaryCols];
    const orderedColState = orderedCols.map((col) => ({ colId: col.colId }));
    // apply the new order when all the cols have been created & are available
    _applyColumnState(beans, { state: orderedColState, applyOrder: true }, source);
    eventSvc.dispatchEvent((0, gridOptionsUtils_1._addGridCommonParams)(gos, { type: 'columnsReset', source }));
}
exports._resetColumnState = _resetColumnState;
/**
 * calculates what events to fire between column state changes. gets used when:
 * a) apply column state
 * b) apply new column definitions (so changes from old cols)
 */
function _compareColumnStatesAndDispatchEvents(beans, source) {
    const { rowGroupColsSvc, pivotColsSvc, valueColsSvc, colModel, sortSvc, eventSvc } = beans;
    const startState = {
        rowGroupColumns: rowGroupColsSvc?.columns.slice() ?? [],
        pivotColumns: pivotColsSvc?.columns.slice() ?? [],
        valueColumns: valueColsSvc?.columns.slice() ?? [],
    };
    const columnStateBefore = _getColumnState(beans);
    const columnStateBeforeMap = {};
    columnStateBefore.forEach((col) => {
        columnStateBeforeMap[col.colId] = col;
    });
    return () => {
        // dispatches generic ColumnEvents where all columns are returned rather than what has changed
        const dispatchWhenListsDifferent = (eventType, colsBefore, colsAfter, idMapper) => {
            const beforeList = colsBefore.map(idMapper);
            const afterList = colsAfter.map(idMapper);
            const unchanged = (0, array_1._areEqual)(beforeList, afterList);
            if (unchanged) {
                return;
            }
            const changes = new Set(colsBefore);
            colsAfter.forEach((id) => {
                // if the first list had it, delete it, as it's unchanged.
                if (!changes.delete(id)) {
                    // if the second list has it, and first doesn't, add it.
                    changes.add(id);
                }
            });
            const changesArr = [...changes];
            eventSvc.dispatchEvent({
                type: eventType,
                columns: changesArr,
                column: changesArr.length === 1 ? changesArr[0] : null,
                source: source,
            });
        };
        // determines which columns have changed according to supplied predicate
        const getChangedColumns = (changedPredicate) => {
            const changedColumns = [];
            colModel.forAllCols((column) => {
                const colStateBefore = columnStateBeforeMap[column.getColId()];
                if (colStateBefore && changedPredicate(colStateBefore, column)) {
                    changedColumns.push(column);
                }
            });
            return changedColumns;
        };
        const columnIdMapper = (c) => c.getColId();
        dispatchWhenListsDifferent('columnRowGroupChanged', startState.rowGroupColumns, rowGroupColsSvc?.columns ?? [], columnIdMapper);
        dispatchWhenListsDifferent('columnPivotChanged', startState.pivotColumns, pivotColsSvc?.columns ?? [], columnIdMapper);
        const valueChangePredicate = (cs, c) => {
            const oldActive = cs.aggFunc != null;
            const activeChanged = oldActive != c.isValueActive();
            // we only check aggFunc if the agg is active
            const aggFuncChanged = oldActive && cs.aggFunc != c.getAggFunc();
            return activeChanged || aggFuncChanged;
        };
        const changedValues = getChangedColumns(valueChangePredicate);
        if (changedValues.length > 0) {
            (0, columnEventUtils_1.dispatchColumnChangedEvent)(eventSvc, 'columnValueChanged', changedValues, source);
        }
        const resizeChangePredicate = (cs, c) => cs.width != c.getActualWidth();
        (0, columnEventUtils_1.dispatchColumnResizedEvent)(eventSvc, getChangedColumns(resizeChangePredicate), true, source);
        const pinnedChangePredicate = (cs, c) => cs.pinned != c.getPinned();
        (0, columnEventUtils_1.dispatchColumnPinnedEvent)(eventSvc, getChangedColumns(pinnedChangePredicate), source);
        const visibilityChangePredicate = (cs, c) => cs.hide == c.isVisible();
        (0, columnEventUtils_1.dispatchColumnVisibleEvent)(eventSvc, getChangedColumns(visibilityChangePredicate), source);
        const sortChangePredicate = (cs, c) => cs.sort != c.getSort() || cs.sortIndex != c.getSortIndex();
        const changedColumns = getChangedColumns(sortChangePredicate);
        if (changedColumns.length > 0) {
            sortSvc?.dispatchSortChangedEvents(source, changedColumns);
        }
        const colStateAfter = _getColumnState(beans);
        // special handling for moved column events
        normaliseColumnMovedEventForColumnState(columnStateBefore, colStateAfter, source, colModel, eventSvc);
    };
}
exports._compareColumnStatesAndDispatchEvents = _compareColumnStatesAndDispatchEvents;
function _getColumnState(beans) {
    const { colModel, rowGroupColsSvc, pivotColsSvc } = beans;
    const primaryCols = colModel.getColDefCols();
    if ((0, generic_1._missing)(primaryCols) || !colModel.isAlive()) {
        return [];
    }
    const rowGroupColumns = rowGroupColsSvc?.columns;
    const pivotColumns = pivotColsSvc?.columns;
    const res = [];
    const createStateItemFromColumn = (column) => {
        const rowGroupIndex = column.isRowGroupActive() && rowGroupColumns ? rowGroupColumns.indexOf(column) : null;
        const pivotIndex = column.isPivotActive() && pivotColumns ? pivotColumns.indexOf(column) : null;
        const aggFunc = column.isValueActive() ? column.getAggFunc() : null;
        const sort = column.getSort() != null ? column.getSort() : null;
        const sortIndex = column.getSortIndex() != null ? column.getSortIndex() : null;
        res.push({
            colId: column.getColId(),
            width: column.getActualWidth(),
            hide: !column.isVisible(),
            pinned: column.getPinned(),
            sort,
            sortIndex,
            aggFunc,
            rowGroup: column.isRowGroupActive(),
            rowGroupIndex,
            pivot: column.isPivotActive(),
            pivotIndex: pivotIndex,
            flex: column.getFlex() ?? null,
        });
    };
    colModel.forAllCols((col) => createStateItemFromColumn(col));
    // for fast looking, store the index of each column
    const colIdToGridIndexMap = new Map(colModel.getCols().map((col, index) => [col.getColId(), index]));
    res.sort((itemA, itemB) => {
        const posA = colIdToGridIndexMap.has(itemA.colId) ? colIdToGridIndexMap.get(itemA.colId) : -1;
        const posB = colIdToGridIndexMap.has(itemB.colId) ? colIdToGridIndexMap.get(itemB.colId) : -1;
        return posA - posB;
    });
    return res;
}
exports._getColumnState = _getColumnState;
function getColumnStateFromColDef(column) {
    const getValueOrNull = (a, b) => (a != null ? a : b != null ? b : null);
    const colDef = column.getColDef();
    const sort = getValueOrNull(colDef.sort, colDef.initialSort);
    const sortIndex = getValueOrNull(colDef.sortIndex, colDef.initialSortIndex);
    const hide = getValueOrNull(colDef.hide, colDef.initialHide);
    const pinned = getValueOrNull(colDef.pinned, colDef.initialPinned);
    const width = getValueOrNull(colDef.width, colDef.initialWidth);
    const flex = getValueOrNull(colDef.flex, colDef.initialFlex);
    let rowGroupIndex = getValueOrNull(colDef.rowGroupIndex, colDef.initialRowGroupIndex);
    let rowGroup = getValueOrNull(colDef.rowGroup, colDef.initialRowGroup);
    if (rowGroupIndex == null && (rowGroup == null || rowGroup == false)) {
        rowGroupIndex = null;
        rowGroup = null;
    }
    let pivotIndex = getValueOrNull(colDef.pivotIndex, colDef.initialPivotIndex);
    let pivot = getValueOrNull(colDef.pivot, colDef.initialPivot);
    if (pivotIndex == null && (pivot == null || pivot == false)) {
        pivotIndex = null;
        pivot = null;
    }
    const aggFunc = getValueOrNull(colDef.aggFunc, colDef.initialAggFunc);
    return {
        colId: column.getColId(),
        sort,
        sortIndex,
        hide,
        pinned,
        width,
        flex,
        rowGroup,
        rowGroupIndex,
        pivot,
        pivotIndex,
        aggFunc,
    };
}
exports.getColumnStateFromColDef = getColumnStateFromColDef;
function orderLiveColsLikeState(params, colModel, gos) {
    if (!params.applyOrder || !params.state) {
        return;
    }
    const colIds = [];
    params.state.forEach((item) => {
        if (item.colId != null) {
            colIds.push(item.colId);
        }
    });
    sortColsLikeKeys(colModel.cols, colIds, colModel, gos);
}
function sortColsLikeKeys(cols, colIds, colModel, gos) {
    if (cols == null) {
        return;
    }
    let newOrder = [];
    const processedColIds = {};
    colIds.forEach((colId) => {
        if (processedColIds[colId]) {
            return;
        }
        const col = cols.map[colId];
        if (col) {
            newOrder.push(col);
            processedColIds[colId] = true;
        }
    });
    // add in all other columns
    let autoGroupInsertIndex = 0;
    cols.list.forEach((col) => {
        const colId = col.getColId();
        const alreadyProcessed = processedColIds[colId] != null;
        if (alreadyProcessed) {
            return;
        }
        const isAutoGroupCol = colId.startsWith(columnUtils_1.GROUP_AUTO_COLUMN_ID);
        if (isAutoGroupCol) {
            // auto group columns, if missing from state list, are added to the start.
            // it's common to have autoGroup missing, as grouping could be on by default
            // on a column, but the user could of since removed the grouping via the UI.
            // if we don't inc the insert index, autoGroups will be inserted in reverse order
            newOrder.splice(autoGroupInsertIndex++, 0, col);
        }
        else {
            // normal columns, if missing from state list, are added at the end
            newOrder.push(col);
        }
    });
    // this is already done in updateCols, however we changed the order above (to match the order of the state
    // columns) so we need to do it again. we could of put logic into the order above to take into account fixed
    // columns, however if we did then we would have logic for updating fixed columns twice. reusing the logic here
    // is less sexy for the code here, but it keeps consistency.
    newOrder = (0, columnMoveUtils_1.placeLockedColumns)(newOrder, gos);
    if (!(0, columnMoveUtils_1.doesMovePassMarryChildren)(newOrder, colModel.getColTree())) {
        (0, logging_1._warn)(39);
        return;
    }
    cols.list = newOrder;
}
function normaliseColumnMovedEventForColumnState(colStateBefore, colStateAfter, source, colModel, eventSvc) {
    // we are only interested in columns that were both present and visible before and after
    const colStateAfterMapped = {};
    colStateAfter.forEach((s) => (colStateAfterMapped[s.colId] = s));
    // get id's of cols in both before and after lists
    const colsIntersectIds = {};
    colStateBefore.forEach((s) => {
        if (colStateAfterMapped[s.colId]) {
            colsIntersectIds[s.colId] = true;
        }
    });
    // filter state lists, so we only have cols that were present before and after
    const beforeFiltered = colStateBefore.filter((c) => colsIntersectIds[c.colId]);
    const afterFiltered = colStateAfter.filter((c) => colsIntersectIds[c.colId]);
    // see if any cols are in a different location
    const movedColumns = [];
    afterFiltered.forEach((csAfter, index) => {
        const csBefore = beforeFiltered && beforeFiltered[index];
        if (csBefore && csBefore.colId !== csAfter.colId) {
            const gridCol = colModel.getCol(csBefore.colId);
            if (gridCol) {
                movedColumns.push(gridCol);
            }
        }
    });
    if (!movedColumns.length) {
        return;
    }
    eventSvc.dispatchEvent({
        type: 'columnMoved',
        columns: movedColumns,
        column: movedColumns.length === 1 ? movedColumns[0] : null,
        finished: true,
        source,
    });
}
// sort the lists according to the indexes that were provided
const comparatorByIndex = (indexes, oldList, colA, colB) => {
    const indexA = indexes[colA.getId()];
    const indexB = indexes[colB.getId()];
    const aHasIndex = indexA != null;
    const bHasIndex = indexB != null;
    if (aHasIndex && bHasIndex) {
        // both a and b are new cols with index, so sort on index
        return indexA - indexB;
    }
    if (aHasIndex) {
        // a has an index, so it should be before a
        return -1;
    }
    if (bHasIndex) {
        // b has an index, so it should be before a
        return 1;
    }
    const oldIndexA = oldList.indexOf(colA);
    const oldIndexB = oldList.indexOf(colB);
    const aHasOldIndex = oldIndexA >= 0;
    const bHasOldIndex = oldIndexB >= 0;
    if (aHasOldIndex && bHasOldIndex) {
        // both a and b are old cols, so sort based on last order
        return oldIndexA - oldIndexB;
    }
    if (aHasOldIndex) {
        // a is old, b is new, so b is first
        return -1;
    }
    // this bit does matter, means both are new cols
    // but without index or that b is old and a is new
    return 1;
};


/***/ }),

/***/ 73146:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getValueFactory = exports._columnsMatch = exports._convertColumnEventSourceType = exports._updateColsMap = exports._areColIdsEqual = exports.convertColumnTypes = exports.isRowNumberCol = exports.isColumnSelectionCol = exports.isColumnGroupAutoCol = exports._destroyColumnTree = exports.getWidthOfColsInList = exports._getColumnsFromTree = exports.ROW_NUMBERS_COLUMN_ID = exports.SELECTION_COLUMN_ID = exports.GROUP_AUTO_COLUMN_ID = void 0;
const agColumn_1 = __webpack_require__(13355);
const agProvidedColumnGroup_1 = __webpack_require__(79409);
const array_1 = __webpack_require__(31502);
const generic_1 = __webpack_require__(34422);
const columnFactoryUtils_1 = __webpack_require__(82716);
exports.GROUP_AUTO_COLUMN_ID = 'ag-Grid-AutoColumn';
exports.SELECTION_COLUMN_ID = 'ag-Grid-SelectionColumn';
exports.ROW_NUMBERS_COLUMN_ID = 'ag-Grid-RowNumbersColumn';
// Possible candidate for reuse (alot of recursive traversal duplication)
function _getColumnsFromTree(rootColumns) {
    const result = [];
    const recursiveFindColumns = (childColumns) => {
        for (let i = 0; i < childColumns.length; i++) {
            const child = childColumns[i];
            if ((0, agColumn_1.isColumn)(child)) {
                result.push(child);
            }
            else if ((0, agProvidedColumnGroup_1.isProvidedColumnGroup)(child)) {
                recursiveFindColumns(child.getChildren());
            }
        }
    };
    recursiveFindColumns(rootColumns);
    return result;
}
exports._getColumnsFromTree = _getColumnsFromTree;
function getWidthOfColsInList(columnList) {
    return columnList.reduce((width, col) => width + col.getActualWidth(), 0);
}
exports.getWidthOfColsInList = getWidthOfColsInList;
function _destroyColumnTree(beans, oldTree, newTree) {
    const oldObjectsById = {};
    if (!oldTree) {
        return;
    }
    // add in all old columns to be destroyed
    (0, columnFactoryUtils_1.depthFirstOriginalTreeSearch)(null, oldTree, (child) => {
        oldObjectsById[child.getInstanceId()] = child;
    });
    // however we don't destroy anything in the new tree. if destroying the grid, there is no new tree
    if (newTree) {
        (0, columnFactoryUtils_1.depthFirstOriginalTreeSearch)(null, newTree, (child) => {
            oldObjectsById[child.getInstanceId()] = null;
        });
    }
    // what's left can be destroyed
    const colsToDestroy = Object.values(oldObjectsById).filter((item) => item != null);
    beans.context.destroyBeans(colsToDestroy);
}
exports._destroyColumnTree = _destroyColumnTree;
function isColumnGroupAutoCol(col) {
    const colId = col.getId();
    return colId.startsWith(exports.GROUP_AUTO_COLUMN_ID);
}
exports.isColumnGroupAutoCol = isColumnGroupAutoCol;
function isColumnSelectionCol(col) {
    const id = typeof col === 'string' ? col : 'getColId' in col ? col.getColId() : col.colId;
    return id?.startsWith(exports.SELECTION_COLUMN_ID) ?? false;
}
exports.isColumnSelectionCol = isColumnSelectionCol;
function isRowNumberCol(col) {
    const id = typeof col === 'string' ? col : 'getColId' in col ? col.getColId() : col.colId;
    return id?.startsWith(exports.ROW_NUMBERS_COLUMN_ID) ?? false;
}
exports.isRowNumberCol = isRowNumberCol;
function convertColumnTypes(type) {
    let typeKeys = [];
    if (type instanceof Array) {
        typeKeys = type;
    }
    else if (typeof type === 'string') {
        typeKeys = type.split(',');
    }
    return typeKeys;
}
exports.convertColumnTypes = convertColumnTypes;
function _areColIdsEqual(colsA, colsB) {
    return (0, array_1._areEqual)(colsA, colsB, (a, b) => a.getColId() === b.getColId());
}
exports._areColIdsEqual = _areColIdsEqual;
function _updateColsMap(cols) {
    cols.map = {};
    cols.list.forEach((col) => (cols.map[col.getId()] = col));
}
exports._updateColsMap = _updateColsMap;
function _convertColumnEventSourceType(source) {
    // unfortunately they do not match so need to perform conversion
    return source === 'gridOptionsUpdated' ? 'gridOptionsChanged' : source;
}
exports._convertColumnEventSourceType = _convertColumnEventSourceType;
function _columnsMatch(column, key) {
    const columnMatches = column === key;
    const colDefMatches = column.getColDef() === key;
    const idMatches = column.getColId() == key;
    return columnMatches || colDefMatches || idMatches;
}
exports._columnsMatch = _columnsMatch;
const getValueFactory = (stateItem, defaultState) => (key1, key2) => {
    const obj = {
        value1: undefined,
        value2: undefined,
    };
    let calculated = false;
    if (stateItem) {
        if (stateItem[key1] !== undefined) {
            obj.value1 = stateItem[key1];
            calculated = true;
        }
        if ((0, generic_1._exists)(key2) && stateItem[key2] !== undefined) {
            obj.value2 = stateItem[key2];
            calculated = true;
        }
    }
    if (!calculated && defaultState) {
        if (defaultState[key1] !== undefined) {
            obj.value1 = defaultState[key1];
        }
        if ((0, generic_1._exists)(key2) && defaultState[key2] !== undefined) {
            obj.value2 = defaultState[key2];
        }
    }
    return obj;
};
exports.getValueFactory = getValueFactory;


/***/ }),

/***/ 5034:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColumnViewportService = void 0;
const beanStub_1 = __webpack_require__(68731);
const agColumn_1 = __webpack_require__(13355);
const generic_1 = __webpack_require__(34422);
class ColumnViewportService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'colViewport';
        // cols in center that are in the viewport
        this.colsWithinViewport = [];
        // same as colsWithinViewport, except we always include columns with headerAutoHeight
        this.headerColsWithinViewport = [];
        // A hash key to keep track of changes in viewport columns
        this.colsWithinViewportHash = '';
        // all columns & groups to be rendered, index by row.
        // used by header rows to get all items to render for that row.
        this.rowsOfHeadersToRenderLeft = {};
        this.rowsOfHeadersToRenderRight = {};
        this.rowsOfHeadersToRenderCenter = {};
    }
    wireBeans(beans) {
        this.visibleCols = beans.visibleCols;
        this.colModel = beans.colModel;
    }
    postConstruct() {
        this.suppressColumnVirtualisation = this.gos.get('suppressColumnVirtualisation');
    }
    setScrollPosition(scrollWidth, scrollPosition, afterScroll = false) {
        const { visibleCols } = this;
        const bodyWidthDirty = visibleCols.isBodyWidthDirty;
        const noChange = scrollWidth === this.scrollWidth && scrollPosition === this.scrollPosition && !bodyWidthDirty;
        if (noChange) {
            return;
        }
        this.scrollWidth = scrollWidth;
        this.scrollPosition = scrollPosition;
        // we need to call setVirtualViewportLeftAndRight() at least once after the body width changes,
        // as the viewport can stay the same, but in RTL, if body width changes, we need to work out the
        // virtual columns again
        visibleCols.isBodyWidthDirty = true;
        if (this.gos.get('enableRtl')) {
            const bodyWidth = visibleCols.bodyWidth;
            this.viewportLeft = bodyWidth - scrollPosition - scrollWidth;
            this.viewportRight = bodyWidth - scrollPosition;
        }
        else {
            this.viewportLeft = scrollPosition;
            this.viewportRight = scrollWidth + scrollPosition;
        }
        if (this.colModel.ready) {
            this.checkViewportColumns(afterScroll);
        }
    }
    getHeadersToRender(type, depth) {
        let result;
        switch (type) {
            case 'left':
                result = this.rowsOfHeadersToRenderLeft[depth];
                break;
            case 'right':
                result = this.rowsOfHeadersToRenderRight[depth];
                break;
            default:
                result = this.rowsOfHeadersToRenderCenter[depth];
                break;
        }
        return result || [];
    }
    extractViewportColumns() {
        const displayedColumnsCenter = this.visibleCols.centerCols;
        if (this.isColumnVirtualisationSuppressed()) {
            // no virtualisation, so don't filter
            this.colsWithinViewport = displayedColumnsCenter;
            this.headerColsWithinViewport = displayedColumnsCenter;
        }
        else {
            // filter out what should be visible
            this.colsWithinViewport = displayedColumnsCenter.filter(this.isColumnInRowViewport.bind(this));
            this.headerColsWithinViewport = displayedColumnsCenter.filter(this.isColumnInHeaderViewport.bind(this));
        }
    }
    isColumnVirtualisationSuppressed() {
        // When running within jsdom the viewportRight is always 0, so we need to return true to allow
        // tests to validate all the columns.
        return this.suppressColumnVirtualisation || this.viewportRight === 0;
    }
    clear(suppressHashClear) {
        this.rowsOfHeadersToRenderLeft = {};
        this.rowsOfHeadersToRenderRight = {};
        this.rowsOfHeadersToRenderCenter = {};
        if (!suppressHashClear) {
            this.colsWithinViewportHash = '';
        }
    }
    isColumnInHeaderViewport(col) {
        // for headers, we never filter out autoHeaderHeight columns, if calculating
        if (col.isAutoHeaderHeight() || isAnyParentAutoHeaderHeight(col)) {
            return true;
        }
        return this.isColumnInRowViewport(col);
    }
    isColumnInRowViewport(col) {
        // we never filter out autoHeight columns, as we need them in the DOM for calculating Auto Height
        if (col.isAutoHeight()) {
            return true;
        }
        const columnLeft = col.getLeft() || 0;
        const columnRight = columnLeft + col.getActualWidth();
        // adding 200 for buffer size, so some cols off viewport are rendered.
        // this helps horizontal scrolling so user rarely sees white space (unless
        // they scroll horizontally fast). however we are conservative, as the more
        // buffer the slower the vertical redraw speed
        const leftBounds = this.viewportLeft - 200;
        const rightBounds = this.viewportRight + 200;
        const columnToMuchLeft = columnLeft < leftBounds && columnRight < leftBounds;
        const columnToMuchRight = columnLeft > rightBounds && columnRight > rightBounds;
        return !columnToMuchLeft && !columnToMuchRight;
    }
    // used by Grid API only
    getViewportColumns() {
        const { leftCols, rightCols } = this.visibleCols;
        const res = this.colsWithinViewport.concat(leftCols).concat(rightCols);
        return res;
    }
    // + rowRenderer
    // if we are not column spanning, this just returns back the virtual centre columns,
    // however if we are column spanning, then different rows can have different virtual
    // columns, so we have to work out the list for each individual row.
    getColsWithinViewport(rowNode) {
        if (!this.colModel.colSpanActive) {
            return this.colsWithinViewport;
        }
        const emptySpaceBeforeColumn = (col) => {
            const left = col.getLeft();
            return (0, generic_1._exists)(left) && left > this.viewportLeft;
        };
        // if doing column virtualisation, then we filter based on the viewport.
        const inViewportCallback = this.isColumnVirtualisationSuppressed()
            ? undefined
            : this.isColumnInRowViewport.bind(this);
        const { visibleCols } = this;
        const displayedColumnsCenter = visibleCols.centerCols;
        return visibleCols.getColsForRow(rowNode, displayedColumnsCenter, inViewportCallback, emptySpaceBeforeColumn);
    }
    // checks what columns are currently displayed due to column virtualisation. dispatches an event
    // if the list of columns has changed.
    // + setColumnWidth(), setViewportPosition(), setColumnDefs(), sizeColumnsToFit()
    checkViewportColumns(afterScroll = false) {
        const viewportColumnsChanged = this.extractViewport();
        if (viewportColumnsChanged) {
            this.eventSvc.dispatchEvent({
                type: 'virtualColumnsChanged',
                afterScroll,
            });
        }
    }
    calculateHeaderRows() {
        // go through each group, see if any of it's cols are displayed, and if yes,
        // then this group is included
        this.clear(true);
        // for easy lookup when building the groups.
        const renderedColIds = {};
        const { leftCols, rightCols, treeLeft, treeRight, treeCenter } = this.visibleCols;
        const allRenderedCols = this.headerColsWithinViewport.concat(leftCols).concat(rightCols);
        allRenderedCols.forEach((col) => (renderedColIds[col.getId()] = true));
        const testGroup = (children, result, depth) => {
            let returnValue = false;
            for (let i = 0; i < children.length; i++) {
                // see if this item is within viewport
                const child = children[i];
                let addThisItem = false;
                if ((0, agColumn_1.isColumn)(child)) {
                    // for column, test if column is included
                    addThisItem = renderedColIds[child.getId()] === true;
                }
                else {
                    // if group, base decision on children
                    const columnGroup = child;
                    const displayedChildren = columnGroup.getDisplayedChildren();
                    if (displayedChildren) {
                        addThisItem = testGroup(displayedChildren, result, depth + 1);
                    }
                }
                if (addThisItem) {
                    returnValue = true;
                    if (!result[depth]) {
                        result[depth] = [];
                    }
                    result[depth].push(child);
                }
            }
            return returnValue;
        };
        testGroup(treeLeft, this.rowsOfHeadersToRenderLeft, 0);
        testGroup(treeRight, this.rowsOfHeadersToRenderRight, 0);
        testGroup(treeCenter, this.rowsOfHeadersToRenderCenter, 0);
    }
    extractViewport() {
        const hashColumn = (c) => `${c.getId()}-${c.getPinned() || 'normal'}`;
        this.extractViewportColumns();
        const newHash = this.getViewportColumns().map(hashColumn).join('#');
        const changed = this.colsWithinViewportHash !== newHash;
        if (changed) {
            this.colsWithinViewportHash = newHash;
            this.calculateHeaderRows();
        }
        return changed;
    }
}
exports.ColumnViewportService = ColumnViewportService;
function isAnyParentAutoHeaderHeight(col) {
    while (col) {
        if (col.isAutoHeaderHeight()) {
            return true;
        }
        col = col.getParent();
    }
    return false;
}


/***/ }),

/***/ 96350:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DataTypeService = void 0;
const keyCode_1 = __webpack_require__(39853);
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const date_1 = __webpack_require__(39827);
const generic_1 = __webpack_require__(34422);
const object_1 = __webpack_require__(6996);
const logging_1 = __webpack_require__(47764);
const columnFactoryUtils_1 = __webpack_require__(82716);
const columnStateUtils_1 = __webpack_require__(2885);
const columnUtils_1 = __webpack_require__(73146);
/**
 *  We are missing object and dateTime here.
 *  This is because dateTime has a lower priority than date and gives us no way to distinguish between the two, and
 *  object type is the default type for all other types.
 *
 *  dateTimeString has higher priority than dateString, since it includes serialized time and isValidDate() considers datetime a valid date.
 */
const SORTED_CELL_DATA_TYPES_FOR_MATCHING = [
    'dateTimeString',
    'dateString',
    'text',
    'number',
    'boolean',
    'date',
];
class DataTypeService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'dataTypeSvc';
        this.dataTypeDefinitions = {};
        this.isPendingInference = false;
        this.isColumnTypeOverrideInDataTypeDefinitions = false;
        // keep track of any column state updates whilst waiting for data types to be inferred
        this.columnStateUpdatesPendingInference = {};
        this.columnStateUpdateListenerDestroyFuncs = [];
        // using an object here to enforce dev to not forget to implement new types as they are added
        this.columnDefinitionPropsPerDataType = {
            number() {
                return { cellEditor: 'agNumberCellEditor' };
            },
            boolean() {
                return {
                    cellEditor: 'agCheckboxCellEditor',
                    cellRenderer: 'agCheckboxCellRenderer',
                    getFindText: () => null,
                    suppressKeyboardEvent: (params) => !!params.colDef.editable && params.event.key === keyCode_1.KeyCode.SPACE,
                };
            },
            date({ formatValue }) {
                return { cellEditor: 'agDateCellEditor', keyCreator: formatValue };
            },
            dateString({ formatValue }) {
                return { cellEditor: 'agDateStringCellEditor', keyCreator: formatValue };
            },
            dateTime(args) {
                return this.date(args);
            },
            dateTimeString(args) {
                return this.dateString(args);
            },
            object({ formatValue, colModel, colId }) {
                return {
                    cellEditorParams: {
                        useFormatter: true,
                    },
                    comparator: (a, b) => {
                        const column = colModel.getColDefCol(colId);
                        const colDef = column?.getColDef();
                        if (!column || !colDef) {
                            return 0;
                        }
                        const valA = a == null ? '' : formatValue({ column, node: null, value: a });
                        const valB = b == null ? '' : formatValue({ column, node: null, value: b });
                        if (valA === valB)
                            return 0;
                        return valA > valB ? 1 : -1;
                    },
                    keyCreator: formatValue,
                };
            },
            text() {
                return {};
            },
        };
    }
    wireBeans(beans) {
        this.colModel = beans.colModel;
    }
    postConstruct() {
        this.processDataTypeDefinitions();
        this.addManagedPropertyListener('dataTypeDefinitions', (event) => {
            this.processDataTypeDefinitions();
            this.colModel.recreateColumnDefs(event);
        });
    }
    processDataTypeDefinitions() {
        const defaultDataTypes = this.getDefaultDataTypes();
        const newDataTypeDefinitions = {};
        const newFormatValueFuncs = {};
        const generateFormatValueFunc = (dataTypeDefinition) => {
            return (params) => {
                const { column, node, value } = params;
                let valueFormatter = column.getColDef().valueFormatter;
                if (valueFormatter === dataTypeDefinition.groupSafeValueFormatter) {
                    valueFormatter = dataTypeDefinition.valueFormatter;
                }
                return this.beans.valueSvc.formatValue(column, node, value, valueFormatter);
            };
        };
        for (const cellDataType of Object.keys(defaultDataTypes)) {
            const defaultDataTypeDef = defaultDataTypes[cellDataType];
            const mergedDataTypeDefinition = {
                ...defaultDataTypeDef,
                groupSafeValueFormatter: createGroupSafeValueFormatter(defaultDataTypeDef, this.gos),
            };
            newDataTypeDefinitions[cellDataType] = mergedDataTypeDefinition;
            newFormatValueFuncs[cellDataType] = generateFormatValueFunc(mergedDataTypeDefinition);
        }
        const userDataTypeDefs = this.gos.get('dataTypeDefinitions') ?? {};
        const newDataTypeMatchers = {};
        for (const cellDataType of Object.keys(userDataTypeDefs)) {
            const userDataTypeDef = userDataTypeDefs[cellDataType];
            const mergedDataTypeDefinition = this.processDataTypeDefinition(userDataTypeDef, userDataTypeDefs, [cellDataType], defaultDataTypes);
            if (mergedDataTypeDefinition) {
                newDataTypeDefinitions[cellDataType] = mergedDataTypeDefinition;
                if (userDataTypeDef.dataTypeMatcher) {
                    newDataTypeMatchers[cellDataType] = userDataTypeDef.dataTypeMatcher;
                }
                newFormatValueFuncs[cellDataType] = generateFormatValueFunc(mergedDataTypeDefinition);
            }
        }
        const { valueParser: defaultValueParser, valueFormatter: defaultValueFormatter } = defaultDataTypes.object;
        const { valueParser: userValueParser, valueFormatter: userValueFormatter } = newDataTypeDefinitions.object;
        this.hasObjectValueParser = userValueParser !== defaultValueParser;
        this.hasObjectValueFormatter = userValueFormatter !== defaultValueFormatter;
        this.formatValueFuncs = newFormatValueFuncs;
        this.dataTypeDefinitions = newDataTypeDefinitions;
        this.dataTypeMatchers = this.sortKeysInMatchers(newDataTypeMatchers, defaultDataTypes);
    }
    /**
     * Sorts the keys in the matchers object.
     * Does not mutate the original object, creates a copy of it with sorted keys instead.
     */
    sortKeysInMatchers(matchers, dataTypes) {
        const sortedMatchers = { ...matchers };
        for (const cellDataType of SORTED_CELL_DATA_TYPES_FOR_MATCHING) {
            delete sortedMatchers[cellDataType];
            sortedMatchers[cellDataType] = matchers[cellDataType] ?? dataTypes[cellDataType].dataTypeMatcher;
        }
        return sortedMatchers;
    }
    processDataTypeDefinition(userDataTypeDef, userDataTypeDefs, alreadyProcessedDataTypes, defaultDataTypes) {
        let mergedDataTypeDefinition;
        const extendsCellDataType = userDataTypeDef.extendsDataType;
        if (userDataTypeDef.columnTypes) {
            this.isColumnTypeOverrideInDataTypeDefinitions = true;
        }
        if (userDataTypeDef.extendsDataType === userDataTypeDef.baseDataType) {
            let baseDataTypeDefinition = defaultDataTypes[extendsCellDataType];
            const overriddenBaseDataTypeDefinition = userDataTypeDefs[extendsCellDataType];
            if (baseDataTypeDefinition && overriddenBaseDataTypeDefinition) {
                // only if it's valid do we override with a provided one
                baseDataTypeDefinition = overriddenBaseDataTypeDefinition;
            }
            if (!validateDataTypeDefinition(userDataTypeDef, baseDataTypeDefinition, extendsCellDataType)) {
                return undefined;
            }
            mergedDataTypeDefinition = mergeDataTypeDefinitions(baseDataTypeDefinition, userDataTypeDef);
        }
        else {
            if (alreadyProcessedDataTypes.includes(extendsCellDataType)) {
                (0, logging_1._warn)(44);
                return undefined;
            }
            const extendedDataTypeDefinition = userDataTypeDefs[extendsCellDataType];
            if (!validateDataTypeDefinition(userDataTypeDef, extendedDataTypeDefinition, extendsCellDataType)) {
                return undefined;
            }
            const mergedExtendedDataTypeDefinition = this.processDataTypeDefinition(extendedDataTypeDefinition, userDataTypeDefs, [...alreadyProcessedDataTypes, extendsCellDataType], defaultDataTypes);
            if (!mergedExtendedDataTypeDefinition) {
                return undefined;
            }
            mergedDataTypeDefinition = mergeDataTypeDefinitions(mergedExtendedDataTypeDefinition, userDataTypeDef);
        }
        return {
            ...mergedDataTypeDefinition,
            groupSafeValueFormatter: createGroupSafeValueFormatter(mergedDataTypeDefinition, this.gos),
        };
    }
    updateColDefAndGetColumnType(colDef, userColDef, colId) {
        let { cellDataType } = userColDef;
        const { field } = userColDef;
        if (cellDataType === undefined) {
            cellDataType = colDef.cellDataType;
        }
        if (cellDataType == null || cellDataType === true) {
            cellDataType = this.canInferCellDataType(colDef, userColDef) ? this.inferCellDataType(field, colId) : false;
        }
        if (!cellDataType) {
            colDef.cellDataType = false;
            return undefined;
        }
        const dataTypeDefinition = this.dataTypeDefinitions[cellDataType];
        if (!dataTypeDefinition) {
            (0, logging_1._warn)(47, { cellDataType });
            return undefined;
        }
        colDef.cellDataType = cellDataType;
        if (dataTypeDefinition.groupSafeValueFormatter) {
            colDef.valueFormatter = dataTypeDefinition.groupSafeValueFormatter;
        }
        if (dataTypeDefinition.valueParser) {
            colDef.valueParser = dataTypeDefinition.valueParser;
        }
        if (!dataTypeDefinition.suppressDefaultProperties) {
            this.setColDefPropertiesForBaseDataType(colDef, cellDataType, dataTypeDefinition, colId);
        }
        return dataTypeDefinition.columnTypes;
    }
    addColumnListeners(column) {
        if (!this.isPendingInference) {
            return;
        }
        const columnStateUpdates = this.columnStateUpdatesPendingInference[column.getColId()];
        if (!columnStateUpdates) {
            return;
        }
        const columnListener = (event) => {
            columnStateUpdates.add(event.key);
        };
        column.__addEventListener('columnStateUpdated', columnListener);
        this.columnStateUpdateListenerDestroyFuncs.push(() => column.__removeEventListener('columnStateUpdated', columnListener));
    }
    canInferCellDataType(colDef, userColDef) {
        const { gos } = this;
        if (!(0, gridOptionsUtils_1._isClientSideRowModel)(gos)) {
            return false;
        }
        const propsToCheckForInference = { cellRenderer: true, valueGetter: true, valueParser: true, refData: true };
        if (doColDefPropsPreventInference(userColDef, propsToCheckForInference)) {
            return false;
        }
        const columnTypes = userColDef.type === null ? colDef.type : userColDef.type;
        if (columnTypes) {
            const columnTypeDefs = gos.get('columnTypes') ?? {};
            const hasPropsPreventingInference = (0, columnUtils_1.convertColumnTypes)(columnTypes).some((columnType) => {
                const columnTypeDef = columnTypeDefs[columnType.trim()];
                return columnTypeDef && doColDefPropsPreventInference(columnTypeDef, propsToCheckForInference);
            });
            if (hasPropsPreventingInference) {
                return false;
            }
        }
        return !doColDefPropsPreventInference(colDef, propsToCheckForInference);
    }
    inferCellDataType(field, colId) {
        if (!field) {
            return undefined;
        }
        let value;
        const initialData = this.getInitialData();
        if (initialData) {
            const fieldContainsDots = field.indexOf('.') >= 0 && !this.gos.get('suppressFieldDotNotation');
            value = (0, object_1._getValueUsingField)(initialData, field, fieldContainsDots);
        }
        else {
            this.initWaitForRowData(colId);
        }
        if (value == null) {
            return undefined;
        }
        const matchedType = Object.keys(this.dataTypeMatchers).find((_cellDataType) => this.dataTypeMatchers[_cellDataType](value));
        return matchedType ?? 'object';
    }
    getInitialData() {
        const rowData = this.gos.get('rowData');
        if (rowData?.length) {
            return rowData[0];
        }
        else if (this.initialData) {
            return this.initialData;
        }
        else {
            const rowNodes = this.beans.rowModel.rootNode?.allLeafChildren;
            if (rowNodes?.length) {
                return rowNodes[0].data;
            }
        }
        return null;
    }
    initWaitForRowData(colId) {
        this.columnStateUpdatesPendingInference[colId] = new Set();
        if (this.isPendingInference) {
            return;
        }
        this.isPendingInference = true;
        const columnTypeOverridesExist = this.isColumnTypeOverrideInDataTypeDefinitions;
        const { colAutosize, eventSvc } = this.beans;
        if (columnTypeOverridesExist && colAutosize) {
            colAutosize.shouldQueueResizeOperations = true;
        }
        const [destroyFunc] = this.addManagedEventListeners({
            rowDataUpdateStarted: (event) => {
                const { firstRowData } = event;
                if (!firstRowData) {
                    return;
                }
                destroyFunc?.();
                this.isPendingInference = false;
                this.processColumnsPendingInference(firstRowData, columnTypeOverridesExist);
                this.columnStateUpdatesPendingInference = {};
                if (columnTypeOverridesExist) {
                    colAutosize?.processResizeOperations();
                }
                eventSvc.dispatchEvent({
                    type: 'dataTypesInferred',
                });
            },
        });
    }
    processColumnsPendingInference(firstRowData, columnTypeOverridesExist) {
        this.initialData = firstRowData;
        const state = [];
        this.destroyColumnStateUpdateListeners();
        const newRowGroupColumnStateWithoutIndex = {};
        const newPivotColumnStateWithoutIndex = {};
        for (const colId of Object.keys(this.columnStateUpdatesPendingInference)) {
            const columnStateUpdates = this.columnStateUpdatesPendingInference[colId];
            const column = this.colModel.getCol(colId);
            if (!column) {
                return;
            }
            const oldColDef = column.getColDef();
            if (!this.resetColDefIntoCol(column, 'cellDataTypeInferred')) {
                return;
            }
            const newColDef = column.getColDef();
            if (columnTypeOverridesExist && newColDef.type && newColDef.type !== oldColDef.type) {
                const updatedColumnState = getUpdatedColumnState(column, columnStateUpdates);
                if (updatedColumnState.rowGroup && updatedColumnState.rowGroupIndex == null) {
                    newRowGroupColumnStateWithoutIndex[colId] = updatedColumnState;
                }
                if (updatedColumnState.pivot && updatedColumnState.pivotIndex == null) {
                    newPivotColumnStateWithoutIndex[colId] = updatedColumnState;
                }
                state.push(updatedColumnState);
            }
        }
        if (columnTypeOverridesExist) {
            state.push(...this.generateColumnStateForRowGroupAndPivotIndexes(newRowGroupColumnStateWithoutIndex, newPivotColumnStateWithoutIndex));
        }
        if (state.length) {
            (0, columnStateUtils_1._applyColumnState)(this.beans, { state }, 'cellDataTypeInferred');
        }
        this.initialData = null;
    }
    generateColumnStateForRowGroupAndPivotIndexes(updatedRowGroupColumnState, updatedPivotColumnState) {
        // Generally columns should appear in the order they were before. For any new columns, these should appear in the original col def order.
        // The exception is for columns that were added via `addGroupColumns`. These should appear at the end.
        // We don't have to worry about full updates, as in this case the arrays are correct, and they won't appear in the updated lists.
        const existingColumnStateUpdates = {};
        const { rowGroupColsSvc, pivotColsSvc } = this.beans;
        rowGroupColsSvc?.restoreColumnOrder(existingColumnStateUpdates, updatedRowGroupColumnState);
        pivotColsSvc?.restoreColumnOrder(existingColumnStateUpdates, updatedPivotColumnState);
        return Object.values(existingColumnStateUpdates);
    }
    resetColDefIntoCol(column, source) {
        const userColDef = column.getUserProvidedColDef();
        if (!userColDef) {
            return false;
        }
        const newColDef = (0, columnFactoryUtils_1._addColumnDefaultAndTypes)(this.beans, userColDef, column.getColId());
        column.setColDef(newColDef, userColDef, source);
        return true;
    }
    getDateStringTypeDefinition(column) {
        const { dateString } = this.dataTypeDefinitions;
        if (!column) {
            return dateString;
        }
        return (this.getDataTypeDefinition(column) ?? dateString);
    }
    getDateParserFunction(column) {
        return this.getDateStringTypeDefinition(column).dateParser;
    }
    getDateFormatterFunction(column) {
        return this.getDateStringTypeDefinition(column).dateFormatter;
    }
    getDateIncludesTimeFlag(cellDataType) {
        return cellDataType === 'dateTime' || cellDataType === 'dateTimeString';
    }
    getDataTypeDefinition(column) {
        const colDef = column.getColDef();
        if (!colDef.cellDataType) {
            return undefined;
        }
        return this.dataTypeDefinitions[colDef.cellDataType];
    }
    getBaseDataType(column) {
        return this.getDataTypeDefinition(column)?.baseDataType;
    }
    checkType(column, value) {
        if (value == null) {
            return true;
        }
        const dataTypeMatcher = this.getDataTypeDefinition(column)?.dataTypeMatcher;
        if (!dataTypeMatcher) {
            return true;
        }
        return dataTypeMatcher(value);
    }
    validateColDef(colDef) {
        const warning = (property) => (0, logging_1._warn)(48, { property });
        if (colDef.cellDataType === 'object') {
            const { object } = this.dataTypeDefinitions;
            if (colDef.valueFormatter === object.groupSafeValueFormatter && !this.hasObjectValueFormatter) {
                warning('Formatter');
            }
            if (colDef.editable && colDef.valueParser === object.valueParser && !this.hasObjectValueParser) {
                warning('Parser');
            }
        }
    }
    postProcess(colDef) {
        const cellDataType = colDef.cellDataType;
        if (!cellDataType) {
            return;
        }
        const { dataTypeDefinitions, beans, formatValueFuncs } = this;
        const dataTypeDefinition = dataTypeDefinitions[cellDataType];
        beans.colFilter?.setColDefPropsForDataType(colDef, dataTypeDefinition, formatValueFuncs[cellDataType]);
    }
    // noinspection JSUnusedGlobalSymbols
    getFormatValue(cellDataType) {
        return this.formatValueFuncs[cellDataType];
    }
    isColPendingInference(colId) {
        return this.isPendingInference && !!this.columnStateUpdatesPendingInference[colId];
    }
    setColDefPropertiesForBaseDataType(colDef, cellDataType, dataTypeDefinition, colId) {
        const formatValue = this.formatValueFuncs[cellDataType];
        const partialColDef = this.columnDefinitionPropsPerDataType[dataTypeDefinition.baseDataType]({
            colDef,
            cellDataType,
            colModel: this.colModel,
            dataTypeDefinition,
            colId,
            formatValue,
        });
        Object.assign(colDef, partialColDef);
    }
    getDateObjectTypeDef(baseDataType) {
        const translate = this.getLocaleTextFunc();
        const includeTime = this.getDateIncludesTimeFlag(baseDataType);
        return {
            baseDataType,
            valueParser: (params) => (0, date_1._parseDateTimeFromString)(params.newValue && String(params.newValue)),
            valueFormatter: (params) => {
                if (params.value == null) {
                    return '';
                }
                if (!(params.value instanceof Date) || isNaN(params.value.getTime())) {
                    return translate('invalidDate', 'Invalid Date');
                }
                return (0, date_1._serialiseDate)(params.value, includeTime) ?? '';
            },
            dataTypeMatcher: (value) => value instanceof Date,
        };
    }
    getDateStringTypeDef(baseDataType) {
        const includeTime = this.getDateIncludesTimeFlag(baseDataType);
        return {
            baseDataType,
            dateParser: (value) => (0, date_1._parseDateTimeFromString)(value) ?? undefined,
            dateFormatter: (value) => (0, date_1._serialiseDate)(value ?? null, includeTime) ?? undefined,
            valueParser: (params) => (0, date_1._isValidDate)(String(params.newValue)) ? params.newValue : null,
            valueFormatter: (params) => (0, date_1._isValidDate)(String(params.value)) ? String(params.value) : '',
            dataTypeMatcher: (value) => typeof value === 'string' && (0, date_1._isValidDate)(value),
        };
    }
    getDefaultDataTypes() {
        const translate = this.getLocaleTextFunc();
        return {
            number: {
                baseDataType: 'number',
                // can be empty space with legacy copy
                valueParser: (params) => params.newValue?.trim?.() === '' ? null : Number(params.newValue),
                valueFormatter: (params) => {
                    if (params.value == null) {
                        return '';
                    }
                    if (typeof params.value !== 'number' || isNaN(params.value)) {
                        return translate('invalidNumber', 'Invalid Number');
                    }
                    return String(params.value);
                },
                dataTypeMatcher: (value) => typeof value === 'number',
            },
            text: {
                baseDataType: 'text',
                valueParser: (params) => params.newValue === '' ? null : (0, generic_1._toStringOrNull)(params.newValue),
                dataTypeMatcher: (value) => typeof value === 'string',
            },
            boolean: {
                baseDataType: 'boolean',
                valueParser: (params) => {
                    if (params.newValue == null) {
                        return params.newValue;
                    }
                    // can be empty space with legacy copy
                    return params.newValue?.trim?.() === '' ? null : String(params.newValue).toLowerCase() === 'true';
                },
                valueFormatter: (params) => params.value == null ? '' : String(params.value),
                dataTypeMatcher: (value) => typeof value === 'boolean',
            },
            date: this.getDateObjectTypeDef('date'),
            dateString: this.getDateStringTypeDef('dateString'),
            dateTime: this.getDateObjectTypeDef('dateTime'),
            dateTimeString: {
                ...this.getDateStringTypeDef('dateTimeString'),
                dataTypeMatcher: (value) => typeof value === 'string' && (0, date_1._isValidDateTime)(value),
            },
            object: {
                baseDataType: 'object',
                valueParser: () => null,
                valueFormatter: (params) => (0, generic_1._toStringOrNull)(params.value) ?? '',
            },
        };
    }
    destroyColumnStateUpdateListeners() {
        this.columnStateUpdateListenerDestroyFuncs.forEach((destroyFunc) => destroyFunc());
        this.columnStateUpdateListenerDestroyFuncs = [];
    }
    destroy() {
        this.dataTypeDefinitions = {};
        this.dataTypeMatchers = {};
        this.formatValueFuncs = {};
        this.columnStateUpdatesPendingInference = {};
        this.destroyColumnStateUpdateListeners();
        super.destroy();
    }
}
exports.DataTypeService = DataTypeService;
function mergeDataTypeDefinitions(parentDataTypeDefinition, childDataTypeDefinition) {
    const mergedDataTypeDefinition = {
        ...parentDataTypeDefinition,
        ...childDataTypeDefinition,
    };
    if (parentDataTypeDefinition.columnTypes &&
        childDataTypeDefinition.columnTypes &&
        childDataTypeDefinition.appendColumnTypes) {
        mergedDataTypeDefinition.columnTypes = [
            ...(0, columnUtils_1.convertColumnTypes)(parentDataTypeDefinition.columnTypes),
            ...(0, columnUtils_1.convertColumnTypes)(childDataTypeDefinition.columnTypes),
        ];
    }
    return mergedDataTypeDefinition;
}
function validateDataTypeDefinition(dataTypeDefinition, parentDataTypeDefinition, parentCellDataType) {
    if (!parentDataTypeDefinition) {
        (0, logging_1._warn)(45, { parentCellDataType });
        return false;
    }
    if (parentDataTypeDefinition.baseDataType !== dataTypeDefinition.baseDataType) {
        (0, logging_1._warn)(46);
        return false;
    }
    return true;
}
function createGroupSafeValueFormatter(dataTypeDefinition, gos) {
    if (!dataTypeDefinition.valueFormatter) {
        return undefined;
    }
    return (params) => {
        if (params.node?.group) {
            const aggFunc = (params.colDef.pivotValueColumn ?? params.column).getAggFunc();
            if (aggFunc) {
                // the resulting type of these will be the same, so we call valueFormatter anyway
                if (aggFunc === 'first' || aggFunc === 'last') {
                    return dataTypeDefinition.valueFormatter(params);
                }
                if (dataTypeDefinition.baseDataType === 'number' && aggFunc !== 'count') {
                    if (typeof params.value === 'number') {
                        return dataTypeDefinition.valueFormatter(params);
                    }
                    if (typeof params.value === 'object') {
                        if (!params.value) {
                            return undefined;
                        }
                        if ('toNumber' in params.value) {
                            return dataTypeDefinition.valueFormatter({
                                ...params,
                                value: params.value.toNumber(),
                            });
                        }
                        if ('value' in params.value) {
                            return dataTypeDefinition.valueFormatter({
                                ...params,
                                value: params.value.value,
                            });
                        }
                    }
                }
                // by default don't use value formatter for agg func as type may have changed
                return undefined;
            }
        }
        else if (gos.get('groupHideOpenParents') && params.column.isRowGroupActive()) {
            // `groupHideOpenParents` passes leaf values in the group column, so need to format still.
            // If it's not a string, we know it hasn't been formatted. Otherwise check the data type matcher.
            if (typeof params.value === 'string' && !dataTypeDefinition.dataTypeMatcher?.(params.value)) {
                return undefined;
            }
        }
        return dataTypeDefinition.valueFormatter(params);
    };
}
function doesColDefPropPreventInference(colDef, checkProps, prop, comparisonValue) {
    if (!checkProps[prop]) {
        return false;
    }
    const value = colDef[prop];
    if (value === null) {
        checkProps[prop] = false;
        return false;
    }
    else {
        return comparisonValue === undefined ? !!value : value === comparisonValue;
    }
}
function doColDefPropsPreventInference(colDef, propsToCheckForInference) {
    return [
        ['cellRenderer', 'agSparklineCellRenderer'],
        ['valueGetter', undefined],
        ['valueParser', undefined],
        ['refData', undefined],
    ].some(([prop, comparisonValue]) => doesColDefPropPreventInference(colDef, propsToCheckForInference, prop, comparisonValue));
}
function getUpdatedColumnState(column, columnStateUpdates) {
    const columnState = (0, columnStateUtils_1.getColumnStateFromColDef)(column);
    columnStateUpdates.forEach((key) => {
        // if the column state has been updated, don't update again
        delete columnState[key];
        if (key === 'rowGroup') {
            delete columnState.rowGroupIndex;
        }
        else if (key === 'pivot') {
            delete columnState.pivotIndex;
        }
    });
    return columnState;
}


/***/ }),

/***/ 96034:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GroupInstanceIdCreator = void 0;
// class returns unique instance id's for columns.
// eg, the following calls (in this order) will result in:
//
// getInstanceIdForKey('country') => 0
// getInstanceIdForKey('country') => 1
// getInstanceIdForKey('country') => 2
// getInstanceIdForKey('country') => 3
// getInstanceIdForKey('age') => 0
// getInstanceIdForKey('age') => 1
// getInstanceIdForKey('country') => 4
class GroupInstanceIdCreator {
    constructor() {
        // this map contains keys to numbers, so we remember what the last call was
        this.existingIds = {};
    }
    getInstanceIdForKey(key) {
        const lastResult = this.existingIds[key];
        let result;
        if (typeof lastResult !== 'number') {
            // first time this key
            result = 0;
        }
        else {
            result = lastResult + 1;
        }
        this.existingIds[key] = result;
        return result;
    }
}
exports.GroupInstanceIdCreator = GroupInstanceIdCreator;


/***/ }),

/***/ 75626:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectionColService = void 0;
const beanStub_1 = __webpack_require__(68731);
const agColumn_1 = __webpack_require__(13355);
const gridOptionsUtils_1 = __webpack_require__(67274);
const array_1 = __webpack_require__(31502);
const columnStateUtils_1 = __webpack_require__(2885);
const columnUtils_1 = __webpack_require__(73146);
class SelectionColService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'selectionColSvc';
    }
    postConstruct() {
        this.addManagedPropertyListener('rowSelection', (event) => {
            this.onSelectionOptionsChanged(event.currentValue, event.previousValue, (0, columnUtils_1._convertColumnEventSourceType)(event.source));
        });
        this.addManagedPropertyListener('selectionColumnDef', this.updateColumns.bind(this));
    }
    addColumns(cols) {
        const selectionCols = this.columns;
        if (selectionCols == null) {
            return;
        }
        cols.list = selectionCols.list.concat(cols.list);
        cols.tree = selectionCols.tree.concat(cols.tree);
        (0, columnUtils_1._updateColsMap)(cols);
    }
    createColumns(cols, updateOrders) {
        const destroyCollection = () => {
            (0, columnUtils_1._destroyColumnTree)(this.beans, this.columns?.tree);
            this.columns = null;
        };
        const newTreeDepth = cols.treeDepth;
        const oldTreeDepth = this.columns?.treeDepth ?? -1;
        const treeDepthSame = oldTreeDepth == newTreeDepth;
        const list = this.generateSelectionCols();
        const areSame = (0, columnUtils_1._areColIdsEqual)(list, this.columns?.list ?? []);
        if (areSame && treeDepthSame) {
            return;
        }
        destroyCollection();
        const { colGroupSvc } = this.beans;
        const treeDepth = colGroupSvc?.findDepth(cols.tree) ?? 0;
        const tree = colGroupSvc?.balanceTreeForAutoCols(list, treeDepth) ?? [];
        this.columns = {
            list,
            tree,
            treeDepth,
            map: {},
        };
        const putSelectionColsFirstInList = (cols) => {
            if (!cols) {
                return null;
            }
            // we use colId, and not instance, to remove old selectionCols
            const colsFiltered = cols.filter((col) => !(0, columnUtils_1.isColumnSelectionCol)(col));
            return [...list, ...colsFiltered];
        };
        updateOrders(putSelectionColsFirstInList);
    }
    updateColumns(event) {
        const source = (0, columnUtils_1._convertColumnEventSourceType)(event.source);
        this.columns?.list.forEach((col) => {
            const newColDef = this.createSelectionColDef(event.currentValue);
            col.setColDef(newColDef, null, source);
            (0, columnStateUtils_1._applyColumnState)(this.beans, { state: [{ ...newColDef, colId: col.getColId() }] }, source);
        });
    }
    getColumn(key) {
        return this.columns?.list.find((col) => (0, columnUtils_1._columnsMatch)(col, key)) ?? null;
    }
    getColumns() {
        return this.columns?.list ?? null;
    }
    isSelectionColumnEnabled() {
        const { gos, beans } = this;
        const rowSelection = gos.get('rowSelection');
        if (typeof rowSelection !== 'object' || !(0, gridOptionsUtils_1._isRowSelection)(gos)) {
            return false;
        }
        const hasAutoCols = (beans.autoColSvc?.getColumns()?.length ?? 0) > 0;
        if (rowSelection.checkboxLocation === 'autoGroupColumn' && hasAutoCols) {
            return false;
        }
        const checkboxes = !!(0, gridOptionsUtils_1._getCheckboxes)(rowSelection);
        const headerCheckbox = (0, gridOptionsUtils_1._getHeaderCheckbox)(rowSelection);
        return checkboxes || headerCheckbox;
    }
    createSelectionColDef(def) {
        const { gos } = this.beans;
        const selectionColumnDef = def ?? gos.get('selectionColumnDef');
        const enableRTL = gos.get('enableRtl');
        // We don't support row spanning in the selection column
        const { rowSpan: _, spanRows: __, ...filteredSelColDef } = (selectionColumnDef ?? {});
        return {
            // overridable properties
            width: 50,
            resizable: false,
            suppressHeaderMenuButton: true,
            sortable: false,
            suppressMovable: true,
            lockPosition: enableRTL ? 'right' : 'left',
            comparator(valueA, valueB, nodeA, nodeB) {
                const aSelected = nodeA.isSelected();
                const bSelected = nodeB.isSelected();
                return aSelected === bSelected ? 0 : aSelected ? 1 : -1;
            },
            editable: false,
            suppressFillHandle: true,
            pinned: null,
            // overrides
            ...filteredSelColDef,
            // non-overridable properties
            colId: columnUtils_1.SELECTION_COLUMN_ID,
            chartDataType: 'excluded',
        };
    }
    generateSelectionCols() {
        if (!this.isSelectionColumnEnabled()) {
            return [];
        }
        const colDef = this.createSelectionColDef();
        const colId = colDef.colId;
        this.gos.validateColDef(colDef, colId, true);
        const col = new agColumn_1.AgColumn(colDef, null, colId, false);
        this.createBean(col);
        return [col];
    }
    onSelectionOptionsChanged(current, prev, source) {
        const prevCheckbox = prev && typeof prev !== 'string' ? (0, gridOptionsUtils_1._getCheckboxes)(prev) : undefined;
        const currCheckbox = current && typeof current !== 'string' ? (0, gridOptionsUtils_1._getCheckboxes)(current) : undefined;
        const checkboxHasChanged = prevCheckbox !== currCheckbox;
        const prevHeaderCheckbox = prev && typeof prev !== 'string' ? (0, gridOptionsUtils_1._getHeaderCheckbox)(prev) : undefined;
        const currHeaderCheckbox = current && typeof current !== 'string' ? (0, gridOptionsUtils_1._getHeaderCheckbox)(current) : undefined;
        const headerCheckboxHasChanged = prevHeaderCheckbox !== currHeaderCheckbox;
        const currLocation = (0, gridOptionsUtils_1._getCheckboxLocation)(current);
        const prevLocation = (0, gridOptionsUtils_1._getCheckboxLocation)(prev);
        const locationChanged = currLocation !== prevLocation;
        if (checkboxHasChanged || headerCheckboxHasChanged || locationChanged) {
            this.beans.colModel.refreshAll(source);
        }
    }
    destroy() {
        (0, columnUtils_1._destroyColumnTree)(this.beans, this.columns?.tree);
        super.destroy();
    }
    /**
     * Refreshes visibility of the selection column based on which columns are currently visible.
     * Called by the VisibleColsService with the columns that are currently visible in left/center/right
     * containers. This method *MUTATES* those arrays directly.
     *
     * The selection column should be visible if all of the following are true
     * - The selection column is not disabled
     * - The number of visible columns excluding the selection column and row numbers column is greater than 0
     * @param leftCols Visible columns in the left-pinned container
     * @param centerCols Visible columns in the center viewport
     * @param rightCols Visible columns in the right-pinned container
     */
    refreshVisibility(leftCols, centerCols, rightCols) {
        // columns list will only be populated if selection column is enabled
        if (!this.columns?.list.length) {
            return;
        }
        const numVisibleCols = leftCols.length + centerCols.length + rightCols.length;
        if (numVisibleCols === 0) {
            return;
        }
        // There's only one selection column
        const column = this.columns.list[0];
        // If it's deliberately hidden, we needn't do anything
        if (!column.isVisible())
            return;
        const hideSelectionCol = () => {
            let cols;
            switch (column.pinned) {
                case 'left':
                case true:
                    cols = leftCols;
                    break;
                case 'right':
                    cols = rightCols;
                    break;
                default:
                    cols = centerCols;
            }
            cols && (0, array_1._removeFromArray)(cols, column);
        };
        const rowNumbersCol = this.beans.rowNumbersSvc?.getColumn(columnUtils_1.ROW_NUMBERS_COLUMN_ID);
        // two conditions for which we hide selection column:
        //   1. Only selection column and row numbers column are visible
        //   2. Only selection column is visible
        const expectedNumCols = rowNumbersCol ? 2 : 1;
        if (expectedNumCols === numVisibleCols) {
            hideSelectionCol();
        }
    }
}
exports.SelectionColService = SelectionColService;


/***/ }),

/***/ 6869:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.depthFirstAllColumnTreeSearch = exports.VisibleColsService = void 0;
const beanStub_1 = __webpack_require__(68731);
const agColumn_1 = __webpack_require__(13355);
const agColumnGroup_1 = __webpack_require__(56908);
const array_1 = __webpack_require__(31502);
const columnUtils_1 = __webpack_require__(73146);
const groupInstanceIdCreator_1 = __webpack_require__(96034);
function _removeAllFromUnorderedArray(array, toRemove) {
    for (let i = 0; i < toRemove.length; i++) {
        const index = array.indexOf(toRemove[i]);
        if (index >= 0) {
            // preserve the last element, then shorten array length by 1 to delete index
            array[index] = array[array.length - 1];
            array.pop();
        }
    }
}
// takes in a list of columns, as specified by the column definitions, and returns column groups
class VisibleColsService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'visibleCols';
        // for fast lookup, to see if a column or group is still visible
        this.colsAndGroupsMap = {};
        // leave level columns of the displayed trees
        this.leftCols = [];
        this.rightCols = [];
        this.centerCols = [];
        // all three lists above combined
        this.allCols = [];
        // used by:
        // + angularGrid -> for setting body width
        // + rowController -> setting main row widths (when inserting and resizing)
        // need to cache this
        this.bodyWidth = 0;
        this.leftWidth = 0;
        this.rightWidth = 0;
        this.isBodyWidthDirty = true;
    }
    refresh(source, skipTreeBuild = false) {
        const { colFlex, colModel, colGroupSvc, colViewport, selectionColSvc } = this.beans;
        // when we open/close col group, skipTreeBuild=false, as we know liveCols haven't changed
        if (!skipTreeBuild) {
            this.buildTrees(colModel, colGroupSvc);
        }
        colGroupSvc?.updateOpenClosedVisibility();
        this.leftCols = pickDisplayedCols(this.treeLeft);
        this.centerCols = pickDisplayedCols(this.treeCenter);
        this.rightCols = pickDisplayedCols(this.treeRight);
        selectionColSvc?.refreshVisibility(this.leftCols, this.centerCols, this.rightCols);
        this.joinColsAriaOrder(colModel);
        this.joinCols();
        this.setLeftValues(source);
        this.autoHeightCols = this.allCols.filter((col) => col.isAutoHeight());
        colFlex?.refreshFlexedColumns();
        this.updateBodyWidths();
        colViewport.checkViewportColumns(false);
        this.setFirstRightAndLastLeftPinned(colModel, this.leftCols, this.rightCols, source);
        this.eventSvc.dispatchEvent({
            type: 'displayedColumnsChanged',
            source,
        });
    }
    // after setColumnWidth or updateGroupsAndPresentedCols
    updateBodyWidths() {
        const newBodyWidth = (0, columnUtils_1.getWidthOfColsInList)(this.centerCols);
        const newLeftWidth = (0, columnUtils_1.getWidthOfColsInList)(this.leftCols);
        const newRightWidth = (0, columnUtils_1.getWidthOfColsInList)(this.rightCols);
        // this is used by virtual col calculation, for RTL only, as a change to body width can impact displayed
        // columns, due to RTL inverting the y coordinates
        this.isBodyWidthDirty = this.bodyWidth !== newBodyWidth;
        const atLeastOneChanged = this.bodyWidth !== newBodyWidth || this.leftWidth !== newLeftWidth || this.rightWidth !== newRightWidth;
        if (atLeastOneChanged) {
            this.bodyWidth = newBodyWidth;
            this.leftWidth = newLeftWidth;
            this.rightWidth = newRightWidth;
            // this event is fired to allow the grid viewport to resize before the
            // scrollbar tries to update its visibility.
            this.eventSvc.dispatchEvent({
                type: 'columnContainerWidthChanged',
            });
            // when this fires, it is picked up by the gridPanel, which ends up in
            // gridPanel calling setWidthAndScrollPosition(), which in turn calls setViewportPosition()
            this.eventSvc.dispatchEvent({
                type: 'displayedColumnsWidthChanged',
            });
        }
    }
    // sets the left pixel position of each column
    setLeftValues(source) {
        this.setLeftValuesOfCols(source);
        this.setLeftValuesOfGroups();
    }
    setFirstRightAndLastLeftPinned(colModel, leftCols, rightCols, source) {
        let lastLeft;
        let firstRight;
        if (this.gos.get('enableRtl')) {
            lastLeft = leftCols ? leftCols[0] : null;
            firstRight = rightCols ? (0, array_1._last)(rightCols) : null;
        }
        else {
            lastLeft = leftCols ? (0, array_1._last)(leftCols) : null;
            firstRight = rightCols ? rightCols[0] : null;
        }
        colModel.getCols().forEach((col) => {
            col.setLastLeftPinned(col === lastLeft, source);
            col.setFirstRightPinned(col === firstRight, source);
        });
    }
    buildTrees(colModel, columnGroupSvc) {
        const cols = colModel.getColsToShow();
        const leftCols = cols.filter((col) => col.getPinned() == 'left');
        const rightCols = cols.filter((col) => col.getPinned() == 'right');
        const centerCols = cols.filter((col) => col.getPinned() != 'left' && col.getPinned() != 'right');
        const idCreator = new groupInstanceIdCreator_1.GroupInstanceIdCreator();
        const createGroups = (params) => {
            return columnGroupSvc ? columnGroupSvc.createColumnGroups(params) : params.columns;
        };
        this.treeLeft = createGroups({
            columns: leftCols,
            idCreator,
            pinned: 'left',
            oldDisplayedGroups: this.treeLeft,
        });
        this.treeRight = createGroups({
            columns: rightCols,
            idCreator,
            pinned: 'right',
            oldDisplayedGroups: this.treeRight,
        });
        this.treeCenter = createGroups({
            columns: centerCols,
            idCreator,
            pinned: null,
            oldDisplayedGroups: this.treeCenter,
        });
        this.updateColsAndGroupsMap();
    }
    clear() {
        this.leftCols = [];
        this.rightCols = [];
        this.centerCols = [];
        this.allCols = [];
        this.ariaOrderColumns = [];
    }
    joinColsAriaOrder(colModel) {
        const allColumns = colModel.getCols();
        const pinnedLeft = [];
        const center = [];
        const pinnedRight = [];
        for (const col of allColumns) {
            const pinned = col.getPinned();
            if (!pinned) {
                center.push(col);
            }
            else if (pinned === true || pinned === 'left') {
                pinnedLeft.push(col);
            }
            else {
                pinnedRight.push(col);
            }
        }
        this.ariaOrderColumns = pinnedLeft.concat(center).concat(pinnedRight);
    }
    getAriaColIndex(colOrGroup) {
        let col;
        if ((0, agColumnGroup_1.isColumnGroup)(colOrGroup)) {
            col = colOrGroup.getLeafColumns()[0];
        }
        else {
            col = colOrGroup;
        }
        return this.ariaOrderColumns.indexOf(col) + 1;
    }
    setLeftValuesOfGroups() {
        // a groups left value is the lest left value of it's children
        [this.treeLeft, this.treeRight, this.treeCenter].forEach((columns) => {
            columns.forEach((column) => {
                if ((0, agColumnGroup_1.isColumnGroup)(column)) {
                    const columnGroup = column;
                    columnGroup.checkLeft();
                }
            });
        });
    }
    setLeftValuesOfCols(source) {
        const { colModel } = this.beans;
        const primaryCols = colModel.getColDefCols();
        if (!primaryCols) {
            return;
        }
        // go through each list of displayed columns
        const allColumns = colModel.getCols().slice(0);
        // let totalColumnWidth = this.getWidthOfColsInList()
        const doingRtl = this.gos.get('enableRtl');
        [this.leftCols, this.rightCols, this.centerCols].forEach((columns) => {
            if (doingRtl) {
                // when doing RTL, we start at the top most pixel (ie RHS) and work backwards
                let left = (0, columnUtils_1.getWidthOfColsInList)(columns);
                columns.forEach((column) => {
                    left -= column.getActualWidth();
                    column.setLeft(left, source);
                });
            }
            else {
                // otherwise normal LTR, we start at zero
                let left = 0;
                columns.forEach((column) => {
                    column.setLeft(left, source);
                    left += column.getActualWidth();
                });
            }
            _removeAllFromUnorderedArray(allColumns, columns);
        });
        // items left in allColumns are columns not displayed, so remove the left position. this is
        // important for the rows, as if a col is made visible, then taken out, then made visible again,
        // we don't want the animation of the cell floating in from the old position, whatever that was.
        allColumns.forEach((column) => {
            column.setLeft(null, source);
        });
    }
    joinCols() {
        if (this.gos.get('enableRtl')) {
            this.allCols = this.rightCols.concat(this.centerCols).concat(this.leftCols);
        }
        else {
            this.allCols = this.leftCols.concat(this.centerCols).concat(this.rightCols);
        }
    }
    getAllTrees() {
        if (this.treeLeft && this.treeRight && this.treeCenter) {
            return this.treeLeft.concat(this.treeCenter).concat(this.treeRight);
        }
        return null;
    }
    // gridPanel -> ensureColumnVisible
    isColDisplayed(column) {
        return this.allCols.indexOf(column) >= 0;
    }
    getLeftColsForRow(rowNode) {
        const { leftCols, beans: { colModel }, } = this;
        const colSpanActive = colModel.colSpanActive;
        if (!colSpanActive) {
            return leftCols;
        }
        return this.getColsForRow(rowNode, leftCols);
    }
    getRightColsForRow(rowNode) {
        const { rightCols, beans: { colModel }, } = this;
        const colSpanActive = colModel.colSpanActive;
        if (!colSpanActive) {
            return rightCols;
        }
        return this.getColsForRow(rowNode, rightCols);
    }
    getColsForRow(rowNode, displayedColumns, filterCallback, emptySpaceBeforeColumn) {
        const result = [];
        let lastConsideredCol = null;
        for (let i = 0; i < displayedColumns.length; i++) {
            const col = displayedColumns[i];
            const maxAllowedColSpan = displayedColumns.length - i;
            const colSpan = Math.min(col.getColSpan(rowNode), maxAllowedColSpan);
            const columnsToCheckFilter = [col];
            if (colSpan > 1) {
                const colsToRemove = colSpan - 1;
                for (let j = 1; j <= colsToRemove; j++) {
                    columnsToCheckFilter.push(displayedColumns[i + j]);
                }
                i += colsToRemove;
            }
            // see which cols we should take out for column virtualisation
            let filterPasses;
            if (filterCallback) {
                // if user provided a callback, means some columns may not be in the viewport.
                // the user will NOT provide a callback if we are talking about pinned areas,
                // as pinned areas have no horizontal scroll and do not virtualise the columns.
                // if lots of columns, that means column spanning, and we set filterPasses = true
                // if one or more of the columns spanned pass the filter.
                filterPasses = false;
                columnsToCheckFilter.forEach((colForFilter) => {
                    if (filterCallback(colForFilter)) {
                        filterPasses = true;
                    }
                });
            }
            else {
                filterPasses = true;
            }
            if (filterPasses) {
                if (result.length === 0 && lastConsideredCol) {
                    const gapBeforeColumn = emptySpaceBeforeColumn ? emptySpaceBeforeColumn(col) : false;
                    if (gapBeforeColumn) {
                        result.push(lastConsideredCol);
                    }
                }
                result.push(col);
            }
            lastConsideredCol = col;
        }
        return result;
    }
    getContainerWidth(pinned) {
        switch (pinned) {
            case 'left':
                return this.leftWidth;
            case 'right':
                return this.rightWidth;
            default:
                return this.bodyWidth;
        }
    }
    getColBefore(col) {
        const allDisplayedColumns = this.allCols;
        const oldIndex = allDisplayedColumns.indexOf(col);
        if (oldIndex > 0) {
            return allDisplayedColumns[oldIndex - 1];
        }
        return null;
    }
    isPinningLeft() {
        return this.leftCols.length > 0;
    }
    isPinningRight() {
        return this.rightCols.length > 0;
    }
    updateColsAndGroupsMap() {
        this.colsAndGroupsMap = {};
        const func = (child) => {
            this.colsAndGroupsMap[child.getUniqueId()] = child;
        };
        depthFirstAllColumnTreeSearch(this.treeCenter, false, func);
        depthFirstAllColumnTreeSearch(this.treeLeft, false, func);
        depthFirstAllColumnTreeSearch(this.treeRight, false, func);
    }
    isVisible(item) {
        const fromMap = this.colsAndGroupsMap[item.getUniqueId()];
        // check for reference, in case new column / group with same id is now present
        return fromMap === item;
    }
    getFirstColumn() {
        const isRtl = this.gos.get('enableRtl');
        const queryOrder = ['leftCols', 'centerCols', 'rightCols'];
        if (isRtl) {
            queryOrder.reverse();
        }
        for (let i = 0; i < queryOrder.length; i++) {
            const container = this[queryOrder[i]];
            if (container.length) {
                return isRtl ? (0, array_1._last)(container) : container[0];
            }
        }
        return null;
    }
    // used by:
    // + rowRenderer -> for navigation
    getColAfter(col) {
        const allDisplayedColumns = this.allCols;
        const oldIndex = allDisplayedColumns.indexOf(col);
        if (oldIndex < allDisplayedColumns.length - 1) {
            return allDisplayedColumns[oldIndex + 1];
        }
        return null;
    }
    // used by:
    // + angularGrid -> setting pinned body width
    // note: this should be cached
    getColsLeftWidth() {
        return (0, columnUtils_1.getWidthOfColsInList)(this.leftCols);
    }
    // note: this should be cached
    getDisplayedColumnsRightWidth() {
        return (0, columnUtils_1.getWidthOfColsInList)(this.rightCols);
    }
    isColAtEdge(col, edge) {
        const allColumns = this.allCols;
        if (!allColumns.length) {
            return false;
        }
        const isFirst = edge === 'first';
        let columnToCompare;
        if ((0, agColumnGroup_1.isColumnGroup)(col)) {
            const leafColumns = col.getDisplayedLeafColumns();
            if (!leafColumns.length) {
                return false;
            }
            columnToCompare = isFirst ? leafColumns[0] : (0, array_1._last)(leafColumns);
        }
        else {
            columnToCompare = col;
        }
        return (isFirst ? allColumns[0] : (0, array_1._last)(allColumns)) === columnToCompare;
    }
}
exports.VisibleColsService = VisibleColsService;
function depthFirstAllColumnTreeSearch(tree, useDisplayedChildren, callback) {
    if (!tree) {
        return;
    }
    for (let i = 0; i < tree.length; i++) {
        const child = tree[i];
        if ((0, agColumnGroup_1.isColumnGroup)(child)) {
            const childTree = useDisplayedChildren ? child.getDisplayedChildren() : child.getChildren();
            depthFirstAllColumnTreeSearch(childTree, useDisplayedChildren, callback);
        }
        callback(child);
    }
}
exports.depthFirstAllColumnTreeSearch = depthFirstAllColumnTreeSearch;
function pickDisplayedCols(tree) {
    const res = [];
    depthFirstAllColumnTreeSearch(tree, true, (child) => {
        if ((0, agColumn_1.isColumn)(child)) {
            res.push(child);
        }
    });
    return res;
}


/***/ }),

/***/ 33789:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setupCompBean = exports.EmptyBean = void 0;
const beanStub_1 = __webpack_require__(68731);
/**
 * An EmptyBean can be used to manage the lifecycle of event handlers that are tied to a component instead of a controller.
 * Used in React to avoid duplicating listeners and setup logic while React is running in StrictMode where setComp will be called multiple times.
 * This is only required for the Components where the ctrl is managed by AG Grid and passed into the React component.
 * Both React and the Ctrl can decide to destroy the EmptyBean which will clean up listeners setup against it.
 */
class EmptyBean extends beanStub_1.BeanStub {
}
exports.EmptyBean = EmptyBean;
/**
 * Sets up the logic for managing the lifecycle of a compBean against a ctrl so that we always cleanup
 * our listeners and destroy the compBean when the ctrl is destroyed no matter which is destroyed first.
 * Closely related to React StrictMode as the compBean is provided from React so it can double render
 * and correctly cleanup listeners from the first render.
 * @param ctrl Ctrl that has setComp called against it
 * @param ctx  Context to use to destroy the compBean
 * @param compBean Optional compBean to use, if not provided, the ctrl will be used
 * @returns The compBean if provided, otherwise the ctrl
 */
function setupCompBean(ctrl, ctx, compBean) {
    if (compBean) {
        // If the ctrl is destroyed first, we need to destroy the compBean
        ctrl.addDestroyFunc(() => ctx.destroyBean(compBean));
    }
    return compBean ?? ctrl;
}
exports.setupCompBean = setupCompBean;


/***/ }),

/***/ 54309:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgComponentUtils = void 0;
const beanStub_1 = __webpack_require__(68731);
const dom_1 = __webpack_require__(33507);
class AgComponentUtils extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'agCompUtils';
    }
    adaptFunction(type, jsCompFunc) {
        if (!type.cellRenderer) {
            return null;
        }
        class Adapter {
            refresh() {
                return false;
            }
            getGui() {
                return this.eGui;
            }
            init(params) {
                const callbackResult = jsCompFunc(params);
                const type = typeof callbackResult;
                if (type === 'string' || type === 'number' || type === 'boolean') {
                    this.eGui = (0, dom_1._loadTemplate)('<span>' + callbackResult + '</span>');
                    return;
                }
                if (callbackResult == null) {
                    this.eGui = (0, dom_1._createElement)({ tag: 'span' });
                    return;
                }
                this.eGui = callbackResult;
            }
        }
        return Adapter;
    }
}
exports.AgComponentUtils = AgComponentUtils;


/***/ }),

/***/ 28414:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CellRendererFunctionModule = void 0;
const version_1 = __webpack_require__(97205);
const agComponentUtils_1 = __webpack_require__(54309);
/**
 * @internal
 */
exports.CellRendererFunctionModule = {
    moduleName: 'CellRendererFunction',
    version: version_1.VERSION,
    beans: [agComponentUtils_1.AgComponentUtils],
};


/***/ }),

/***/ 8759:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseComponentWrapper = void 0;
const logging_1 = __webpack_require__(47764);
class BaseComponentWrapper {
    wrap(OriginalConstructor, mandatoryMethods, optionalMethods, componentType) {
        const wrapper = this.createWrapper(OriginalConstructor, componentType);
        mandatoryMethods?.forEach((methodName) => {
            this.createMethod(wrapper, methodName, true);
        });
        optionalMethods?.forEach((methodName) => {
            this.createMethod(wrapper, methodName, false);
        });
        return wrapper;
    }
    createMethod(wrapper, methodName, mandatory) {
        wrapper.addMethod(methodName, this.createMethodProxy(wrapper, methodName, mandatory));
    }
    createMethodProxy(wrapper, methodName, mandatory) {
        return function () {
            if (wrapper.hasMethod(methodName)) {
                // eslint-disable-next-line
                return wrapper.callMethod(methodName, arguments);
            }
            if (mandatory) {
                (0, logging_1._warn)(49, { methodName });
            }
            // multiple features rely on this returning `null` rather than `undefined`,
            // so that they can differentiate whether the underlying component has implemented a void method or not
            return null;
        };
    }
}
exports.BaseComponentWrapper = BaseComponentWrapper;


/***/ }),

/***/ 34110:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Registry = void 0;
const beanStub_1 = __webpack_require__(68731);
const context_1 = __webpack_require__(62342);
const logging_1 = __webpack_require__(47764);
class Registry extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'registry';
        this.agGridDefaults = {};
        this.agGridDefaultOverrides = {};
        this.jsComps = {};
        this.selectors = {};
        this.icons = {};
    }
    postConstruct() {
        const comps = this.gos.get('components');
        if (comps != null) {
            for (const key of Object.keys(comps)) {
                this.jsComps[key] = comps[key];
            }
        }
    }
    registerModule(module) {
        const { icons, userComponents, dynamicBeans, selectors } = module;
        if (userComponents) {
            const registerUserComponent = (name, component, params, processParams) => {
                this.agGridDefaults[name] = component;
                if (params || processParams) {
                    this.agGridDefaultOverrides[name] = { params, processParams };
                }
            };
            for (const name of Object.keys(userComponents)) {
                let comp = userComponents[name];
                if ((0, context_1.isComponentMetaFunc)(comp)) {
                    comp = comp.getComp(this.beans);
                }
                if (typeof comp === 'object') {
                    const { classImp, params, processParams } = comp;
                    registerUserComponent(name, classImp, params, processParams);
                }
                else {
                    registerUserComponent(name, comp);
                }
            }
        }
        if (dynamicBeans) {
            // initialise the dynamic beans registry on first use
            this.dynamicBeans ?? (this.dynamicBeans = {});
            for (const name of Object.keys(dynamicBeans)) {
                this.dynamicBeans[name] = dynamicBeans[name];
            }
        }
        selectors?.forEach((selector) => {
            this.selectors[selector.selector] = selector;
        });
        if (icons) {
            for (const name of Object.keys(icons)) {
                this.icons[name] = icons[name];
            }
        }
    }
    getUserComponent(propertyName, name) {
        const createResult = (component, componentFromFramework, params, processParams) => ({
            componentFromFramework,
            component,
            params,
            processParams,
        });
        const { frameworkOverrides } = this.beans;
        // FrameworkOverrides.frameworkComponent() is used in two locations:
        // 1) for Vue, user provided components get registered via a framework specific way.
        // 2) for React, it's how the React UI provides alternative default components (eg GroupCellRenderer and DetailCellRenderer)
        const registeredViaFrameworkComp = frameworkOverrides.frameworkComponent(name, this.gos.get('components'));
        if (registeredViaFrameworkComp != null) {
            return createResult(registeredViaFrameworkComp, true);
        }
        const jsComponent = this.jsComps[name];
        if (jsComponent) {
            const isFwkComp = frameworkOverrides.isFrameworkComponent(jsComponent);
            return createResult(jsComponent, isFwkComp);
        }
        const defaultComponent = this.agGridDefaults[name];
        if (defaultComponent) {
            const overrides = this.agGridDefaultOverrides[name];
            return createResult(defaultComponent, false, overrides?.params, overrides?.processParams);
        }
        this.beans.validation?.missingUserComponent(propertyName, name, this.agGridDefaults, this.jsComps);
        return null;
    }
    createDynamicBean(name, mandatory, ...args) {
        if (!this.dynamicBeans) {
            // this happens when a module tries to init a dynamic bean during module initialization lifecycle
            throw new Error((0, logging_1._errMsg)(279, { name }));
        }
        const BeanClass = this.dynamicBeans[name];
        if (BeanClass == null) {
            if (mandatory) {
                throw new Error(this.beans.validation?.missingDynamicBean(name) ?? (0, logging_1._errMsg)(256));
            }
            return undefined;
        }
        return new BeanClass(...args);
    }
    getSelector(name) {
        return this.selectors[name];
    }
    getIcon(name) {
        return this.icons[name];
    }
}
exports.Registry = Registry;


/***/ }),

/***/ 54126:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._unwrapUserComp = void 0;
function _unwrapUserComp(comp) {
    const compAsAny = comp;
    const isProxy = compAsAny != null && compAsAny.getFrameworkComponentInstance != null;
    return isProxy ? compAsAny.getFrameworkComponentInstance() : comp;
}
exports._unwrapUserComp = _unwrapUserComp;


/***/ }),

/***/ 12036:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._mergeFilterParamsWithApplicationProvidedParams = exports._getFilterCompKeys = exports._getFloatingFilterCompDetails = exports._getTooltipCompDetails = exports._getNoRowsOverlayCompDetails = exports._getLoadingOverlayCompDetails = exports._getDateCompDetails = exports._getFilterDetails = exports._getCellEditorDetails = exports._getLoadingCellRendererDetails = exports._getEditorRendererDetails = exports._getCellRendererDetails = exports._getFullWidthDetailCellRendererDetails = exports._getFullWidthGroupCellRendererDetails = exports._getFullWidthLoadingCellRendererDetails = exports._getFullWidthCellRendererDetails = exports._getInnerHeaderGroupCompDetails = exports._getHeaderGroupCompDetails = exports._getInnerHeaderCompDetails = exports._getHeaderCompDetails = exports._getInnerCellRendererDetails = exports._getDragAndDropImageCompDetails = void 0;
const iFilter_1 = __webpack_require__(25679);
const userComponentFactory_1 = __webpack_require__(31585);
const DateComponent = {
    name: 'dateComponent',
    mandatoryMethods: ['getDate', 'setDate'],
    optionalMethods: ['afterGuiAttached', 'setInputPlaceholder', 'setInputAriaLabel', 'setDisabled', 'refresh'],
};
const DragAndDropImageComponent = {
    name: 'dragAndDropImageComponent',
    mandatoryMethods: ['setIcon', 'setLabel'],
};
const HeaderComponent = { name: 'headerComponent', optionalMethods: ['refresh'] };
const InnerHeaderComponent = { name: 'innerHeaderComponent' };
const InnerHeaderGroupComponent = { name: 'innerHeaderGroupComponent' };
const HeaderGroupComponent = { name: 'headerGroupComponent' };
const InnerCellRendererComponent = {
    name: 'innerRenderer',
    cellRenderer: true,
    optionalMethods: ['afterGuiAttached'],
};
const CellRendererComponent = {
    name: 'cellRenderer',
    optionalMethods: ['refresh', 'afterGuiAttached'],
    cellRenderer: true,
};
const EditorRendererComponent = {
    name: 'cellRenderer',
    optionalMethods: ['refresh', 'afterGuiAttached'],
};
const LoadingCellRendererComponent = { name: 'loadingCellRenderer', cellRenderer: true };
const CellEditorComponent = {
    name: 'cellEditor',
    mandatoryMethods: ['getValue'],
    optionalMethods: [
        'isPopup',
        'isCancelBeforeStart',
        'isCancelAfterEnd',
        'getPopupPosition',
        'focusIn',
        'focusOut',
        'afterGuiAttached',
        'refresh',
    ],
};
const LoadingOverlayComponent = { name: 'loadingOverlayComponent', optionalMethods: ['refresh'] };
const NoRowsOverlayComponent = { name: 'noRowsOverlayComponent', optionalMethods: ['refresh'] };
const TooltipComponent = { name: 'tooltipComponent' };
const FilterComponent = {
    name: 'filter',
    mandatoryMethods: ['isFilterActive', 'doesFilterPass', 'getModel', 'setModel'],
    optionalMethods: [
        'afterGuiAttached',
        'afterGuiDetached',
        'onNewRowsLoaded',
        'getModelAsString',
        'onFloatingFilterChanged',
        'onAnyFilterChanged',
        'refresh',
    ],
};
const FloatingFilterComponent = {
    name: 'floatingFilterComponent',
    mandatoryMethods: ['onParentModelChanged'],
    optionalMethods: ['afterGuiAttached', 'refresh'],
};
const FullWidth = {
    name: 'fullWidthCellRenderer',
    optionalMethods: ['refresh', 'afterGuiAttached'],
    cellRenderer: true,
};
const FullWidthLoading = { name: 'loadingCellRenderer', cellRenderer: true };
const FullWidthGroup = {
    name: 'groupRowRenderer',
    optionalMethods: ['afterGuiAttached'],
    cellRenderer: true,
};
const FullWidthDetail = { name: 'detailCellRenderer', optionalMethods: ['refresh'], cellRenderer: true };
function _getDragAndDropImageCompDetails(userCompFactory, params) {
    return userCompFactory.getCompDetailsFromGridOptions(DragAndDropImageComponent, 'agDragAndDropImage', params, true);
}
exports._getDragAndDropImageCompDetails = _getDragAndDropImageCompDetails;
function _getInnerCellRendererDetails(userCompFactory, def, params) {
    return userCompFactory.getCompDetails(def, InnerCellRendererComponent, undefined, params);
}
exports._getInnerCellRendererDetails = _getInnerCellRendererDetails;
function _getHeaderCompDetails(userCompFactory, colDef, params) {
    return userCompFactory.getCompDetails(colDef, HeaderComponent, 'agColumnHeader', params);
}
exports._getHeaderCompDetails = _getHeaderCompDetails;
function _getInnerHeaderCompDetails(userCompFactory, headerCompParams, params) {
    return userCompFactory.getCompDetails(headerCompParams, InnerHeaderComponent, undefined, params);
}
exports._getInnerHeaderCompDetails = _getInnerHeaderCompDetails;
function _getHeaderGroupCompDetails(userCompFactory, params) {
    const colGroupDef = params.columnGroup.getColGroupDef();
    return userCompFactory.getCompDetails(colGroupDef, HeaderGroupComponent, 'agColumnGroupHeader', params);
}
exports._getHeaderGroupCompDetails = _getHeaderGroupCompDetails;
function _getInnerHeaderGroupCompDetails(userCompFactory, headerGroupCompParams, params) {
    return userCompFactory.getCompDetails(headerGroupCompParams, InnerHeaderGroupComponent, undefined, params);
}
exports._getInnerHeaderGroupCompDetails = _getInnerHeaderGroupCompDetails;
// this one is unusual, as it can be LoadingCellRenderer, DetailCellRenderer, FullWidthCellRenderer or GroupRowRenderer.
// so we have to pass the type in.
function _getFullWidthCellRendererDetails(userCompFactory, params) {
    return userCompFactory.getCompDetailsFromGridOptions(FullWidth, undefined, params, true);
}
exports._getFullWidthCellRendererDetails = _getFullWidthCellRendererDetails;
function _getFullWidthLoadingCellRendererDetails(userCompFactory, params) {
    return userCompFactory.getCompDetailsFromGridOptions(FullWidthLoading, 'agLoadingCellRenderer', params, true);
}
exports._getFullWidthLoadingCellRendererDetails = _getFullWidthLoadingCellRendererDetails;
function _getFullWidthGroupCellRendererDetails(userCompFactory, params) {
    return userCompFactory.getCompDetailsFromGridOptions(FullWidthGroup, 'agGroupRowRenderer', params, true);
}
exports._getFullWidthGroupCellRendererDetails = _getFullWidthGroupCellRendererDetails;
function _getFullWidthDetailCellRendererDetails(userCompFactory, params) {
    return userCompFactory.getCompDetailsFromGridOptions(FullWidthDetail, 'agDetailCellRenderer', params, true);
}
exports._getFullWidthDetailCellRendererDetails = _getFullWidthDetailCellRendererDetails;
// CELL RENDERER
function _getCellRendererDetails(userCompFactory, def, params) {
    return userCompFactory.getCompDetails(def, CellRendererComponent, undefined, params);
}
exports._getCellRendererDetails = _getCellRendererDetails;
function _getEditorRendererDetails(userCompFactory, def, params) {
    return userCompFactory.getCompDetails(def, EditorRendererComponent, undefined, params);
}
exports._getEditorRendererDetails = _getEditorRendererDetails;
function _getLoadingCellRendererDetails(userCompFactory, def, params) {
    return userCompFactory.getCompDetails(def, LoadingCellRendererComponent, 'agSkeletonCellRenderer', params, true);
}
exports._getLoadingCellRendererDetails = _getLoadingCellRendererDetails;
// CELL EDITOR
function _getCellEditorDetails(userCompFactory, def, params) {
    return userCompFactory.getCompDetails(def, CellEditorComponent, 'agCellEditor', params, true);
}
exports._getCellEditorDetails = _getCellEditorDetails;
// FILTER
/**
 * @param defaultFilter provided filters only
 */
function _getFilterDetails(userCompFactory, def, params, defaultFilter) {
    const filter = def.filter;
    if ((0, iFilter_1.isColumnFilterComp)(filter)) {
        def = {
            filter: filter.component,
            filterParams: def.filterParams,
        };
    }
    return userCompFactory.getCompDetails(def, FilterComponent, defaultFilter, params, true);
}
exports._getFilterDetails = _getFilterDetails;
function _getDateCompDetails(userCompFactory, def, params) {
    return userCompFactory.getCompDetails(def, DateComponent, 'agDateInput', params, true);
}
exports._getDateCompDetails = _getDateCompDetails;
function _getLoadingOverlayCompDetails(userCompFactory, params) {
    return userCompFactory.getCompDetailsFromGridOptions(LoadingOverlayComponent, 'agLoadingOverlay', params, true);
}
exports._getLoadingOverlayCompDetails = _getLoadingOverlayCompDetails;
function _getNoRowsOverlayCompDetails(userCompFactory, params) {
    return userCompFactory.getCompDetailsFromGridOptions(NoRowsOverlayComponent, 'agNoRowsOverlay', params, true);
}
exports._getNoRowsOverlayCompDetails = _getNoRowsOverlayCompDetails;
function _getTooltipCompDetails(userCompFactory, params) {
    return userCompFactory.getCompDetails(params.colDef, TooltipComponent, 'agTooltipComponent', params, true);
}
exports._getTooltipCompDetails = _getTooltipCompDetails;
/**
 * @param defaultFloatingFilter provided floating filters only
 */
function _getFloatingFilterCompDetails(userCompFactory, def, params, defaultFloatingFilter) {
    return userCompFactory.getCompDetails(def, FloatingFilterComponent, defaultFloatingFilter, params);
}
exports._getFloatingFilterCompDetails = _getFloatingFilterCompDetails;
function _getFilterCompKeys(frameworkOverrides, def) {
    return (0, userComponentFactory_1._getUserCompKeys)(frameworkOverrides, def, FilterComponent);
}
exports._getFilterCompKeys = _getFilterCompKeys;
function _mergeFilterParamsWithApplicationProvidedParams(userCompFactory, defObject, paramsFromGrid) {
    return userCompFactory.mergeParams(defObject, FilterComponent, paramsFromGrid);
}
exports._mergeFilterParamsWithApplicationProvidedParams = _mergeFilterParamsWithApplicationProvidedParams;


/***/ }),

/***/ 31585:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserComponentFactory = exports._getUserCompKeys = void 0;
const beanStub_1 = __webpack_require__(68731);
const object_1 = __webpack_require__(6996);
const promise_1 = __webpack_require__(57990);
const logging_1 = __webpack_require__(47764);
function doesImplementIComponent(candidate) {
    if (!candidate) {
        return false;
    }
    return candidate.prototype && 'getGui' in candidate.prototype;
}
function _getUserCompKeys(frameworkOverrides, defObject, type, params) {
    const { name } = type;
    let compName;
    let jsComp;
    let fwComp;
    let paramsFromSelector;
    let popupFromSelector;
    let popupPositionFromSelector;
    // there are two types of js comps, class based and func based. we can only check for
    // class based, by checking if getGui() exists. no way to differentiate js func based vs eg react func based
    // const isJsClassComp = (comp: any) => doesImplementIComponent(comp);
    // const fwActive = this.frameworkCompWrapper != null;
    // pull from defObject if available
    if (defObject) {
        const defObjectAny = defObject;
        // if selector, use this
        const selectorFunc = defObjectAny[name + 'Selector'];
        const selectorRes = selectorFunc ? selectorFunc(params) : null;
        const assignComp = (providedJsComp) => {
            if (typeof providedJsComp === 'string') {
                compName = providedJsComp;
            }
            else if (providedJsComp != null && providedJsComp !== true) {
                const isFwkComp = frameworkOverrides.isFrameworkComponent(providedJsComp);
                if (isFwkComp) {
                    fwComp = providedJsComp;
                }
                else {
                    jsComp = providedJsComp;
                }
            }
        };
        if (selectorRes) {
            assignComp(selectorRes.component);
            paramsFromSelector = selectorRes.params;
            popupFromSelector = selectorRes.popup;
            popupPositionFromSelector = selectorRes.popupPosition;
        }
        else {
            // if no selector, or result of selector is empty, take from defObject
            assignComp(defObjectAny[name]);
        }
    }
    return { compName, jsComp, fwComp, paramsFromSelector, popupFromSelector, popupPositionFromSelector };
}
exports._getUserCompKeys = _getUserCompKeys;
class UserComponentFactory extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'userCompFactory';
    }
    wireBeans(beans) {
        this.agCompUtils = beans.agCompUtils;
        this.registry = beans.registry;
        this.frameworkCompWrapper = beans.frameworkCompWrapper;
        this.gridOptions = beans.gridOptions;
    }
    getCompDetailsFromGridOptions(type, defaultName, params, mandatory = false) {
        return this.getCompDetails(this.gridOptions, type, defaultName, params, mandatory);
    }
    getCompDetails(defObject, type, defaultName, params, mandatory = false) {
        const { name, cellRenderer } = type;
        let { compName, jsComp, fwComp, paramsFromSelector, popupFromSelector, popupPositionFromSelector } = _getUserCompKeys(this.beans.frameworkOverrides, defObject, type, params);
        // for grid-provided comps only
        let defaultCompParams;
        let defaultCompProcessParams;
        const lookupFromRegistry = (key) => {
            const item = this.registry.getUserComponent(name, key);
            if (item) {
                jsComp = !item.componentFromFramework ? item.component : undefined;
                fwComp = item.componentFromFramework ? item.component : undefined;
                defaultCompParams = item.params;
                defaultCompProcessParams = item.processParams;
            }
        };
        // if compOption is a string, means we need to look the item up
        if (compName != null) {
            lookupFromRegistry(compName);
        }
        // if lookup brought nothing back, and we have a default, lookup the default
        if (jsComp == null && fwComp == null && defaultName != null) {
            lookupFromRegistry(defaultName);
        }
        // if we have a comp option, and it's a function, replace it with an object equivalent adaptor
        if (jsComp && cellRenderer && !doesImplementIComponent(jsComp)) {
            jsComp = this.agCompUtils?.adaptFunction(type, jsComp);
        }
        if (!jsComp && !fwComp) {
            const { validation } = this.beans;
            if (mandatory && (compName !== defaultName || !defaultName)) {
                // expecting the user to provide a component with this name
                if (compName) {
                    // If we have validation and this is a grid comp without a default (e.g. filters tool panel),
                    // we will have already warned about this
                    if (!validation?.isProvidedUserComp(compName)) {
                        (0, logging_1._error)(50, { compName });
                    }
                }
                else {
                    if (defaultName) {
                        // validation will have already warned about this
                        if (!validation) {
                            (0, logging_1._error)(260, {
                                ...this.gos.getModuleErrorParams(),
                                propName: name,
                                compName: defaultName,
                            });
                        }
                    }
                    else {
                        (0, logging_1._error)(216, { name });
                    }
                }
            }
            else if (defaultName && !validation) {
                // Grid should be providing this component.
                // Validation service will have already warned about this with the correct module name if it was present.
                (0, logging_1._error)(146, { comp: defaultName });
            }
            return;
        }
        const paramsMerged = this.mergeParams(defObject, type, params, paramsFromSelector, defaultCompParams, defaultCompProcessParams);
        const componentFromFramework = jsComp == null;
        const componentClass = jsComp ?? fwComp;
        return {
            componentFromFramework,
            componentClass,
            params: paramsMerged,
            type: type,
            popupFromSelector,
            popupPositionFromSelector,
            newAgStackInstance: () => this.newAgStackInstance(componentClass, componentFromFramework, paramsMerged, type),
        };
    }
    newAgStackInstance(ComponentClass, componentFromFramework, params, type) {
        const jsComponent = !componentFromFramework;
        // using javascript component
        let instance;
        if (jsComponent) {
            instance = new ComponentClass();
        }
        else {
            // Using framework component
            instance = this.frameworkCompWrapper.wrap(ComponentClass, type.mandatoryMethods, type.optionalMethods, type);
        }
        this.createBean(instance);
        const deferredInit = instance.init?.(params);
        if (deferredInit == null) {
            return promise_1.AgPromise.resolve(instance);
        }
        return deferredInit.then(() => instance);
    }
    /**
     * merges params with application provided params
     * used by Floating Filter
     */
    mergeParams(defObject, type, paramsFromGrid, paramsFromSelector = null, defaultCompParams, defaultCompProcessParams) {
        const params = { ...paramsFromGrid, ...defaultCompParams };
        // pull user params from the defObject
        const defObjectAny = defObject;
        const userParams = defObjectAny && defObjectAny[type.name + 'Params'];
        if (typeof userParams === 'function') {
            const userParamsFromFunc = userParams(paramsFromGrid);
            (0, object_1._mergeDeep)(params, userParamsFromFunc);
        }
        else if (typeof userParams === 'object') {
            (0, object_1._mergeDeep)(params, userParams);
        }
        (0, object_1._mergeDeep)(params, paramsFromSelector);
        return defaultCompProcessParams ? defaultCompProcessParams(params) : params;
    }
}
exports.UserComponentFactory = UserComponentFactory;


/***/ }),

/***/ 39853:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KeyCode = void 0;
exports.KeyCode = {
    BACKSPACE: 'Backspace',
    TAB: 'Tab',
    ENTER: 'Enter',
    ESCAPE: 'Escape',
    SPACE: ' ',
    LEFT: 'ArrowLeft',
    UP: 'ArrowUp',
    RIGHT: 'ArrowRight',
    DOWN: 'ArrowDown',
    DELETE: 'Delete',
    F2: 'F2',
    PAGE_UP: 'PageUp',
    PAGE_DOWN: 'PageDown',
    PAGE_HOME: 'Home',
    PAGE_END: 'End',
    // these should be used with `event.code` instead of `event.key`
    // as `event.key` changes when non-latin keyboards are used
    A: 'KeyA',
    C: 'KeyC',
    D: 'KeyD',
    V: 'KeyV',
    X: 'KeyX',
    Y: 'KeyY',
    Z: 'KeyZ',
};


/***/ }),

/***/ 68731:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeanStub = void 0;
const localEventService_1 = __webpack_require__(85889);
const localeUtils_1 = __webpack_require__(87230);
const event_1 = __webpack_require__(92979);
class BeanStub {
    constructor() {
        this.destroyFunctions = [];
        this.destroyed = false;
        // for vue 3 - prevents Vue from trying to make this (and obviously any sub classes) from being reactive
        // prevents vue from creating proxies for created objects and prevents identity related issues
        this.__v_skip = true;
        this.propertyListenerId = 0;
        // Enable multiple grid properties to be updated together by the user but only trigger shared logic once.
        // Closely related to logic in GridOptionsUtils.ts _processOnChange
        this.lastChangeSetIdLookup = {};
        this.isAlive = () => !this.destroyed;
    }
    preWireBeans(beans) {
        this.beans = beans;
        this.stubContext = beans.context;
        this.eventSvc = beans.eventSvc;
        this.gos = beans.gos;
    }
    // this was a test constructor niall built, when active, it prints after 5 seconds all beans/components that are
    // not destroyed. to use, create a new grid, then api.destroy() before 5 seconds. then anything that gets printed
    // points to a bean or component that was not properly disposed of.
    // constructor() {
    //     setTimeout(()=> {
    //         if (this.isAlive()) {
    //             let prototype: any = Object.getPrototypeOf(this);
    //             const constructor: any = prototype.constructor;
    //             const constructorString = constructor.toString();
    //             const beanName = constructorString.substring(9, constructorString.indexOf("("));
    //             console.log('is alive ' + beanName);
    //         }
    //     }, 5000);
    // }
    destroy() {
        const { destroyFunctions } = this;
        for (let i = 0; i < destroyFunctions.length; i++) {
            destroyFunctions[i]();
        }
        destroyFunctions.length = 0;
        this.destroyed = true;
        // cast destroy type as we do not want to expose destroy event type to the dispatchLocalEvent method
        // as no one else should be firing destroyed at the bean stub.
        this.dispatchLocalEvent({ type: 'destroyed' });
    }
    // The typing of AgEventListener<any, any, any> is not ideal, but it's the best we can do at the moment to enable
    // eventSvc to have the best typing at the expense of BeanStub local events
    /** Add a local event listener against this BeanStub */
    addEventListener(eventType, listener, async) {
        if (!this.localEventService) {
            this.localEventService = new localEventService_1.LocalEventService();
        }
        this.localEventService.addEventListener(eventType, listener, async);
    }
    /** Remove a local event listener from this BeanStub */
    removeEventListener(eventType, listener, async) {
        this.localEventService?.removeEventListener(eventType, listener, async);
    }
    dispatchLocalEvent(event) {
        this.localEventService?.dispatchEvent(event);
    }
    addManagedElementListeners(object, handlers) {
        return this._setupListeners(object, handlers);
    }
    addManagedEventListeners(handlers) {
        return this._setupListeners(this.eventSvc, handlers);
    }
    addManagedListeners(object, handlers) {
        return this._setupListeners(object, handlers);
    }
    _setupListeners(object, handlers) {
        const destroyFuncs = [];
        for (const k of Object.keys(handlers)) {
            const handler = handlers[k];
            if (handler) {
                destroyFuncs.push(this._setupListener(object, k, handler));
            }
        }
        return destroyFuncs;
    }
    _setupListener(object, event, listener) {
        if (this.destroyed) {
            return () => null;
        }
        let destroyFunc;
        if (isAgEventEmitter(object)) {
            object.__addEventListener(event, listener);
            destroyFunc = () => {
                object.__removeEventListener(event, listener);
                return null;
            };
        }
        else {
            if (object instanceof HTMLElement) {
                (0, event_1._addSafePassiveEventListener)(this.beans.frameworkOverrides, object, event, listener);
            }
            else {
                object.addEventListener(event, listener);
            }
            destroyFunc = () => {
                object.removeEventListener(event, listener);
                return null;
            };
        }
        this.destroyFunctions.push(destroyFunc);
        return () => {
            destroyFunc();
            // Only remove if manually called before bean is destroyed
            this.destroyFunctions = this.destroyFunctions.filter((fn) => fn !== destroyFunc);
            return null;
        };
    }
    /**
     * Setup a managed property listener for the given GridOption property.
     * However, stores the destroy function in the beanStub so that if this bean
     * is a component the destroy function will be called when the component is destroyed
     * as opposed to being cleaned up only when the GridOptionsService is destroyed.
     */
    setupGridOptionListener(event, listener) {
        const { gos } = this;
        gos.addPropertyEventListener(event, listener);
        const destroyFunc = () => {
            gos.removePropertyEventListener(event, listener);
            return null;
        };
        this.destroyFunctions.push(destroyFunc);
        return () => {
            destroyFunc();
            // Only remove if manually called before bean is destroyed
            this.destroyFunctions = this.destroyFunctions.filter((fn) => fn !== destroyFunc);
            return null;
        };
    }
    /**
     * Setup a managed property listener for the given GridOption property.
     * @param event GridOption property to listen to changes for.
     * @param listener Listener to run when property value changes
     */
    addManagedPropertyListener(event, listener) {
        if (this.destroyed) {
            return () => null;
        }
        return this.setupGridOptionListener(event, listener);
    }
    /**
     * Setup managed property listeners for the given set of GridOption properties.
     * The listener will be run if any of the property changes but will only run once if
     * multiple of the properties change within the same framework lifecycle event.
     * Works on the basis that GridOptionsService updates all properties *before* any property change events are fired.
     * @param events Array of GridOption properties to listen for changes too.
     * @param listener Shared listener to run if any of the properties change
     */
    addManagedPropertyListeners(events, listener) {
        if (this.destroyed) {
            return;
        }
        // Ensure each set of events can run for the same changeSetId
        const eventsKey = events.join('-') + this.propertyListenerId++;
        const wrappedListener = (event) => {
            if (event.changeSet) {
                // ChangeSet is only set when the property change is part of a group of changes from ComponentUtils
                // Direct api calls should always be run as
                if (event.changeSet && event.changeSet.id === this.lastChangeSetIdLookup[eventsKey]) {
                    // Already run the listener for this set of prop changes so don't run again
                    return;
                }
                this.lastChangeSetIdLookup[eventsKey] = event.changeSet.id;
            }
            // Don't expose the underlying event value changes to the group listener.
            const propertiesChangeEvent = {
                type: 'gridPropertyChanged',
                changeSet: event.changeSet,
                source: event.source,
            };
            listener(propertiesChangeEvent);
        };
        events.forEach((event) => this.setupGridOptionListener(event, wrappedListener));
    }
    getLocaleTextFunc() {
        return (0, localeUtils_1._getLocaleTextFunc)(this.beans.localeSvc);
    }
    addDestroyFunc(func) {
        // if we are already destroyed, we execute the func now
        if (this.isAlive()) {
            this.destroyFunctions.push(func);
        }
        else {
            func();
        }
    }
    /** doesn't throw an error if `bean` is undefined */
    createOptionalManagedBean(bean, context) {
        return bean ? this.createManagedBean(bean, context) : undefined;
    }
    createManagedBean(bean, context) {
        const res = this.createBean(bean, context);
        this.addDestroyFunc(this.destroyBean.bind(this, bean, context));
        return res;
    }
    createBean(bean, context, afterPreCreateCallback) {
        return (context || this.stubContext).createBean(bean, afterPreCreateCallback);
    }
    /**
     * Destroys a bean and returns undefined to support destruction and clean up in a single line.
     * this.dateComp = this.context.destroyBean(this.dateComp);
     */
    destroyBean(bean, context) {
        return (context || this.stubContext).destroyBean(bean);
    }
    /**
     * Destroys an array of beans and returns an empty array to support destruction and clean up in a single line.
     * this.dateComps = this.context.destroyBeans(this.dateComps);
     */
    destroyBeans(beans, context) {
        return (context || this.stubContext).destroyBeans(beans);
    }
}
exports.BeanStub = BeanStub;
// type guard for IAgEventEmitter
function isAgEventEmitter(object) {
    return object.__addEventListener !== undefined;
}


/***/ }),

/***/ 62342:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Context = exports.isComponentMetaFunc = void 0;
const moduleRegistry_1 = __webpack_require__(2132);
const genericContext_1 = __webpack_require__(10569);
function isComponentMetaFunc(componentMeta) {
    return typeof componentMeta === 'object' && !!componentMeta.getComp;
}
exports.isComponentMetaFunc = isComponentMetaFunc;
class Context extends genericContext_1.GenericContext {
    init(params) {
        this.gridId = params.gridId;
        this.beans.context = this;
        this.destroyCallback = params.destroyCallback;
        super.init(params);
    }
    destroy() {
        super.destroy();
        (0, moduleRegistry_1._unRegisterGridModules)(this.gridId);
        this.destroyCallback?.();
    }
    getGridId() {
        return this.gridId;
    }
}
exports.Context = Context;


/***/ }),

/***/ 10569:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GenericContext = void 0;
class GenericContext {
    constructor(params) {
        this.beans = {};
        this.createdBeans = [];
        this.destroyed = false;
        if (!params || !params.beanClasses) {
            return;
        }
        this.beanDestroyComparator = params.beanDestroyComparator;
        this.init(params);
    }
    init(params) {
        for (const beanName of Object.keys(params.providedBeanInstances)) {
            this.beans[beanName] = params.providedBeanInstances[beanName];
        }
        params.beanClasses.forEach((BeanClass) => {
            const instance = new BeanClass();
            if (instance.beanName) {
                this.beans[instance.beanName] = instance;
            }
            else {
                // eslint-disable-next-line no-console
                console.error(`Bean ${BeanClass.name} is missing beanName`);
            }
            this.createdBeans.push(instance);
        });
        params.derivedBeans?.forEach((beanFunc) => {
            const { beanName, bean } = beanFunc(this);
            this.beans[beanName] = bean;
            this.createdBeans.push(bean);
        });
        if (params.beanInitComparator) {
            // sort the beans so that they are in a consistent order
            this.createdBeans.sort(params.beanInitComparator);
        }
        this.initBeans(this.createdBeans);
    }
    getBeanInstances() {
        return Object.values(this.beans);
    }
    createBean(bean, afterPreCreateCallback) {
        this.initBeans([bean], afterPreCreateCallback);
        return bean;
    }
    initBeans(beanInstances, afterPreCreateCallback) {
        beanInstances.forEach((instance) => {
            // used by BaseBeans to avoid the need for calling super.wireBeans() in every subclasses
            instance.preWireBeans?.(this.beans);
            instance.wireBeans?.(this.beans);
        });
        // used by the component class
        beanInstances.forEach((instance) => instance.preConstruct?.());
        if (afterPreCreateCallback) {
            beanInstances.forEach(afterPreCreateCallback);
        }
        beanInstances.forEach((instance) => instance.postConstruct?.());
    }
    getBeans() {
        return this.beans;
    }
    getBean(name) {
        return this.beans[name];
    }
    destroy() {
        if (this.destroyed) {
            return;
        }
        // Set before doing the destroy, so if context.destroy() gets called via another bean
        // we are marked as destroyed already to prevent running destroy() twice
        this.destroyed = true;
        const beanInstances = this.getBeanInstances();
        if (this.beanDestroyComparator) {
            beanInstances.sort(this.beanDestroyComparator);
        }
        this.destroyBeans(beanInstances);
        this.beans = {};
        this.createdBeans = [];
    }
    /**
     * Destroys a bean and returns undefined to support destruction and clean up in a single line.
     * this.dateComp = this.context.destroyBean(this.dateComp);
     */
    destroyBean(bean) {
        bean?.destroy?.();
    }
    /**
     * Destroys an array of beans and returns an empty array to support destruction and clean up in a single line.
     * this.dateComps = this.context.destroyBeans(this.dateComps);
     */
    destroyBeans(beans) {
        if (beans) {
            for (let i = 0; i < beans.length; i++) {
                this.destroyBean(beans[i]);
            }
        }
        return [];
    }
    isDestroyed() {
        return this.destroyed;
    }
}
exports.GenericContext = GenericContext;


/***/ }),

/***/ 23943:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.gridBeanDestroyComparator = exports.gridBeanInitComparator = void 0;
/**
 * We know that there is a risk in a change of behaviour if beans are registered in a different order due to the way
 * that this means that their event listeners will be registered in a different order. If they fire in a different order
 * there is a risk that behaviour will be inconsistent.
 * As core beans are going to become optional and could be registered in unpredictable orders via feature modules,
 * we need to provide a consistent order for them to be registered in.
 *
 * We have not included beans from modules as they will be registered after the core beans in the order they are provided.
 */
const orderedCoreBeans = [
    // Validate license first
    'licenseManager',
    // core beans only
    'environment',
    'eventSvc',
    'gos',
    'paginationAutoPageSizeSvc',
    'apiFunctionSvc',
    'gridApi',
    'registry',
    'agCompUtils',
    'userCompFactory',
    'rowContainerHeight',
    'horizontalResizeSvc',
    'localeSvc',
    'pinnedRowModel',
    'dragSvc',
    'colGroupSvc',
    'visibleCols',
    'popupSvc',
    'selectionSvc',
    'colFilter',
    'quickFilter',
    'filterManager',
    'colModel',
    'headerNavigation',
    'pageBounds',
    'pagination',
    'pageBoundsListener',
    'rowSpanSvc',
    'stickyRowSvc',
    'rowRenderer',
    'expressionSvc',
    'alignedGridsSvc',
    'navigation',
    'valueCache',
    'valueSvc',
    'autoWidthCalc',
    'filterMenuFactory',
    'dragAndDrop',
    'focusSvc',
    'cellNavigation',
    'cellStyles',
    'scrollVisibleSvc',
    'sortSvc',
    'colHover',
    'colAnimation',
    'autoColSvc',
    'selectionColSvc',
    'changeDetectionSvc',
    'animationFrameSvc',
    'undoRedo',
    'colDefFactory',
    'rowStyleSvc',
    'rowNodeBlockLoader',
    'rowNodeSorter',
    'ctrlsSvc',
    'pinnedCols',
    'dataTypeSvc',
    'syncSvc',
    'overlays',
    'stateSvc',
    'expansionSvc',
    'apiEventSvc',
    'ariaAnnounce',
    'menuSvc',
    'colMoves',
    'colAutosize',
    'colFlex',
    'colResize',
    'pivotColsSvc',
    'valueColsSvc',
    'rowGroupColsSvc',
    'funcColsSvc',
    'colNames',
    'colViewport',
    'pivotResultCols',
    'showRowGroupCols',
    'validation', // Have validations run last
];
const beanNamePosition = Object.fromEntries(orderedCoreBeans.map((beanName, index) => [beanName, index]));
function gridBeanInitComparator(bean1, bean2) {
    // if the beans are not in the ordered list, just ensure they are after the ordered beans and stable to provided order
    const index1 = (bean1.beanName ? beanNamePosition[bean1.beanName] : undefined) ?? Number.MAX_SAFE_INTEGER;
    const index2 = (bean2.beanName ? beanNamePosition[bean2.beanName] : undefined) ?? Number.MAX_SAFE_INTEGER;
    return index1 - index2;
}
exports.gridBeanInitComparator = gridBeanInitComparator;
function gridBeanDestroyComparator(bean1, 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
bean2) {
    if (bean1?.beanName === 'gridDestroySvc') {
        return -1;
    }
    if (bean2?.beanName === 'gridDestroySvc') {
        return 1;
    }
    return 0;
}
exports.gridBeanDestroyComparator = gridBeanDestroyComparator;


/***/ }),

/***/ 1310:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CsvCreator = void 0;
const baseCreator_1 = __webpack_require__(47331);
const downloader_1 = __webpack_require__(3885);
const gridOptionsUtils_1 = __webpack_require__(67274);
const logging_1 = __webpack_require__(47764);
const csvSerializingSession_1 = __webpack_require__(32927);
class CsvCreator extends baseCreator_1.BaseCreator {
    constructor() {
        super(...arguments);
        this.beanName = 'csvCreator';
    }
    wireBeans(beans) {
        this.colModel = beans.colModel;
        this.colNames = beans.colNames;
        this.rowGroupColsSvc = beans.rowGroupColsSvc;
        this.valueSvc = beans.valueSvc;
    }
    getMergedParams(params) {
        const baseParams = this.gos.get('defaultCsvExportParams');
        return Object.assign({}, baseParams, params);
    }
    export(userParams) {
        if (this.isExportSuppressed()) {
            // Export cancelled.
            (0, logging_1._warn)(51);
            return;
        }
        const mergedParams = this.getMergedParams(userParams);
        const data = this.getData(mergedParams);
        const packagedFile = new Blob(['\ufeff', data], { type: 'text/plain' });
        const fileName = typeof mergedParams.fileName === 'function'
            ? mergedParams.fileName((0, gridOptionsUtils_1._addGridCommonParams)(this.gos, {}))
            : mergedParams.fileName;
        (0, downloader_1._downloadFile)(this.getFileName(fileName), packagedFile);
    }
    exportDataAsCsv(params) {
        this.export(params);
    }
    getDataAsCsv(params, skipDefaultParams = false) {
        const mergedParams = skipDefaultParams ? Object.assign({}, params) : this.getMergedParams(params);
        return this.getData(mergedParams);
    }
    getDefaultFileExtension() {
        return 'csv';
    }
    createSerializingSession(params) {
        const { colModel, colNames, rowGroupColsSvc, valueSvc, gos } = this;
        const { processCellCallback, processHeaderCallback, processGroupHeaderCallback, processRowGroupCallback, suppressQuotes, columnSeparator, } = params;
        return new csvSerializingSession_1.CsvSerializingSession({
            colModel,
            colNames,
            valueSvc,
            gos,
            processCellCallback: processCellCallback || undefined,
            processHeaderCallback: processHeaderCallback || undefined,
            processGroupHeaderCallback: processGroupHeaderCallback || undefined,
            processRowGroupCallback: processRowGroupCallback || undefined,
            suppressQuotes: suppressQuotes || false,
            columnSeparator: columnSeparator || ',',
            rowGroupColsSvc,
        });
    }
    isExportSuppressed() {
        return this.gos.get('suppressCsvExport');
    }
}
exports.CsvCreator = CsvCreator;


/***/ }),

/***/ 72984:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.exportDataAsCsv = exports.getDataAsCsv = void 0;
function getDataAsCsv(beans, params) {
    return beans.csvCreator?.getDataAsCsv(params);
}
exports.getDataAsCsv = getDataAsCsv;
function exportDataAsCsv(beans, params) {
    beans.csvCreator?.exportDataAsCsv(params);
}
exports.exportDataAsCsv = exportDataAsCsv;


/***/ }),

/***/ 59734:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CsvExportModule = void 0;
const exportModule_1 = __webpack_require__(92728);
const version_1 = __webpack_require__(97205);
const csvCreator_1 = __webpack_require__(1310);
const csvExportApi_1 = __webpack_require__(72984);
/**
 * @feature Import & Export -> CSV Export
 */
exports.CsvExportModule = {
    moduleName: 'CsvExport',
    version: version_1.VERSION,
    beans: [csvCreator_1.CsvCreator],
    apiFunctions: {
        getDataAsCsv: csvExportApi_1.getDataAsCsv,
        exportDataAsCsv: csvExportApi_1.exportDataAsCsv,
    },
    dependsOn: [exportModule_1.SharedExportModule],
};


/***/ }),

/***/ 32927:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CsvSerializingSession = void 0;
const baseGridSerializingSession_1 = __webpack_require__(68376);
const logging_1 = __webpack_require__(47764);
const LINE_SEPARATOR = '\r\n';
class CsvSerializingSession extends baseGridSerializingSession_1.BaseGridSerializingSession {
    constructor(config) {
        super(config);
        this.config = config;
        this.isFirstLine = true;
        this.result = '';
        const { suppressQuotes, columnSeparator } = config;
        this.suppressQuotes = suppressQuotes;
        this.columnSeparator = columnSeparator;
    }
    addCustomContent(content) {
        if (!content) {
            return;
        }
        if (typeof content === 'string') {
            if (!/^\s*\n/.test(content)) {
                this.beginNewLine();
            }
            // replace whatever newlines are supplied with the style we're using
            content = content.replace(/\r?\n/g, LINE_SEPARATOR);
            this.result += content;
        }
        else {
            content.forEach((row) => {
                this.beginNewLine();
                row.forEach((cell, index) => {
                    if (index !== 0) {
                        this.result += this.columnSeparator;
                    }
                    this.result += this.putInQuotes(cell.data.value || '');
                    if (cell.mergeAcross) {
                        this.appendEmptyCells(cell.mergeAcross);
                    }
                });
            });
        }
    }
    onNewHeaderGroupingRow() {
        this.beginNewLine();
        return {
            onColumn: this.onNewHeaderGroupingRowColumn.bind(this),
        };
    }
    onNewHeaderGroupingRowColumn(columnGroup, header, index, span) {
        if (index != 0) {
            this.result += this.columnSeparator;
        }
        this.result += this.putInQuotes(header);
        this.appendEmptyCells(span);
    }
    appendEmptyCells(count) {
        for (let i = 1; i <= count; i++) {
            this.result += this.columnSeparator + this.putInQuotes('');
        }
    }
    onNewHeaderRow() {
        this.beginNewLine();
        return {
            onColumn: this.onNewHeaderRowColumn.bind(this),
        };
    }
    onNewHeaderRowColumn(column, index) {
        if (index != 0) {
            this.result += this.columnSeparator;
        }
        this.result += this.putInQuotes(this.extractHeaderValue(column));
    }
    onNewBodyRow() {
        this.beginNewLine();
        return {
            onColumn: this.onNewBodyRowColumn.bind(this),
        };
    }
    onNewBodyRowColumn(column, index, node) {
        if (index != 0) {
            this.result += this.columnSeparator;
        }
        const rowCellValue = this.extractRowCellValue(column, index, index, 'csv', node);
        this.result += this.putInQuotes(rowCellValue.valueFormatted ?? rowCellValue.value);
    }
    putInQuotes(value) {
        if (this.suppressQuotes) {
            return value;
        }
        if (value === null || value === undefined) {
            return '""';
        }
        let stringValue;
        if (typeof value === 'string') {
            stringValue = value;
        }
        else if (typeof value.toString === 'function') {
            stringValue = value.toString();
        }
        else {
            (0, logging_1._warn)(53);
            stringValue = '';
        }
        // replace each " with "" (ie two sets of double quotes is how to do double quotes in csv)
        const valueEscaped = stringValue.replace(/"/g, '""');
        return '"' + valueEscaped + '"';
    }
    parse() {
        return this.result;
    }
    beginNewLine() {
        if (!this.isFirstLine) {
            this.result += LINE_SEPARATOR;
        }
        this.isFirstLine = false;
    }
}
exports.CsvSerializingSession = CsvSerializingSession;


/***/ }),

/***/ 80020:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CtrlsService = void 0;
const beanStub_1 = __webpack_require__(68731);
/**
 * This is the number of controls defined above in `ReadyParams`.
 * This allows us to quickly know when all controls have been registered.
 */
const NUM_CTRLS = 23;
// for all controllers that are singletons, they can register here so other parts
// of the application can access them.
class CtrlsService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'ctrlsSvc';
        this.params = {};
        this.ready = false;
        this.readyCallbacks = [];
    }
    postConstruct() {
        // With React 19 StrictMode, ctrlService can be ready twice.
        // The first time after the first render cycle, and the second time after the second render cycle which is only done in StrictMode.
        // By making the local events async, we effectively debounce the first ready event until after the second render cycle has completed.
        // This means that the ready logic across the grid will run against the currently rendered components and controllers.
        // We make this async only for React 19 as StrictMode in React 19 double fires ref callbacks whereas previous versions of React do not.
        this.addEventListener('ready', () => {
            this.updateReady();
            if (this.ready) {
                this.readyCallbacks.forEach((c) => c(this.params));
                this.readyCallbacks.length = 0;
            }
        }, this.beans.frameworkOverrides.runWhenReadyAsync?.() ?? false);
    }
    updateReady() {
        const values = Object.values(this.params);
        // ready when all ctrls have been registered and are alive
        this.ready =
            values.length === NUM_CTRLS &&
                values.every((ctrl) => {
                    return ctrl?.isAlive() ?? false;
                });
    }
    whenReady(caller, callback) {
        if (this.ready) {
            callback(this.params);
        }
        else {
            this.readyCallbacks.push(callback);
        }
        caller.addDestroyFunc(() => {
            // remove the callback if the caller is destroyed so that we don't call it against a destroyed component
            const index = this.readyCallbacks.indexOf(callback);
            if (index >= 0) {
                this.readyCallbacks.splice(index, 1);
            }
        });
    }
    register(ctrlType, ctrl) {
        this.params[ctrlType] = ctrl;
        this.updateReady();
        if (this.ready) {
            this.dispatchLocalEvent({ type: 'ready' });
        }
        ctrl.addDestroyFunc(() => {
            // Ensure ready is false when a controller is destroyed
            // We do not clear them as a lot of code still runs during destroy logic which may need access to the controllers
            // NOTE: This is not ideal and we should look to stop logic using controllers during destroy
            this.updateReady();
        });
    }
    get(ctrlType) {
        return this.params[ctrlType];
    }
    getGridBodyCtrl() {
        return this.params.gridBodyCtrl;
    }
    getHeaderRowContainerCtrls() {
        const { leftHeader, centerHeader, rightHeader } = this.params;
        return [leftHeader, rightHeader, centerHeader];
    }
    getHeaderRowContainerCtrl(pinned) {
        const params = this.params;
        switch (pinned) {
            case 'left':
                return params.leftHeader;
            case 'right':
                return params.rightHeader;
            default:
                return params.centerHeader;
        }
    }
    getScrollFeature() {
        return this.getGridBodyCtrl().scrollFeature;
    }
}
exports.CtrlsService = CtrlsService;


/***/ }),

/***/ 82671:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dragAndDropImageComponentCSS = void 0;
exports.dragAndDropImageComponentCSS = `.ag-dnd-ghost{align-items:center;background-color:var(--ag-drag-and-drop-image-background-color);border:var(--ag-drag-and-drop-image-border);border-radius:var(--ag-border-radius);box-shadow:var(--ag-drag-and-drop-image-shadow);color:var(--ag-text-color);cursor:move;display:flex;font-weight:500;gap:var(--ag-cell-widget-spacing);height:var(--ag-header-height);overflow:hidden;padding-left:var(--ag-cell-horizontal-padding);padding-right:var(--ag-cell-horizontal-padding);text-overflow:ellipsis;transform:translateY(calc(var(--ag-spacing)*2));white-space:nowrap}`;


/***/ }),

/***/ 33814:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DragAndDropImageComponent = void 0;
const dom_1 = __webpack_require__(33507);
const icon_1 = __webpack_require__(59970);
const component_1 = __webpack_require__(78020);
const dragAndDropImageComponent_css_GENERATED_1 = __webpack_require__(82671);
// the wrapper div has no class - the drag and drop service adds the theme class to it
const DragAndDropElement = {
    tag: 'div',
    children: [
        {
            tag: 'div',
            ref: 'eGhost',
            cls: 'ag-dnd-ghost ag-unselectable',
            children: [
                { tag: 'span', ref: 'eIcon', cls: 'ag-dnd-ghost-icon ag-shake-left-to-right' },
                { tag: 'div', ref: 'eLabel', cls: 'ag-dnd-ghost-label' },
            ],
        },
    ],
};
class DragAndDropImageComponent extends component_1.Component {
    constructor() {
        super();
        this.dragSource = null;
        this.eIcon = component_1.RefPlaceholder;
        this.eLabel = component_1.RefPlaceholder;
        this.eGhost = component_1.RefPlaceholder;
        this.registerCSS(dragAndDropImageComponent_css_GENERATED_1.dragAndDropImageComponentCSS);
    }
    postConstruct() {
        const create = (iconName) => (0, icon_1._createIcon)(iconName, this.beans, null);
        this.dropIconMap = {
            pinned: create('columnMovePin'),
            hide: create('columnMoveHide'),
            move: create('columnMoveMove'),
            left: create('columnMoveLeft'),
            right: create('columnMoveRight'),
            group: create('columnMoveGroup'),
            aggregate: create('columnMoveValue'),
            pivot: create('columnMovePivot'),
            notAllowed: create('dropNotAllowed'),
        };
    }
    init(params) {
        this.dragSource = params.dragSource;
        this.setTemplate(DragAndDropElement);
        // also apply theme class to the ghost element for backwards compatibility
        // with themes that use .ag-theme-classname.ag-dnd-ghost, which used to be
        // required before the theme class was also set on the wrapper.
        this.beans.environment.applyThemeClasses(this.eGhost);
    }
    destroy() {
        this.dragSource = null;
        super.destroy();
    }
    setIcon(iconName, shake) {
        const { eIcon, dragSource, dropIconMap, gos } = this;
        (0, dom_1._clearElement)(eIcon);
        let eIconChild = null;
        if (!iconName) {
            iconName = dragSource?.getDefaultIconName ? dragSource.getDefaultIconName() : 'notAllowed';
        }
        eIconChild = dropIconMap[iconName];
        eIcon.classList.toggle('ag-shake-left-to-right', shake);
        if (eIconChild === dropIconMap['hide'] && gos.get('suppressDragLeaveHidesColumns')) {
            return;
        }
        if (eIconChild) {
            eIcon.appendChild(eIconChild);
        }
    }
    setLabel(label) {
        this.eLabel.textContent = label;
    }
}
exports.DragAndDropImageComponent = DragAndDropImageComponent;


/***/ }),

/***/ 12903:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DragAndDropService = exports.DragSourceType = void 0;
const userCompUtils_1 = __webpack_require__(12036);
const beanStub_1 = __webpack_require__(68731);
const mouseEventUtils_1 = __webpack_require__(8399);
const gridOptionsUtils_1 = __webpack_require__(67274);
const array_1 = __webpack_require__(31502);
const logging_1 = __webpack_require__(47764);
var DragSourceType;
(function (DragSourceType) {
    DragSourceType[DragSourceType["ToolPanel"] = 0] = "ToolPanel";
    DragSourceType[DragSourceType["HeaderCell"] = 1] = "HeaderCell";
    DragSourceType[DragSourceType["RowDrag"] = 2] = "RowDrag";
    DragSourceType[DragSourceType["ChartPanel"] = 3] = "ChartPanel";
    DragSourceType[DragSourceType["AdvancedFilterBuilder"] = 4] = "AdvancedFilterBuilder";
})(DragSourceType || (exports.DragSourceType = DragSourceType = {}));
class DragAndDropService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'dragAndDrop';
        this.dragSourceAndParamsList = [];
        this.dropTargets = [];
    }
    wireBeans(beans) {
        this.ctrlsSvc = beans.ctrlsSvc;
        this.dragSvc = beans.dragSvc;
        this.environment = beans.environment;
        this.userCompFactory = beans.userCompFactory;
    }
    addDragSource(dragSource, allowTouch = false) {
        const params = {
            eElement: dragSource.eElement,
            dragStartPixels: dragSource.dragStartPixels,
            onDragStart: this.onDragStart.bind(this, dragSource),
            onDragStop: this.onDragStop.bind(this),
            onDragging: this.onDragging.bind(this),
            onDragCancel: this.onDragCancel.bind(this),
            includeTouch: allowTouch,
        };
        this.dragSourceAndParamsList.push({ params: params, dragSource: dragSource });
        this.dragSvc.addDragSource(params);
    }
    getDragAndDropImageComponent() {
        const { dragAndDropImageComp } = this;
        if (!dragAndDropImageComp || !dragAndDropImageComp.comp) {
            return null;
        }
        return dragAndDropImageComp.comp;
    }
    removeDragSource(dragSource) {
        const { dragSourceAndParamsList, dragSvc } = this;
        const sourceAndParams = dragSourceAndParamsList.find((item) => item.dragSource === dragSource);
        if (sourceAndParams) {
            dragSvc.removeDragSource(sourceAndParams.params);
            (0, array_1._removeFromArray)(dragSourceAndParamsList, sourceAndParams);
        }
    }
    destroy() {
        const { dragSourceAndParamsList, dragSvc, dropTargets } = this;
        dragSourceAndParamsList.forEach((sourceAndParams) => dragSvc.removeDragSource(sourceAndParams.params));
        dragSourceAndParamsList.length = 0;
        dropTargets.length = 0;
        this.clearDragAndDropProperties();
        super.destroy();
    }
    nudge() {
        if (this.dragging) {
            this.onDragging(this.eventLastTime, true);
        }
    }
    onDragStart(dragSource, mouseEvent) {
        this.dragging = true;
        this.dragSource = dragSource;
        this.eventLastTime = mouseEvent;
        this.dragItem = dragSource.getDragItem();
        dragSource.onDragStarted?.();
        this.createDragAndDropImageComponent();
    }
    onDragStop(mouseEvent) {
        this.dragSource?.onDragStopped?.();
        const { lastDropTarget } = this;
        if (lastDropTarget?.onDragStop) {
            const draggingEvent = this.createDropTargetEvent(lastDropTarget, mouseEvent, null, null, false);
            lastDropTarget.onDragStop(draggingEvent);
        }
        this.clearDragAndDropProperties();
    }
    onDragCancel() {
        const { dragSource, lastDropTarget } = this;
        dragSource?.onDragCancelled?.();
        if (lastDropTarget?.onDragCancel) {
            lastDropTarget.onDragCancel(this.createDropTargetEvent(lastDropTarget, this.eventLastTime, null, null, false));
        }
        this.clearDragAndDropProperties();
    }
    clearDragAndDropProperties() {
        this.eventLastTime = null;
        this.dragging = false;
        this.lastDropTarget = undefined;
        this.dragItem = null;
        this.dragSource = null;
        this.removeDragAndDropImageComponent();
    }
    onDragging(mouseEvent, fromNudge = false) {
        const hDirection = this.getHorizontalDirection(mouseEvent);
        const vDirection = this.getVerticalDirection(mouseEvent);
        this.eventLastTime = mouseEvent;
        this.positionDragAndDropImageComp(mouseEvent);
        // check if mouseEvent intersects with any of the drop targets
        const validDropTargets = this.dropTargets.filter((target) => this.isMouseOnDropTarget(mouseEvent, target));
        const dropTarget = this.findCurrentDropTarget(mouseEvent, validDropTargets);
        const { lastDropTarget, dragSource, dragAndDropImageComp, dragItem } = this;
        if (dropTarget !== lastDropTarget) {
            this.leaveLastTargetIfExists(mouseEvent, hDirection, vDirection, fromNudge);
            if (lastDropTarget !== null && dropTarget === null) {
                dragSource?.onGridExit?.(dragItem);
            }
            if (lastDropTarget === null && dropTarget !== null) {
                dragSource?.onGridEnter?.(dragItem);
            }
            this.enterDragTargetIfExists(dropTarget, mouseEvent, hDirection, vDirection, fromNudge);
            if (dropTarget && dragAndDropImageComp) {
                const { comp, promise } = dragAndDropImageComp;
                if (comp) {
                    comp.setIcon(dropTarget.getIconName ? dropTarget.getIconName() : null, false);
                }
                else {
                    promise.then((resolvedComponent) => {
                        if (resolvedComponent) {
                            resolvedComponent.setIcon(dropTarget.getIconName ? dropTarget.getIconName() : null, false);
                        }
                    });
                }
            }
            this.lastDropTarget = dropTarget;
        }
        else if (dropTarget && dropTarget.onDragging) {
            const draggingEvent = this.createDropTargetEvent(dropTarget, mouseEvent, hDirection, vDirection, fromNudge);
            dropTarget.onDragging(draggingEvent);
        }
    }
    getAllContainersFromDropTarget(dropTarget) {
        const secondaryContainers = dropTarget.getSecondaryContainers ? dropTarget.getSecondaryContainers() : null;
        const containers = [[dropTarget.getContainer()]];
        return secondaryContainers ? containers.concat(secondaryContainers) : containers;
    }
    // checks if the mouse is on the drop target. it checks eContainer and eSecondaryContainers
    isMouseOnDropTarget(mouseEvent, dropTarget) {
        const allContainersFromDropTarget = this.getAllContainersFromDropTarget(dropTarget);
        let mouseOverTarget = false;
        const allContainersIntersect = (mouseEvent, containers) => {
            for (const container of containers) {
                const { width, height, left, right, top, bottom } = container.getBoundingClientRect();
                // if element is not visible, then width and height are zero
                if (width === 0 || height === 0) {
                    return false;
                }
                const horizontalFit = mouseEvent.clientX >= left && mouseEvent.clientX < right;
                const verticalFit = mouseEvent.clientY >= top && mouseEvent.clientY < bottom;
                if (!horizontalFit || !verticalFit) {
                    return false;
                }
            }
            return true;
        };
        for (const currentContainers of allContainersFromDropTarget) {
            if (allContainersIntersect(mouseEvent, currentContainers)) {
                mouseOverTarget = true;
                break;
            }
        }
        const { eElement, type } = this.dragSource;
        if (dropTarget.targetContainsSource && !dropTarget.getContainer().contains(eElement)) {
            return false;
        }
        return mouseOverTarget && dropTarget.isInterestedIn(type, eElement);
    }
    findCurrentDropTarget(mouseEvent, validDropTargets) {
        const len = validDropTargets.length;
        if (len === 0) {
            return null;
        }
        if (len === 1) {
            return validDropTargets[0];
        }
        const rootNode = (0, gridOptionsUtils_1._getRootNode)(this.beans);
        // elementsFromPoint return a list of elements under
        // the mouseEvent sorted from topMost to bottomMost
        const elementStack = rootNode.elementsFromPoint(mouseEvent.clientX, mouseEvent.clientY);
        // loop over the sorted elementStack to find which dropTarget comes first
        for (const el of elementStack) {
            for (const dropTarget of validDropTargets) {
                const containers = this.getAllContainersFromDropTarget(dropTarget).flatMap((a) => a);
                if (containers.indexOf(el) !== -1) {
                    return dropTarget;
                }
            }
        }
        // we should never hit this point of the code because only
        // valid dropTargets should be provided to this method.
        return null;
    }
    enterDragTargetIfExists(dropTarget, mouseEvent, hDirection, vDirection, fromNudge) {
        if (!dropTarget) {
            return;
        }
        if (dropTarget.onDragEnter) {
            const dragEnterEvent = this.createDropTargetEvent(dropTarget, mouseEvent, hDirection, vDirection, fromNudge);
            dropTarget.onDragEnter(dragEnterEvent);
        }
    }
    leaveLastTargetIfExists(mouseEvent, hDirection, vDirection, fromNudge) {
        const { lastDropTarget } = this;
        if (!lastDropTarget) {
            return;
        }
        if (lastDropTarget.onDragLeave) {
            const dragLeaveEvent = this.createDropTargetEvent(lastDropTarget, mouseEvent, hDirection, vDirection, fromNudge);
            lastDropTarget.onDragLeave(dragLeaveEvent);
        }
        const dragAndDropImageComponent = this.getDragAndDropImageComponent();
        if (dragAndDropImageComponent) {
            dragAndDropImageComponent.setIcon(null, false);
        }
    }
    addDropTarget(dropTarget) {
        this.dropTargets.push(dropTarget);
    }
    removeDropTarget(dropTarget) {
        this.dropTargets = this.dropTargets.filter((target) => target.getContainer() !== dropTarget.getContainer());
    }
    hasExternalDropZones() {
        return this.dropTargets.some((zones) => zones.external);
    }
    findExternalZone(params) {
        const externalTargets = this.dropTargets.filter((target) => target.external);
        return externalTargets.find((zone) => zone.getContainer() === params.getContainer()) || null;
    }
    isDropZoneWithinThisGrid(draggingEvent) {
        const gridBodyCon = this.ctrlsSvc.getGridBodyCtrl();
        const gridGui = gridBodyCon.eGridBody;
        const { dropZoneTarget } = draggingEvent;
        return gridGui.contains(dropZoneTarget);
    }
    getHorizontalDirection(event) {
        const clientX = this.eventLastTime?.clientX;
        const eClientX = event.clientX;
        if (clientX === eClientX) {
            return null;
        }
        return clientX > eClientX ? 'left' : 'right';
    }
    getVerticalDirection(event) {
        const clientY = this.eventLastTime?.clientY;
        const eClientY = event.clientY;
        if (clientY === eClientY) {
            return null;
        }
        return clientY > eClientY ? 'up' : 'down';
    }
    createDropTargetEvent(dropTarget, event, hDirection, vDirection, fromNudge) {
        // localise x and y to the target
        const dropZoneTarget = dropTarget.getContainer();
        const rect = dropZoneTarget.getBoundingClientRect();
        const { dragItem, dragSource, gos } = this;
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        return (0, gridOptionsUtils_1._addGridCommonParams)(gos, {
            event,
            x,
            y,
            vDirection,
            hDirection,
            dragSource: dragSource,
            fromNudge,
            dragItem: dragItem,
            dropZoneTarget,
        });
    }
    positionDragAndDropImageComp(event) {
        const dragAndDropImageComponent = this.getDragAndDropImageComponent();
        if (!dragAndDropImageComponent) {
            return;
        }
        (0, gridOptionsUtils_1._anchorElementToMouseMoveEvent)(dragAndDropImageComponent.getGui(), event, this.beans);
    }
    removeDragAndDropImageComponent() {
        const { dragAndDropImageComp } = this;
        if (dragAndDropImageComp) {
            const { comp } = dragAndDropImageComp;
            if (comp) {
                const eGui = comp.getGui();
                this.dragAndDropImageParent?.removeChild(eGui);
                this.destroyBean(comp);
            }
        }
        this.dragAndDropImageComp = null;
    }
    createDragAndDropImageComponent() {
        const { dragSource, gos, userCompFactory } = this;
        if (!dragSource) {
            return;
        }
        const userCompDetails = (0, userCompUtils_1._getDragAndDropImageCompDetails)(userCompFactory, (0, gridOptionsUtils_1._addGridCommonParams)(gos, {
            dragSource,
        }));
        if (!userCompDetails) {
            return;
        }
        const promise = userCompDetails.newAgStackInstance();
        this.dragAndDropImageComp = {
            promise,
        };
        promise.then((comp) => {
            if (!comp || !this.isAlive()) {
                return;
            }
            this.processDragAndDropImageComponent(comp);
            this.dragAndDropImageComp.comp = comp;
        });
    }
    processDragAndDropImageComponent(dragAndDropImageComponent) {
        const { dragSource, environment } = this;
        if (!dragSource) {
            return;
        }
        const eGui = dragAndDropImageComponent.getGui();
        eGui.style.setProperty('position', 'absolute');
        eGui.style.setProperty('z-index', '9999');
        (0, mouseEventUtils_1._stampTopLevelGridCompWithGridInstance)(this.gos, eGui);
        environment.applyThemeClasses(eGui);
        dragAndDropImageComponent.setIcon(null, false);
        let { dragItemName } = dragSource;
        if (typeof dragItemName === 'function') {
            dragItemName = dragItemName();
        }
        dragAndDropImageComponent.setLabel(dragItemName || '');
        eGui.style.top = '20px';
        eGui.style.left = '20px';
        const targetEl = (0, gridOptionsUtils_1._getPageBody)(this.beans);
        this.dragAndDropImageParent = targetEl;
        if (!targetEl) {
            (0, logging_1._warn)(54);
        }
        else {
            targetEl.appendChild(eGui);
        }
    }
    registerGridDropTarget(elementFn, ctrl) {
        // this drop target is just used to see if the drop event is inside the grid
        const dropTarget = {
            getContainer: elementFn,
            isInterestedIn: (type) => type === DragSourceType.HeaderCell || type === DragSourceType.ToolPanel,
            getIconName: () => 'notAllowed',
        };
        this.addDropTarget(dropTarget);
        ctrl.addDestroyFunc(() => this.removeDropTarget(dropTarget));
    }
}
exports.DragAndDropService = DragAndDropService;


/***/ }),

/***/ 72830:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setRowDropPositionIndicator = exports.getRowDropPositionIndicator = exports.getRowDropZoneParams = exports.removeRowDropZone = exports.addRowDropZone = void 0;
function addRowDropZone(beans, params) {
    beans.rowDragSvc?.rowDragFeature?.addRowDropZone(params);
}
exports.addRowDropZone = addRowDropZone;
function removeRowDropZone(beans, params) {
    const activeDropTarget = beans.dragAndDrop?.findExternalZone(params);
    if (activeDropTarget) {
        beans.dragAndDrop?.removeDropTarget(activeDropTarget);
    }
}
exports.removeRowDropZone = removeRowDropZone;
function getRowDropZoneParams(beans, events) {
    return beans.rowDragSvc?.rowDragFeature?.getRowDropZone(events);
}
exports.getRowDropZoneParams = getRowDropZoneParams;
function getRowDropPositionIndicator(beans) {
    const rowDropHighlightSvc = beans.rowDropHighlightSvc;
    return rowDropHighlightSvc
        ? { row: rowDropHighlightSvc.row, dropIndicatorPosition: rowDropHighlightSvc.position }
        : { row: null, dropIndicatorPosition: 'none' };
}
exports.getRowDropPositionIndicator = getRowDropPositionIndicator;
function setRowDropPositionIndicator(beans, params) {
    const rowDropHighlightSvc = beans.rowDropHighlightSvc;
    if (!rowDropHighlightSvc) {
        return;
    }
    const rowNode = params?.row;
    let position = params?.dropIndicatorPosition;
    if (position !== 'above' && position !== 'below' && position !== 'inside') {
        position = 'none';
    }
    const rowIndex = rowNode?.rowIndex;
    if (rowIndex === null || rowIndex === undefined || position === 'none') {
        rowDropHighlightSvc.clear();
    }
    else {
        rowDropHighlightSvc.set(rowNode, position);
    }
}
exports.setRowDropPositionIndicator = setRowDropPositionIndicator;


/***/ }),

/***/ 24388:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HorizontalResizeModule = exports.RowDragModule = exports.SharedDragAndDropModule = exports.DragAndDropModule = exports.DragModule = void 0;
const dndSourceComp_1 = __webpack_require__(60714);
const version_1 = __webpack_require__(97205);
const dragAndDropImageComponent_1 = __webpack_require__(33814);
const dragAndDropService_1 = __webpack_require__(12903);
const dragApi_1 = __webpack_require__(72830);
const dragApi_2 = __webpack_require__(72830);
const dragService_1 = __webpack_require__(52165);
const horizontalResizeService_1 = __webpack_require__(26843);
const rowDragService_1 = __webpack_require__(92895);
const rowDropHighlightService_1 = __webpack_require__(37406);
/**
 * @internal
 */
exports.DragModule = {
    moduleName: 'Drag',
    version: version_1.VERSION,
    beans: [dragService_1.DragService],
};
/**
 * @feature Import & Export -> Drag & Drop
 * @colDef dndSource, dndSourceOnRowDrag
 */
exports.DragAndDropModule = {
    moduleName: 'DragAndDrop',
    version: version_1.VERSION,
    dynamicBeans: {
        dndSourceComp: dndSourceComp_1.DndSourceComp,
    },
    icons: {
        // drag handle used to pick up draggable rows
        rowDrag: 'grip',
    },
};
/**
 * @internal
 */
exports.SharedDragAndDropModule = {
    moduleName: 'SharedDragAndDrop',
    version: version_1.VERSION,
    beans: [dragAndDropService_1.DragAndDropService],
    dependsOn: [exports.DragModule],
    userComponents: {
        agDragAndDropImage: dragAndDropImageComponent_1.DragAndDropImageComponent,
    },
    icons: {
        // shown on drag and drop image component icon while dragging column to the side of the grid to pin
        columnMovePin: 'pin',
        // shown on drag and drop image component icon while dragging over part of the page that is not a drop zone
        columnMoveHide: 'eye-slash',
        // shown on drag and drop image component icon while dragging columns to reorder
        columnMoveMove: 'arrows',
        // animating icon shown when dragging a column to the right of the grid causes horizontal scrolling
        columnMoveLeft: 'left',
        // animating icon shown when dragging a column to the left of the grid causes horizontal scrolling
        columnMoveRight: 'right',
        // shown on drag and drop image component icon while dragging over Row Groups drop zone
        columnMoveGroup: 'group',
        // shown on drag and drop image component icon while dragging over Values drop zone
        columnMoveValue: 'aggregation',
        // shown on drag and drop image component icon while dragging over pivot drop zone
        columnMovePivot: 'pivot',
        // shown on drag and drop image component icon while dragging over drop zone that doesn't support it, e.g.
        // string column over aggregation drop zone
        dropNotAllowed: 'not-allowed',
        // drag handle used to pick up draggable rows
        rowDrag: 'grip',
    },
};
/**
 * @feature Rows -> Row Dragging
 * @colDef rowDrag
 */
exports.RowDragModule = {
    moduleName: 'RowDrag',
    version: version_1.VERSION,
    beans: [rowDropHighlightService_1.RowDropHighlightService, rowDragService_1.RowDragService],
    apiFunctions: {
        addRowDropZone: dragApi_1.addRowDropZone,
        removeRowDropZone: dragApi_1.removeRowDropZone,
        getRowDropZoneParams: dragApi_1.getRowDropZoneParams,
        getRowDropPositionIndicator: dragApi_2.getRowDropPositionIndicator,
        setRowDropPositionIndicator: dragApi_2.setRowDropPositionIndicator,
    },
    dependsOn: [exports.SharedDragAndDropModule],
};
/**
 * @internal
 */
exports.HorizontalResizeModule = {
    moduleName: 'HorizontalResize',
    version: version_1.VERSION,
    beans: [horizontalResizeService_1.HorizontalResizeService],
    dependsOn: [exports.DragModule],
};


/***/ }),

/***/ 52165:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DragService = void 0;
const keyCode_1 = __webpack_require__(39853);
const beanStub_1 = __webpack_require__(68731);
const mouseEventUtils_1 = __webpack_require__(8399);
const gridOptionsUtils_1 = __webpack_require__(67274);
const array_1 = __webpack_require__(31502);
const browser_1 = __webpack_require__(98667);
const dom_1 = __webpack_require__(33507);
const generic_1 = __webpack_require__(34422);
const mouse_1 = __webpack_require__(3276);
/** Adds drag listening onto an element. In AG Grid this is used twice, first is resizing columns,
 * second is moving the columns and column groups around (ie the 'drag' part of Drag and Drop. */
class DragService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'dragSvc';
        this.dragEndFunctions = [];
        this.dragSources = [];
    }
    destroy() {
        const { dragSources } = this;
        dragSources.forEach(this.removeListener.bind(this));
        dragSources.length = 0;
        super.destroy();
    }
    removeListener(dragSourceAndListener) {
        const element = dragSourceAndListener.dragSource.eElement;
        const mouseDownListener = dragSourceAndListener.mouseDownListener;
        element.removeEventListener('mousedown', mouseDownListener);
        // remove touch listener only if it exists
        if (dragSourceAndListener.touchEnabled) {
            const touchStartListener = dragSourceAndListener.touchStartListener;
            element.removeEventListener('touchstart', touchStartListener, { passive: true });
        }
    }
    removeDragSource(params) {
        const { dragSources } = this;
        const dragSourceAndListener = dragSources.find((item) => item.dragSource === params);
        if (!dragSourceAndListener) {
            return;
        }
        this.removeListener(dragSourceAndListener);
        (0, array_1._removeFromArray)(dragSources, dragSourceAndListener);
    }
    addDragSource(params) {
        const mouseListener = this.onMouseDown.bind(this, params);
        const { eElement, includeTouch, stopPropagationForTouch } = params;
        eElement.addEventListener('mousedown', mouseListener);
        let touchListener = null;
        const suppressTouch = this.gos.get('suppressTouch');
        if (includeTouch && !suppressTouch) {
            touchListener = (touchEvent) => {
                if ((0, dom_1._isFocusableFormField)(touchEvent.target)) {
                    return;
                }
                if (stopPropagationForTouch) {
                    touchEvent.stopPropagation();
                }
                this.onTouchStart(params, touchEvent);
            };
            // we set passive=false, as we want to prevent default on this event
            eElement.addEventListener('touchstart', touchListener, { passive: false });
        }
        this.dragSources.push({
            dragSource: params,
            mouseDownListener: mouseListener,
            touchStartListener: touchListener,
            touchEnabled: !!includeTouch,
        });
    }
    // gets called whenever mouse down on any drag source
    onTouchStart(params, touchEvent) {
        this.currentDragParams = params;
        this.dragging = false;
        const touch = touchEvent.touches[0];
        this.touchLastTime = touch;
        this.touchStart = touch;
        const touchMoveEvent = (e) => this.onTouchMove(e, params.eElement);
        const touchEndEvent = (e) => this.onTouchUp(e, params.eElement);
        const documentTouchMove = (e) => {
            if (e.cancelable) {
                e.preventDefault();
            }
        };
        const target = touchEvent.target;
        const events = [
            // Prevents the page document from moving while we are dragging items around.
            // preventDefault needs to be called in the touchmove listener and never inside the
            // touchstart, because using touchstart causes the click event to be cancelled on touch devices.
            {
                target: (0, gridOptionsUtils_1._getRootNode)(this.beans),
                type: 'touchmove',
                listener: documentTouchMove,
                options: { passive: false },
            },
            { target, type: 'touchmove', listener: touchMoveEvent, options: { passive: true } },
            { target, type: 'touchend', listener: touchEndEvent, options: { passive: true } },
            { target, type: 'touchcancel', listener: touchEndEvent, options: { passive: true } },
        ];
        // temporally add these listeners, for the duration of the drag
        this.addTemporaryEvents(events);
        // see if we want to start dragging straight away
        if (params.dragStartPixels === 0) {
            this.onCommonMove(touch, this.touchStart, params.eElement);
        }
    }
    // gets called whenever mouse down on any drag source
    onMouseDown(params, mouseEvent) {
        const e = mouseEvent;
        if (params.skipMouseEvent && params.skipMouseEvent(mouseEvent)) {
            return;
        }
        // if there are two elements with parent / child relationship, and both are draggable,
        // when we drag the child, we should NOT drag the parent. an example of this is row moving
        // and range selection - row moving should get preference when use drags the rowDrag component.
        if (e._alreadyProcessedByDragService) {
            return;
        }
        e._alreadyProcessedByDragService = true;
        // only interested in left button clicks
        if (mouseEvent.button !== 0) {
            return;
        }
        if (this.shouldPreventMouseEvent(mouseEvent)) {
            mouseEvent.preventDefault();
        }
        this.currentDragParams = params;
        this.dragging = false;
        this.mouseStartEvent = mouseEvent;
        this.startTarget = mouseEvent.target;
        const mouseMoveEvent = (event) => this.onMouseMove(event, params.eElement);
        const mouseUpEvent = (event) => this.onMouseUp(event, params.eElement);
        const contextEvent = (event) => event.preventDefault();
        const keydownEvent = (event) => {
            if (event.key === keyCode_1.KeyCode.ESCAPE) {
                this.cancelDrag(params.eElement);
            }
        };
        const target = (0, gridOptionsUtils_1._getRootNode)(this.beans);
        const events = [
            { target, type: 'mousemove', listener: mouseMoveEvent },
            { target, type: 'mouseup', listener: mouseUpEvent },
            { target, type: 'contextmenu', listener: contextEvent },
            { target, type: 'keydown', listener: keydownEvent },
        ];
        // temporally add these listeners, for the duration of the drag
        this.addTemporaryEvents(events);
        //see if we want to start dragging straight away
        if (params.dragStartPixels === 0) {
            this.onMouseMove(mouseEvent, params.eElement);
        }
    }
    addTemporaryEvents(events) {
        events.forEach((currentEvent) => {
            const { target, type, listener, options } = currentEvent;
            target.addEventListener(type, listener, options);
        });
        this.dragEndFunctions.push(() => {
            events.forEach((currentEvent) => {
                const { target, type, listener, options } = currentEvent;
                target.removeEventListener(type, listener, options);
            });
        });
    }
    // returns true if the event is close to the original event by X pixels either vertically or horizontally.
    // we only start dragging after X pixels so this allows us to know if we should start dragging yet.
    isEventNearStartEvent(currentEvent, startEvent) {
        // by default, we wait 4 pixels before starting the drag
        const { dragStartPixels } = this.currentDragParams;
        const requiredPixelDiff = (0, generic_1._exists)(dragStartPixels) ? dragStartPixels : 4;
        return (0, mouse_1._areEventsNear)(currentEvent, startEvent, requiredPixelDiff);
    }
    getFirstActiveTouch(touchList) {
        for (let i = 0; i < touchList.length; i++) {
            if (touchList[i].identifier === this.touchStart.identifier) {
                return touchList[i];
            }
        }
        return null;
    }
    onCommonMove(currentEvent, startEvent, el) {
        if (!this.dragging) {
            // if mouse hasn't travelled from the start position enough, do nothing
            if (this.isEventNearStartEvent(currentEvent, startEvent)) {
                return;
            }
            this.dragging = true;
            this.eventSvc.dispatchEvent({
                type: 'dragStarted',
                target: el,
            });
            this.currentDragParams.onDragStart(startEvent);
            // we need ONE drag action at the startEvent, so that we are guaranteed the drop target
            // at the start gets notified. this is because the drag can start outside of the element
            // that started it, as the mouse is allowed drag away from the mouse down before it's
            // considered a drag (the isEventNearStartEvent() above). if we didn't do this, then
            // it would be possible to click a column by the edge, then drag outside of the drop zone
            // in less than 4 pixels and the drag officially starts outside of the header but the header
            // wouldn't be notified of the dragging.
            // if currentDragParams is null here, it means that drag has been cancelled.
            if (!this.currentDragParams) {
                this.dragging = false;
                return;
            }
            this.currentDragParams.onDragging(startEvent);
        }
        this.currentDragParams?.onDragging(currentEvent);
    }
    onTouchMove(touchEvent, el) {
        const touch = this.getFirstActiveTouch(touchEvent.touches);
        if (!touch) {
            return;
        }
        // this.___statusPanel.setInfoText(Math.random() + ' onTouchMove preventDefault stopPropagation');
        this.onCommonMove(touch, this.touchStart, el);
    }
    // only gets called after a mouse down - as this is only added after mouseDown
    // and is removed when mouseUp happens
    onMouseMove(mouseEvent, el) {
        if ((0, browser_1._isBrowserSafari)()) {
            const eDocument = (0, gridOptionsUtils_1._getDocument)(this.beans);
            eDocument.getSelection()?.removeAllRanges();
        }
        if (this.shouldPreventMouseEvent(mouseEvent)) {
            mouseEvent.preventDefault();
        }
        this.onCommonMove(mouseEvent, this.mouseStartEvent, el);
    }
    shouldPreventMouseEvent(mouseEvent) {
        const { gos } = this;
        const isEnableCellTextSelect = gos.get('enableCellTextSelection');
        const isMouseMove = mouseEvent.type === 'mousemove';
        const isOverFormFieldElement = (mouseEvent) => {
            const el = mouseEvent.target;
            const tagName = el?.tagName.toLocaleLowerCase();
            return !!tagName?.match('^a$|textarea|input|select|button');
        };
        return (
        // when `isEnableCellTextSelect` is `true`, we need to preventDefault on mouseMove
        // to avoid the grid text being selected while dragging components.
        isEnableCellTextSelect &&
            isMouseMove &&
            mouseEvent.cancelable &&
            (0, mouseEventUtils_1._isEventFromThisGrid)(gos, mouseEvent) &&
            !isOverFormFieldElement(mouseEvent));
    }
    onTouchUp(touchEvent, el) {
        let touch = this.getFirstActiveTouch(touchEvent.changedTouches);
        // i haven't worked this out yet, but there is no matching touch
        // when we get the touch up event. to get around this, we swap in
        // the last touch. this is a hack to 'get it working' while we
        // figure out what's going on, why we are not getting a touch in
        // current event.
        if (!touch) {
            touch = this.touchLastTime;
        }
        // if mouse was left up before we started to move, then this is a tap.
        // we check this before onUpCommon as onUpCommon resets the dragging
        // let tap = !this.dragging;
        // let tapTarget = this.currentDragParams.eElement;
        this.onUpCommon(touch, el);
        // if tap, tell user
        // console.log(`${Math.random()} tap = ${tap}`);
        // if (tap) {
        //     tapTarget.click();
        // }
    }
    onMouseUp(mouseEvent, el) {
        this.onUpCommon(mouseEvent, el);
    }
    onUpCommon(eventOrTouch, el) {
        if (this.dragging) {
            this.dragging = false;
            this.currentDragParams.onDragStop(eventOrTouch);
            this.eventSvc.dispatchEvent({
                type: 'dragStopped',
                target: el,
            });
        }
        this.resetDragProperties();
    }
    cancelDrag(el) {
        this.eventSvc.dispatchEvent({
            type: 'dragCancelled',
            target: el,
        });
        this.currentDragParams?.onDragCancel?.();
        this.resetDragProperties();
    }
    resetDragProperties() {
        this.mouseStartEvent = null;
        this.startTarget = null;
        this.touchStart = null;
        this.touchLastTime = null;
        this.currentDragParams = null;
        const { dragEndFunctions } = this;
        dragEndFunctions.forEach((func) => func());
        dragEndFunctions.length = 0;
    }
}
exports.DragService = DragService;


/***/ }),

/***/ 26843:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HorizontalResizeService = void 0;
const beanStub_1 = __webpack_require__(68731);
class HorizontalResizeService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'horizontalResizeSvc';
    }
    addResizeBar(params) {
        const dragSource = {
            dragStartPixels: params.dragStartPixels || 0,
            eElement: params.eResizeBar,
            onDragStart: this.onDragStart.bind(this, params),
            onDragStop: this.onDragStop.bind(this, params),
            onDragging: this.onDragging.bind(this, params),
            onDragCancel: this.onDragStop.bind(this, params),
            includeTouch: true,
            stopPropagationForTouch: true,
        };
        const { dragSvc } = this.beans;
        dragSvc.addDragSource(dragSource);
        // we pass remove func back to the caller, so call can tell us when they
        // are finished, and then we remove the listener from the drag source
        const finishedWithResizeFunc = () => dragSvc.removeDragSource(dragSource);
        return finishedWithResizeFunc;
    }
    onDragStart(params, mouseEvent) {
        this.dragStartX = mouseEvent.clientX;
        this.setResizeIcons();
        const shiftKey = mouseEvent instanceof MouseEvent && mouseEvent.shiftKey === true;
        params.onResizeStart(shiftKey);
    }
    setResizeIcons() {
        const ctrl = this.beans.ctrlsSvc.get('gridCtrl');
        // change the body cursor, so when drag moves out of the drag bar, the cursor is still 'resize' (or 'move'
        ctrl.setResizeCursor(true);
        // we don't want text selection outside the grid (otherwise it looks weird as text highlights when we move)
        ctrl.disableUserSelect(true);
    }
    onDragStop(params) {
        params.onResizeEnd(this.resizeAmount);
        this.resetIcons();
    }
    resetIcons() {
        const ctrl = this.beans.ctrlsSvc.get('gridCtrl');
        ctrl.setResizeCursor(false);
        ctrl.disableUserSelect(false);
    }
    onDragging(params, mouseEvent) {
        this.resizeAmount = mouseEvent.clientX - this.dragStartX;
        params.onResizing(this.resizeAmount);
    }
}
exports.HorizontalResizeService = HorizontalResizeService;


/***/ }),

/***/ 21633:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RowDragComp = void 0;
const beanStub_1 = __webpack_require__(68731);
const icon_1 = __webpack_require__(59970);
const component_1 = __webpack_require__(78020);
const dragAndDropService_1 = __webpack_require__(12903);
const RowDragElement = {
    tag: 'div',
    cls: 'ag-drag-handle ag-row-drag',
    attrs: { 'aria-hidden': 'true' },
};
class RowDragComp extends component_1.Component {
    constructor(cellValueFn, rowNode, column, customGui, dragStartPixels, suppressVisibilityChange) {
        super();
        this.cellValueFn = cellValueFn;
        this.rowNode = rowNode;
        this.column = column;
        this.customGui = customGui;
        this.dragStartPixels = dragStartPixels;
        this.suppressVisibilityChange = suppressVisibilityChange;
        this.dragSource = null;
    }
    isCustomGui() {
        return this.customGui != null;
    }
    postConstruct() {
        const { beans, rowNode, column, gos } = this;
        if (!this.customGui) {
            this.setTemplate(RowDragElement);
            this.getGui().appendChild((0, icon_1._createIconNoSpan)('rowDrag', beans, null));
            this.addDragSource();
        }
        else {
            this.setDragElement(this.customGui, this.dragStartPixels);
        }
        if (!this.suppressVisibilityChange) {
            const strategy = gos.get('rowDragManaged')
                ? new ManagedVisibilityStrategy(this, rowNode, column)
                : new NonManagedVisibilityStrategy(this, rowNode, column);
            this.createManagedBean(strategy, this.beans.context);
        }
    }
    setDragElement(dragElement, dragStartPixels) {
        // We set suppressDataRefValidation as the drag element could contain AG Grid comps with data references
        // that are not part of this row dragger's context. Maybe this should just setGui and not setTemplateFromElement?
        this.setTemplateFromElement(dragElement, undefined, undefined, true);
        this.addDragSource(dragStartPixels);
    }
    getSelectedNodes() {
        const rowNode = this.rowNode;
        const isRowDragMultiRow = this.gos.get('rowDragMultiRow');
        if (!isRowDragMultiRow) {
            return [rowNode];
        }
        const selection = this.beans.selectionSvc?.getSelectedNodes() ?? [];
        return selection.indexOf(rowNode) !== -1 ? selection : [rowNode];
    }
    getDragItem() {
        const { column, rowNode } = this;
        return {
            rowNode,
            rowNodes: this.getSelectedNodes(),
            columns: column ? [column] : undefined,
            defaultTextValue: this.cellValueFn(),
        };
    }
    getRowDragText(column) {
        if (column) {
            const colDef = column.getColDef();
            if (colDef.rowDragText) {
                return colDef.rowDragText;
            }
        }
        return this.gos.get('rowDragText');
    }
    addDragSource(dragStartPixels = 4) {
        // if this is changing the drag element, delete the previous dragSource
        if (this.dragSource) {
            this.removeDragSource();
        }
        if (this.gos.get('rowDragManaged') && this.rowNode.footer) {
            return; // Footer nodes in row drag managed mode are not draggable
        }
        const eGui = this.getGui();
        if (this.gos.get('enableCellTextSelection')) {
            this.removeMouseDownListener();
            this.mouseDownListener = this.addManagedElementListeners(eGui, {
                mousedown: (e) => {
                    e?.preventDefault();
                },
            })[0];
        }
        const translate = this.getLocaleTextFunc();
        this.dragSource = {
            type: dragAndDropService_1.DragSourceType.RowDrag,
            eElement: eGui,
            dragItemName: () => {
                const dragItem = this.getDragItem();
                const dragItemCount = dragItem.rowNodes?.length || 1;
                const rowDragText = this.getRowDragText(this.column);
                if (rowDragText) {
                    return rowDragText(dragItem, dragItemCount);
                }
                return dragItemCount === 1
                    ? this.cellValueFn()
                    : `${dragItemCount} ${translate('rowDragRows', 'rows')}`;
            },
            getDragItem: () => this.getDragItem(),
            dragStartPixels,
            dragSourceDomDataKey: this.gos.getDomDataKey(),
        };
        this.beans.dragAndDrop.addDragSource(this.dragSource, true);
    }
    destroy() {
        this.removeDragSource();
        this.removeMouseDownListener();
        super.destroy();
    }
    removeDragSource() {
        if (!this.dragSource) {
            return;
        }
        this.beans.dragAndDrop.removeDragSource(this.dragSource);
        this.dragSource = null;
    }
    removeMouseDownListener() {
        if (!this.mouseDownListener) {
            return;
        }
        this.mouseDownListener();
        this.mouseDownListener = undefined;
    }
}
exports.RowDragComp = RowDragComp;
class VisibilityStrategy extends beanStub_1.BeanStub {
    constructor(parent, rowNode, column) {
        super();
        this.parent = parent;
        this.rowNode = rowNode;
        this.column = column;
    }
    setDisplayedOrVisible(neverDisplayed, alwaysHidden = false) {
        const displayedOptions = { skipAriaHidden: true };
        if (neverDisplayed) {
            this.parent.setDisplayed(false, displayedOptions);
        }
        else {
            let shown = !alwaysHidden;
            let isShownSometimes = false;
            const { column, rowNode, parent } = this;
            if (column) {
                const rowDrag = column.getColDef().rowDrag;
                isShownSometimes = typeof rowDrag === 'function';
                shown = (alwaysHidden ? !!rowDrag : column.isRowDrag(rowNode)) || parent.isCustomGui();
            }
            // if shown sometimes, them some rows can have drag handle while other don't,
            // so we use setVisible to keep the handles horizontally aligned (as _setVisible
            // keeps the empty space, whereas setDisplayed looses the space)
            if (isShownSometimes) {
                parent.setDisplayed(true, displayedOptions);
                parent.setVisible(shown && !alwaysHidden, displayedOptions);
            }
            else {
                parent.setDisplayed(shown, displayedOptions);
                parent.setVisible(!alwaysHidden, displayedOptions);
            }
        }
    }
}
// when non managed, the visibility depends on suppressRowDrag property only
class NonManagedVisibilityStrategy extends VisibilityStrategy {
    postConstruct() {
        this.addManagedPropertyListener('suppressRowDrag', this.onSuppressRowDrag.bind(this));
        // in case data changes, then we need to update visibility of drag item
        const listener = this.workOutVisibility.bind(this);
        this.addManagedListeners(this.rowNode, {
            dataChanged: listener,
            cellChanged: listener,
        });
        this.addManagedListeners(this.beans.eventSvc, { newColumnsLoaded: listener });
        this.workOutVisibility();
    }
    onSuppressRowDrag() {
        this.workOutVisibility();
    }
    workOutVisibility() {
        // only show the drag if both sort and filter are not present
        const neverDisplayed = this.gos.get('suppressRowDrag');
        this.setDisplayedOrVisible(neverDisplayed);
    }
}
// when managed, the visibility depends on sort, filter and row group, as well as suppressRowDrag property
class ManagedVisibilityStrategy extends VisibilityStrategy {
    postConstruct() {
        const listener = this.workOutVisibility.bind(this);
        // we do not show the component if sort, filter or grouping is active
        this.addManagedListeners(this.beans.eventSvc, {
            sortChanged: listener,
            filterChanged: listener,
            columnRowGroupChanged: listener,
            newColumnsLoaded: listener,
        });
        // in case data changes, then we need to update visibility of drag item
        this.addManagedListeners(this.rowNode, {
            dataChanged: listener,
            cellChanged: listener,
        });
        this.addManagedPropertyListener('suppressRowDrag', this.onSuppressRowDrag.bind(this));
        this.workOutVisibility();
    }
    onSuppressRowDrag() {
        this.workOutVisibility();
    }
    workOutVisibility() {
        const { rowDragSvc, dragAndDrop, gos } = this.beans;
        // only show the drag if both sort and filter are not present
        const rowDragFeature = rowDragSvc.rowDragFeature;
        const shouldPreventRowMove = rowDragFeature && rowDragFeature.shouldPreventRowMove();
        const suppressRowDrag = gos.get('suppressRowDrag');
        const hasExternalDropZones = dragAndDrop.hasExternalDropZones();
        const neverDisplayed = (shouldPreventRowMove && !hasExternalDropZones) || suppressRowDrag;
        this.setDisplayedOrVisible(neverDisplayed, this.rowNode.footer);
    }
}


/***/ }),

/***/ 12254:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RowDragFeature = void 0;
const autoScrollService_1 = __webpack_require__(35628);
const beanStub_1 = __webpack_require__(68731);
const positionUtils_1 = __webpack_require__(6257);
const mouseEventUtils_1 = __webpack_require__(8399);
const gridOptionsUtils_1 = __webpack_require__(67274);
const array_1 = __webpack_require__(31502);
const changedPath_1 = __webpack_require__(76800);
const logging_1 = __webpack_require__(47764);
const dragAndDropService_1 = __webpack_require__(12903);
class RowDragFeature extends beanStub_1.BeanStub {
    constructor(eContainer) {
        super();
        this.eContainer = null;
        this.lastDraggingEvent = null;
        this.autoScrollService = null;
        this.makeGroupThrottleTimer = null;
        this.makeGroupThrottleTarget = null;
        this.makeGroupThrottled = false;
        this.makeGroupThrottleCallback = () => {
            this.makeGroupThrottleTimer = null;
            const event = this.lastDraggingEvent;
            if (event) {
                this.makeGroupThrottled = true;
                this.doManagedDrag(event, false);
                this.makeGroupExpanded(this.makeGroupThrottleTarget);
            }
        };
        this.eContainer = eContainer;
    }
    postConstruct() {
        const { rowModel, gos, ctrlsSvc } = this.beans;
        if ((0, gridOptionsUtils_1._isClientSideRowModel)(gos, rowModel)) {
            this.clientSideRowModel = rowModel;
        }
        ctrlsSvc.whenReady(this, (p) => {
            const gridBodyCon = p.gridBodyCtrl;
            let oldVScroll = 0;
            const getVScroll = () => gridBodyCon.scrollFeature.getVScrollPosition().top;
            this.autoScrollService = new autoScrollService_1.AutoScrollService({
                scrollContainer: gridBodyCon.eBodyViewport,
                scrollAxis: 'y',
                getVerticalPosition: getVScroll,
                setVerticalPosition: (position) => gridBodyCon.scrollFeature.setVerticalScrollPosition(position),
                onScrollCallback: () => {
                    const newVScroll = getVScroll();
                    if (oldVScroll !== newVScroll) {
                        oldVScroll = newVScroll;
                        const lastDraggingEvent = this.lastDraggingEvent;
                        if (lastDraggingEvent) {
                            this.onDragging(lastDraggingEvent);
                        }
                    }
                },
            });
        });
    }
    destroy() {
        super.destroy();
        this.eContainer = null;
        this.lastDraggingEvent = null;
        this.makeGroupThrottleClear();
        const autoScrollService = this.autoScrollService;
        if (autoScrollService) {
            this.autoScrollService = null;
            autoScrollService?.ensureCleared();
        }
    }
    getContainer() {
        return this.eContainer;
    }
    isInterestedIn(type) {
        return type === dragAndDropService_1.DragSourceType.RowDrag;
    }
    getIconName() {
        const managedDrag = this.gos.get('rowDragManaged');
        if (managedDrag && this.shouldPreventRowMove()) {
            return 'notAllowed';
        }
        return 'move';
    }
    shouldPreventRowMove() {
        const { rowGroupColsSvc, filterManager, sortSvc } = this.beans;
        const rowGroupCols = rowGroupColsSvc?.columns ?? [];
        if (rowGroupCols.length) {
            return true;
        }
        const isFilterPresent = filterManager?.isAnyFilterPresent();
        if (isFilterPresent) {
            return true;
        }
        const isSortActive = sortSvc?.isSortActive();
        if (isSortActive) {
            return true;
        }
        return false;
    }
    getRowNodes(draggingEvent) {
        if (!this.isFromThisGrid(draggingEvent)) {
            return (draggingEvent.dragItem.rowNodes || []);
        }
        const currentNode = draggingEvent.dragItem.rowNode;
        const isRowDragMultiRow = this.gos.get('rowDragMultiRow');
        if (isRowDragMultiRow) {
            const selectedNodes = [...(this.beans.selectionSvc?.getSelectedNodes() ?? [])].sort((a, b) => {
                if (a.rowIndex == null || b.rowIndex == null) {
                    return 0;
                }
                return this.getRowIndexNumber(a) - this.getRowIndexNumber(b);
            });
            if (selectedNodes.indexOf(currentNode) !== -1) {
                return selectedNodes;
            }
        }
        return [currentNode];
    }
    onDragEnter(draggingEvent) {
        // builds a lits of all rows being dragged before firing events
        draggingEvent.dragItem.rowNodes = this.getRowNodes(draggingEvent);
        // when entering, we fire the enter event, then in onEnterOrDragging,
        // we also fire the move event. so we get both events when entering.
        this.dispatchGridEvent('rowDragEnter', draggingEvent);
        this.getRowNodes(draggingEvent).forEach((rowNode) => {
            this.setRowNodeDragging(rowNode, true);
        });
        this.onEnterOrDragging(draggingEvent);
    }
    onDragging(draggingEvent) {
        this.onEnterOrDragging(draggingEvent);
    }
    isFromThisGrid(draggingEvent) {
        const { dragSourceDomDataKey } = draggingEvent.dragSource;
        return dragSourceDomDataKey === this.gos.getDomDataKey();
    }
    onEnterOrDragging(draggingEvent) {
        if (!this.autoScrollService) {
            return; // destroyed
        }
        // this event is fired for enter and move
        this.dispatchGridEvent('rowDragMove', draggingEvent);
        this.lastDraggingEvent = draggingEvent;
        if (this.gos.get('rowDragManaged')) {
            this.doManagedDrag(draggingEvent, true);
        }
        this.autoScrollService.check(draggingEvent.event);
    }
    doManagedDrag(draggingEvent, throttleMakeGroup) {
        const { dragAndDrop, gos } = this.beans;
        const isFromThisGrid = this.isFromThisGrid(draggingEvent);
        const managedDrag = gos.get('rowDragManaged');
        if (managedDrag && this.shouldPreventRowMove()) {
            return;
        }
        if (gos.get('suppressMoveWhenRowDragging') || !isFromThisGrid) {
            if (dragAndDrop.isDropZoneWithinThisGrid(draggingEvent)) {
                const rowsDrop = this.managedRowsDrop(draggingEvent, throttleMakeGroup);
                const target = rowsDrop?.target;
                const rowDropHighlightSvc = this.beans.rowDropHighlightSvc;
                if (target && rowsDrop.rows.length) {
                    rowDropHighlightSvc.set(target, rowsDrop.position);
                }
                else {
                    rowDropHighlightSvc.clear();
                }
            }
        }
        else {
            const rowsDrop = this.managedRowsDrop(draggingEvent, throttleMakeGroup);
            if (rowsDrop) {
                this.dropRows(rowsDrop);
            }
        }
    }
    getRowIndexNumber(rowNode) {
        const rowIndexStr = rowNode.getRowIndexString();
        return parseInt((0, array_1._last)(rowIndexStr.split('-')), 10);
    }
    managedRowsDrop(draggingEvent, throttleMakeGroup) {
        const { rowNode, rowNodes: rows } = draggingEvent.dragItem;
        const rowsLen = rows?.length;
        const source = rowsLen && (rowNode ?? rows[0]);
        if (!source) {
            this.makeGroupThrottleClear();
            return null; // Nothing to move
        }
        const { beans, gos, clientSideRowModel } = this;
        const rootNode = clientSideRowModel.rootNode;
        const y = (0, mouseEventUtils_1._getNormalisedMousePosition)(beans, draggingEvent).y;
        let targetRowIndex = clientSideRowModel.getRowIndexAtPixel(y);
        let target = clientSideRowModel.getRow(targetRowIndex) ?? null;
        const moved = source !== target;
        let yDelta = target ? (y - target.rowTop - target.rowHeight / 2) / target.rowHeight || 0 : 1;
        const sameGrid = this.isFromThisGrid(draggingEvent);
        const groupingApproach = (0, gridOptionsUtils_1._getGroupingApproach)(gos);
        const canSetParent = 
        // We don't yet support drag and drop with grouping
        groupingApproach !== 'group' &&
            // We don't yet support moving tree rows from a different grid in a structured way
            sameGrid;
        let newParent = null;
        if (canSetParent && target?.footer) {
            // Footer row. Get the real parent, that is the sibling of the footer
            newParent = target.sibling ?? rootNode;
            const found = getPrevOrNext(clientSideRowModel, -1, target) ?? getPrevOrNext(clientSideRowModel, 1, target);
            yDelta = found && found.rowIndex > target.rowIndex ? -0.5 : 0.5;
            target = found ?? null;
        }
        let above = yDelta < 0;
        let targetInRows = false;
        if (sameGrid && target) {
            if (!moved) {
                if (Math.abs(yDelta) <= 0.5) {
                    this.makeGroupThrottleClear();
                    return null; // Nothing to move
                }
                targetInRows = true;
            }
            else {
                targetInRows = rows.indexOf(target) >= 0;
                if (targetInRows) {
                    const newTarget = getRowsPrevOrNext(clientSideRowModel, targetRowIndex < source.rowIndex, rows);
                    if (newTarget?.parent === target.parent) {
                        target = newTarget; // Delta dragging, the user moved to a selected row above or below
                        targetRowIndex = target.rowIndex;
                    }
                }
            }
            if (targetInRows || (!canSetParent && Math.abs(targetRowIndex - source.rowIndex) === 1)) {
                above = targetRowIndex < source.rowIndex; // Select the row above or below without the mid point if the diff is 1
            }
        }
        const makeGroupThrottleTarget = this.makeGroupThrottleTarget;
        if (makeGroupThrottleTarget !== null && makeGroupThrottleTarget !== target) {
            this.makeGroupThrottleClear();
        }
        if (target?.expanded && target.childrenAfterSort?.length) {
            this.makeGroupThrottled = true;
            this.makeGroupThrottleTarget = target;
        }
        if (newParent === null && canSetParent) {
            if (!target || (yDelta >= 0.5 && target.rowIndex === beans.pageBounds.getLastRow())) {
                newParent = rootNode; // Dragging outside of the rows, move to last row at the root level
            }
            else if (this.targetShouldBeParent(target, yDelta, targetInRows, rows)) {
                if (this.makeGroupThrottled) {
                    newParent = target;
                }
                if (throttleMakeGroup && (newParent === null || !target.expanded)) {
                    this.makeGroupThrottleTarget = target;
                    this.makeGroupThrottleStart();
                }
            }
            newParent ?? (newParent = target?.parent ?? rootNode);
        }
        let inside = false;
        if (newParent !== null) {
            if (newParent === target && newParent !== rootNode) {
                inside = true; // Dragging as child
                const firstRow = newParent.expanded ? getPrevOrNext(clientSideRowModel, 1, target) : null;
                if (firstRow?.parent === newParent) {
                    target = firstRow; // Instead of showing "inside" style, we can show "above" by using first child as target
                    inside = false;
                    above = true;
                }
            }
            if (target && !inside) {
                // Set target to the first group that is not the root node or the new parent
                let current = target;
                while (current && current !== rootNode && current !== newParent) {
                    target = current;
                    current = current.parent;
                }
            }
            if (rowsHaveSameParent(rows, newParent)) {
                newParent = null; // No need to set parent if all rows have the same parent
            }
        }
        if (!newParent && targetInRows && (canSetParent || source === target)) {
            // No delta dragging of multiple rows with TreeData or no change, nothing to move
            return null;
        }
        const position = inside ? 'inside' : above ? 'above' : 'below';
        const result = {
            api: this.beans.gridApi,
            context: this.beans.gridOptions.context,
            draggingEvent,
            sameGrid,
            position,
            source,
            target,
            newParent,
            rows,
        };
        let customPosition = false;
        const isRowValidDropPosition = gos.get('isRowValidDropPosition');
        if (isRowValidDropPosition) {
            const canDropResult = isRowValidDropPosition(result);
            if (!canDropResult) {
                result.rows = array_1._EmptyArray; // Cannot drop, so no rows
            }
            else if (typeof canDropResult === 'object') {
                // Custom result, override the default values
                if (canDropResult.rows !== undefined) {
                    result.rows = canDropResult.rows ?? array_1._EmptyArray;
                }
                if (canDropResult.newParent !== undefined) {
                    result.newParent = canDropResult.newParent;
                }
                if (canDropResult.target !== undefined) {
                    result.target = canDropResult.target;
                }
                if (canDropResult.position) {
                    customPosition = true;
                    result.position = canDropResult.position;
                }
            }
        }
        if ((!result.newParent || !result.rows.length) && !customPosition) {
            result.position = above ? 'above' : 'below'; // Remove 'inside' if no new parent
        }
        return result;
    }
    makeGroupThrottleStart() {
        if (this.makeGroupThrottleTimer === null) {
            this.makeGroupThrottleTimer = window.setTimeout(this.makeGroupThrottleCallback, this.gos.get('rowDragInsertDelay'));
        }
    }
    makeGroupExpanded(target) {
        if (target && !target.expanded && target.childrenAfterSort?.length && target.isExpandable()) {
            target.setExpanded(true, this.lastDraggingEvent?.event, true);
        }
    }
    makeGroupThrottleClear() {
        this.makeGroupThrottled = false;
        this.makeGroupThrottleTarget = null;
        const timer = this.makeGroupThrottleTimer;
        if (timer !== null) {
            this.makeGroupThrottleTimer = null;
            clearTimeout(timer);
        }
    }
    targetShouldBeParent(target, yDelta, targetInRows, rows) {
        const targetRowIndex = target?.rowIndex;
        if (targetInRows || targetRowIndex === null) {
            return false;
        }
        const INSIDE_THRESHOLD = 0.25;
        if (yDelta < -0.5 + INSIDE_THRESHOLD) {
            return false; // Definitely above
        }
        if (yDelta < 0.5 - INSIDE_THRESHOLD) {
            return true; // Definitely inside
        }
        let nextRow;
        let nextRowIndex = targetRowIndex + 1;
        const clientSideRowModel = this.clientSideRowModel;
        do {
            nextRow = clientSideRowModel.getRow(nextRowIndex++);
        } while (nextRow && nextRow.footer);
        const childrenAfterGroup = target.childrenAfterGroup;
        if (nextRow && nextRow.parent === target && childrenAfterGroup?.length) {
            const rowsSet = new Set(rows);
            for (const child of childrenAfterGroup) {
                if (child.rowIndex !== null && !rowsSet.has(child)) {
                    return true; // The group has children, so we can move inside
                }
            }
        }
        return false;
    }
    addRowDropZone(params) {
        if (!params.getContainer()) {
            (0, logging_1._warn)(55);
            return;
        }
        const dragAndDrop = this.beans.dragAndDrop;
        if (dragAndDrop.findExternalZone(params)) {
            (0, logging_1._warn)(56);
            return;
        }
        let processedParams = {
            getContainer: params.getContainer,
        };
        if (params.fromGrid) {
            processedParams = params;
        }
        else {
            if (params.onDragEnter) {
                processedParams.onDragEnter = (e) => {
                    params.onDragEnter(this.draggingToRowDragEvent('rowDragEnter', e));
                };
            }
            if (params.onDragLeave) {
                processedParams.onDragLeave = (e) => {
                    params.onDragLeave(this.draggingToRowDragEvent('rowDragLeave', e));
                };
            }
            if (params.onDragging) {
                processedParams.onDragging = (e) => {
                    params.onDragging(this.draggingToRowDragEvent('rowDragMove', e));
                };
            }
            if (params.onDragStop) {
                processedParams.onDragStop = (e) => {
                    params.onDragStop(this.draggingToRowDragEvent('rowDragEnd', e));
                };
            }
            if (params.onDragCancel) {
                processedParams.onDragCancel = (e) => {
                    params.onDragCancel(this.draggingToRowDragEvent('rowDragCancel', e));
                };
            }
        }
        const dropTarget = {
            isInterestedIn: (type) => type === dragAndDropService_1.DragSourceType.RowDrag,
            getIconName: () => 'move',
            external: true,
            ...processedParams,
        };
        dragAndDrop.addDropTarget(dropTarget);
        this.addDestroyFunc(() => dragAndDrop.removeDropTarget(dropTarget));
    }
    getRowDropZone(events) {
        const getContainer = this.getContainer.bind(this);
        const onDragEnter = this.onDragEnter.bind(this);
        const onDragLeave = this.onDragLeave.bind(this);
        const onDragging = this.onDragging.bind(this);
        const onDragStop = this.onDragStop.bind(this);
        const onDragCancel = this.onDragCancel.bind(this);
        let params;
        if (!events) {
            params = {
                getContainer,
                onDragEnter,
                onDragLeave,
                onDragging,
                onDragStop,
                onDragCancel,
                /* @private */ fromGrid: true,
            };
        }
        else {
            params = {
                getContainer,
                onDragEnter: events.onDragEnter
                    ? (e) => {
                        onDragEnter(e);
                        events.onDragEnter(this.draggingToRowDragEvent('rowDragEnter', e));
                    }
                    : onDragEnter,
                onDragLeave: events.onDragLeave
                    ? (e) => {
                        onDragLeave(e);
                        events.onDragLeave(this.draggingToRowDragEvent('rowDragLeave', e));
                    }
                    : onDragLeave,
                onDragging: events.onDragging
                    ? (e) => {
                        onDragging(e);
                        events.onDragging(this.draggingToRowDragEvent('rowDragMove', e));
                    }
                    : onDragging,
                onDragStop: events.onDragStop
                    ? (e) => {
                        onDragStop(e);
                        events.onDragStop(this.draggingToRowDragEvent('rowDragEnd', e));
                    }
                    : onDragStop,
                onDragCancel: events.onDragCancel
                    ? (e) => {
                        onDragCancel(e);
                        events.onDragCancel(this.draggingToRowDragEvent('rowDragCancel', e));
                    }
                    : onDragCancel,
                fromGrid: true /* @private */,
            };
        }
        // Cast to RowDropZoneParams to hide the internal properties
        return params;
    }
    draggingToRowDragEvent(type, draggingEvent) {
        const beans = this.beans;
        const { pageBounds, rowModel, gos } = beans;
        const y = (0, mouseEventUtils_1._getNormalisedMousePosition)(this.beans, draggingEvent).y;
        const mouseIsPastLastRow = y > pageBounds.getCurrentPagePixelRange().pageLastPixel;
        let overIndex = -1;
        let overNode;
        if (!mouseIsPastLastRow) {
            overIndex = rowModel.getRowIndexAtPixel(y);
            overNode = rowModel.getRow(overIndex);
        }
        const event = (0, gridOptionsUtils_1._addGridCommonParams)(gos, {
            type: type,
            event: draggingEvent.event,
            node: draggingEvent.dragItem.rowNode,
            nodes: draggingEvent.dragItem.rowNodes,
            overIndex: overIndex,
            overNode: overNode,
            y,
            vDirection: draggingEvent.vDirection,
        });
        return event;
    }
    dispatchGridEvent(type, draggingEvent) {
        const event = this.draggingToRowDragEvent(type, draggingEvent);
        this.eventSvc.dispatchEvent(event);
    }
    onDragLeave(draggingEvent) {
        this.dispatchGridEvent('rowDragLeave', draggingEvent);
        this.stopDragging(draggingEvent);
        if (this.gos.get('rowDragManaged')) {
            this.beans.rowDropHighlightSvc.clear();
        }
        this.makeGroupThrottleClear();
    }
    onDragStop(draggingEvent) {
        this.dispatchGridEvent('rowDragEnd', draggingEvent);
        this.stopDragging(draggingEvent);
        const { dragAndDrop, gos } = this.beans;
        if (gos.get('rowDragManaged') &&
            (gos.get('suppressMoveWhenRowDragging') || !this.isFromThisGrid(draggingEvent)) &&
            dragAndDrop.isDropZoneWithinThisGrid(draggingEvent)) {
            const rowsDrop = this.managedRowsDrop(draggingEvent, false);
            if (rowsDrop) {
                this.dropRows(rowsDrop);
            }
            this.beans.rowDropHighlightSvc.clear();
        }
        this.makeGroupThrottleClear();
    }
    onDragCancel(draggingEvent) {
        this.dispatchGridEvent('rowDragCancel', draggingEvent);
        this.stopDragging(draggingEvent);
        const { dragAndDrop, gos } = this.beans;
        if (gos.get('rowDragManaged') &&
            (gos.get('suppressMoveWhenRowDragging') || !this.isFromThisGrid(draggingEvent)) &&
            dragAndDrop.isDropZoneWithinThisGrid(draggingEvent)) {
            this.beans.rowDropHighlightSvc.clear();
        }
        this.makeGroupThrottleClear();
    }
    stopDragging(draggingEvent) {
        this.autoScrollService?.ensureCleared();
        this.getRowNodes(draggingEvent).forEach((rowNode) => {
            this.setRowNodeDragging(rowNode, false);
        });
    }
    setRowNodeDragging(rowNode, dragging) {
        if (rowNode.dragging !== dragging) {
            rowNode.dragging = dragging;
            rowNode.dispatchRowEvent('draggingChanged');
        }
    }
    /** Drag and drop. Returns false if at least a row was moved, otherwise true */
    dropRows(rowsDrop) {
        return rowsDrop.sameGrid ? this.moveRows(rowsDrop) : this.addRows(rowsDrop);
    }
    addRows({ position, target, rows }) {
        const getRowIdFunc = (0, gridOptionsUtils_1._getRowIdCallback)(this.gos);
        const clientSideRowModel = this.clientSideRowModel;
        const add = rows
            .filter(({ data, rowPinned }) => !clientSideRowModel.getRowNode(getRowIdFunc?.({ data, level: 0, rowPinned }) ?? data.id))
            .map(({ data }) => data);
        if (add.length === 0) {
            return false; // Nothing to add
        }
        const addIndex = target ? getLeafSourceRowIndex(target) + (position === 'above' ? 0 : 1) : undefined;
        clientSideRowModel.updateRowData({ add, addIndex });
        return true;
    }
    refreshModelAfterDrop() {
        this.clientSideRowModel.refreshModel({
            step: 'group',
            keepRenderedRows: true,
            animate: !this.gos.get('suppressAnimationFrame'),
            changedPath: new changedPath_1.ChangedPath(false, this.clientSideRowModel.rootNode),
            rowNodesOrderChanged: true,
        });
    }
    moveRows({ position, target, rows, newParent }) {
        let changed = false;
        const clientSideRowModel = this.clientSideRowModel;
        const leafs = new Set();
        for (const row of rows) {
            if (row.footer || (row.rowTop === null && row !== clientSideRowModel.getRowNode(row.id))) {
                continue; // This row cannot be dragged, not in allLeafChildren and not a filler
            }
            if (newParent && row.parent !== newParent) {
                if (wouldFormCycle(row, newParent)) {
                    continue; // Invalid move.
                }
                row.treeParent = newParent;
                changed = true;
            }
            const leafRow = getLeafRow(row);
            if (leafRow) {
                leafs.add(leafRow);
            }
        }
        if (!changed && leafs.size === 0) {
            return false; // Nothing to move
        }
        // Get the focussed cell so we can ensure it remains focussed after the move
        const focusSvc = this.beans.focusSvc;
        const cellPosition = focusSvc.getFocusedCell();
        const cellCtrl = cellPosition && (0, positionUtils_1._getCellByPosition)(this.beans, cellPosition);
        if (leafs.size &&
            this.reorderLeafChildren(leafs, ...this.getMoveRowsBounds(leafs, target, position === 'above'))) {
            changed = true;
        }
        if (!changed) {
            return false;
        }
        this.refreshModelAfterDrop();
        // Get the focussed cell so we can ensure it remains focussed after the move
        if (cellCtrl) {
            cellCtrl.focusCell();
        }
        else {
            focusSvc.clearFocusedCell();
        }
        return true;
    }
    /** For reorderLeafChildren, returns min index of the rows to move, the target index and the max index of the rows to move. */
    getMoveRowsBounds(leafs, target, above) {
        const totalRows = this.clientSideRowModel.rootNode?.allLeafChildren.length ?? 0;
        let targetPositionIdx = getLeafSourceRowIndex(target);
        if (targetPositionIdx < 0 || targetPositionIdx >= totalRows) {
            targetPositionIdx = totalRows;
        }
        else if (!above) {
            ++targetPositionIdx;
        }
        let firstAffectedLeafIdx = targetPositionIdx;
        let lastAffectedLeafIndex = Math.min(targetPositionIdx, totalRows - 1);
        for (const row of leafs) {
            const sourceRowIndex = row.sourceRowIndex;
            if (sourceRowIndex < firstAffectedLeafIdx)
                firstAffectedLeafIdx = sourceRowIndex;
            if (sourceRowIndex > lastAffectedLeafIndex)
                lastAffectedLeafIndex = sourceRowIndex;
        }
        return [firstAffectedLeafIdx, targetPositionIdx, lastAffectedLeafIndex];
    }
    /** Reorders the children of the root node, so that the rows to move are in the correct order.
     * @param leafs The valid set of rows to move, as returned by getValidRowsToMove
     * @param firstAffectedLeafIdx The first index of the rows to move
     * @param targetPositionIdx The target index, where the rows will be moved
     * @param lastAffectedLeafIndex The last index of the rows to move
     * @returns True if the order of the rows changed, false otherwise
     */
    reorderLeafChildren(leafs, firstAffectedLeafIdx, targetPositionIdx, lastAffectedLeafIndex) {
        let orderChanged = false;
        const allLeafChildren = this.clientSideRowModel.rootNode?.allLeafChildren;
        if (!leafs.size || !allLeafChildren) {
            return false;
        }
        // First partition. Filter from left to right, so the middle can be overwritten
        let writeIdxLeft = firstAffectedLeafIdx;
        for (let readIdx = firstAffectedLeafIdx; readIdx < targetPositionIdx; ++readIdx) {
            const row = allLeafChildren[readIdx];
            if (!leafs.has(row)) {
                if (row.sourceRowIndex !== writeIdxLeft) {
                    row.sourceRowIndex = writeIdxLeft;
                    allLeafChildren[writeIdxLeft] = row;
                    orderChanged = true;
                }
                ++writeIdxLeft;
            }
        }
        // Third partition. Filter from right to left, so the middle can be overwritten
        let writeIdxRight = lastAffectedLeafIndex;
        for (let readIdx = lastAffectedLeafIndex; readIdx >= targetPositionIdx; --readIdx) {
            const row = allLeafChildren[readIdx];
            if (!leafs.has(row)) {
                if (row.sourceRowIndex !== writeIdxRight) {
                    row.sourceRowIndex = writeIdxRight;
                    allLeafChildren[writeIdxRight] = row;
                    orderChanged = true;
                }
                --writeIdxRight;
            }
        }
        // Second partition. Overwrites the middle between the other two filtered partitions
        for (const row of leafs) {
            if (row.sourceRowIndex !== writeIdxLeft) {
                row.sourceRowIndex = writeIdxLeft;
                allLeafChildren[writeIdxLeft] = row;
                orderChanged = true;
            }
            ++writeIdxLeft;
        }
        return orderChanged;
    }
}
exports.RowDragFeature = RowDragFeature;
const getRowsPrevOrNext = (clientSideRowModel, above, rows) => {
    return above ? getPrevOrNext(clientSideRowModel, -1, rows[0]) : getPrevOrNext(clientSideRowModel, 1, (0, array_1._last)(rows));
};
/** When dragging multiple rows, we want the user to be able to drag to the prev or next in the group if dragging on one of the selected rows. */
const getPrevOrNext = (clientSideRowModel, increment, initialRow) => {
    if (initialRow) {
        const rowCount = clientSideRowModel.getRowCount();
        let rowIndex = initialRow.rowIndex + increment;
        while (rowIndex >= 0 && rowIndex < rowCount) {
            const row = clientSideRowModel.getRow(rowIndex);
            if (!row || !row.footer) {
                return row;
            }
            rowIndex += increment;
        }
    }
    return undefined; // Out of bounds
};
const wouldFormCycle = (row, newParent) => {
    let parent = newParent;
    while (parent) {
        if (parent === row) {
            return true;
        }
        parent = parent.parent;
    }
    return false;
};
const rowsHaveSameParent = (rows, newParent) => {
    for (let i = 0, len = rows.length; i < len; ++i) {
        if (rows[i].parent !== newParent) {
            return false;
        }
    }
    return true;
};
const getLeafSourceRowIndex = (row) => {
    const leaf = getLeafRow(row);
    return leaf !== undefined ? leaf.sourceRowIndex : -1;
};
const getLeafRow = (row) => {
    while (row) {
        if (row.sourceRowIndex >= 0) {
            return row;
        }
        const childrenAfterGroup = row.childrenAfterGroup;
        if (!childrenAfterGroup?.length) {
            return undefined;
        }
        row = childrenAfterGroup[0];
    }
};


/***/ }),

/***/ 92895:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RowDragService = void 0;
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const rowDragComp_1 = __webpack_require__(21633);
const rowDragFeature_1 = __webpack_require__(12254);
class RowDragService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'rowDragSvc';
    }
    setupRowDrag(element, ctrl) {
        const rowDragFeature = ctrl.createManagedBean(new rowDragFeature_1.RowDragFeature(element));
        const dragAndDrop = this.beans.dragAndDrop;
        dragAndDrop.addDropTarget(rowDragFeature);
        ctrl.addDestroyFunc(() => dragAndDrop.removeDropTarget(rowDragFeature));
        this.rowDragFeature = rowDragFeature;
    }
    createRowDragComp(cellValueFn, rowNode, column, customGui, dragStartPixels, suppressVisibilityChange) {
        return new rowDragComp_1.RowDragComp(cellValueFn, rowNode, column, customGui, dragStartPixels, suppressVisibilityChange);
    }
    createRowDragCompForRow(rowNode, element) {
        if ((0, gridOptionsUtils_1._isCellSelectionEnabled)(this.gos)) {
            return undefined;
        }
        const translate = this.getLocaleTextFunc();
        return this.createRowDragComp(() => `1 ${translate('rowDragRow', 'row')}`, rowNode, undefined, element, undefined, true);
    }
    createRowDragCompForCell(rowNode, column, cellValueFn, element, dragStartPixels, suppressVisibilityChange) {
        const gos = this.gos;
        if (gos.get('rowDragManaged')) {
            // row dragging only available in default row model and when not using pagination
            if (!(0, gridOptionsUtils_1._isClientSideRowModel)(gos) || gos.get('pagination')) {
                return undefined;
            }
        }
        // otherwise (normal case) we are creating a RowDraggingComp for the first time
        const rowDragComp = this.createRowDragComp(cellValueFn, rowNode, column, element, dragStartPixels, suppressVisibilityChange);
        return rowDragComp;
    }
}
exports.RowDragService = RowDragService;


/***/ }),

/***/ 37406:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RowDropHighlightService = void 0;
const beanStub_1 = __webpack_require__(68731);
class RowDropHighlightService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'rowDropHighlightSvc';
        this.uiLevel = 0;
        this.row = null;
        this.position = 'none';
    }
    postConstruct() {
        this.addManagedEventListeners({
            modelUpdated: this.onModelUpdated.bind(this),
        });
    }
    onModelUpdated() {
        const row = this.row;
        if (!row || row.rowIndex === null || this.position === 'none') {
            this.clear();
        }
        else {
            this.set(row, this.position);
        }
    }
    destroy() {
        this.clear();
        super.destroy();
    }
    clear() {
        const last = this.row;
        if (last) {
            this.uiLevel = 0;
            this.position = 'none';
            this.row = null;
            last.dispatchRowEvent('rowHighlightChanged');
        }
    }
    set(row, dropIndicatorPosition) {
        const nodeChanged = row !== this.row;
        const uiLevel = row.uiLevel;
        const highlightChanged = dropIndicatorPosition !== this.position;
        const uiLevelChanged = uiLevel !== this.uiLevel;
        if (nodeChanged || highlightChanged || uiLevelChanged) {
            if (nodeChanged) {
                this.clear();
            }
            this.uiLevel = uiLevel;
            this.position = dropIndicatorPosition;
            this.row = row;
            row.dispatchRowEvent('rowHighlightChanged');
        }
    }
}
exports.RowDropHighlightService = RowDropHighlightService;


/***/ }),

/***/ 26564:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cellEditingCSS = void 0;
exports.cellEditingCSS = `.ag-cell-inline-editing{border:var(--ag-cell-editing-border)!important;border-radius:var(--ag-border-radius);box-shadow:var(--ag-cell-editing-shadow);padding:0;z-index:1;.ag-cell-edit-wrapper,.ag-cell-editor,.ag-cell-wrapper,:where(.ag-cell-editor) .ag-input-field-input,:where(.ag-cell-editor) .ag-wrapper{height:100%;line-height:normal;min-height:100%;width:100%}&.ag-cell-editing-error{border-color:var(--ag-invalid-color)!important}}:where(.ag-popup-editor) .ag-large-text{background-color:var(--ag-background-color);border-radius:var(--ag-border-radius);box-shadow:var(--ag-dropdown-shadow);padding:0}.ag-large-text-input{height:auto;padding:var(--ag-cell-horizontal-padding)}:where(.ag-rtl .ag-large-text-input) textarea{resize:none}:where(.ag-ltr) .ag-checkbox-edit{padding-left:var(--ag-cell-horizontal-padding)}:where(.ag-rtl) .ag-checkbox-edit{padding-right:var(--ag-cell-horizontal-padding)}:where(.ag-row.ag-row-editing-invalid .ag-cell-inline-editing){opacity:.8}`;


/***/ }),

/***/ 50227:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CheckboxCellEditor = void 0;
const aria_1 = __webpack_require__(95230);
const agAbstractCellEditor_1 = __webpack_require__(94872);
const agCheckbox_1 = __webpack_require__(90066);
const component_1 = __webpack_require__(78020);
const CheckboxCellEditorElement = {
    tag: 'div',
    cls: 'ag-cell-wrapper ag-cell-edit-wrapper ag-checkbox-edit',
    children: [
        {
            tag: 'ag-checkbox',
            ref: 'eEditor',
            role: 'presentation',
        },
    ],
};
class CheckboxCellEditor extends agAbstractCellEditor_1.AgAbstractCellEditor {
    constructor() {
        super(CheckboxCellEditorElement, [agCheckbox_1.AgCheckboxSelector]);
        this.eEditor = component_1.RefPlaceholder;
    }
    initialiseEditor(params) {
        const isSelected = params.value ?? undefined;
        const eEditor = this.eEditor;
        eEditor.setValue(isSelected);
        const inputEl = eEditor.getInputElement();
        inputEl.setAttribute('tabindex', '-1');
        this.setAriaLabel(isSelected);
        this.addManagedListeners(eEditor, {
            fieldValueChanged: (event) => this.setAriaLabel(event.selected),
        });
    }
    getValue() {
        return this.eEditor.getValue();
    }
    focusIn() {
        this.eEditor.getFocusableElement().focus();
    }
    afterGuiAttached() {
        if (this.params.cellStartedEdit) {
            this.focusIn();
        }
    }
    isPopup() {
        return false;
    }
    setAriaLabel(isSelected) {
        const translate = this.getLocaleTextFunc();
        const stateName = (0, aria_1._getAriaCheckboxStateName)(translate, isSelected);
        const ariaLabel = translate('ariaToggleCellValue', 'Press SPACE to toggle cell value');
        this.eEditor.setInputAriaLabel(`${ariaLabel} (${stateName})`);
    }
    getValidationElement() {
        return this.eEditor.getInputElement();
    }
    getValidationErrors() {
        const { params } = this;
        const { getValidationErrors } = params;
        const value = this.getValue();
        if (!getValidationErrors) {
            return null;
        }
        return getValidationErrors({
            value,
            internalErrors: null,
            cellEditorParams: params,
        });
    }
}
exports.CheckboxCellEditor = CheckboxCellEditor;


/***/ }),

/***/ 65314:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DateCellEditor = void 0;
const date_1 = __webpack_require__(39827);
const generic_1 = __webpack_require__(34422);
const agInputDateField_1 = __webpack_require__(23611);
const simpleCellEditor_1 = __webpack_require__(65336);
const DateCellElement = {
    tag: 'ag-input-date-field',
    ref: 'eEditor',
    cls: 'ag-cell-editor',
};
class DateCellEditorInput {
    constructor(getDataTypeService, getLocaleTextFunc) {
        this.getDataTypeService = getDataTypeService;
        this.getLocaleTextFunc = getLocaleTextFunc;
    }
    getTemplate() {
        return DateCellElement;
    }
    getAgComponents() {
        return [agInputDateField_1.AgInputDateFieldSelector];
    }
    init(eEditor, params) {
        this.eEditor = eEditor;
        this.params = params;
        const { min, max, step, colDef } = params;
        if (min != null) {
            eEditor.setMin(min);
        }
        if (max != null) {
            eEditor.setMax(max);
        }
        if (step != null) {
            eEditor.setStep(step);
        }
        this.includeTime =
            params.includeTime ?? this.getDataTypeService()?.getDateIncludesTimeFlag?.(colDef.cellDataType);
        if (this.includeTime != null) {
            eEditor.setIncludeTime(this.includeTime);
        }
    }
    getValidationErrors() {
        const eInput = this.eEditor.getInputElement();
        const value = eInput.valueAsDate;
        const { params } = this;
        const { min, max, getValidationErrors } = params;
        let internalErrors = [];
        const translate = this.getLocaleTextFunc();
        if (value instanceof Date && !isNaN(value.getTime())) {
            if (min) {
                const minValue = min instanceof Date ? min : new Date(min);
                if (value < minValue) {
                    const minDateString = minValue.toLocaleDateString();
                    internalErrors.push(translate('minDateValidation', `Date must be after ${minDateString}`, [minDateString]));
                }
            }
            if (max) {
                const maxValue = max instanceof Date ? max : new Date(max);
                if (value > maxValue) {
                    const maxDateString = maxValue.toLocaleDateString();
                    internalErrors.push(translate('maxDateValidation', `Date must be before ${maxDateString}`, [maxDateString]));
                }
            }
        }
        if (!internalErrors.length) {
            internalErrors = null;
        }
        if (getValidationErrors) {
            return getValidationErrors({ value, cellEditorParams: params, internalErrors });
        }
        return internalErrors;
    }
    getValue() {
        const { eEditor, params } = this;
        const value = eEditor.getDate();
        if (!(0, generic_1._exists)(value) && !(0, generic_1._exists)(params.value)) {
            return params.value;
        }
        return value ?? null;
    }
    getStartValue() {
        const { value } = this.params;
        if (!(value instanceof Date)) {
            return undefined;
        }
        return (0, date_1._serialiseDate)(value, this.includeTime ?? false);
    }
}
class DateCellEditor extends simpleCellEditor_1.SimpleCellEditor {
    constructor() {
        super(new DateCellEditorInput(() => this.beans.dataTypeSvc, () => this.getLocaleTextFunc()));
    }
}
exports.DateCellEditor = DateCellEditor;


/***/ }),

/***/ 72059:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DateStringCellEditor = void 0;
const date_1 = __webpack_require__(39827);
const generic_1 = __webpack_require__(34422);
const agInputDateField_1 = __webpack_require__(23611);
const simpleCellEditor_1 = __webpack_require__(65336);
const DateStringCellElement = {
    tag: 'ag-input-date-field',
    ref: 'eEditor',
    cls: 'ag-cell-editor',
};
class DateStringCellEditorInput {
    constructor(getDataTypeService, getLocaleTextFunc) {
        this.getDataTypeService = getDataTypeService;
        this.getLocaleTextFunc = getLocaleTextFunc;
    }
    getTemplate() {
        return DateStringCellElement;
    }
    getAgComponents() {
        return [agInputDateField_1.AgInputDateFieldSelector];
    }
    init(eEditor, params) {
        this.eEditor = eEditor;
        this.params = params;
        const { min, max, step, colDef } = params;
        if (min != null) {
            eEditor.setMin(min);
        }
        if (max != null) {
            eEditor.setMax(max);
        }
        if (step != null) {
            eEditor.setStep(step);
        }
        this.includeTime =
            params.includeTime ?? this.getDataTypeService()?.getDateIncludesTimeFlag?.(colDef.cellDataType);
        if (this.includeTime != null) {
            eEditor.setIncludeTime(this.includeTime);
        }
    }
    getValidationErrors() {
        const { eEditor, params } = this;
        const raw = eEditor.getInputElement().value;
        const value = this.formatDate(this.parseDate(raw ?? undefined));
        const { min, max, getValidationErrors } = params;
        let internalErrors = [];
        if (value) {
            const date = new Date(value);
            const translate = this.getLocaleTextFunc();
            if (min) {
                const minDate = new Date(min);
                if (date < minDate) {
                    const minDateString = minDate.toLocaleDateString();
                    internalErrors.push(translate('minDateValidation', `Date must be after ${minDateString}`, [minDateString]));
                }
            }
            if (max) {
                const maxDate = new Date(max);
                if (date > maxDate) {
                    const maxDateString = maxDate.toLocaleDateString();
                    internalErrors.push(translate('maxDateValidation', `Date must be before ${maxDateString}`, [maxDateString]));
                }
            }
        }
        if (!internalErrors.length) {
            internalErrors = null;
        }
        if (getValidationErrors) {
            return getValidationErrors({
                value: this.getValue(),
                cellEditorParams: params,
                internalErrors,
            });
        }
        return internalErrors;
    }
    getValue() {
        const { params, eEditor } = this;
        const value = this.formatDate(eEditor.getDate());
        if (!(0, generic_1._exists)(value) && !(0, generic_1._exists)(params.value)) {
            return params.value;
        }
        return params.parseValue(value ?? '');
    }
    getStartValue() {
        return (0, date_1._serialiseDate)(this.parseDate(this.params.value ?? undefined) ?? null, this.includeTime ?? false);
    }
    parseDate(value) {
        const dataTypeSvc = this.getDataTypeService();
        return dataTypeSvc
            ? dataTypeSvc.getDateParserFunction(this.params.column)(value)
            : (0, date_1._parseDateTimeFromString)(value) ?? undefined;
    }
    formatDate(value) {
        const dataTypeSvc = this.getDataTypeService();
        return dataTypeSvc
            ? dataTypeSvc.getDateFormatterFunction(this.params.column)(value)
            : (0, date_1._serialiseDate)(value ?? null, this.includeTime ?? false) ?? undefined;
    }
}
class DateStringCellEditor extends simpleCellEditor_1.SimpleCellEditor {
    constructor() {
        super(new DateStringCellEditorInput(() => this.beans.dataTypeSvc, () => this.getLocaleTextFunc()));
    }
}
exports.DateStringCellEditor = DateStringCellEditor;


/***/ }),

/***/ 74578:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LargeTextCellEditor = void 0;
const keyCode_1 = __webpack_require__(39853);
const generic_1 = __webpack_require__(34422);
const agAbstractCellEditor_1 = __webpack_require__(94872);
const agInputTextArea_1 = __webpack_require__(56209);
const component_1 = __webpack_require__(78020);
const LargeTextCellElement = {
    tag: 'div',
    cls: 'ag-large-text',
    children: [
        {
            tag: 'ag-input-text-area',
            ref: 'eEditor',
            cls: 'ag-large-text-input',
        },
    ],
};
class LargeTextCellEditor extends agAbstractCellEditor_1.AgAbstractCellEditor {
    constructor() {
        super(LargeTextCellElement, [agInputTextArea_1.AgInputTextAreaSelector]);
        this.eEditor = component_1.RefPlaceholder;
    }
    initialiseEditor(params) {
        const { eEditor } = this;
        const { cellStartedEdit, value, maxLength, cols, rows } = params;
        this.focusAfterAttached = cellStartedEdit;
        // disable initial tooltips added to the input field
        // let the validation handle tooltips.
        eEditor.getInputElement().setAttribute('title', '');
        eEditor
            .setMaxLength(maxLength || 200)
            .setCols(cols || 60)
            .setRows(rows || 10);
        if (value != null) {
            eEditor.setValue(value.toString(), true);
        }
        this.addGuiEventListener('keydown', this.onKeyDown.bind(this));
        this.activateTabIndex();
    }
    onKeyDown(event) {
        const key = event.key;
        if (key === keyCode_1.KeyCode.LEFT ||
            key === keyCode_1.KeyCode.UP ||
            key === keyCode_1.KeyCode.RIGHT ||
            key === keyCode_1.KeyCode.DOWN ||
            (event.shiftKey && key === keyCode_1.KeyCode.ENTER)) {
            // shift+enter allows for newlines
            event.stopPropagation();
        }
    }
    afterGuiAttached() {
        const translate = this.getLocaleTextFunc();
        this.eEditor.setInputAriaLabel(translate('ariaInputEditor', 'Input Editor'));
        if (this.focusAfterAttached) {
            this.eEditor.getFocusableElement().focus();
        }
    }
    getValue() {
        const { eEditor, params } = this;
        const { value } = params;
        const editorValue = eEditor.getValue();
        if (!(0, generic_1._exists)(editorValue) && !(0, generic_1._exists)(value)) {
            return value;
        }
        return params.parseValue(editorValue);
    }
    getValidationElement() {
        return this.eEditor.getInputElement();
    }
    getValidationErrors() {
        const { params } = this;
        const { maxLength, getValidationErrors } = params;
        const translate = this.getLocaleTextFunc();
        const value = this.getValue();
        let internalErrors = [];
        if (typeof value === 'string' && maxLength != null && value.length > maxLength) {
            internalErrors.push(translate('maxLengthValidation', `Must be ${maxLength} characters or fewer.`, [String(maxLength)]));
        }
        if (!internalErrors.length) {
            internalErrors = null;
        }
        if (getValidationErrors) {
            return getValidationErrors({
                value,
                internalErrors,
                cellEditorParams: params,
            });
        }
        return internalErrors;
    }
}
exports.LargeTextCellEditor = LargeTextCellEditor;


/***/ }),

/***/ 44371:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NumberCellEditor = void 0;
const keyCode_1 = __webpack_require__(39853);
const browser_1 = __webpack_require__(98667);
const generic_1 = __webpack_require__(34422);
const agInputNumberField_1 = __webpack_require__(18792);
const simpleCellEditor_1 = __webpack_require__(65336);
const NumberCellElement = {
    tag: 'ag-input-number-field',
    ref: 'eEditor',
    cls: 'ag-cell-editor',
};
class NumberCellEditorInput {
    constructor(getLocaleTextFunc) {
        this.getLocaleTextFunc = getLocaleTextFunc;
    }
    getTemplate() {
        return NumberCellElement;
    }
    getAgComponents() {
        return [agInputNumberField_1.AgInputNumberFieldSelector];
    }
    init(eEditor, params) {
        this.eEditor = eEditor;
        this.params = params;
        const { max, min, precision, step } = params;
        if (max != null) {
            eEditor.setMax(max);
        }
        if (min != null) {
            eEditor.setMin(min);
        }
        if (precision != null) {
            eEditor.setPrecision(precision);
        }
        if (step != null) {
            eEditor.setStep(step);
        }
        const editorEl = eEditor.getInputElement();
        if (params.preventStepping) {
            eEditor.addManagedElementListeners(editorEl, { keydown: this.preventStepping });
        }
        else if (params.showStepperButtons) {
            editorEl.classList.add('ag-number-field-input-stepper');
        }
    }
    getValidationErrors() {
        const { params } = this;
        const { min, max, getValidationErrors } = params;
        const eInput = this.eEditor.getInputElement();
        const value = eInput.valueAsNumber;
        const translate = this.getLocaleTextFunc();
        let internalErrors = [];
        if (typeof value === 'number') {
            if (min != null && value < min) {
                internalErrors.push(translate('minValueValidation', `Must be greater than or equal to ${min}.`, [String(min)]));
            }
            if (max != null && value > max) {
                internalErrors.push(translate('maxValueValidation', `Must be less than or equal to ${max}.`, [String(max)]));
            }
        }
        if (!internalErrors.length) {
            internalErrors = null;
        }
        if (getValidationErrors) {
            return getValidationErrors({
                value,
                cellEditorParams: params,
                internalErrors,
            });
        }
        return internalErrors;
    }
    preventStepping(e) {
        if (e.key === keyCode_1.KeyCode.UP || e.key === keyCode_1.KeyCode.DOWN) {
            e.preventDefault();
        }
    }
    getValue() {
        const { eEditor, params } = this;
        const value = eEditor.getValue();
        if (!(0, generic_1._exists)(value) && !(0, generic_1._exists)(params.value)) {
            return params.value;
        }
        let parsedValue = params.parseValue(value);
        if (parsedValue == null) {
            return parsedValue;
        }
        if (typeof parsedValue === 'string') {
            if (parsedValue === '') {
                return null;
            }
            parsedValue = Number(parsedValue);
        }
        return isNaN(parsedValue) ? null : parsedValue;
    }
    getStartValue() {
        return this.params.value;
    }
    setCaret() {
        if ((0, browser_1._isBrowserSafari)()) {
            // If not safari, input is already focused.
            // For safari we need to focus only for this use case to avoid AG-3238,
            // but still ensure the input has focus.
            this.eEditor.getInputElement().focus({ preventScroll: true });
        }
    }
}
class NumberCellEditor extends simpleCellEditor_1.SimpleCellEditor {
    constructor() {
        super(new NumberCellEditorInput(() => this.getLocaleTextFunc()));
    }
}
exports.NumberCellEditor = NumberCellEditor;


/***/ }),

/***/ 55609:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PopupEditorWrapper = void 0;
const gridOptionsUtils_1 = __webpack_require__(67274);
const keyboard_1 = __webpack_require__(16466);
const popupComponent_1 = __webpack_require__(63598);
const PopupEditorElement = { tag: 'div', cls: 'ag-popup-editor', attrs: { tabindex: '-1' } };
class PopupEditorWrapper extends popupComponent_1.PopupComponent {
    constructor(params) {
        super(PopupEditorElement);
        this.params = params;
    }
    postConstruct() {
        (0, gridOptionsUtils_1._setDomData)(this.gos, this.getGui(), 'popupEditorWrapper', true);
        this.addKeyDownListener();
    }
    addKeyDownListener() {
        const eGui = this.getGui();
        const params = this.params;
        const listener = (event) => {
            if (!(0, keyboard_1._isUserSuppressingKeyboardEvent)(this.gos, event, params.node, params.column, true)) {
                params.onKeyDown(event);
            }
        };
        this.addManagedElementListeners(eGui, { keydown: listener });
    }
}
exports.PopupEditorWrapper = PopupEditorWrapper;


/***/ }),

/***/ 28774:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectCellEditor = void 0;
const keyCode_1 = __webpack_require__(39853);
const generic_1 = __webpack_require__(34422);
const logging_1 = __webpack_require__(47764);
const agAbstractCellEditor_1 = __webpack_require__(94872);
const agSelect_1 = __webpack_require__(70159);
const component_1 = __webpack_require__(78020);
const SelectCellElement = {
    tag: 'div',
    cls: 'ag-cell-edit-wrapper',
    children: [
        {
            tag: 'ag-select',
            ref: 'eEditor',
            cls: 'ag-cell-editor',
        },
    ],
};
class SelectCellEditor extends agAbstractCellEditor_1.AgAbstractCellEditor {
    wireBeans(beans) {
        this.valueSvc = beans.valueSvc;
    }
    constructor() {
        super(SelectCellElement, [agSelect_1.AgSelectSelector]);
        this.eEditor = component_1.RefPlaceholder;
        this.startedByEnter = false;
    }
    initialiseEditor(params) {
        this.focusAfterAttached = params.cellStartedEdit;
        const { eEditor, valueSvc, gos } = this;
        const { values, value, eventKey } = params;
        if ((0, generic_1._missing)(values)) {
            (0, logging_1._warn)(58);
            return;
        }
        this.startedByEnter = eventKey != null ? eventKey === keyCode_1.KeyCode.ENTER : false;
        let hasValue = false;
        values.forEach((currentValue) => {
            const option = { value: currentValue };
            const valueFormatted = valueSvc.formatValue(params.column, null, currentValue);
            const valueFormattedExits = valueFormatted !== null && valueFormatted !== undefined;
            option.text = valueFormattedExits ? valueFormatted : currentValue;
            eEditor.addOption(option);
            hasValue = hasValue || value === currentValue;
        });
        if (hasValue) {
            eEditor.setValue(params.value, true);
        }
        else if (params.values.length) {
            eEditor.setValue(params.values[0], true);
        }
        const { valueListGap, valueListMaxWidth, valueListMaxHeight } = params;
        if (valueListGap != null) {
            eEditor.setPickerGap(valueListGap);
        }
        if (valueListMaxHeight != null) {
            eEditor.setPickerMaxHeight(valueListMaxHeight);
        }
        if (valueListMaxWidth != null) {
            eEditor.setPickerMaxWidth(valueListMaxWidth);
        }
        // we don't want to add this if full row editing, otherwise selecting will stop the
        // full row editing.
        if (gos.get('editType') !== 'fullRow') {
            this.addManagedListeners(this.eEditor, { selectedItem: () => params.stopEditing() });
        }
    }
    afterGuiAttached() {
        if (this.focusAfterAttached) {
            this.eEditor.getFocusableElement().focus();
        }
        if (this.startedByEnter) {
            setTimeout(() => {
                if (this.isAlive()) {
                    this.eEditor.showPicker();
                }
            });
        }
    }
    focusIn() {
        this.eEditor.getFocusableElement().focus();
    }
    getValue() {
        return this.eEditor.getValue();
    }
    isPopup() {
        return false;
    }
    getValidationElement() {
        return this.eEditor.getAriaElement();
    }
    getValidationErrors() {
        const { params } = this;
        const { values, getValidationErrors } = params;
        const value = this.getValue();
        let internalErrors = [];
        if (values && !values.includes(value)) {
            const translate = this.getLocaleTextFunc();
            internalErrors.push(translate('invalidSelectionValidation', 'Invalid selection.'));
        }
        else {
            internalErrors = null;
        }
        if (getValidationErrors) {
            return getValidationErrors({
                value,
                internalErrors,
                cellEditorParams: params,
            });
        }
        return internalErrors;
    }
}
exports.SelectCellEditor = SelectCellEditor;


/***/ }),

/***/ 65336:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SimpleCellEditor = void 0;
const keyCode_1 = __webpack_require__(39853);
const browser_1 = __webpack_require__(98667);
const agAbstractCellEditor_1 = __webpack_require__(94872);
const component_1 = __webpack_require__(78020);
class SimpleCellEditor extends agAbstractCellEditor_1.AgAbstractCellEditor {
    constructor(cellEditorInput) {
        super();
        this.cellEditorInput = cellEditorInput;
        this.eEditor = component_1.RefPlaceholder;
    }
    initialiseEditor(params) {
        const { cellEditorInput } = this;
        this.setTemplate({ tag: 'div', cls: 'ag-cell-edit-wrapper', children: [cellEditorInput.getTemplate()] }, cellEditorInput.getAgComponents());
        const { eEditor } = this;
        const { cellStartedEdit, eventKey, suppressPreventDefault } = params;
        // disable initial tooltips added to the input field
        // let the validation handle tooltips.
        eEditor.getInputElement().setAttribute('title', '');
        cellEditorInput.init(eEditor, params);
        let startValue;
        let shouldSetStartValue = true;
        // cellStartedEdit is only false if we are doing fullRow editing
        if (cellStartedEdit) {
            this.focusAfterAttached = true;
            if (eventKey === keyCode_1.KeyCode.BACKSPACE || eventKey === keyCode_1.KeyCode.DELETE) {
                startValue = '';
            }
            else if (eventKey && eventKey.length === 1) {
                if (suppressPreventDefault) {
                    shouldSetStartValue = false;
                }
                else {
                    startValue = eventKey;
                }
            }
            else {
                startValue = cellEditorInput.getStartValue();
                if (eventKey !== keyCode_1.KeyCode.F2) {
                    this.highlightAllOnFocus = true;
                }
            }
        }
        else {
            this.focusAfterAttached = false;
            startValue = cellEditorInput.getStartValue();
        }
        if (shouldSetStartValue && startValue != null) {
            eEditor.setStartValue(startValue);
        }
        this.addGuiEventListener('keydown', (event) => {
            const { key } = event;
            if (key === keyCode_1.KeyCode.PAGE_UP || key === keyCode_1.KeyCode.PAGE_DOWN) {
                event.preventDefault();
            }
        });
    }
    afterGuiAttached() {
        const translate = this.getLocaleTextFunc();
        const eInput = this.eEditor;
        eInput.setInputAriaLabel(translate('ariaInputEditor', 'Input Editor'));
        if (!this.focusAfterAttached) {
            return;
        }
        // Added for AG-3238. We can't remove this explicit focus() because Chrome requires an input
        // to be focused before setSelectionRange will work. But it triggers a bug in Safari where
        // explicitly focusing then blurring an empty field will cause the parent container to scroll.
        if (!(0, browser_1._isBrowserSafari)()) {
            eInput.getFocusableElement().focus();
        }
        const inputEl = eInput.getInputElement();
        if (this.highlightAllOnFocus) {
            inputEl.select();
        }
        else {
            this.cellEditorInput.setCaret?.();
        }
    }
    // gets called when tabbing through cells and in full row edit mode
    focusIn() {
        const { eEditor } = this;
        const focusEl = eEditor.getFocusableElement();
        const inputEl = eEditor.getInputElement();
        focusEl.focus();
        inputEl.select();
    }
    getValue() {
        return this.cellEditorInput.getValue();
    }
    isPopup() {
        return false;
    }
    getValidationElement() {
        return this.eEditor.getInputElement();
    }
    getValidationErrors() {
        return this.cellEditorInput.getValidationErrors();
    }
}
exports.SimpleCellEditor = SimpleCellEditor;


/***/ }),

/***/ 15457:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextCellEditor = void 0;
const generic_1 = __webpack_require__(34422);
const agInputTextField_1 = __webpack_require__(45946);
const simpleCellEditor_1 = __webpack_require__(65336);
const TextCellEditorElement = {
    tag: 'ag-input-text-field',
    ref: 'eEditor',
    cls: 'ag-cell-editor',
};
class TextCellEditorInput {
    constructor(getLocaleTextFunc) {
        this.getLocaleTextFunc = getLocaleTextFunc;
    }
    getTemplate() {
        return TextCellEditorElement;
    }
    getAgComponents() {
        return [agInputTextField_1.AgInputTextFieldSelector];
    }
    init(eEditor, params) {
        this.eEditor = eEditor;
        this.params = params;
        const maxLength = params.maxLength;
        if (maxLength != null) {
            eEditor.setMaxLength(maxLength);
        }
    }
    getValidationErrors() {
        const { params } = this;
        const { maxLength, getValidationErrors } = params;
        const value = this.getValue();
        const translate = this.getLocaleTextFunc();
        let internalErrors = [];
        if (maxLength != null && typeof value === 'string' && value.length > maxLength) {
            internalErrors.push(translate('maxLengthValidation', `Must be ${maxLength} characters or fewer.`, [String(maxLength)]));
        }
        if (!internalErrors.length) {
            internalErrors = null;
        }
        if (getValidationErrors) {
            return getValidationErrors({ value, cellEditorParams: params, internalErrors });
        }
        return internalErrors;
    }
    getValue() {
        const { eEditor, params } = this;
        const value = eEditor.getValue();
        if (!(0, generic_1._exists)(value) && !(0, generic_1._exists)(params.value)) {
            return params.value;
        }
        return params.parseValue(value);
    }
    getStartValue() {
        const params = this.params;
        const formatValue = params.useFormatter || params.column.getColDef().refData;
        return formatValue ? params.formatValue(params.value) : params.value;
    }
    setCaret() {
        // when we started editing, we want the caret at the end, not the start.
        // this comes into play in two scenarios:
        //   a) when user hits F2
        //   b) when user hits a printable character
        const eInput = this.eEditor;
        const value = eInput.getValue();
        const len = ((0, generic_1._exists)(value) && value.length) || 0;
        if (len) {
            eInput.getInputElement().setSelectionRange(len, len);
        }
    }
}
class TextCellEditor extends simpleCellEditor_1.SimpleCellEditor {
    constructor() {
        super(new TextCellEditorInput(() => this.getLocaleTextFunc()));
    }
}
exports.TextCellEditor = TextCellEditor;


/***/ }),

/***/ 52470:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCurrentRedoSize = exports.getCurrentUndoSize = exports.validateEdit = exports.cancelEdits = exports.startEditingCell = exports.isEditing = exports.stopEditing = exports.getEditingCells = exports.redoCellEditing = exports.undoCellEditing = void 0;
const scrollApi_1 = __webpack_require__(11765);
const positionUtils_1 = __webpack_require__(6257);
const logging_1 = __webpack_require__(47764);
const controllers_1 = __webpack_require__(1081);
const editors_1 = __webpack_require__(78994);
function undoCellEditing(beans) {
    beans.undoRedo?.undo('api');
}
exports.undoCellEditing = undoCellEditing;
function redoCellEditing(beans) {
    beans.undoRedo?.redo('api');
}
exports.redoCellEditing = redoCellEditing;
function getEditingCells(beans) {
    const edits = beans.editModelSvc?.getEditMap();
    const positions = [];
    edits?.forEach((editRow, rowNode) => {
        const { rowIndex, rowPinned } = rowNode;
        editRow.forEach(({ newValue, oldValue, state }, column) => {
            const diff = (0, editors_1._valuesDiffer)({ newValue, oldValue });
            if (newValue === editors_1.UNEDITED) {
                newValue = undefined;
            }
            const edit = {
                newValue,
                oldValue,
                state,
                column,
                colId: column.getColId(),
                colKey: column.getColId(),
                rowIndex: rowIndex,
                rowPinned,
            };
            const changed = state === 'changed' && diff;
            const editing = state === 'editing';
            if (editing) {
                positions.push(edit);
            }
            else if (changed) {
                positions.push(edit);
            }
        });
    });
    return positions;
}
exports.getEditingCells = getEditingCells;
function stopEditing(beans, cancel = false) {
    const { editSvc } = beans;
    if (editSvc?.isBatchEditing()) {
        if (cancel) {
            beans.editModelSvc?.getEditPositions().forEach((cellPosition) => {
                if (cellPosition.state === 'editing') {
                    editSvc.revertSingleCellEdit(cellPosition);
                }
            });
        }
        else {
            (0, editors_1._syncFromEditors)(beans);
        }
        (0, editors_1._destroyEditors)(beans);
    }
    else {
        editSvc?.stopEditing(undefined, { cancel, source: 'api' });
    }
}
exports.stopEditing = stopEditing;
function isEditing(beans, cellPosition) {
    const cellCtrl = (0, controllers_1._getCellCtrl)(beans, cellPosition);
    return beans.editSvc?.isEditing(cellCtrl) ?? false;
}
exports.isEditing = isEditing;
function startEditingCell(beans, params) {
    const { key, colKey, rowIndex, rowPinned } = params;
    const { editSvc, colModel } = beans;
    const column = colModel.getCol(colKey);
    if (!column) {
        (0, logging_1._warn)(12, { colKey });
        return;
    }
    const cellPosition = {
        rowIndex,
        rowPinned: rowPinned || null,
        column,
    };
    const notPinned = rowPinned == null;
    if (notPinned) {
        (0, scrollApi_1.ensureIndexVisible)(beans, rowIndex);
    }
    (0, scrollApi_1.ensureColumnVisible)(beans, colKey);
    if (!(0, positionUtils_1._getCellByPosition)(beans, cellPosition)) {
        return;
    }
    editSvc?.setEditingCells([
        {
            ...cellPosition,
            colId: column.getColId(),
            newValue: key,
            state: 'editing',
        },
    ], { update: true });
}
exports.startEditingCell = startEditingCell;
function cancelEdits({ editSvc }) {
    editSvc?.stopEditing(undefined, { cancel: true, source: editSvc?.isBatchEditing() ? 'ui' : 'api' });
}
exports.cancelEdits = cancelEdits;
function validateEdit(beans) {
    return beans.editSvc?.validateEdit() || null;
}
exports.validateEdit = validateEdit;
function getCurrentUndoSize(beans) {
    return beans.undoRedo?.getCurrentUndoStackSize() ?? 0;
}
exports.getCurrentUndoSize = getCurrentUndoSize;
function getCurrentRedoSize(beans) {
    return beans.undoRedo?.getCurrentRedoStackSize() ?? 0;
}
exports.getCurrentRedoSize = getCurrentRedoSize;


/***/ }),

/***/ 68544:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EditRowValidationModel = exports.EditCellValidationModel = exports.EditModelService = void 0;
const beanStub_1 = __webpack_require__(68731);
const editors_1 = __webpack_require__(78994);
class EditModelService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'editModelSvc';
        this.edits = new Map();
        this.cellValidations = new EditCellValidationModel();
        this.rowValidations = new EditRowValidationModel();
        // during some operations, we want to always return false from `hasEdits`
        this.suspendEdits = false;
    }
    suspend(suspend) {
        this.suspendEdits = suspend;
    }
    removeEdits({ rowNode, column }) {
        if (!this.hasEdits({ rowNode }) || !rowNode) {
            return;
        }
        const editRow = this.getEditRow(rowNode);
        if (column) {
            editRow.delete(column);
        }
        else {
            editRow.clear();
        }
        if (editRow.size === 0) {
            this.edits.delete(rowNode);
        }
    }
    getEditRow(rowNode, params = {}) {
        if (this.suspendEdits) {
            return undefined;
        }
        if (this.edits.size === 0) {
            return undefined;
        }
        const edits = rowNode && this.edits.get(rowNode);
        if (edits) {
            return edits;
        }
        if (params.checkSiblings) {
            const pinnedSibling = rowNode.pinnedSibling;
            if (pinnedSibling) {
                return this.getEditRow(pinnedSibling);
            }
        }
        return undefined;
    }
    getEditRowDataValue(rowNode, { checkSiblings } = {}) {
        if (this.edits.size === 0) {
            return rowNode.data;
        }
        const editRow = this.getEditRow(rowNode);
        const pinnedSibling = rowNode.pinnedSibling;
        const siblingRow = checkSiblings && pinnedSibling && this.getEditRow(pinnedSibling);
        if (!editRow && !siblingRow) {
            return rowNode.data;
        }
        const data = Object.assign({}, rowNode.data);
        const applyEdits = (edits, data) => edits.forEach(({ newValue }, column) => {
            if (newValue !== editors_1.UNEDITED) {
                data[column.getColId()] = newValue;
            }
        });
        if (editRow) {
            applyEdits(editRow, data);
        }
        if (siblingRow) {
            applyEdits(siblingRow, data);
        }
        return data;
    }
    getEdit(position) {
        if (this.suspendEdits) {
            return undefined;
        }
        if (this.edits.size === 0) {
            return undefined;
        }
        return position.rowNode && position.column && this.getEditRow(position.rowNode)?.get(position.column);
    }
    getEditMap(copy = true) {
        if (this.suspendEdits || this.edits.size === 0) {
            return new Map();
        }
        if (!copy) {
            return this.edits;
        }
        const map = new Map();
        this.edits.forEach((editRow, rowNode) => map.set(rowNode, new Map(editRow)));
        return map;
    }
    setEditMap(newEdits) {
        this.edits.clear();
        newEdits.forEach((editRow, rowNode) => {
            const newRow = new Map();
            editRow.forEach((cellData, column) => 
            // Ensure we copy the cell data to avoid reference issues
            newRow.set(column, { ...cellData }));
            this.edits.set(rowNode, newRow);
        });
    }
    setEdit(position, edit) {
        (this.edits.size === 0 || !this.edits.has(position.rowNode)) && this.edits.set(position.rowNode, new Map());
        this.getEditRow(position.rowNode).set(position.column, edit);
    }
    clearEditValue(position) {
        const { rowNode, column } = position;
        if (rowNode) {
            if (column) {
                const edit = this.getEdit(position);
                if (edit) {
                    edit.newValue = edit.oldValue;
                    edit.state = 'changed';
                }
            }
            else {
                this.getEditRow(rowNode)?.forEach((cellData) => {
                    cellData.newValue = cellData.oldValue;
                    cellData.state = 'changed';
                });
            }
        }
    }
    setState(position, state) {
        if (!position.rowNode || !position.column) {
            return;
        }
        const { rowNode, column } = position;
        let editRow = this.getEditRow(rowNode);
        const edit = editRow?.get(column);
        if (edit) {
            edit.state = state;
        }
        else {
            if (!editRow) {
                editRow = new Map();
                this.edits.set(rowNode, editRow);
            }
            editRow.set(column, { newValue: undefined, oldValue: undefined, state });
        }
    }
    getState(position) {
        if (this.suspendEdits) {
            return undefined;
        }
        return this.getEdit(position)?.state;
    }
    getEditPositions(editMap) {
        if (this.suspendEdits || this.edits.size === 0) {
            return [];
        }
        const positions = [];
        (editMap ?? this.edits).forEach((editRow, rowNode) => {
            for (const column of editRow.keys()) {
                positions.push({
                    rowNode,
                    column,
                    ...editRow.get(column),
                });
            }
        });
        return positions;
    }
    hasRowEdits(rowNode, params) {
        if (this.suspendEdits) {
            return false;
        }
        if (this.edits.size === 0) {
            return false;
        }
        const rowEdits = this.getEditRow(rowNode, params);
        return !!rowEdits;
    }
    hasEdits(position = {}, params = {}) {
        if (this.suspendEdits) {
            return false;
        }
        if (this.edits.size === 0) {
            return false;
        }
        const { rowNode, column } = position;
        const { withOpenEditor } = params;
        if (rowNode) {
            const rowEdits = this.getEditRow(rowNode, params);
            if (!rowEdits) {
                return false;
            }
            if (column) {
                if (withOpenEditor) {
                    return this.getEdit(position)?.state === 'editing';
                }
                return rowEdits.has(column) ?? false;
            }
            if (rowEdits.size !== 0) {
                if (withOpenEditor) {
                    return Array.from(rowEdits.values()).some(({ state }) => state === 'editing');
                }
                return true;
            }
            return false;
        }
        if (withOpenEditor) {
            return this.getEditPositions().some(({ state }) => state === 'editing');
        }
        return this.edits.size > 0;
    }
    start(position) {
        const map = this.getEditRow(position.rowNode) ?? new Map();
        const { rowNode, column } = position;
        if (column && !map.has(column)) {
            map.set(column, {
                newValue: editors_1.UNEDITED,
                oldValue: this.beans.valueSvc.getValue(column, rowNode, true, 'api'),
                state: 'editing',
            });
        }
        this.edits.set(rowNode, map);
    }
    stop(position) {
        if (!this.hasEdits(position)) {
            return;
        }
        if (position) {
            this.removeEdits(position);
        }
        else {
            this.clear();
        }
        return;
    }
    clear() {
        for (const pendingRowEdits of this.edits.values()) {
            pendingRowEdits.clear();
        }
        this.edits.clear();
    }
    getCellValidationModel() {
        return this.cellValidations;
    }
    getRowValidationModel() {
        return this.rowValidations;
    }
    setCellValidationModel(model) {
        this.cellValidations = model;
    }
    setRowValidationModel(model) {
        this.rowValidations = model;
    }
    destroy() {
        super.destroy();
        this.clear();
    }
}
exports.EditModelService = EditModelService;
class EditCellValidationModel {
    constructor() {
        this.cellValidations = new Map();
    }
    getCellValidation(position) {
        const { rowNode, column } = position || {};
        return this.cellValidations?.get(rowNode)?.get(column);
    }
    hasCellValidation(position) {
        if (!position || !position.rowNode || !position.column) {
            return this.cellValidations.size > 0;
        }
        return !!this.getCellValidation(position);
    }
    setCellValidation(position, validation) {
        const { rowNode, column } = position;
        if (!this.cellValidations.has(rowNode)) {
            this.cellValidations.set(rowNode, new Map());
        }
        this.cellValidations.get(rowNode).set(column, validation);
    }
    clearCellValidation(position) {
        const { rowNode, column } = position;
        this.cellValidations.get(rowNode)?.delete(column);
    }
    setCellValidationMap(validationMap) {
        this.cellValidations = validationMap;
    }
    getCellValidationMap() {
        return this.cellValidations;
    }
    clearCellValidationMap() {
        this.cellValidations.clear();
    }
}
exports.EditCellValidationModel = EditCellValidationModel;
class EditRowValidationModel {
    constructor() {
        this.rowValidations = new Map();
    }
    getRowValidation(position) {
        const { rowNode } = position || {};
        return this.rowValidations.get(rowNode);
    }
    hasRowValidation(position) {
        if (!position || !position.rowNode) {
            return this.rowValidations.size > 0;
        }
        return !!this.getRowValidation(position);
    }
    setRowValidation({ rowNode }, rowValidation) {
        this.rowValidations.set(rowNode, rowValidation);
    }
    clearRowValidation({ rowNode }) {
        this.rowValidations.delete(rowNode);
    }
    setRowValidationMap(validationMap) {
        this.rowValidations = validationMap;
    }
    getRowValidationMap() {
        return this.rowValidations;
    }
    clearRowValidationMap() {
        this.rowValidations.clear();
    }
}
exports.EditRowValidationModel = EditRowValidationModel;


/***/ }),

/***/ 84652:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CustomEditorModule = exports.LargeTextEditorModule = exports.SelectEditorModule = exports.CheckboxEditorModule = exports.DateEditorModule = exports.NumberEditorModule = exports.TextEditorModule = exports.UndoRedoEditModule = exports.EditCoreModule = void 0;
const tooltipModule_1 = __webpack_require__(34658);
const undoRedoService_1 = __webpack_require__(57113);
const version_1 = __webpack_require__(97205);
const popupModule_1 = __webpack_require__(3137);
const cell_editing_css_GENERATED_1 = __webpack_require__(26564);
const checkboxCellEditor_1 = __webpack_require__(50227);
const dateCellEditor_1 = __webpack_require__(65314);
const dateStringCellEditor_1 = __webpack_require__(72059);
const largeTextCellEditor_1 = __webpack_require__(74578);
const numberCellEditor_1 = __webpack_require__(44371);
const selectCellEditor_1 = __webpack_require__(28774);
const textCellEditor_1 = __webpack_require__(15457);
const editApi_1 = __webpack_require__(52470);
const editModelService_1 = __webpack_require__(68544);
const editService_1 = __webpack_require__(61277);
const fullRowEditStrategy_1 = __webpack_require__(40104);
const singleCellEditStrategy_1 = __webpack_require__(30149);
const editors_1 = __webpack_require__(78994);
/**
 * @internal
 */
exports.EditCoreModule = {
    moduleName: 'EditCore',
    version: version_1.VERSION,
    beans: [editModelService_1.EditModelService, editService_1.EditService],
    apiFunctions: {
        getEditingCells: editApi_1.getEditingCells,
        getCellEditorInstances: editors_1.getCellEditorInstances,
        startEditingCell: editApi_1.startEditingCell,
        stopEditing: editApi_1.stopEditing,
        isEditing: editApi_1.isEditing,
        validateEdit: editApi_1.validateEdit,
    },
    dynamicBeans: {
        singleCell: singleCellEditStrategy_1.SingleCellEditStrategy,
        fullRow: fullRowEditStrategy_1.FullRowEditStrategy,
    },
    dependsOn: [popupModule_1.PopupModule, tooltipModule_1.TooltipModule],
    css: [cell_editing_css_GENERATED_1.cellEditingCSS],
};
/**
 * @feature Editing -> Undo / Redo Edits
 */
exports.UndoRedoEditModule = {
    moduleName: 'UndoRedoEdit',
    version: version_1.VERSION,
    beans: [undoRedoService_1.UndoRedoService],
    apiFunctions: {
        undoCellEditing: editApi_1.undoCellEditing,
        redoCellEditing: editApi_1.redoCellEditing,
        getCurrentUndoSize: editApi_1.getCurrentUndoSize,
        getCurrentRedoSize: editApi_1.getCurrentRedoSize,
    },
    dependsOn: [exports.EditCoreModule],
};
/**
 * @feature Editing -> Text Editor
 */
exports.TextEditorModule = {
    moduleName: 'TextEditor',
    version: version_1.VERSION,
    userComponents: { agCellEditor: textCellEditor_1.TextCellEditor, agTextCellEditor: textCellEditor_1.TextCellEditor },
    dependsOn: [exports.EditCoreModule],
};
/**
 * @feature Editing -> Number Editor
 */
exports.NumberEditorModule = {
    moduleName: 'NumberEditor',
    version: version_1.VERSION,
    userComponents: {
        agNumberCellEditor: {
            classImp: numberCellEditor_1.NumberCellEditor,
        },
    },
    dependsOn: [exports.EditCoreModule],
};
/**
 * @feature Editing -> Date Editor
 */
exports.DateEditorModule = {
    moduleName: 'DateEditor',
    version: version_1.VERSION,
    userComponents: {
        agDateCellEditor: dateCellEditor_1.DateCellEditor,
        agDateStringCellEditor: dateStringCellEditor_1.DateStringCellEditor,
    },
    dependsOn: [exports.EditCoreModule],
};
/**
 * @feature Editing -> Checkbox Editor
 */
exports.CheckboxEditorModule = {
    moduleName: 'CheckboxEditor',
    version: version_1.VERSION,
    userComponents: {
        agCheckboxCellEditor: checkboxCellEditor_1.CheckboxCellEditor,
    },
    dependsOn: [exports.EditCoreModule],
};
/**
 * @feature Editing -> Select Editor
 */
exports.SelectEditorModule = {
    moduleName: 'SelectEditor',
    version: version_1.VERSION,
    userComponents: { agSelectCellEditor: selectCellEditor_1.SelectCellEditor },
    dependsOn: [exports.EditCoreModule],
};
/**
 * @feature Editing -> Large Text Editor
 */
exports.LargeTextEditorModule = {
    moduleName: 'LargeTextEditor',
    version: version_1.VERSION,
    userComponents: { agLargeTextCellEditor: largeTextCellEditor_1.LargeTextCellEditor },
    dependsOn: [exports.EditCoreModule],
};
/**
 * @feature Editing
 */
exports.CustomEditorModule = {
    moduleName: 'CustomEditor',
    version: version_1.VERSION,
    dependsOn: [exports.EditCoreModule],
};


/***/ }),

/***/ 61277:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EditService = void 0;
const keyCode_1 = __webpack_require__(39853);
const beanStub_1 = __webpack_require__(68731);
const positionUtils_1 = __webpack_require__(6257);
const gridOptionsUtils_1 = __webpack_require__(67274);
const cellCtrl_1 = __webpack_require__(60814);
const popupEditorWrapper_1 = __webpack_require__(55609);
const cellEditStyleFeature_1 = __webpack_require__(46904);
const rowEditStyleFeature_1 = __webpack_require__(13536);
const controllers_1 = __webpack_require__(1081);
const editors_1 = __webpack_require__(78994);
const refresh_1 = __webpack_require__(11539);
// stop editing sources that we treat as UI-originated so we follow standard processing.
const SOURCE_TRANSFORM = {
    paste: 'ui',
    rangeSvc: 'ui',
    fillHandle: 'api',
    cellClear: 'api',
};
const SOURCE_TRANSFORM_KEYS = new Set(Object.keys(SOURCE_TRANSFORM));
const CANCEL_PARAMS = { cancel: true, source: 'api' };
const COMMIT_PARAMS = { cancel: false, source: 'api' };
const CHECK_SIBLING = { checkSiblings: true };
const FORCE_REFRESH = { force: true, suppressFlash: true };
class EditService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'editSvc';
        this.batch = false;
    }
    postConstruct() {
        const { beans } = this;
        this.model = beans.editModelSvc;
        this.valueSvc = beans.valueSvc;
        this.rangeSvc = beans.rangeSvc;
        this.addManagedPropertyListener('editType', ({ currentValue }) => {
            this.stopEditing(undefined, CANCEL_PARAMS);
            // will re-create if different
            this.createStrategy(currentValue);
        });
        const handler = (0, refresh_1._refreshEditCells)(beans);
        const stopInvalidEdits = () => {
            const hasCellValidation = this.model.getCellValidationModel().getCellValidationMap().size > 0;
            const hasRowValidation = this.model.getRowValidationModel().getRowValidationMap().size > 0;
            if (hasCellValidation || hasRowValidation) {
                this.stopEditing(undefined, CANCEL_PARAMS);
            }
            else {
                if (this.isEditing()) {
                    if (this.isBatchEditing()) {
                        (0, editors_1._destroyEditors)(beans, this.model.getEditPositions());
                    }
                    else {
                        this.stopEditing(undefined, COMMIT_PARAMS);
                    }
                }
            }
            return false;
        };
        this.addManagedEventListeners({
            columnPinned: handler,
            columnVisible: handler,
            columnRowGroupChanged: handler,
            rowGroupOpened: handler,
            pinnedRowsChanged: handler,
            displayedRowsChanged: handler,
            rowDataUpdated: stopInvalidEdits,
            sortChanged: stopInvalidEdits,
            filterChanged: stopInvalidEdits,
            cellFocused: this.onCellFocused.bind(this),
        });
    }
    isBatchEditing() {
        return this.batch;
    }
    setBatchEditing(enabled) {
        if (enabled) {
            this.batch = true;
            this.stopEditing(undefined, CANCEL_PARAMS);
        }
        else {
            this.stopEditing(undefined, CANCEL_PARAMS);
            this.batch = false;
        }
    }
    createStrategy(editType) {
        const { beans, gos, strategy } = this;
        const name = editType ?? gos.get('editType') ?? 'singleCell';
        if (strategy) {
            if (strategy.beanName === name) {
                return strategy;
            }
            this.destroyStrategy();
        }
        return (this.strategy = this.createOptionalManagedBean(beans.registry.createDynamicBean(name, true)));
    }
    destroyStrategy() {
        if (!this.strategy) {
            return;
        }
        this.strategy.destroy();
        this.strategy = this.destroyBean(this.strategy);
    }
    shouldStartEditing(position, event, cellStartedEdit, source = 'ui') {
        this.strategy ?? (this.strategy = this.createStrategy());
        return this.strategy?.shouldStart(position, event, cellStartedEdit, source) ?? null;
    }
    shouldStopEditing(position, event, source = 'ui') {
        return this.strategy?.shouldStop(position, event, source) ?? null;
    }
    shouldCancelEditing(position, event, source = 'ui') {
        return this.strategy?.shouldCancel(position, event, source) ?? null;
    }
    validateEdit() {
        return (0, editors_1._validateEdit)(this.beans);
    }
    isEditing(position, params) {
        return this.model.hasEdits(position, params ?? CHECK_SIBLING);
    }
    isRowEditing(rowNode, params) {
        return (rowNode && this.model.hasRowEdits(rowNode, params)) ?? false;
    }
    /** @returns whether to prevent default on event */
    startEditing(position, params) {
        const { startedEdit = true, event = null, source = 'ui', ignoreEventKey = false } = params;
        this.strategy ?? (this.strategy = this.createStrategy());
        if (!this.isCellEditable(position, 'api')) {
            return;
        }
        // because of async in React, the cellComp may not be set yet, if no cellComp then we are
        // yet to initialise the cell, so we re-schedule this operation for when celLComp is attached
        const cellCtrl = (0, controllers_1._getCellCtrl)(this.beans, position);
        if (cellCtrl && !cellCtrl.comp) {
            cellCtrl.onCompAttachedFuncs.push(() => this.startEditing(position, params));
            return;
        }
        const res = this.shouldStartEditing?.(position, event, startedEdit, source);
        if (res === false && source !== 'api') {
            this.isEditing(position) && this.stopEditing();
            return;
        }
        if (!this.batch && this.shouldStopEditing(position, undefined, source)) {
            this.stopEditing(undefined, { source });
        }
        if (res && this.isBatchEditing()) {
            this.dispatchBatchEvent('batchEditingStarted', new Map());
        }
        this.strategy.start(position, event, source, ignoreEventKey);
        return;
    }
    stopEditing(position, params) {
        const { event, cancel, source = 'ui', suppressNavigateAfterEdit } = params || {};
        const { beans, model } = this;
        if (SOURCE_TRANSFORM_KEYS.has(source)) {
            if (this.isBatchEditing()) {
                // if we are in batch editing, we do not stop editing on paste
                this.bulkRefresh(position);
                return false;
            }
            return this.stopEditing(position, { ...params, source: SOURCE_TRANSFORM[source] });
        }
        if (!this.isEditing() || !this.strategy) {
            return false;
        }
        const cellCtrl = (0, controllers_1._getCellCtrl)(beans, position);
        if (cellCtrl) {
            cellCtrl.onEditorAttachedFuncs = [];
        }
        let edits = model.getEditMap(true);
        let res = false;
        const willStop = !cancel && !!this.shouldStopEditing(position, event, source);
        const willCancel = cancel && !!this.shouldCancelEditing(position, event, source);
        if (willStop || willCancel) {
            (0, editors_1._syncFromEditors)(beans);
            const freshEdits = model.getEditMap();
            this.processEdits(freshEdits, cancel);
            this.strategy?.stop(cancel);
            this.bulkRefresh(undefined, edits);
            edits = freshEdits;
            res || (res = willStop);
        }
        else if (event instanceof KeyboardEvent &&
            this.batch &&
            this.strategy?.midBatchInputsAllowed(position) &&
            this.isEditing(position, { withOpenEditor: true })) {
            const key = event.key;
            const isEnter = key === keyCode_1.KeyCode.ENTER;
            const isEscape = key === keyCode_1.KeyCode.ESCAPE;
            if (isEnter || isEscape) {
                if (isEnter) {
                    (0, editors_1._syncFromEditors)(beans);
                }
                else if (isEscape) {
                    // only if ESC is pressed while in the editor for this cell
                    this.revertSingleCellEdit(cellCtrl, false);
                }
                (0, editors_1._destroyEditors)(beans, model.getEditPositions());
                event.preventDefault();
                this.bulkRefresh(position, edits, { suppressFlash: true });
                edits = model.getEditMap();
            }
        }
        else {
            (0, editors_1._syncFromEditors)(beans);
            edits = model.getEditMap();
        }
        if (res && position) {
            this.model.removeEdits(position);
        }
        if (!suppressNavigateAfterEdit && cellCtrl) {
            this.navigateAfterEdit(event instanceof KeyboardEvent && event.shiftKey, cellCtrl.cellPosition);
        }
        (0, editors_1._purgeUnchangedEdits)(beans);
        if (!this.model.hasEdits()) {
            this.model.getCellValidationModel().clearCellValidationMap();
            this.model.getRowValidationModel().clearRowValidationMap();
        }
        this.bulkRefresh();
        if (willCancel) {
            // if we cancelled the edit, we need to refresh the rows to remove the pending value and editing styles
            this.beans.rowRenderer.refreshRows({ rowNodes: Array.from(edits.keys()) });
        }
        if (this.isBatchEditing()) {
            this.beans.rowRenderer.refreshRows({ suppressFlash: true, force: true });
            if (res && willStop) {
                this.dispatchBatchEvent('batchEditingStopped', edits);
            }
        }
        return res;
    }
    navigateAfterEdit(shiftKey, cellPosition) {
        const navAfterEdit = this.gos.get('enterNavigatesVerticallyAfterEdit');
        if (navAfterEdit) {
            const key = shiftKey ? keyCode_1.KeyCode.UP : keyCode_1.KeyCode.DOWN;
            this.beans.navigation?.navigateToNextCell(null, key, cellPosition, false);
        }
    }
    processEdits(edits, cancel = false) {
        const rowNodes = Array.from(edits.keys());
        const { beans } = this;
        const hasValidationErrors = this.model.getCellValidationModel().getCellValidationMap().size > 0 ||
            this.model.getRowValidationModel().getRowValidationMap().size > 0;
        for (const rowNode of rowNodes) {
            const editRow = edits.get(rowNode);
            for (const column of editRow.keys()) {
                const editValue = editRow.get(column);
                const position = { rowNode, column };
                const cellCtrl = (0, controllers_1._getCellCtrl)(beans, position);
                const valueChanged = (0, editors_1._valuesDiffer)(editValue);
                if (!cancel && valueChanged && !hasValidationErrors) {
                    // we suppressRefreshCell because the call to rowNode.setDataValue() results in change detection
                    // getting triggered, which results in all cells getting refreshed. we do not want this refresh
                    // to happen on this call as we want to call it explicitly below. otherwise refresh gets called twice.
                    // if we only did this refresh (and not the one below) then the cell would flash and not be forced.
                    if (cellCtrl) {
                        cellCtrl.suppressRefreshCell = true;
                    }
                    rowNode.setDataValue(column, editValue.newValue, 'commit');
                    if (cellCtrl) {
                        cellCtrl.suppressRefreshCell = false;
                    }
                    cellCtrl?.refreshCell(FORCE_REFRESH);
                }
            }
        }
    }
    setEditMap(edits, params) {
        this.strategy ?? (this.strategy = this.createStrategy());
        this.strategy?.setEditMap(edits, params);
        this.bulkRefresh();
        // force refresh of all row cells as custom renderers may depend on multiple cell values
        this.beans.rowRenderer.refreshCells(FORCE_REFRESH);
    }
    dispatchEditValuesChanged({ rowNode, column }, edit = {}) {
        if (!rowNode || !column || !edit) {
            return;
        }
        const { newValue, oldValue } = edit;
        const { rowIndex, rowPinned, data } = rowNode;
        this.beans.eventSvc.dispatchEvent({
            type: 'cellEditValuesChanged',
            node: rowNode,
            rowIndex,
            rowPinned,
            column,
            source: 'api',
            data,
            newValue,
            oldValue,
            value: newValue,
            colDef: column.getColDef(),
        });
    }
    bulkRefresh(position = {}, editMap, params = {}) {
        const { beans, gos } = this;
        const { editModelSvc, rowModel } = beans;
        if ((0, gridOptionsUtils_1._isClientSideRowModel)(gos, rowModel)) {
            if (position.rowNode && position.column) {
                this.refCell(position, this.model.getEdit(position), params);
            }
            else if (editMap) {
                editModelSvc?.getEditMap(false)?.forEach((editRow, rowNode) => {
                    for (const column of editRow.keys()) {
                        this.refCell({ rowNode, column }, editRow.get(column), params);
                    }
                });
            }
        }
    }
    refCell({ rowNode, column }, edit, params = {}) {
        const { beans, gos } = this;
        const updatedNodes = new Set([rowNode]);
        const refreshNodes = new Set();
        const pinnedSibling = rowNode.pinnedSibling;
        if (pinnedSibling) {
            updatedNodes.add(pinnedSibling);
        }
        const sibling = rowNode.sibling;
        if (sibling) {
            refreshNodes.add(sibling);
        }
        let parent = rowNode.parent;
        while (parent) {
            if (parent.sibling?.footer && gos.get('groupTotalRow')) {
                refreshNodes.add(parent.sibling);
            }
            else if (!parent.parent && parent.sibling && gos.get('grandTotalRow')) {
                refreshNodes.add(parent.sibling);
            }
            else {
                refreshNodes.add(parent);
            }
            parent = parent.parent;
        }
        updatedNodes.forEach((node) => this.dispatchEditValuesChanged({ rowNode: node, column }, edit));
        updatedNodes.forEach((node) => (0, controllers_1._getCellCtrl)(beans, { rowNode: node, column })?.refreshCell(params));
        refreshNodes.forEach((node) => (0, controllers_1._getCellCtrl)(beans, { rowNode: node, column })?.refreshCell(params));
    }
    stopAllEditing(cancel = false, source = 'ui') {
        if (this.isEditing()) {
            this.stopEditing(undefined, { cancel, source });
        }
    }
    isCellEditable(position, source = 'ui') {
        const { rowNode } = position;
        if (rowNode.group) {
            // This is a group - it could be a tree group or a grouping group...
            if (this.gos.get('treeData')) {
                // tree - allow editing of groups with data by default.
                // Allow editing filler nodes (node without data) only if enableGroupEdit is true.
                if (!rowNode.data && !this.gos.get('enableGroupEdit')) {
                    return false;
                }
            }
            else {
                // grouping - allow editing of groups if the user has enableGroupEdit option enabled
                if (!this.gos.get('enableGroupEdit')) {
                    return false;
                }
            }
        }
        this.strategy ?? (this.strategy = this.createStrategy());
        return this.strategy?.isCellEditable(position, source) ?? false;
    }
    cellEditingInvalidCommitBlocks() {
        return this.gos.get('invalidEditValueMode') === 'block';
    }
    checkNavWithValidation(position, event) {
        if (this.hasValidationErrors(position)) {
            const cellCtrl = (0, controllers_1._getCellCtrl)(this.beans, position);
            if (this.cellEditingInvalidCommitBlocks()) {
                event?.preventDefault?.();
                !cellCtrl?.hasBrowserFocus() && cellCtrl?.focusCell();
                cellCtrl?.comp?.getCellEditor()?.focusIn?.();
                return 'block-stop';
            }
            cellCtrl && this.revertSingleCellEdit(cellCtrl);
            return 'revert-continue';
        }
        return 'continue';
    }
    revertSingleCellEdit(cellPosition, focus = false) {
        const cellCtrl = (0, controllers_1._getCellCtrl)(this.beans, cellPosition);
        if (!cellCtrl?.comp?.getCellEditor()) {
            // don't cancel/revert if there is no editor
            return;
        }
        this.model.clearEditValue(cellPosition);
        (0, editors_1._destroyEditors)(this.beans, [cellPosition]);
        (0, editors_1._setupEditor)(this.beans, cellPosition);
        (0, editors_1._populateModelValidationErrors)(this.beans);
        cellCtrl?.refreshCell(FORCE_REFRESH);
        // refresh the styles directly rather than through refreshRow as that causes the group cell renderer to
        // be recreated and would discard future mouse click events
        cellCtrl.rowCtrl.rowEditStyleFeature?.applyRowStyles();
        if (!focus) {
            return;
        }
        cellCtrl?.focusCell();
        cellCtrl?.comp?.getCellEditor()?.focusIn?.();
    }
    hasValidationErrors(position) {
        (0, editors_1._populateModelValidationErrors)(this.beans);
        const cellCtrl = (0, controllers_1._getCellCtrl)(this.beans, position);
        if (cellCtrl) {
            cellCtrl.refreshCell(FORCE_REFRESH);
            // refresh the styles directly rather than through refreshRow as that causes the group cell renderer to
            // be recreated and would discard future mouse click events
            cellCtrl.rowCtrl.rowEditStyleFeature?.applyRowStyles();
        }
        let invalid = false;
        if (position?.rowNode) {
            invalid || (invalid = this.model.getRowValidationModel().hasRowValidation({ rowNode: position.rowNode }));
            if (position.column) {
                invalid || (invalid = this.model
                    .getCellValidationModel()
                    .hasCellValidation({ rowNode: position.rowNode, column: position.column }));
            }
        }
        else {
            invalid || (invalid = this.model.getCellValidationModel().getCellValidationMap().size > 0);
            invalid || (invalid = this.model.getRowValidationModel().getRowValidationMap().size > 0);
        }
        return invalid;
    }
    moveToNextCell(prev, backwards, event, source = 'ui') {
        let res;
        if (prev instanceof cellCtrl_1.CellCtrl && this.isEditing()) {
            // if we are editing, we know it's not a Full Width Row (RowComp)
            res = this.strategy?.moveToNextEditingCell(prev, backwards, event, source);
        }
        if (res === null) {
            return res;
        }
        // if a cell wasn't found, it's possible that focus was moved to the header
        res = res || !!this.beans.focusSvc.focusedHeader;
        if (res === false) {
            // not a header and not the table
            this.stopEditing();
        }
        return res;
    }
    getCellDataValue({ rowNode, column }) {
        if (!rowNode || !column) {
            return undefined;
        }
        let edit = this.model.getEdit({ rowNode, column });
        const pinnedSibling = rowNode.pinnedSibling;
        if (pinnedSibling) {
            const siblingEdit = this.model.getEdit({ rowNode: pinnedSibling, column });
            if (siblingEdit) {
                edit = siblingEdit;
            }
        }
        const newValue = edit?.newValue;
        return newValue === editors_1.UNEDITED || !edit
            ? this.valueSvc.getValue(column, rowNode, true, 'api')
            : newValue;
    }
    getRowDataValue(rowNode, params) {
        return this.model.getEditRowDataValue(rowNode, params);
    }
    addStopEditingWhenGridLosesFocus(viewports) {
        // TODO: find a better place for this
        (0, controllers_1._addStopEditingWhenGridLosesFocus)(this, this.beans, viewports);
    }
    createPopupEditorWrapper(params) {
        // TODO: find a better place for this
        return new popupEditorWrapper_1.PopupEditorWrapper(params);
    }
    setDataValue(position, newValue, eventSource) {
        if ((!this.isEditing() || eventSource === 'commit') &&
            eventSource !== 'paste' &&
            eventSource !== 'rangeSvc' &&
            eventSource !== 'renderer' &&
            eventSource !== 'cellClear') {
            return;
        }
        const { beans } = this;
        this.strategy ?? (this.strategy = this.createStrategy());
        const source = this.isBatchEditing() ? 'ui' : 'api';
        const existing = this.model.getEdit(position);
        if (existing) {
            if (existing.newValue === newValue) {
                return false;
            }
            if (existing.oldValue !== newValue) {
                (0, editors_1._syncFromEditor)(beans, position, newValue, eventSource);
                this.stopEditing(position, { source });
                return true;
            }
            if (existing.oldValue === newValue) {
                beans.editModelSvc?.removeEdits(position);
                this.dispatchEditValuesChanged(position, {
                    newValue,
                    oldValue: existing.oldValue,
                });
                return true;
            }
        }
        (0, editors_1._syncFromEditor)(beans, position, newValue, eventSource);
        this.stopEditing(position, { source });
        return true;
    }
    handleColDefChanged(cellCtrl) {
        (0, editors_1._refreshEditorOnColDefChanged)(this.beans, cellCtrl);
    }
    destroy() {
        this.model.clear();
        this.destroyStrategy();
        super.destroy();
    }
    prepDetailsDuringBatch(position, params) {
        if (!this.batch) {
            return;
        }
        const hasEdits = this.model.hasRowEdits(position.rowNode, CHECK_SIBLING);
        if (!hasEdits) {
            return;
        }
        const { rowNode, column } = position;
        const { compDetails, valueToDisplay } = params;
        if (compDetails) {
            const { params } = compDetails;
            params.data = this.model.getEditRowDataValue(rowNode, CHECK_SIBLING);
            return { compDetails };
        }
        const editRow = this.model.getEditRow(position.rowNode, CHECK_SIBLING);
        if (valueToDisplay !== undefined && editRow?.has(column)) {
            return { valueToDisplay: this.valueSvc.getValue(column, rowNode) };
        }
    }
    cleanupEditors() {
        this.strategy?.cleanupEditors();
    }
    dispatchCellEvent(position, event, type, payload) {
        this.strategy?.dispatchCellEvent(position, event, type, payload);
    }
    dispatchRowEvent(position, type) {
        this.strategy?.dispatchRowEvent(position, type);
    }
    dispatchBatchEvent(type, edits) {
        this.eventSvc.dispatchEvent(this.createBatchEditEvent(type, edits));
    }
    createBatchEditEvent(type, edits) {
        return (0, gridOptionsUtils_1._addGridCommonParams)(this.gos, {
            type,
            ...(type === 'batchEditingStopped'
                ? {
                    changes: this.model.getEditPositions(edits).map((edit) => {
                        return {
                            ...edit,
                            rowIndex: edit.rowNode.rowIndex,
                            rowPinned: edit.rowNode.rowPinned,
                            columnId: edit.column.getColId(),
                        };
                    }),
                }
                : {}),
        });
    }
    applyBulkEdit({ rowNode, column }, ranges) {
        if (!ranges || ranges.length === 0) {
            return;
        }
        const { beans, rangeSvc, valueSvc } = this;
        (0, editors_1._syncFromEditors)(beans);
        const edits = this.model.getEditMap(true);
        const editValue = edits.get(rowNode)?.get(column)?.newValue;
        ranges.forEach((range) => {
            rangeSvc?.forEachRowInRange(range, (position) => {
                const rowNode = (0, positionUtils_1._getRowNode)(beans, position);
                if (rowNode === undefined) {
                    return;
                }
                const editRow = edits.get(rowNode) ?? new Map();
                for (const column of range.columns) {
                    if (!column) {
                        continue;
                    }
                    if (this.isCellEditable({ rowNode, column }, 'api')) {
                        const oldValue = valueSvc.getValue(column, rowNode, true, 'api');
                        let newValue = valueSvc.parseValue(column, rowNode ?? null, editValue, oldValue);
                        if (Number.isNaN(newValue)) {
                            // non-number was bulk edited into a number column
                            newValue = null;
                        }
                        editRow.set(column, {
                            newValue,
                            oldValue,
                            state: 'changed',
                        });
                    }
                }
                if (editRow.size > 0) {
                    edits.set(rowNode, editRow);
                }
            });
            this.setEditMap(edits);
            if (this.batch) {
                this.cleanupEditors();
                (0, editors_1._purgeUnchangedEdits)(beans);
                // force refresh of all row cells as custom renderers may depend on multiple cell values
                this.bulkRefresh();
                return;
            }
            this.stopEditing(undefined, { source: 'api' });
        });
        this.bulkRefresh();
        // focus the first cell in the range
        const cellCtrl = (0, controllers_1._getCellCtrl)(beans, { rowNode, column });
        if (cellCtrl) {
            cellCtrl.focusCell(true);
        }
    }
    createCellStyleFeature(cellCtrl, beans) {
        return new cellEditStyleFeature_1.CellEditStyleFeature(cellCtrl, beans);
    }
    createRowStyleFeature(rowCtrl, beans) {
        return new rowEditStyleFeature_1.RowEditStyleFeature(rowCtrl, beans);
    }
    setEditingCells(cells, params) {
        const { beans } = this;
        const { colModel, valueSvc } = beans;
        const edits = new Map();
        cells.forEach(({ colId, column, colKey, rowIndex, rowPinned, newValue, state }) => {
            const col = colId ? colModel.getCol(colId) : colKey ? colModel.getCol(colKey) : column;
            if (!col) {
                return;
            }
            const rowNode = (0, positionUtils_1._getRowNode)(beans, { rowIndex, rowPinned });
            if (!rowNode) {
                return;
            }
            const oldValue = valueSvc.getValue(col, rowNode, true, 'api');
            if (!(0, editors_1._valuesDiffer)({ newValue, oldValue }) && state !== 'editing') {
                // If the new value is the same as the old value, we don't need to update
                return;
            }
            let editRow = edits.get(rowNode);
            if (!editRow) {
                editRow = new Map();
                edits.set(rowNode, editRow);
            }
            // translate undefined to unedited, don't translate null as that means cell was cleared
            if (newValue === undefined) {
                newValue = editors_1.UNEDITED;
            }
            editRow.set(col, { newValue, oldValue, state: state ?? 'changed' });
        });
        this.setEditMap(edits, params);
    }
    onCellFocused(event) {
        const cellCtrl = (0, controllers_1._getCellCtrl)(this.beans, event);
        if (!cellCtrl || !this.isEditing(cellCtrl, CHECK_SIBLING)) {
            return;
        }
        const edit = this.model.getEdit(cellCtrl);
        if (!edit || !(0, editors_1._valuesDiffer)(edit)) {
            return;
        }
        const translate = this.getLocaleTextFunc();
        const label = translate('ariaPendingChange', 'Pending Change');
        this.beans.ariaAnnounce?.announceValue(label, 'pendingChange');
    }
}
exports.EditService = EditService;


/***/ }),

/***/ 13448:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseEditStrategy = void 0;
const keyCode_1 = __webpack_require__(39853);
const beanStub_1 = __webpack_require__(68731);
const positionUtils_1 = __webpack_require__(6257);
const controllers_1 = __webpack_require__(1081);
const editors_1 = __webpack_require__(78994);
class BaseEditStrategy extends beanStub_1.BeanStub {
    postConstruct() {
        this.model = this.beans.editModelSvc;
        this.editSvc = this.beans.editSvc;
        this.addManagedEventListeners({
            cellFocused: this.onCellFocusChanged?.bind(this),
            cellFocusCleared: this.onCellFocusChanged?.bind(this),
        });
    }
    clearEdits(position) {
        this.model.clearEditValue(position);
    }
    onCellFocusChanged(event) {
        let cellCtrl;
        const previous = event['previousParams'];
        const { editSvc, beans } = this;
        if (previous) {
            cellCtrl = (0, controllers_1._getCellCtrl)(beans, previous);
        }
        const { gos, editModelSvc } = beans;
        const isFocusCleared = event.type === 'cellFocusCleared';
        // check if any editors open
        if (editSvc.isEditing(undefined, { withOpenEditor: true })) {
            if (cellCtrl && !isFocusCleared && editSvc.checkNavWithValidation(cellCtrl, event) === 'block-stop') {
                return;
            }
            // if focus is clearing, we should stop editing
            // or cancel the editing if `block` and `hasErrors`
            const { column, rowIndex, rowPinned } = event;
            const cellPositionFromEvent = {
                column: column,
                rowNode: (0, positionUtils_1._getRowNode)(beans, { rowIndex: rowIndex, rowPinned }),
            };
            const isBlock = gos.get('invalidEditValueMode') === 'block';
            const hasError = isBlock && !!editModelSvc?.getCellValidationModel().hasCellValidation(cellPositionFromEvent);
            // if we don't have a previous cell, we don't need to force stopEditing
            const result = previous || isFocusCleared
                ? editSvc.stopEditing(undefined, {
                    cancel: hasError,
                    source: isFocusCleared ? 'api' : undefined,
                })
                : true;
            // editSvc didn't handle the stopEditing, we need to do more ourselves
            if (!result) {
                if (editSvc.isBatchEditing()) {
                    // close editors, but don't stop editing in batch mode
                    editSvc.cleanupEditors();
                }
                else {
                    // if not batch editing, then we stop editing the cell
                    editSvc.stopEditing(undefined, { source: 'api' });
                }
            }
        }
        cellCtrl?.refreshCell({ suppressFlash: true, force: true });
    }
    isCellEditable({ rowNode, column }, _source = 'ui') {
        return column.isColumnFunc(rowNode, column.getColDef().editable);
    }
    stop(cancel) {
        const editingCells = this.model.getEditPositions();
        const results = { all: [], pass: [], fail: [] };
        editingCells.forEach((cell) => {
            results.all.push(cell);
            const validation = this.model.getCellValidationModel().getCellValidation(cell);
            // check if the cell is valid
            if ((validation?.errorMessages?.length ?? 0) > 0) {
                results.fail.push(cell);
                return;
            }
            results.pass.push(cell);
        });
        if (cancel) {
            editingCells.forEach((cell) => {
                (0, editors_1._destroyEditor)(this.beans, cell);
                this.model.stop(cell);
            });
            return true;
        }
        const actions = this.processValidationResults(results);
        if (actions.destroy.length > 0) {
            actions.destroy.forEach((cell) => {
                (0, editors_1._destroyEditor)(this.beans, cell);
                this.model.stop(cell);
            });
        }
        if (actions.keep.length > 0) {
            actions.keep.forEach((cell) => {
                const cellCtrl = (0, controllers_1._getCellCtrl)(this.beans, cell);
                if (!this.editSvc?.cellEditingInvalidCommitBlocks()) {
                    cellCtrl && this.editSvc.revertSingleCellEdit(cellCtrl);
                }
            });
        }
        return true;
    }
    cleanupEditors({ rowNode } = {}, includeEditing) {
        (0, editors_1._syncFromEditors)(this.beans);
        const positions = this.model.getEditPositions();
        const discard = [];
        if (rowNode) {
            positions.forEach((pos) => {
                // if the rowNode is provided, we only keep positions that match it
                if (!(!rowNode || pos.rowNode === rowNode)) {
                    discard.push(pos);
                }
            });
        }
        else {
            positions.forEach((pos) => {
                // if no rowNode is provided, we keep all positions
                discard.push(pos);
            });
        }
        // clean up any dangling editors
        (0, editors_1._destroyEditors)(this.beans, discard);
        (0, editors_1._purgeUnchangedEdits)(this.beans, includeEditing);
    }
    stopAllEditing() {
        (0, editors_1._syncFromEditors)(this.beans);
        this.stop();
    }
    setFocusOutOnEditor(cellCtrl) {
        cellCtrl.comp?.getCellEditor()?.focusOut?.();
    }
    setFocusInOnEditor(cellCtrl) {
        const comp = cellCtrl.comp;
        const editor = comp?.getCellEditor();
        if (editor?.focusIn) {
            // if the editor is present, then we just focus it
            editor.focusIn();
        }
        else {
            // if the editor is not present, it means async cell editor (e.g. React)
            // and we are trying to set focus before the cell editor is present, so we
            // focus the cell instead
            const isFullRow = this.beans.gos.get('editType') === 'fullRow';
            cellCtrl.focusCell(isFullRow);
            cellCtrl.onEditorAttachedFuncs.push(() => comp?.getCellEditor()?.focusIn?.());
        }
    }
    setupEditors(cells = this.model.getEditPositions(), position, cellStartedEdit, event, ignoreEventKey = false) {
        const key = (event instanceof KeyboardEvent && !ignoreEventKey && event.key) || undefined;
        (0, editors_1._setupEditors)(this.beans, cells, position, key, event, cellStartedEdit);
    }
    dispatchCellEvent(position, event, type, payload) {
        const cellCtrl = (0, controllers_1._getCellCtrl)(this.beans, position);
        if (cellCtrl) {
            this.eventSvc.dispatchEvent({ ...cellCtrl.createEvent(event ?? null, type), ...payload });
        }
    }
    dispatchRowEvent(position, type) {
        const rowCtrl = (0, controllers_1._getRowCtrl)(this.beans, position);
        if (rowCtrl) {
            this.eventSvc.dispatchEvent(rowCtrl.createRowEvent(type));
        }
    }
    shouldStart({ column }, event, cellStartedEdit, source = 'ui') {
        if (event instanceof KeyboardEvent &&
            (event.key === keyCode_1.KeyCode.TAB ||
                event.key === keyCode_1.KeyCode.ENTER ||
                event.key === keyCode_1.KeyCode.F2 ||
                (event.key === keyCode_1.KeyCode.BACKSPACE && cellStartedEdit))) {
            return true;
        }
        const extendingRange = event?.shiftKey && this.beans.rangeSvc?.getCellRanges().length != 0;
        if (extendingRange) {
            return false;
        }
        const colDef = column?.getColDef();
        const clickCount = this.deriveClickCount(colDef);
        const type = event?.type;
        if (type === 'click' && event?.detail === 1 && clickCount === 1) {
            return true;
        }
        if (type === 'dblclick' && event?.detail === 2 && clickCount === 2) {
            return true;
        }
        if (source === 'api') {
            return cellStartedEdit ?? false;
        }
        return false;
    }
    shouldStop(_position, event, source = 'ui') {
        const batch = this.editSvc.isBatchEditing();
        if (batch && source === 'api') {
            // we always defer to the API
            return true;
        }
        if (batch && source === 'ui') {
            // we always defer to the UI
            return false;
        }
        if (source === 'api') {
            return true;
        }
        if (event instanceof KeyboardEvent && !batch) {
            return event.key === keyCode_1.KeyCode.ENTER;
        }
        return null;
    }
    shouldCancel(_position, event, source = 'ui') {
        const batch = this.editSvc.isBatchEditing();
        if (event instanceof KeyboardEvent && !batch) {
            const result = event.key === keyCode_1.KeyCode.ESCAPE;
            if (result) {
                return true;
            }
        }
        if (batch && source === 'api') {
            // we always defer to the API
            return true;
        }
        if (source === 'api') {
            return true;
        }
        return false;
    }
    setEditMap(edits, params) {
        if (!params?.update) {
            this.editSvc.stopEditing(undefined, { cancel: true, source: 'api' });
        }
        // Identify incoming editing cells
        const cells = [];
        edits.forEach((editRow, rowNode) => {
            editRow.forEach((cellData, column) => {
                if (cellData.state === 'editing') {
                    cells.push({ ...cellData, rowNode, column });
                }
            });
        });
        if (params?.update) {
            edits = new Map([...this.model.getEditMap(), ...edits]);
        }
        this.model?.setEditMap(edits);
        if (cells.length > 0) {
            const cell = cells.at(-1);
            const key = cell.newValue === editors_1.UNEDITED ? undefined : cell.newValue;
            this.start(cell, new KeyboardEvent('keydown', { key }), 'api');
            const cellCtrl = (0, controllers_1._getCellCtrl)(this.beans, cell);
            if (cellCtrl) {
                this.setFocusInOnEditor(cellCtrl);
            }
        }
    }
    deriveClickCount(colDef) {
        const { gos } = this.beans;
        if (gos.get('suppressClickEdit') === true) {
            return 0;
        }
        if (gos.get('singleClickEdit') === true) {
            return 1;
        }
        if (colDef?.singleClickEdit) {
            return 1;
        }
        return 2;
    }
    destroy() {
        this.cleanupEditors();
        super.destroy();
    }
}
exports.BaseEditStrategy = BaseEditStrategy;


/***/ }),

/***/ 40104:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FullRowEditStrategy = void 0;
const controllers_1 = __webpack_require__(1081);
const editors_1 = __webpack_require__(78994);
const baseEditStrategy_1 = __webpack_require__(13448);
class FullRowEditStrategy extends baseEditStrategy_1.BaseEditStrategy {
    constructor() {
        super(...arguments);
        this.beanName = 'fullRow';
    }
    isCellEditable(position, source = 'ui') {
        const editable = super.isCellEditable(position, source);
        if (editable === true || source === 'ui') {
            return editable;
        }
        // check if other cells in row are editable, so starting edit on uneditable cell will still work
        const columns = this.beans.colModel.getCols();
        return columns.some((col) => super.isCellEditable({ rowNode: position.rowNode, column: col }, source));
    }
    shouldStop(position, event, _source = 'ui') {
        const { rowNode } = position || {};
        const oldRowCtrl = (0, controllers_1._getRowCtrl)(this.beans, {
            rowNode: this.rowNode,
        });
        if (!oldRowCtrl) {
            return true;
        }
        const res = super.shouldStop({ rowNode: this.rowNode }, event, _source);
        if (res !== null) {
            return res;
        }
        if (!this.rowNode) {
            return false;
        }
        // stop editing if we've changed rows
        return rowNode !== this.rowNode;
    }
    midBatchInputsAllowed({ rowNode }) {
        if (!rowNode) {
            return false;
        }
        return this.model.hasEdits({ rowNode });
    }
    clearEdits(position) {
        this.model.clearEditValue(position);
    }
    start(position, event, _source = 'ui', ignoreEventKey) {
        const { rowNode } = position;
        if (this.rowNode !== rowNode) {
            super.cleanupEditors(position);
        }
        if (!this.model.hasEdits({ rowNode })) {
            this.dispatchRowEvent({ rowNode }, 'rowEditingStarted');
        }
        const columns = this.beans.visibleCols.allCols;
        const cells = [];
        columns.forEach((column) => {
            if (!column.isCellEditable(rowNode)) {
                return;
            }
            const position = {
                rowNode,
                column,
            };
            cells.push(position);
            if (!this.model.hasEdits(position)) {
                this.model.start(position);
            }
        });
        this.rowNode = rowNode;
        this.setupEditors(cells, position, true, event, ignoreEventKey);
    }
    processValidationResults(results) {
        const anyFailed = results.fail.length > 0;
        // if any of the cells failed, keep those editors
        if (anyFailed && this.editSvc.cellEditingInvalidCommitBlocks()) {
            return {
                destroy: [],
                keep: results.all,
            };
        }
        // if no cells failed, we destroy all editors
        return {
            destroy: results.all,
            keep: [],
        };
    }
    stop(cancel) {
        const { rowNode } = this;
        if (rowNode && !this.model.hasRowEdits(rowNode)) {
            return false;
        }
        const rowEdits = this.model.getEditRow(rowNode);
        let hadRowEdits = false;
        for (const [, edit] of rowEdits) {
            if ((0, editors_1._valuesDiffer)(edit)) {
                hadRowEdits = true;
                break;
            }
        }
        // rerun validation, new values might have triggered row validations
        (0, editors_1._populateModelValidationErrors)(this.beans);
        if (!cancel && this.editSvc?.checkNavWithValidation({ rowNode }) === 'block-stop') {
            return false;
        }
        super.stop(cancel);
        if (rowNode) {
            if (hadRowEdits) {
                this.dispatchRowEvent({ rowNode }, 'rowValueChanged');
            }
            this.dispatchRowEvent({ rowNode }, 'rowEditingStopped');
        }
        this.rowNode = undefined;
        return true;
    }
    onCellFocusChanged(event) {
        const { rowIndex } = event;
        const prev = event['previousParams'];
        if (prev?.rowIndex === rowIndex || event.sourceEvent instanceof KeyboardEvent) {
            return;
        }
        if (this.model.getRowValidationModel().getRowValidationMap().size > 0) {
            return;
        }
        super.onCellFocusChanged(event);
        const previous = event['previousParams'];
        if (previous) {
            (0, controllers_1._getRowCtrl)(this.beans, previous)?.refreshRow({ suppressFlash: true, force: true });
        }
    }
    cleanupEditors({ rowNode } = {}, includeEditing) {
        super.cleanupEditors({ rowNode }, includeEditing);
        if (rowNode) {
            this.dispatchRowEvent({ rowNode: this.rowNode }, 'rowEditingStopped');
        }
    }
    // returns null if no navigation should be performed
    moveToNextEditingCell(prevCell, backwards, event, source = 'ui') {
        // check for all cell-level validation errors
        const preventNavigation = this.editSvc.checkNavWithValidation(undefined, event) === 'block-stop';
        const prevPos = prevCell.cellPosition;
        // find the next cell to start editing
        let nextCell;
        // fineNextCell in fullRow mode causes CellComps to initialise editors, this is
        // undesirable so we suspend the model while we find the next cell.
        this.model.suspend(true);
        try {
            nextCell = this.beans.navigation?.findNextCellToFocusOn(prevPos, {
                backwards,
                startEditing: true,
                // Default behaviour for fullRow is skip to the next cell,
                // editable or not. FullRow editing might have some editable
                // and some not editable cells in the row.
                // More complex logic needed to skip to the
                // next FullRow editable cell,
                skipToNextEditableCell: false,
            });
        }
        finally {
            this.model.suspend(false);
        }
        if (nextCell === false) {
            return null;
        }
        if (nextCell == null) {
            return preventNavigation;
        }
        const nextPos = nextCell.cellPosition;
        const prevEditable = prevCell.isCellEditable();
        const nextEditable = nextCell.isCellEditable();
        const rowsMatch = nextPos && prevPos.rowIndex === nextPos.rowIndex && prevPos.rowPinned === nextPos.rowPinned;
        if (!rowsMatch) {
            // run validation to gather row-level validation errors
            (0, editors_1._populateModelValidationErrors)(this.beans);
            if (this.model.getRowValidationModel().getRowValidationMap().size > 0) {
                // if there was a previous row validation error, we need to check if that's still the case
                if (this.editSvc.checkNavWithValidation(prevCell, event) === 'block-stop') {
                    return true;
                }
            }
            else {
                const rowPreventNavigation = this.editSvc.checkNavWithValidation(prevCell, event) === 'block-stop';
                if (rowPreventNavigation) {
                    return true;
                }
            }
            if (preventNavigation && this.model.getRowValidationModel().getRowValidation(prevCell)) {
                return true;
            }
        }
        if (prevEditable) {
            this.setFocusOutOnEditor(prevCell);
        }
        if (nextEditable && !preventNavigation) {
            if (!nextCell.comp?.getCellEditor()) {
                // editor missing because it was outside the viewport during creating phase, attempt to create it now
                (0, editors_1._setupEditor)(this.beans, nextCell, undefined, event, true);
            }
            this.setFocusInOnEditor(nextCell);
            nextCell.focusCell(false, event);
        }
        else {
            nextCell.focusCell(true, event);
        }
        if (!rowsMatch && !preventNavigation) {
            super.cleanupEditors(nextCell, true);
            this.editSvc.startEditing(nextCell, { startedEdit: true, event, source, ignoreEventKey: true });
        }
        prevCell.rowCtrl?.refreshRow({ suppressFlash: true, force: true });
        return true;
    }
    destroy() {
        super.destroy();
        this.rowNode = undefined;
    }
}
exports.FullRowEditStrategy = FullRowEditStrategy;


/***/ }),

/***/ 30149:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SingleCellEditStrategy = void 0;
const positionUtils_1 = __webpack_require__(6257);
const controllers_1 = __webpack_require__(1081);
const editors_1 = __webpack_require__(78994);
const baseEditStrategy_1 = __webpack_require__(13448);
class SingleCellEditStrategy extends baseEditStrategy_1.BaseEditStrategy {
    constructor() {
        super(...arguments);
        this.beanName = 'singleCell';
    }
    shouldStop(position, event, source = 'ui') {
        const res = super.shouldStop(position, event, source);
        if (res !== null) {
            return res;
        }
        const { rowNode, column } = position || {};
        if ((!this.rowNode || !this.column) && rowNode && column) {
            return null;
        }
        return this.rowNode !== rowNode || this.column !== column;
    }
    midBatchInputsAllowed(position) {
        return this.model.hasEdits(position);
    }
    start(position, event, _source = 'ui', ignoreEventKey) {
        if (this.rowNode !== position.rowNode || this.column !== position.column) {
            super.cleanupEditors();
        }
        this.rowNode = position.rowNode;
        this.column = position.column;
        this.model.start(position);
        this.setupEditors([position], position, true, event, ignoreEventKey);
    }
    dispatchRowEvent(_position, _type) {
        // NOP - single cell edit strategy does not dispatch row events
    }
    stop(cancel) {
        super.stop(cancel);
        this.rowNode = undefined;
        this.column = undefined;
        return true;
    }
    onCellFocusChanged(event) {
        const { colModel, editSvc } = this.beans;
        const { rowIndex, column, rowPinned } = event;
        const rowNode = (0, positionUtils_1._getRowNode)(this.beans, { rowIndex: rowIndex, rowPinned });
        const curColId = (0, controllers_1._getColId)(column);
        const curCol = colModel.getCol(curColId);
        const previous = event['previousParams'];
        if (previous) {
            const prevColId = (0, controllers_1._getColId)(previous.column);
            if (previous?.rowIndex === rowIndex && prevColId === curColId && previous?.rowPinned === rowPinned) {
                return;
            }
        }
        if (editSvc?.isEditing({ rowNode, column: curCol }, { withOpenEditor: true }) &&
            event.type === 'cellFocused') {
            // editor is already active, so we don't need to do anything
            return;
        }
        super.onCellFocusChanged(event);
    }
    // returns null if no navigation should be performed
    moveToNextEditingCell(prevCell, backwards, event, source = 'ui') {
        // check for all cell-level validation errors
        const preventNavigation = this.editSvc.checkNavWithValidation(undefined, event) === 'block-stop';
        const prevPos = prevCell.cellPosition;
        // find the next cell to start editing
        let nextCell;
        const shouldSuspend = this.beans.gos.get('editType') === 'fullRow';
        if (shouldSuspend) {
            // fineNextCell in fullRow mode causes CellComps to initialise editors, this is
            // undesirable so we suspend the model while we find the next cell.
            this.model.suspend(true);
        }
        else {
            // before we stop editing, we need to focus the cell element
            // so the grid doesn't detect that focus has left the grid
            prevCell.eGui.focus();
            // need to do this before getting next cell to edit, in case the next cell
            // has editable function (eg colDef.editable=func() ) and it depends on the
            // result of this cell, so need to save updates from the first edit, in case
            // the value is referenced in the function.
            prevCell.stopEditing();
        }
        try {
            nextCell = this.beans.navigation?.findNextCellToFocusOn(prevPos, {
                backwards,
                startEditing: true,
                // Default behaviour for fullRow is skip to the next cell,
                // editable or not. FullRow editing might have some editable
                // and some not editable cells in the row.
                // More complex logic needed to skip to the
                // next FullRow editable cell,
                // skipToNextEditableCell: false,
            });
        }
        finally {
            if (shouldSuspend) {
                this.model.suspend(false);
            }
        }
        if (nextCell === false) {
            return null;
        }
        if (nextCell == null) {
            return preventNavigation;
        }
        const nextPos = nextCell.cellPosition;
        const prevEditable = prevCell.isCellEditable();
        const nextEditable = nextCell.isCellEditable();
        const rowsMatch = nextPos && prevPos.rowIndex === nextPos.rowIndex && prevPos.rowPinned === nextPos.rowPinned;
        if (!rowsMatch) {
            // run validation to gather row-level validation errors
            (0, editors_1._populateModelValidationErrors)(this.beans);
            if (this.model.getRowValidationModel().getRowValidationMap().size > 0) {
                // if there was a previous row validation error, we need to check if that's still the case
                if (this.editSvc.checkNavWithValidation(prevCell, event) === 'block-stop') {
                    return true;
                }
            }
            else {
                const rowPreventNavigation = this.editSvc.checkNavWithValidation(prevCell, event) === 'block-stop';
                if (rowPreventNavigation) {
                    return true;
                }
            }
            if (preventNavigation && this.model.getRowValidationModel().getRowValidation(prevCell)) {
                return true;
            }
        }
        if (prevEditable) {
            this.setFocusOutOnEditor(prevCell);
        }
        if (!rowsMatch && !preventNavigation) {
            super.cleanupEditors(nextCell, true);
            this.editSvc.startEditing(nextCell, { startedEdit: true, event, source, ignoreEventKey: true });
        }
        if (nextEditable && !preventNavigation) {
            // need to focus the cell before setting the editor, otherwise the focus handler won't cause previous editor cleanups
            nextCell.focusCell(false, event);
            if (!nextCell.comp?.getCellEditor()) {
                // editor missing because it was outside the viewport during creating phase, attempt to create it now
                (0, editors_1._setupEditor)(this.beans, nextCell, undefined, event, true);
            }
            this.setFocusInOnEditor(nextCell);
        }
        else {
            if (preventNavigation && this.model.getCellValidationModel().getCellValidation(prevCell)) {
                return true;
            }
            nextCell.focusCell(true, event);
        }
        prevCell.rowCtrl?.refreshRow({ suppressFlash: true, force: true });
        return true;
    }
    processValidationResults(results) {
        const anyFailed = results.fail.length > 0;
        // if any of the cells failed, we keep all editors
        if (anyFailed && this.editSvc.cellEditingInvalidCommitBlocks()) {
            return {
                destroy: [],
                keep: results.all,
            };
        }
        // if no cells failed, we destroy all editors
        return {
            destroy: results.all,
            keep: [],
        };
    }
    destroy() {
        super.destroy();
        this.rowNode = undefined;
        this.column = undefined;
    }
}
exports.SingleCellEditStrategy = SingleCellEditStrategy;


/***/ }),

/***/ 46904:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CellEditStyleFeature = void 0;
const beanStub_1 = __webpack_require__(68731);
const style_utils_1 = __webpack_require__(89320);
class CellEditStyleFeature extends beanStub_1.BeanStub {
    constructor(cellCtrl, beans) {
        super();
        this.cellCtrl = cellCtrl;
        this.beans = beans;
        this.editSvc = beans.editSvc;
        this.editModelSvc = beans.editModelSvc;
    }
    setComp(comp) {
        this.cellComp = comp;
        this.applyCellStyles();
    }
    applyCellStyles() {
        const { cellCtrl, editSvc, beans } = this;
        if (editSvc?.isBatchEditing() && editSvc.isEditing()) {
            const state = (0, style_utils_1._hasEdits)(beans, cellCtrl) || (0, style_utils_1._hasLeafEdits)(beans, cellCtrl) || (0, style_utils_1._hasPinnedEdits)(beans, cellCtrl);
            this.applyBatchingStyle(state);
        }
        else {
            this.applyBatchingStyle(false);
        }
        const hasErrors = !!this.editModelSvc?.getCellValidationModel().hasCellValidation(this.cellCtrl);
        this.cellComp.toggleCss('ag-cell-editing-error', hasErrors);
    }
    applyBatchingStyle(newState) {
        this.cellComp.toggleCss('ag-cell-editing', newState ?? false);
        this.cellComp.toggleCss('ag-cell-batch-edit', (newState && this.editSvc?.isBatchEditing()) ?? false);
    }
}
exports.CellEditStyleFeature = CellEditStyleFeature;


/***/ }),

/***/ 13536:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RowEditStyleFeature = void 0;
const beanStub_1 = __webpack_require__(68731);
const style_utils_1 = __webpack_require__(89320);
class RowEditStyleFeature extends beanStub_1.BeanStub {
    constructor(rowCtrl, beans) {
        super();
        this.rowCtrl = rowCtrl;
        this.beans = beans;
        this.gos = beans.gos;
        this.editSvc = beans.editSvc;
        this.editModelSvc = beans.editModelSvc;
    }
    applyRowStyles() {
        const { rowCtrl, editModelSvc, beans } = this;
        let rowNode = rowCtrl.rowNode;
        let edits = editModelSvc?.getEditRow(rowNode);
        const hasErrors = this.editModelSvc?.getRowValidationModel().hasRowValidation({ rowNode });
        if (!edits && rowNode.pinnedSibling) {
            rowNode = rowNode.pinnedSibling;
            edits = editModelSvc?.getEditRow(rowNode);
        }
        if (edits) {
            const editing = Array.from(edits.keys()).some((column) => {
                const position = { rowNode, column };
                return ((0, style_utils_1._hasEdits)(beans, position, true) ||
                    (0, style_utils_1._hasLeafEdits)(beans, position) ||
                    (0, style_utils_1._hasPinnedEdits)(beans, position));
            });
            this.applyStyle(hasErrors, editing);
            return;
        }
        this.applyStyle(hasErrors);
    }
    applyStyle(hasErrors = false, editing = false) {
        const batchEdit = this.editSvc?.isBatchEditing() ?? false;
        const fullRow = this.gos.get('editType') === 'fullRow';
        this.rowCtrl?.forEachGui(undefined, ({ rowComp }) => {
            rowComp.toggleCss('ag-row-editing', fullRow && editing);
            rowComp.toggleCss('ag-row-batch-edit', fullRow && editing && batchEdit);
            // required for Material theme
            rowComp.toggleCss('ag-row-inline-editing', editing);
            rowComp.toggleCss('ag-row-not-inline-editing', !editing);
            rowComp.toggleCss('ag-row-editing-invalid', fullRow && editing && hasErrors);
        });
    }
}
exports.RowEditStyleFeature = RowEditStyleFeature;


/***/ }),

/***/ 89320:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._hasPinnedEdits = exports._hasLeafEdits = exports._hasEdits = void 0;
const editors_1 = __webpack_require__(78994);
const editHighlightFn = (edit, includeEditing = false) => {
    if (edit !== undefined) {
        return (0, editors_1._valuesDiffer)(edit) || (includeEditing && edit.state === 'editing');
    }
};
function _hasEdits(beans, position, includeEditing = false) {
    return editHighlightFn(beans.editModelSvc?.getEdit(position), includeEditing);
}
exports._hasEdits = _hasEdits;
function _hasLeafEdits(beans, position) {
    const { editModelSvc } = beans;
    const { column, rowNode } = position;
    // if we have group total rows, we should decorate them, rather than agg nodes
    if (beans.gos.get('groupTotalRow') && !rowNode?.footer) {
        return false;
    }
    for (const node of rowNode?.allLeafChildren ?? []) {
        const highlight = editHighlightFn(editModelSvc?.getEdit({ rowNode: node, column })) ||
            editHighlightFn(editModelSvc?.getEdit({ rowNode: node.pinnedSibling, column }));
        if (highlight) {
            return true;
        }
    }
}
exports._hasLeafEdits = _hasLeafEdits;
function _hasPinnedEdits(beans, { rowNode, column }) {
    rowNode = rowNode.pinnedSibling;
    if (!rowNode) {
        return;
    }
    return editHighlightFn(beans.editModelSvc?.getEdit({
        rowNode,
        column,
    }));
}
exports._hasPinnedEdits = _hasPinnedEdits;


/***/ }),

/***/ 1081:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._getColId = exports._addStopEditingWhenGridLosesFocus = exports._getCtrls = exports._getCellCtrl = exports._getRowCtrl = void 0;
const positionUtils_1 = __webpack_require__(6257);
const mouseEventUtils_1 = __webpack_require__(8399);
const browser_1 = __webpack_require__(98667);
const editors_1 = __webpack_require__(78994);
function _getRowCtrl(beans, inputs = {}) {
    const { rowIndex, rowId, rowCtrl, rowPinned } = inputs;
    if (rowCtrl) {
        return rowCtrl;
    }
    const { rowModel, rowRenderer } = beans;
    let { rowNode } = inputs;
    rowNode ?? (rowNode = rowId ? (0, positionUtils_1._getRowById)(beans, rowId, rowPinned) : rowModel.getRow(rowIndex));
    return rowRenderer.getRowCtrls(rowNode ? [rowNode] : [])?.[0];
}
exports._getRowCtrl = _getRowCtrl;
function _getCellCtrl(beans, inputs = {}) {
    const { cellCtrl, colId, columnId, column } = inputs;
    if (cellCtrl) {
        return cellCtrl;
    }
    const actualColumn = beans.colModel.getCol(colId ?? columnId ?? _getColId(column));
    const rowCtrl = inputs.rowCtrl ?? _getRowCtrl(beans, inputs);
    const result = rowCtrl?.getCellCtrl(actualColumn) ?? undefined;
    if (result) {
        // if we found a cellCtrl, return it
        return result;
    }
    const rowNode = inputs.rowNode ?? rowCtrl?.rowNode;
    if (rowNode) {
        // can occur in spannedRow settings
        return beans.rowRenderer.getCellCtrls([rowNode], [actualColumn])?.[0];
    }
    return undefined;
}
exports._getCellCtrl = _getCellCtrl;
function _getCtrls(beans, inputs = {}) {
    const rowCtrl = _getRowCtrl(beans, inputs);
    const cellCtrl = _getCellCtrl(beans, inputs);
    return {
        rowCtrl,
        cellCtrl,
    };
}
exports._getCtrls = _getCtrls;
function _stopEditing(beans) {
    const { editSvc } = beans;
    if (editSvc?.isBatchEditing()) {
        (0, editors_1._destroyEditors)(beans);
    }
    else {
        editSvc?.stopEditing(undefined, { source: 'api' });
    }
}
function _addStopEditingWhenGridLosesFocus(bean, beans, viewports) {
    const { gos, popupSvc } = beans;
    if (!gos.get('stopEditingWhenCellsLoseFocus')) {
        return;
    }
    const focusOutListener = (event) => {
        // this is the element the focus is moving to
        const elementWithFocus = event.relatedTarget;
        if ((0, browser_1._getTabIndex)(elementWithFocus) === null) {
            _stopEditing(beans);
            return;
        }
        let clickInsideGrid = 
        // see if click came from inside the viewports
        viewports.some((viewport) => viewport.contains(elementWithFocus)) &&
            // and also that it's not from a detail grid
            (0, mouseEventUtils_1._isElementInThisGrid)(gos, elementWithFocus);
        if (!clickInsideGrid) {
            clickInsideGrid =
                !!popupSvc &&
                    (popupSvc.getActivePopups().some((popup) => popup.contains(elementWithFocus)) ||
                        popupSvc.isElementWithinCustomPopup(elementWithFocus));
        }
        if (!clickInsideGrid) {
            _stopEditing(beans);
        }
    };
    viewports.forEach((viewport) => bean.addManagedElementListeners(viewport, { focusout: focusOutListener }));
}
exports._addStopEditingWhenGridLosesFocus = _addStopEditingWhenGridLosesFocus;
function _getColId(column) {
    if (!column) {
        return undefined;
    }
    if (typeof column === 'string') {
        return column;
    }
    return column.getColId();
}
exports._getColId = _getColId;


/***/ }),

/***/ 78994:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._validateEdit = exports._generateRowValidationErrors = exports._populateModelValidationErrors = exports._destroyEditor = exports._destroyEditors = exports._syncFromEditor = exports._syncFromEditors = exports._refreshEditorOnColDefChanged = exports._purgeUnchangedEdits = exports._setupEditor = exports._valuesDiffer = exports._setupEditors = exports.getCellEditorInstances = exports.getCellEditorInstanceMap = exports.UNEDITED = void 0;
const unwrapUserComp_1 = __webpack_require__(54126);
const userCompUtils_1 = __webpack_require__(12036);
const gridOptionsUtils_1 = __webpack_require__(67274);
const localeUtils_1 = __webpack_require__(87230);
const aria_1 = __webpack_require__(95230);
const editModelService_1 = __webpack_require__(68544);
const controllers_1 = __webpack_require__(1081);
exports.UNEDITED = Symbol('unedited');
function getCellEditorInstanceMap(beans, params = {}) {
    const res = [];
    const ctrls = beans.rowRenderer.getCellCtrls(params.rowNodes, params.columns);
    for (const ctrl of ctrls) {
        const cellEditor = ctrl.comp?.getCellEditor();
        if (cellEditor) {
            res.push({
                ctrl,
                editor: (0, unwrapUserComp_1._unwrapUserComp)(cellEditor),
            });
        }
    }
    return res;
}
exports.getCellEditorInstanceMap = getCellEditorInstanceMap;
const getCellEditorInstances = (beans, params = {}) => getCellEditorInstanceMap(beans, params).map((res) => res.editor);
exports.getCellEditorInstances = getCellEditorInstances;
function _setupEditors(beans, editingCells, position, key, event, cellStartedEdit) {
    if (editingCells.length === 0 && position?.rowNode && position?.column) {
        _setupEditor(beans, position, key, event, cellStartedEdit);
    }
    const { valueSvc, editSvc, editModelSvc } = beans;
    const { rowNode, column } = position ?? {};
    for (const cellPosition of editingCells) {
        const { rowNode: cellRowNode, column: cellColumn } = cellPosition;
        const curCellCtrl = (0, controllers_1._getCellCtrl)(beans, cellPosition);
        if (!curCellCtrl) {
            if (cellRowNode && cellColumn) {
                const oldValue = valueSvc.getValue(cellColumn, cellRowNode, undefined, 'api');
                const isNewValueCell = position?.rowNode === cellRowNode && position?.column === cellColumn;
                const cellStartValue = (isNewValueCell && key) || undefined;
                const newValue = cellStartValue ??
                    editSvc?.getCellDataValue(cellPosition) ??
                    valueSvc.getValueForDisplay(cellColumn, cellRowNode)?.value ??
                    oldValue ??
                    exports.UNEDITED;
                editModelSvc?.setEdit(cellPosition, { newValue, oldValue, state: 'editing' });
            }
            continue;
        }
        const shouldStartEditing = cellStartedEdit && rowNode === curCellCtrl.rowNode && curCellCtrl.column === column;
        _setupEditor(beans, { rowNode: rowNode, column: curCellCtrl.column }, shouldStartEditing ? key : null, shouldStartEditing ? event : null, shouldStartEditing);
    }
    return;
}
exports._setupEditors = _setupEditors;
function _valuesDiffer({ newValue, oldValue }) {
    if (newValue === exports.UNEDITED) {
        newValue = oldValue;
    }
    return newValue !== oldValue;
}
exports._valuesDiffer = _valuesDiffer;
function _setupEditor(beans, position, key, event, cellStartedEdit) {
    const cellCtrl = (0, controllers_1._getCellCtrl)(beans, position);
    const editorComp = cellCtrl?.comp?.getCellEditor();
    const editorParams = _createEditorParams(beans, position, key, cellStartedEdit);
    const oldValue = beans.valueSvc.getValue(position.column, position.rowNode, undefined, 'api');
    // if key is a single character, then we treat it as user input
    let newValue = key?.length === 1 ? key : editorParams.value;
    if (newValue === undefined) {
        newValue = oldValue;
    }
    beans.editModelSvc?.setEdit(position, { newValue: newValue ?? exports.UNEDITED, oldValue, state: 'editing' });
    if (editorComp) {
        // don't reinitialise, just refresh if possible
        editorComp.refresh?.(editorParams);
        return;
    }
    const colDef = position.column.getColDef();
    const compDetails = (0, userCompUtils_1._getCellEditorDetails)(beans.userCompFactory, colDef, editorParams);
    // if cellEditorSelector was used, we give preference to popup and popupPosition from the selector
    const popup = compDetails?.popupFromSelector != null ? compDetails.popupFromSelector : !!colDef.cellEditorPopup;
    const popupLocation = compDetails?.popupPositionFromSelector != null
        ? compDetails.popupPositionFromSelector
        : colDef.cellEditorPopupPosition;
    checkAndPreventDefault(compDetails.params, event);
    if (cellCtrl) {
        cellCtrl.editCompDetails = compDetails;
        cellCtrl.comp?.setEditDetails(compDetails, popup, popupLocation, beans.gos.get('reactiveCustomComponents'));
        cellCtrl?.rowCtrl?.refreshRow({ suppressFlash: true });
        beans.editSvc?.dispatchCellEvent(position, null, 'cellEditingStarted');
    }
    return;
}
exports._setupEditor = _setupEditor;
function _valueFromEditor(cancel, cellComp) {
    const noValueResult = { newValueExists: false };
    if (cancel) {
        return noValueResult;
    }
    const cellEditor = cellComp?.getCellEditor();
    if (!cellEditor) {
        return noValueResult;
    }
    const userWantsToCancel = cellEditor.isCancelAfterEnd?.();
    if (userWantsToCancel) {
        return noValueResult;
    }
    const validationErrors = cellEditor.getValidationErrors?.();
    if ((validationErrors?.length ?? 0) > 0) {
        return noValueResult;
    }
    const newValue = cellEditor.getValue();
    return {
        newValue,
        newValueExists: true,
    };
}
function _createEditorParams(beans, position, key, cellStartedEdit) {
    const { valueSvc, gos, editSvc } = beans;
    const cellCtrl = (0, controllers_1._getCellCtrl)(beans, position);
    const rowIndex = position.rowNode?.rowIndex ?? undefined;
    const batchEdit = editSvc?.isBatchEditing();
    const agColumn = beans.colModel.getCol(position.column.getId());
    const { rowNode, column } = position;
    const initialNewValue = editSvc?.getCellDataValue(position) ?? _valueFromEditor(false, cellCtrl?.comp)?.newValue;
    const value = initialNewValue === exports.UNEDITED ? valueSvc.getValueForDisplay(agColumn, rowNode)?.value : initialNewValue;
    return (0, gridOptionsUtils_1._addGridCommonParams)(gos, {
        value,
        eventKey: key ?? null,
        column,
        colDef: column.getColDef(),
        rowIndex,
        node: rowNode,
        data: rowNode.data,
        cellStartedEdit: cellStartedEdit ?? false,
        onKeyDown: cellCtrl?.onKeyDown.bind(cellCtrl),
        stopEditing: (suppressNavigateAfterEdit) => {
            editSvc.stopEditing(position, { source: batchEdit ? 'ui' : 'api', suppressNavigateAfterEdit });
            _destroyEditor(beans, position);
        },
        eGridCell: cellCtrl?.eGui,
        parseValue: (newValue) => valueSvc.parseValue(agColumn, rowNode, newValue, cellCtrl?.value),
        formatValue: cellCtrl?.formatValue.bind(cellCtrl),
        validate: () => {
            editSvc?.validateEdit();
        },
    });
}
function _purgeUnchangedEdits(beans, includeEditing) {
    const { editModelSvc } = beans;
    editModelSvc?.getEditMap().forEach((editRow, rowNode) => {
        editRow.forEach((edit, column) => {
            if (!includeEditing && (edit.state === 'editing' || edit.newValue === exports.UNEDITED)) {
                return;
            }
            if (!_valuesDiffer(edit) && (edit.state !== 'editing' || includeEditing)) {
                // remove edits where the pending is equal to the old value
                editModelSvc?.removeEdits({ rowNode, column });
            }
        });
    });
}
exports._purgeUnchangedEdits = _purgeUnchangedEdits;
function _refreshEditorOnColDefChanged(beans, cellCtrl) {
    const editor = cellCtrl.comp?.getCellEditor();
    if (!editor?.refresh) {
        return;
    }
    const { eventKey, cellStartedEdit } = cellCtrl.editCompDetails.params;
    const { column } = cellCtrl;
    const editorParams = _createEditorParams(beans, cellCtrl, eventKey, cellStartedEdit);
    const colDef = column.getColDef();
    const compDetails = (0, userCompUtils_1._getCellEditorDetails)(beans.userCompFactory, colDef, editorParams);
    editor.refresh(checkAndPreventDefault(compDetails.params, eventKey));
}
exports._refreshEditorOnColDefChanged = _refreshEditorOnColDefChanged;
function checkAndPreventDefault(params, event) {
    if (event instanceof KeyboardEvent && params.column.getColDef().cellEditor === 'agNumberCellEditor') {
        // `-`, `+`, `.`, `e` need suppressPreventDefault to prevent the editor from ignoring the keypress
        params.suppressPreventDefault =
            ['-', '+', '.', 'e'].includes(event?.key ?? '') || params.suppressPreventDefault;
    }
    else {
        event?.preventDefault?.();
    }
    return params;
}
function _syncFromEditors(beans) {
    beans.editModelSvc?.getEditPositions().forEach((cellId) => {
        const cellCtrl = (0, controllers_1._getCellCtrl)(beans, cellId);
        if (!cellCtrl) {
            return;
        }
        const { newValue, newValueExists } = _valueFromEditor(false, cellCtrl.comp);
        if (!newValueExists) {
            return;
        }
        _syncFromEditor(beans, cellId, newValue);
    });
}
exports._syncFromEditors = _syncFromEditors;
function _syncFromEditor(beans, position, newValue, source) {
    const { editModelSvc, valueSvc, eventSvc } = beans;
    if (!editModelSvc) {
        return;
    }
    const { rowNode, column } = position;
    if (!(rowNode && column)) {
        return;
    }
    const oldValue = valueSvc.getValue(column, rowNode, undefined, 'api');
    const cellCtrl = (0, controllers_1._getCellCtrl)(beans, position);
    const hasEditor = !!cellCtrl?.comp?.getCellEditor();
    const prevEditValue = editModelSvc?.getEdit(position)?.newValue;
    // Only handle undefined, null is used to indicate a cleared cell value
    if (newValue === undefined) {
        newValue = exports.UNEDITED;
    }
    // Note: we don't clear the edit state here (even if new===old) as this is also called from the stop editing flow.
    editModelSvc.setEdit(position, { newValue, oldValue, state: hasEditor ? 'editing' : 'changed' });
    // re-read the value once it's been through all the formatting and parsing
    const { value } = valueSvc.getValueForDisplay(column, rowNode, true);
    editModelSvc.getEdit(position).newValue = value;
    if (prevEditValue === newValue || hasEditor) {
        // If the value hasn't changed or the editor is currently open, we don't need to dispatch an event
        return;
    }
    const { rowIndex, rowPinned, data } = rowNode;
    eventSvc.dispatchEvent({
        type: 'cellEditValuesChanged',
        value: newValue,
        colDef: column.getColDef(),
        newValue,
        oldValue,
        source,
        column,
        rowIndex,
        rowPinned,
        data,
        node: rowNode,
    });
}
exports._syncFromEditor = _syncFromEditor;
function _destroyEditors(beans, edits) {
    if (!edits) {
        edits = beans.editModelSvc?.getEditPositions();
    }
    edits.forEach((cellPosition) => _destroyEditor(beans, cellPosition));
}
exports._destroyEditors = _destroyEditors;
function _destroyEditor(beans, position) {
    const { rowNode, column } = position;
    const cellCtrl = (0, controllers_1._getCellCtrl)(beans, position);
    if (!cellCtrl) {
        if (beans.editModelSvc?.hasEdits(position) && rowNode && column) {
            beans.editModelSvc?.setState(position, 'changed');
        }
        return;
    }
    const { comp } = cellCtrl;
    if (comp && !comp.getCellEditor()) {
        // no editor, nothing to do
        return;
    }
    const errorMessages = comp?.getCellEditor()?.getValidationErrors?.();
    const cellValidationModel = beans.editModelSvc?.getCellValidationModel();
    if (errorMessages?.length) {
        cellValidationModel?.setCellValidation(position, { errorMessages });
    }
    else {
        cellValidationModel?.clearCellValidation(position);
    }
    comp?.setEditDetails(); // passing nothing stops editing
    if (beans.editModelSvc?.hasEdits(position) && rowNode && column) {
        beans.editModelSvc?.setState(position, 'changed');
    }
    comp?.refreshEditStyles(false, false);
    cellCtrl?.refreshCell({ force: true, suppressFlash: true });
    const edit = beans.editModelSvc?.getEdit(position);
    beans.editSvc?.dispatchCellEvent(position, null, 'cellEditingStopped', {
        valueChanged: edit && _valuesDiffer(edit),
    });
}
exports._destroyEditor = _destroyEditor;
function _populateModelValidationErrors(beans) {
    const mappedEditors = getCellEditorInstanceMap(beans);
    const cellValidationModel = new editModelService_1.EditCellValidationModel();
    const { ariaAnnounce, localeSvc, editModelSvc, gos } = beans;
    const includeRows = gos.get('editType') === 'fullRow';
    const translate = (0, localeUtils_1._getLocaleTextFunc)(localeSvc);
    const ariaValidationErrorPrefix = translate('ariaValidationErrorPrefix', 'Cell Editor Validation');
    for (const mappedEditor of mappedEditors) {
        const { ctrl, editor } = mappedEditor;
        const { rowNode, column } = ctrl;
        const errorMessages = editor.getValidationErrors?.() ?? [];
        const el = editor.getValidationElement?.();
        if (el) {
            const isInvalid = errorMessages != null && errorMessages.length > 0;
            const invalidMessage = isInvalid ? errorMessages.join('. ') : '';
            (0, aria_1._setAriaInvalid)(el, isInvalid);
            if (isInvalid) {
                ariaAnnounce.announceValue(`${ariaValidationErrorPrefix} ${errorMessages}`, 'editorValidation');
            }
            if (el instanceof HTMLInputElement) {
                el.setCustomValidity(invalidMessage);
            }
            else {
                el.classList.toggle('invalid', isInvalid);
            }
        }
        if (errorMessages?.length > 0) {
            cellValidationModel.setCellValidation({
                rowNode,
                column,
            }, {
                errorMessages,
            });
        }
    }
    _syncFromEditors(beans);
    // the cellValidationModel should probably be reused to avoid
    // the second loop over mappedEditor below
    editModelSvc?.setCellValidationModel(cellValidationModel);
    const rowCtrlSet = new Set();
    for (const { ctrl } of mappedEditors) {
        rowCtrlSet.add(ctrl.rowCtrl);
    }
    if (includeRows) {
        const rowValidations = (0, exports._generateRowValidationErrors)(beans);
        editModelSvc?.setRowValidationModel(rowValidations);
    }
    for (const rowCtrl of rowCtrlSet.values()) {
        rowCtrl.rowEditStyleFeature?.applyRowStyles();
        for (const cellCtrl of rowCtrl.getAllCellCtrls()) {
            cellCtrl.tooltipFeature?.refreshTooltip(true);
            cellCtrl.editorTooltipFeature?.refreshTooltip(true);
            cellCtrl.editStyleFeature?.applyCellStyles?.();
        }
    }
}
exports._populateModelValidationErrors = _populateModelValidationErrors;
const _generateRowValidationErrors = (beans) => {
    const rowValidationModel = new editModelService_1.EditRowValidationModel();
    const getFullRowEditValidationErrors = beans.gos.get('getFullRowEditValidationErrors');
    // populate row-level errors
    const editMap = beans.editModelSvc?.getEditMap();
    if (!editMap) {
        return rowValidationModel;
    }
    for (const rowNode of editMap.keys()) {
        const rowEditMap = editMap.get(rowNode);
        if (!rowEditMap) {
            continue;
        }
        const editorsState = [];
        const { rowIndex, rowPinned } = rowNode;
        for (const column of rowEditMap.keys()) {
            const editValue = rowEditMap.get(column);
            if (!editValue) {
                continue;
            }
            editorsState.push({
                column,
                colId: column.getColId(),
                rowIndex: rowIndex,
                rowPinned,
                ...editValue,
                // don't expose this implementation detail
                newValue: editValue.newValue === exports.UNEDITED ? undefined : editValue.newValue,
            });
        }
        const errorMessages = getFullRowEditValidationErrors?.({ editorsState }) ?? [];
        if (errorMessages.length > 0) {
            rowValidationModel.setRowValidation({
                rowNode,
            }, { errorMessages });
        }
    }
    return rowValidationModel;
};
exports._generateRowValidationErrors = _generateRowValidationErrors;
function _validateEdit(beans) {
    _populateModelValidationErrors(beans);
    const map = beans.editModelSvc?.getCellValidationModel().getCellValidationMap();
    if (!map) {
        return null;
    }
    const validations = [];
    map.forEach((rowValidations, rowNode) => {
        rowValidations.forEach(({ errorMessages }, column) => {
            validations.push({
                column,
                rowIndex: rowNode.rowIndex,
                rowPinned: rowNode.rowPinned,
                messages: errorMessages ?? null,
            });
        });
    });
    return validations;
}
exports._validateEdit = _validateEdit;


/***/ }),

/***/ 11539:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._refreshEditCells = void 0;
const purgeRows = ({ rowModel, pinnedRowModel, editModelSvc }, rowNodes) => {
    const found = new Set();
    rowModel.forEachNode((node) => rowNodes.has(node) && found.add(node));
    pinnedRowModel?.forEachPinnedRow('top', (node) => rowNodes.has(node) && found.add(node));
    pinnedRowModel?.forEachPinnedRow('bottom', (node) => rowNodes.has(node) && found.add(node));
    rowNodes.forEach((rowNode) => {
        if (!found.has(rowNode)) {
            editModelSvc.removeEdits({ rowNode });
        }
    });
    return found;
};
const purgeCells = ({ editModelSvc }, rowNodes, columns) => {
    rowNodes.forEach((rowNode) => editModelSvc
        ?.getEditRow(rowNode)
        ?.forEach((_, column) => !columns.has(column) && editModelSvc.removeEdits({ rowNode, column })));
};
const _refreshEditCells = (beans) => () => {
    const columns = new Set(beans.colModel.getCols());
    const updates = beans.editModelSvc.getEditMap(true);
    const rowNodes = new Set(updates.keys());
    purgeCells(beans, purgeRows(beans, rowNodes), columns);
};
exports._refreshEditCells = _refreshEditCells;


/***/ }),

/***/ 13355:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgColumn = exports.isColumn = exports.getNextColInstanceId = void 0;
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const localEventService_1 = __webpack_require__(85889);
const generic_1 = __webpack_require__(34422);
const object_1 = __webpack_require__(6996);
const string_1 = __webpack_require__(37766);
const logging_1 = __webpack_require__(47764);
const COL_DEF_DEFAULTS = {
    resizable: true,
    sortable: true,
};
let instanceIdSequence = 0;
function getNextColInstanceId() {
    return instanceIdSequence++;
}
exports.getNextColInstanceId = getNextColInstanceId;
function isColumn(col) {
    return col instanceof AgColumn;
}
exports.isColumn = isColumn;
// Wrapper around a user provide column definition. The grid treats the column definition as ready only.
// This class contains all the runtime information about a column, plus some logic (the definition has no logic).
// This class implements both interfaces ColumnGroupChild and ProvidedColumnGroupChild as the class can
// appear as a child of either the original tree or the displayed tree. However the relevant group classes
// for each type only implements one, as each group can only appear in it's associated tree (eg ProvidedColumnGroup
// can only appear in OriginalColumn tree).
class AgColumn extends beanStub_1.BeanStub {
    constructor(colDef, 
    // We do NOT use this anywhere, we just keep a reference. this is to check object equivalence
    // when the user provides an updated list of columns - so we can check if we have a column already
    // existing for a col def. we cannot use the this.colDef as that is the result of a merge.
    // This is used in ColumnFactory
    userProvidedColDef, colId, primary) {
        super();
        this.colDef = colDef;
        this.userProvidedColDef = userProvidedColDef;
        this.colId = colId;
        this.primary = primary;
        this.isColumn = true;
        // used by React (and possibly other frameworks) as key for rendering. also used to
        // identify old vs new columns for destroying cols when no longer used.
        this.instanceId = getNextColInstanceId();
        // The measured height of this column's header when autoHeaderHeight is enabled
        this.autoHeaderHeight = null;
        this.moving = false;
        this.menuVisible = false;
        this.lastLeftPinned = false;
        this.firstRightPinned = false;
        this.filterActive = false;
        this.colEventSvc = new localEventService_1.LocalEventService();
        this.tooltipEnabled = false;
        this.rowGroupActive = false;
        this.pivotActive = false;
        this.aggregationActive = false;
        this.flex = null;
        this.colIdSanitised = (0, string_1._escapeString)(colId);
    }
    destroy() {
        super.destroy();
        this.beans.rowSpanSvc?.deregister(this);
    }
    getInstanceId() {
        return this.instanceId;
    }
    setState() {
        const { colDef, beans: { sortSvc, pinnedCols, colFlex }, } = this;
        sortSvc?.initCol(this);
        const hide = colDef.hide;
        if (hide !== undefined) {
            this.visible = !hide;
        }
        else {
            this.visible = !colDef.initialHide;
        }
        pinnedCols?.initCol(this);
        colFlex?.initCol(this);
    }
    // gets called when user provides an alternative colDef, eg
    setColDef(colDef, userProvidedColDef, source) {
        const colSpanChanged = colDef.spanRows !== this.colDef.spanRows;
        this.colDef = colDef;
        this.userProvidedColDef = userProvidedColDef;
        this.initMinAndMaxWidths();
        this.initDotNotation();
        this.initTooltip();
        if (colSpanChanged) {
            this.beans.rowSpanSvc?.deregister(this);
            this.initRowSpan();
        }
        this.dispatchColEvent('colDefChanged', source);
    }
    getUserProvidedColDef() {
        return this.userProvidedColDef;
    }
    getParent() {
        return this.parent;
    }
    getOriginalParent() {
        return this.originalParent;
    }
    // this is done after constructor as it uses gridOptionsService
    postConstruct() {
        this.setState();
        this.initMinAndMaxWidths();
        this.resetActualWidth('gridInitializing');
        this.initDotNotation();
        this.initTooltip();
        this.initRowSpan();
    }
    initDotNotation() {
        const { gos, colDef: { field, tooltipField }, } = this;
        const suppressDotNotation = gos.get('suppressFieldDotNotation');
        this.fieldContainsDots = (0, generic_1._exists)(field) && field.indexOf('.') >= 0 && !suppressDotNotation;
        this.tooltipFieldContainsDots = (0, generic_1._exists)(tooltipField) && tooltipField.indexOf('.') >= 0 && !suppressDotNotation;
    }
    initMinAndMaxWidths() {
        const colDef = this.colDef;
        this.minWidth = colDef.minWidth ?? this.beans.environment.getDefaultColumnMinWidth();
        this.maxWidth = colDef.maxWidth ?? Number.MAX_SAFE_INTEGER;
    }
    initTooltip() {
        this.beans.tooltipSvc?.initCol(this);
    }
    initRowSpan() {
        if (this.colDef.spanRows) {
            this.beans.rowSpanSvc?.register(this);
        }
    }
    resetActualWidth(source) {
        const initialWidth = this.calculateColInitialWidth(this.colDef);
        this.setActualWidth(initialWidth, source, true);
    }
    calculateColInitialWidth(colDef) {
        let width;
        const colDefWidth = colDef.width;
        const colDefInitialWidth = colDef.initialWidth;
        if (colDefWidth != null) {
            width = colDefWidth;
        }
        else if (colDefInitialWidth != null) {
            width = colDefInitialWidth;
        }
        else {
            width = 200;
        }
        return Math.max(Math.min(width, this.maxWidth), this.minWidth);
    }
    isEmptyGroup() {
        return false;
    }
    isRowGroupDisplayed(colId) {
        return this.beans.showRowGroupCols?.isRowGroupDisplayed(this, colId) ?? false;
    }
    isPrimary() {
        return this.primary;
    }
    isFilterAllowed() {
        // filter defined means it's a string, class or true.
        // if its false, null or undefined then it's false.
        const filterDefined = !!this.colDef.filter;
        return filterDefined;
    }
    isFieldContainsDots() {
        return this.fieldContainsDots;
    }
    isTooltipEnabled() {
        return this.tooltipEnabled;
    }
    isTooltipFieldContainsDots() {
        return this.tooltipFieldContainsDots;
    }
    getHighlighted() {
        return this.highlighted;
    }
    __addEventListener(eventType, listener) {
        this.colEventSvc.addEventListener(eventType, listener);
    }
    __removeEventListener(eventType, listener) {
        this.colEventSvc.removeEventListener(eventType, listener);
    }
    /**
     * PUBLIC USE ONLY: for internal use within AG Grid use the `__addEventListener` and `__removeEventListener` methods.
     */
    addEventListener(eventType, userListener) {
        this.frameworkEventListenerService = this.beans.frameworkOverrides.createLocalEventListenerWrapper?.(this.frameworkEventListenerService, this.colEventSvc);
        const listener = this.frameworkEventListenerService?.wrap(eventType, userListener) ?? userListener;
        this.colEventSvc.addEventListener(eventType, listener);
    }
    /**
     * PUBLIC USE ONLY: for internal use within AG Grid use the `__addEventListener` and `__removeEventListener` methods.
     */
    removeEventListener(eventType, userListener) {
        const listener = this.frameworkEventListenerService?.unwrap(eventType, userListener) ?? userListener;
        this.colEventSvc.removeEventListener(eventType, listener);
    }
    createColumnFunctionCallbackParams(rowNode) {
        return (0, gridOptionsUtils_1._addGridCommonParams)(this.gos, {
            node: rowNode,
            data: rowNode.data,
            column: this,
            colDef: this.colDef,
        });
    }
    isSuppressNavigable(rowNode) {
        return this.beans.cellNavigation?.isSuppressNavigable(this, rowNode) ?? false;
    }
    isCellEditable(rowNode) {
        return this.beans.editSvc?.isCellEditable({ rowNode, column: this }) ?? false;
    }
    isSuppressFillHandle() {
        return !!this.colDef.suppressFillHandle;
    }
    isAutoHeight() {
        return !!this.colDef.autoHeight;
    }
    isAutoHeaderHeight() {
        return !!this.colDef.autoHeaderHeight;
    }
    isRowDrag(rowNode) {
        return this.isColumnFunc(rowNode, this.colDef.rowDrag);
    }
    isDndSource(rowNode) {
        return this.isColumnFunc(rowNode, this.colDef.dndSource);
    }
    isCellCheckboxSelection(rowNode) {
        return this.beans.selectionSvc?.isCellCheckboxSelection(this, rowNode) ?? false;
    }
    isSuppressPaste(rowNode) {
        return this.isColumnFunc(rowNode, this.colDef?.suppressPaste ?? null);
    }
    isResizable() {
        return !!this.getColDefValue('resizable');
    }
    /** Get value from ColDef or default if it exists. */
    getColDefValue(key) {
        return this.colDef[key] ?? COL_DEF_DEFAULTS[key];
    }
    isColumnFunc(rowNode, value) {
        // if boolean set, then just use it
        if (typeof value === 'boolean') {
            return value;
        }
        // if function, then call the function to find out
        if (typeof value === 'function') {
            const params = this.createColumnFunctionCallbackParams(rowNode);
            const editableFunc = value;
            return editableFunc(params);
        }
        return false;
    }
    createColumnEvent(type, source) {
        return (0, gridOptionsUtils_1._addGridCommonParams)(this.gos, {
            type,
            column: this,
            columns: [this],
            source,
        });
    }
    isMoving() {
        return this.moving;
    }
    getSort() {
        return this.sort;
    }
    isSortable() {
        return !!this.getColDefValue('sortable');
    }
    /** @deprecated v32 use col.getSort() === 'asc */
    isSortAscending() {
        return this.sort === 'asc';
    }
    /** @deprecated v32 use col.getSort() === 'desc */
    isSortDescending() {
        return this.sort === 'desc';
    }
    /** @deprecated v32 use col.getSort() === undefined */
    isSortNone() {
        return (0, generic_1._missing)(this.sort);
    }
    /** @deprecated v32 use col.getSort() !== undefined */
    isSorting() {
        return (0, generic_1._exists)(this.sort);
    }
    getSortIndex() {
        return this.sortIndex;
    }
    isMenuVisible() {
        return this.menuVisible;
    }
    getAggFunc() {
        return this.aggFunc;
    }
    getLeft() {
        return this.left;
    }
    getOldLeft() {
        return this.oldLeft;
    }
    getRight() {
        return this.left + this.actualWidth;
    }
    setLeft(left, source) {
        this.oldLeft = this.left;
        if (this.left !== left) {
            this.left = left;
            this.dispatchColEvent('leftChanged', source);
        }
    }
    isFilterActive() {
        return this.filterActive;
    }
    /** @deprecated v33 Use `api.isColumnHovered(column)` instead. */
    isHovered() {
        (0, logging_1._warn)(261);
        return !!this.beans.colHover?.isHovered(this);
    }
    setFirstRightPinned(firstRightPinned, source) {
        if (this.firstRightPinned !== firstRightPinned) {
            this.firstRightPinned = firstRightPinned;
            this.dispatchColEvent('firstRightPinnedChanged', source);
        }
    }
    setLastLeftPinned(lastLeftPinned, source) {
        if (this.lastLeftPinned !== lastLeftPinned) {
            this.lastLeftPinned = lastLeftPinned;
            this.dispatchColEvent('lastLeftPinnedChanged', source);
        }
    }
    isFirstRightPinned() {
        return this.firstRightPinned;
    }
    isLastLeftPinned() {
        return this.lastLeftPinned;
    }
    isPinned() {
        return this.pinned === 'left' || this.pinned === 'right';
    }
    isPinnedLeft() {
        return this.pinned === 'left';
    }
    isPinnedRight() {
        return this.pinned === 'right';
    }
    getPinned() {
        return this.pinned;
    }
    setVisible(visible, source) {
        const newValue = visible === true;
        if (this.visible !== newValue) {
            this.visible = newValue;
            this.dispatchColEvent('visibleChanged', source);
        }
        this.dispatchStateUpdatedEvent('hide');
    }
    isVisible() {
        return this.visible;
    }
    isSpanHeaderHeight() {
        const colDef = this.getColDef();
        return !colDef.suppressSpanHeaderHeight;
    }
    getColumnGroupPaddingInfo() {
        let parent = this.getParent();
        if (!parent || !parent.isPadding()) {
            return { numberOfParents: 0, isSpanningTotal: false };
        }
        const numberOfParents = parent.getPaddingLevel() + 1;
        let isSpanningTotal = true;
        while (parent) {
            if (!parent.isPadding()) {
                isSpanningTotal = false;
                break;
            }
            parent = parent.getParent();
        }
        return { numberOfParents, isSpanningTotal };
    }
    getColDef() {
        return this.colDef;
    }
    getDefinition() {
        return this.colDef;
    }
    getColumnGroupShow() {
        return this.colDef.columnGroupShow;
    }
    getColId() {
        return this.colId;
    }
    getId() {
        return this.colId;
    }
    getUniqueId() {
        return this.colId;
    }
    getActualWidth() {
        return this.actualWidth;
    }
    getAutoHeaderHeight() {
        return this.autoHeaderHeight;
    }
    /** Returns true if the header height has changed */
    setAutoHeaderHeight(height) {
        const changed = height !== this.autoHeaderHeight;
        this.autoHeaderHeight = height;
        return changed;
    }
    createBaseColDefParams(rowNode) {
        const params = (0, gridOptionsUtils_1._addGridCommonParams)(this.gos, {
            node: rowNode,
            data: rowNode.data,
            colDef: this.colDef,
            column: this,
        });
        return params;
    }
    getColSpan(rowNode) {
        if ((0, generic_1._missing)(this.colDef.colSpan)) {
            return 1;
        }
        const params = this.createBaseColDefParams(rowNode);
        const colSpan = this.colDef.colSpan(params);
        // colSpan must be number equal to or greater than 1
        return Math.max(colSpan, 1);
    }
    getRowSpan(rowNode) {
        if ((0, generic_1._missing)(this.colDef.rowSpan)) {
            return 1;
        }
        const params = this.createBaseColDefParams(rowNode);
        const rowSpan = this.colDef.rowSpan(params);
        // rowSpan must be number equal to or greater than 1
        return Math.max(rowSpan, 1);
    }
    setActualWidth(actualWidth, source, silent = false) {
        actualWidth = Math.max(actualWidth, this.minWidth);
        actualWidth = Math.min(actualWidth, this.maxWidth);
        if (this.actualWidth !== actualWidth) {
            // disable flex for this column if it was manually resized.
            this.actualWidth = actualWidth;
            if (this.flex != null && source !== 'flex' && source !== 'gridInitializing') {
                this.flex = null;
            }
            if (!silent) {
                this.fireColumnWidthChangedEvent(source);
            }
        }
        this.dispatchStateUpdatedEvent('width');
    }
    fireColumnWidthChangedEvent(source) {
        this.dispatchColEvent('widthChanged', source);
    }
    isGreaterThanMax(width) {
        return width > this.maxWidth;
    }
    getMinWidth() {
        return this.minWidth;
    }
    getMaxWidth() {
        return this.maxWidth;
    }
    getFlex() {
        return this.flex;
    }
    isRowGroupActive() {
        return this.rowGroupActive;
    }
    isPivotActive() {
        return this.pivotActive;
    }
    isAnyFunctionActive() {
        return this.isPivotActive() || this.isRowGroupActive() || this.isValueActive();
    }
    isAnyFunctionAllowed() {
        return this.isAllowPivot() || this.isAllowRowGroup() || this.isAllowValue();
    }
    isValueActive() {
        return this.aggregationActive;
    }
    isAllowPivot() {
        return this.colDef.enablePivot === true;
    }
    isAllowValue() {
        return this.colDef.enableValue === true;
    }
    isAllowRowGroup() {
        return this.colDef.enableRowGroup === true;
    }
    dispatchColEvent(type, source, additionalEventAttributes) {
        const colEvent = this.createColumnEvent(type, source);
        if (additionalEventAttributes) {
            (0, object_1._mergeDeep)(colEvent, additionalEventAttributes);
        }
        this.colEventSvc.dispatchEvent(colEvent);
    }
    dispatchStateUpdatedEvent(key) {
        this.colEventSvc.dispatchEvent({
            type: 'columnStateUpdated',
            key,
        });
    }
}
exports.AgColumn = AgColumn;


/***/ }),

/***/ 56908:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgColumnGroup = exports.isColumnGroup = exports.createUniqueColumnGroupId = void 0;
const beanStub_1 = __webpack_require__(68731);
const array_1 = __webpack_require__(31502);
const agColumn_1 = __webpack_require__(13355);
function createUniqueColumnGroupId(groupId, instanceId) {
    return (groupId + '_' + instanceId);
}
exports.createUniqueColumnGroupId = createUniqueColumnGroupId;
function isColumnGroup(col) {
    return col instanceof AgColumnGroup;
}
exports.isColumnGroup = isColumnGroup;
class AgColumnGroup extends beanStub_1.BeanStub {
    constructor(providedColumnGroup, groupId, partId, pinned) {
        super();
        this.providedColumnGroup = providedColumnGroup;
        this.groupId = groupId;
        this.partId = partId;
        this.pinned = pinned;
        this.isColumn = false;
        // depends on the open/closed state of the group, only displaying columns are stored here
        this.displayedChildren = [];
        // The measured height of this column's header when autoHeaderHeight is enabled
        this.autoHeaderHeight = null;
        this.parent = null;
    }
    // as the user is adding and removing columns, the groups are recalculated.
    // this reset clears out all children, ready for children to be added again
    reset() {
        this.parent = null;
        this.children = null;
        this.displayedChildren = null;
    }
    getParent() {
        return this.parent;
    }
    getUniqueId() {
        return createUniqueColumnGroupId(this.groupId, this.partId);
    }
    isEmptyGroup() {
        return this.displayedChildren.length === 0;
    }
    isMoving() {
        const allLeafColumns = this.getProvidedColumnGroup().getLeafColumns();
        if (!allLeafColumns || allLeafColumns.length === 0) {
            return false;
        }
        return allLeafColumns.every((col) => col.isMoving());
    }
    checkLeft() {
        // first get all children to setLeft, as it impacts our decision below
        this.displayedChildren.forEach((child) => {
            if (isColumnGroup(child)) {
                child.checkLeft();
            }
        });
        // set our left based on first displayed column
        if (this.displayedChildren.length > 0) {
            if (this.gos.get('enableRtl')) {
                const lastChild = (0, array_1._last)(this.displayedChildren);
                const lastChildLeft = lastChild.getLeft();
                this.setLeft(lastChildLeft);
            }
            else {
                const firstChildLeft = this.displayedChildren[0].getLeft();
                this.setLeft(firstChildLeft);
            }
        }
        else {
            // this should never happen, as if we have no displayed columns, then
            // this groups should not even exist.
            this.setLeft(null);
        }
    }
    getLeft() {
        return this.left;
    }
    getOldLeft() {
        return this.oldLeft;
    }
    setLeft(left) {
        this.oldLeft = this.left;
        if (this.left !== left) {
            this.left = left;
            this.dispatchLocalEvent({ type: 'leftChanged' });
        }
    }
    getPinned() {
        return this.pinned;
    }
    getGroupId() {
        return this.groupId;
    }
    getPartId() {
        return this.partId;
    }
    getActualWidth() {
        let groupActualWidth = 0;
        this.displayedChildren?.forEach((child) => {
            groupActualWidth += child.getActualWidth();
        });
        return groupActualWidth;
    }
    isResizable() {
        if (!this.displayedChildren) {
            return false;
        }
        // if at least one child is resizable, then the group is resizable
        let result = false;
        this.displayedChildren.forEach((child) => {
            if (child.isResizable()) {
                result = true;
            }
        });
        return result;
    }
    getMinWidth() {
        let result = 0;
        this.displayedChildren.forEach((groupChild) => {
            result += groupChild.getMinWidth();
        });
        return result;
    }
    addChild(child) {
        if (!this.children) {
            this.children = [];
        }
        this.children.push(child);
    }
    getDisplayedChildren() {
        return this.displayedChildren;
    }
    getLeafColumns() {
        const result = [];
        this.addLeafColumns(result);
        return result;
    }
    getDisplayedLeafColumns() {
        const result = [];
        this.addDisplayedLeafColumns(result);
        return result;
    }
    getDefinition() {
        return this.providedColumnGroup.getColGroupDef();
    }
    getColGroupDef() {
        return this.providedColumnGroup.getColGroupDef();
    }
    isPadding() {
        return this.providedColumnGroup.isPadding();
    }
    isExpandable() {
        return this.providedColumnGroup.isExpandable();
    }
    isExpanded() {
        return this.providedColumnGroup.isExpanded();
    }
    setExpanded(expanded) {
        this.providedColumnGroup.setExpanded(expanded);
    }
    isAutoHeaderHeight() {
        return !!this.getColGroupDef()?.autoHeaderHeight;
    }
    getAutoHeaderHeight() {
        return this.autoHeaderHeight;
    }
    /** Returns true if the header height has changed */
    setAutoHeaderHeight(height) {
        const changed = height !== this.autoHeaderHeight;
        this.autoHeaderHeight = height;
        return changed;
    }
    addDisplayedLeafColumns(leafColumns) {
        this.displayedChildren.forEach((child) => {
            if ((0, agColumn_1.isColumn)(child)) {
                leafColumns.push(child);
            }
            else if (isColumnGroup(child)) {
                child.addDisplayedLeafColumns(leafColumns);
            }
        });
    }
    addLeafColumns(leafColumns) {
        this.children.forEach((child) => {
            if ((0, agColumn_1.isColumn)(child)) {
                leafColumns.push(child);
            }
            else if (isColumnGroup(child)) {
                child.addLeafColumns(leafColumns);
            }
        });
    }
    getChildren() {
        return this.children;
    }
    getColumnGroupShow() {
        return this.providedColumnGroup.getColumnGroupShow();
    }
    getProvidedColumnGroup() {
        return this.providedColumnGroup;
    }
    getPaddingLevel() {
        const parent = this.getParent();
        if (!this.isPadding() || !parent || !parent.isPadding()) {
            return 0;
        }
        return 1 + parent.getPaddingLevel();
    }
    calculateDisplayedColumns() {
        // clear out last time we calculated
        this.displayedChildren = [];
        // find the column group that is controlling expandable. this is relevant when we have padding (empty)
        // groups, where the expandable is actually the first parent that is not a padding group.
        let parentWithExpansion = this;
        while (parentWithExpansion != null && parentWithExpansion.isPadding()) {
            parentWithExpansion = parentWithExpansion.getParent();
        }
        const isExpandable = parentWithExpansion ? parentWithExpansion.getProvidedColumnGroup().isExpandable() : false;
        // it not expandable, everything is visible
        if (!isExpandable) {
            this.displayedChildren = this.children;
            this.dispatchLocalEvent({ type: 'displayedChildrenChanged' });
            return;
        }
        // Add cols based on columnGroupShow
        // Note - the below also adds padding groups, these are always added because they never have
        // colDef.columnGroupShow set.
        this.children.forEach((child) => {
            // never add empty groups
            const emptyGroup = isColumnGroup(child) && (!child.displayedChildren || !child.displayedChildren.length);
            if (emptyGroup) {
                return;
            }
            const headerGroupShow = child.getColumnGroupShow();
            switch (headerGroupShow) {
                case 'open':
                    // when set to open, only show col if group is open
                    if (parentWithExpansion.getProvidedColumnGroup().isExpanded()) {
                        this.displayedChildren.push(child);
                    }
                    break;
                case 'closed':
                    // when set to open, only show col if group is open
                    if (!parentWithExpansion.getProvidedColumnGroup().isExpanded()) {
                        this.displayedChildren.push(child);
                    }
                    break;
                default:
                    this.displayedChildren.push(child);
                    break;
            }
        });
        this.dispatchLocalEvent({ type: 'displayedChildrenChanged' });
    }
}
exports.AgColumnGroup = AgColumnGroup;


/***/ }),

/***/ 79409:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgProvidedColumnGroup = exports.isProvidedColumnGroup = void 0;
const beanStub_1 = __webpack_require__(68731);
const agColumn_1 = __webpack_require__(13355);
function isProvidedColumnGroup(col) {
    return col instanceof AgProvidedColumnGroup;
}
exports.isProvidedColumnGroup = isProvidedColumnGroup;
class AgProvidedColumnGroup extends beanStub_1.BeanStub {
    constructor(colGroupDef, groupId, padding, level) {
        super();
        this.colGroupDef = colGroupDef;
        this.groupId = groupId;
        this.padding = padding;
        this.level = level;
        this.isColumn = false;
        this.expandable = false;
        // used by React (and possibly other frameworks) as key for rendering. also used to
        // identify old vs new columns for destroying cols when no longer used.
        this.instanceId = (0, agColumn_1.getNextColInstanceId)();
        this.expandableListenerRemoveCallback = null;
        this.expanded = !!colGroupDef?.openByDefault;
    }
    destroy() {
        if (this.expandableListenerRemoveCallback) {
            this.reset(null, undefined);
        }
        super.destroy();
    }
    reset(colGroupDef, level) {
        this.colGroupDef = colGroupDef;
        this.level = level;
        this.originalParent = null;
        if (this.expandableListenerRemoveCallback) {
            this.expandableListenerRemoveCallback();
        }
        // we use ! below, as we want to set the object back to the
        // way it was when it was first created
        this.children = undefined;
        this.expandable = undefined;
    }
    getInstanceId() {
        return this.instanceId;
    }
    getOriginalParent() {
        return this.originalParent;
    }
    getLevel() {
        return this.level;
    }
    isVisible() {
        // return true if at least one child is visible
        if (this.children) {
            return this.children.some((child) => child.isVisible());
        }
        return false;
    }
    isPadding() {
        return this.padding;
    }
    setExpanded(expanded) {
        this.expanded = expanded === undefined ? false : expanded;
        this.dispatchLocalEvent({ type: 'expandedChanged' });
    }
    isExpandable() {
        return this.expandable;
    }
    isExpanded() {
        return this.expanded;
    }
    getGroupId() {
        return this.groupId;
    }
    getId() {
        return this.getGroupId();
    }
    setChildren(children) {
        this.children = children;
    }
    getChildren() {
        return this.children;
    }
    getColGroupDef() {
        return this.colGroupDef;
    }
    getLeafColumns() {
        const result = [];
        this.addLeafColumns(result);
        return result;
    }
    forEachLeafColumn(callback) {
        if (!this.children) {
            return;
        }
        for (const child of this.children) {
            if ((0, agColumn_1.isColumn)(child)) {
                callback(child);
            }
            else if (isProvidedColumnGroup(child)) {
                child.forEachLeafColumn(callback);
            }
        }
    }
    addLeafColumns(leafColumns) {
        if (!this.children) {
            return;
        }
        this.children.forEach((child) => {
            if ((0, agColumn_1.isColumn)(child)) {
                leafColumns.push(child);
            }
            else if (isProvidedColumnGroup(child)) {
                child.addLeafColumns(leafColumns);
            }
        });
    }
    getColumnGroupShow() {
        const colGroupDef = this.colGroupDef;
        if (!colGroupDef) {
            return;
        }
        return colGroupDef.columnGroupShow;
    }
    // need to check that this group has at least one col showing when both expanded and contracted.
    // if not, then we don't allow expanding and contracting on this group
    setupExpandable() {
        this.setExpandable();
        if (this.expandableListenerRemoveCallback) {
            this.expandableListenerRemoveCallback();
        }
        const listener = this.onColumnVisibilityChanged.bind(this);
        this.getLeafColumns().forEach((col) => col.__addEventListener('visibleChanged', listener));
        this.expandableListenerRemoveCallback = () => {
            this.getLeafColumns().forEach((col) => col.__removeEventListener('visibleChanged', listener));
            this.expandableListenerRemoveCallback = null;
        };
    }
    setExpandable() {
        if (this.isPadding()) {
            return;
        }
        // want to make sure the group doesn't disappear when it's open
        let atLeastOneShowingWhenOpen = false;
        // want to make sure the group doesn't disappear when it's closed
        let atLeastOneShowingWhenClosed = false;
        // want to make sure the group has something to show / hide
        let atLeastOneChangeable = false;
        const children = this.findChildrenRemovingPadding();
        for (let i = 0, j = children.length; i < j; i++) {
            const abstractColumn = children[i];
            if (!abstractColumn.isVisible()) {
                continue;
            }
            // if the abstractColumn is a grid generated group, there will be no colDef
            const headerGroupShow = abstractColumn.getColumnGroupShow();
            if (headerGroupShow === 'open') {
                atLeastOneShowingWhenOpen = true;
                atLeastOneChangeable = true;
            }
            else if (headerGroupShow === 'closed') {
                atLeastOneShowingWhenClosed = true;
                atLeastOneChangeable = true;
            }
            else {
                atLeastOneShowingWhenOpen = true;
                atLeastOneShowingWhenClosed = true;
            }
        }
        const expandable = atLeastOneShowingWhenOpen && atLeastOneShowingWhenClosed && atLeastOneChangeable;
        if (this.expandable !== expandable) {
            this.expandable = expandable;
            this.dispatchLocalEvent({ type: 'expandableChanged' });
        }
    }
    findChildrenRemovingPadding() {
        const res = [];
        const process = (items) => {
            items.forEach((item) => {
                // if padding, we add this children instead of the padding
                const skipBecausePadding = isProvidedColumnGroup(item) && item.isPadding();
                if (skipBecausePadding) {
                    process(item.children);
                }
                else {
                    res.push(item);
                }
            });
        };
        process(this.children);
        return res;
    }
    onColumnVisibilityChanged() {
        this.setExpandable();
    }
}
exports.AgProvidedColumnGroup = AgProvidedColumnGroup;


/***/ }),

/***/ 35449:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultColumnTypes = void 0;
exports.DefaultColumnTypes = {
    numericColumn: {
        headerClass: 'ag-right-aligned-header',
        cellClass: 'ag-right-aligned-cell',
    },
    rightAligned: {
        headerClass: 'ag-right-aligned-header',
        cellClass: 'ag-right-aligned-cell',
    },
};


/***/ }),

/***/ 6257:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._getRowBelow = exports._getRowAbove = exports._getRowById = exports._getCellByPosition = exports._getRowNode = exports._getLastRow = exports._getFirstRow = exports._isSameRow = exports._isRowBefore = exports._areCellsEqual = exports._createCellId = void 0;
const gridOptionsUtils_1 = __webpack_require__(67274);
const generic_1 = __webpack_require__(34422);
function _createCellId(cellPosition) {
    const { rowIndex, rowPinned, column } = cellPosition;
    return `${rowIndex}.${rowPinned == null ? 'null' : rowPinned}.${column.getId()}`;
}
exports._createCellId = _createCellId;
function _areCellsEqual(cellA, cellB) {
    const colsMatch = cellA.column === cellB.column;
    const floatingMatch = cellA.rowPinned === cellB.rowPinned;
    const indexMatch = cellA.rowIndex === cellB.rowIndex;
    return colsMatch && floatingMatch && indexMatch;
}
exports._areCellsEqual = _areCellsEqual;
// tests if this row selection is before the other row selection
function _isRowBefore(rowA, rowB) {
    switch (rowA.rowPinned) {
        case 'top':
            // we we are floating top, and other isn't, then we are always before
            if (rowB.rowPinned !== 'top') {
                return true;
            }
            break;
        case 'bottom':
            // if we are floating bottom, and the other isn't, then we are never before
            if (rowB.rowPinned !== 'bottom') {
                return false;
            }
            break;
        default:
            // if we are not floating, but the other one is floating...
            if ((0, generic_1._exists)(rowB.rowPinned)) {
                return rowB.rowPinned !== 'top';
            }
            break;
    }
    return rowA.rowIndex < rowB.rowIndex;
}
exports._isRowBefore = _isRowBefore;
function _isSameRow(rowA, rowB) {
    // if both missing
    if (!rowA && !rowB) {
        return true;
    }
    // if only one missing
    if ((rowA && !rowB) || (!rowA && rowB)) {
        return false;
    }
    // otherwise compare (use == to compare rowPinned because it can be null or undefined)
    return rowA.rowIndex === rowB.rowIndex && rowA.rowPinned == rowB.rowPinned;
}
exports._isSameRow = _isSameRow;
function _getFirstRow(beans) {
    let rowIndex = 0;
    let rowPinned;
    const { pinnedRowModel, rowModel, pageBounds } = beans;
    if (pinnedRowModel?.getPinnedTopRowCount()) {
        rowPinned = 'top';
    }
    else if (rowModel.getRowCount()) {
        rowPinned = null;
        rowIndex = pageBounds.getFirstRow();
    }
    else if (pinnedRowModel?.getPinnedBottomRowCount()) {
        rowPinned = 'bottom';
    }
    return rowPinned === undefined ? null : { rowIndex, rowPinned };
}
exports._getFirstRow = _getFirstRow;
function _getLastRow(beans) {
    let rowIndex;
    let rowPinned = null;
    const { pinnedRowModel, pageBounds } = beans;
    const pinnedBottomCount = pinnedRowModel?.getPinnedBottomRowCount();
    const pinnedTopCount = pinnedRowModel?.getPinnedTopRowCount();
    if (pinnedBottomCount) {
        rowPinned = 'bottom';
        rowIndex = pinnedBottomCount - 1;
    }
    else if (beans.rowModel.getRowCount()) {
        rowPinned = null;
        rowIndex = pageBounds.getLastRow();
    }
    else if (pinnedTopCount) {
        rowPinned = 'top';
        rowIndex = pinnedTopCount - 1;
    }
    return rowIndex === undefined ? null : { rowIndex, rowPinned };
}
exports._getLastRow = _getLastRow;
function _getRowNode(beans, gridRow) {
    switch (gridRow.rowPinned) {
        case 'top':
            return beans.pinnedRowModel?.getPinnedTopRow(gridRow.rowIndex);
        case 'bottom':
            return beans.pinnedRowModel?.getPinnedBottomRow(gridRow.rowIndex);
        default:
            return beans.rowModel.getRow(gridRow.rowIndex);
    }
}
exports._getRowNode = _getRowNode;
function _getCellByPosition(beans, cellPosition) {
    // if spanned, return cell ctrl from spanned renderer
    const spannedCellCtrl = beans.spannedRowRenderer?.getCellByPosition(cellPosition);
    if (spannedCellCtrl) {
        return spannedCellCtrl;
    }
    const rowCtrl = beans.rowRenderer.getRowByPosition(cellPosition);
    if (!rowCtrl) {
        return null;
    }
    return rowCtrl.getCellCtrl(cellPosition.column);
}
exports._getCellByPosition = _getCellByPosition;
function _getRowById(beans, rowId, rowPinned) {
    const { rowModel: rm, pinnedRowModel: prm } = beans;
    let node;
    node ?? (node = rm?.getRowNode(rowId));
    if (rowPinned) {
        node ?? (node = prm?.getPinnedRowById(rowId, rowPinned));
    }
    else {
        node ?? (node = prm?.getPinnedRowById(rowId, 'top'));
        node ?? (node = prm?.getPinnedRowById(rowId, 'bottom'));
    }
    return node;
}
exports._getRowById = _getRowById;
function _getRowAbove(beans, rowPosition) {
    const { rowIndex: index, rowPinned: pinned } = rowPosition;
    const { pageBounds, pinnedRowModel, rowModel } = beans;
    if (index === 0) {
        if (pinned === 'top') {
            return null;
        }
        if (pinned === 'bottom' && rowModel.isRowsToRender()) {
            return { rowIndex: pageBounds.getLastRow(), rowPinned: null };
        }
        return pinnedRowModel?.isRowsToRender('top')
            ? { rowIndex: pinnedRowModel.getPinnedTopRowCount() - 1, rowPinned: 'top' }
            : null;
    }
    const rowNode = pinned ? undefined : rowModel.getRow(index);
    return getNextStickyPosition(beans, rowNode, true) ?? { rowIndex: index - 1, rowPinned: pinned };
}
exports._getRowAbove = _getRowAbove;
function _getRowBelow(beans, rowPosition) {
    const { rowIndex: index, rowPinned: pinned } = rowPosition;
    const { pageBounds, pinnedRowModel, rowModel } = beans;
    if (isLastRowInContainer(beans, rowPosition)) {
        if (pinned === 'bottom') {
            return null;
        }
        if (pinned === 'top' && rowModel.isRowsToRender()) {
            return { rowIndex: pageBounds.getFirstRow(), rowPinned: null };
        }
        return pinnedRowModel?.isRowsToRender('bottom') ? { rowIndex: 0, rowPinned: 'bottom' } : null;
    }
    const rowNode = pinned ? undefined : rowModel.getRow(index);
    return getNextStickyPosition(beans, rowNode) ?? { rowIndex: index + 1, rowPinned: pinned };
}
exports._getRowBelow = _getRowBelow;
function getNextStickyPosition(beans, rowNode, up) {
    const { gos, rowRenderer } = beans;
    if (!rowNode?.sticky || !(0, gridOptionsUtils_1._isGroupRowsSticky)(gos)) {
        return;
    }
    const stickyRowCtrls = up ? rowRenderer.getStickyTopRowCtrls() : rowRenderer.getStickyBottomRowCtrls();
    let nextCtrl;
    for (let i = 0; i < stickyRowCtrls.length; i++) {
        if (stickyRowCtrls[i].rowNode.rowIndex === rowNode.rowIndex) {
            nextCtrl = stickyRowCtrls[i + (up ? -1 : 1)];
            break;
        }
    }
    return nextCtrl ? { rowIndex: nextCtrl.rowNode.rowIndex, rowPinned: null } : undefined;
}
function isLastRowInContainer(beans, rowPosition) {
    const { rowPinned, rowIndex } = rowPosition;
    const { pinnedRowModel, pageBounds } = beans;
    if (rowPinned === 'top') {
        const lastTopIndex = (pinnedRowModel?.getPinnedTopRowCount() ?? 0) - 1;
        return lastTopIndex <= rowIndex;
    }
    if (rowPinned === 'bottom') {
        const lastBottomIndex = (pinnedRowModel?.getPinnedBottomRowCount() ?? 0) - 1;
        return lastBottomIndex <= rowIndex;
    }
    const lastBodyIndex = pageBounds.getLastRow();
    return lastBodyIndex <= rowIndex;
}


/***/ }),

/***/ 3373:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RowNode = exports.ROW_ID_PREFIX_BOTTOM_PINNED = exports.ROW_ID_PREFIX_TOP_PINNED = exports.ROW_ID_PREFIX_ROW_GROUP = void 0;
const gridOptionsUtils_1 = __webpack_require__(67274);
const localEventService_1 = __webpack_require__(85889);
const logging_1 = __webpack_require__(47764);
exports.ROW_ID_PREFIX_ROW_GROUP = 'row-group-';
exports.ROW_ID_PREFIX_TOP_PINNED = 't-';
exports.ROW_ID_PREFIX_BOTTOM_PINNED = 'b-';
let OBJECT_ID_SEQUENCE = 0;
class RowNode {
    constructor(beans) {
        /** `true` if this row is a master row, part of master / detail (ie row can be expanded to show detail) */
        this.master = false;
        /** `true` if this row is a detail row, part of master / detail (ie child row of an expanded master row)*/
        this.detail = undefined;
        /** The current row index. If the row is filtered out or in a collapsed group, this value is set to `null`. */
        this.rowIndex = null;
        /** The key for the group eg Ireland, UK, USA */
        this.key = null;
        /**
         * The index of the row in the source rowData array including any updates via transactions.
         * It does not change when sorting, filtering, grouping, pivoting or any other UI related operations.
         * If this is a filler node (a visual row created by AG Grid in tree data or grouping) the value is set to `-1`.
         *
         * Generally readonly. It is modified only by:
         * - ClientSideNodeManager, cast to ClientSideNodeManagerRowNode
         * - ClientSideRowModel, cast to ClientSideRowModelRowNode
         */
        this.sourceRowIndex = -1;
        /** Children mapped by the pivot columns or group key */
        this.childrenMapped = null;
        /**
         * Parent RowNode for tree data.
         * When set, the parent node in the hierarchy is updated during Client-Side Row Model (CSRM) grouping.
         * Used by the ClientSideChildrenTreeNodeManager, TreeGroupStrategy, RowDragFeature
         */
        this.treeParent = null;
        /** The flags associated to this node. Used only internally within TreeGroupStrategy. */
        this.treeNodeFlags = 0;
        /**
         * This is `true` if the row has a rowIndex assigned, otherwise `false`.
         */
        this.displayed = false;
        /** The row top position in pixels. */
        this.rowTop = null;
        /** The top pixel for this row last time, makes sense if data set was ordered or filtered,
         * it is used so new rows can animate in from their old position. */
        this.oldRowTop = null;
        /** `true` by default - can be overridden via gridOptions.isRowSelectable(rowNode) */
        this.selectable = true;
        /**
         * Used by sorting service - to give deterministic sort to groups. Previously we
         * just id for this, however id is a string and had slower sorting compared to numbers.
         * If re-naming this property, you must also update `IGNORED_SIBLING_PROPERTIES`
         */
        this.__objectId = OBJECT_ID_SEQUENCE++;
        /** `true` when nodes with the same id are being removed and added as part of the same batch transaction */
        this.alreadyRendered = false;
        this.hovered = false;
        this.__selected = false;
        this.beans = beans;
    }
    /**
     * Replaces the data on the `rowNode`. When this method is called, the grid refreshes the entire rendered row if it is displayed.
     */
    setData(data) {
        this.setDataCommon(data, false);
    }
    // similar to setRowData, however it is expected that the data is the same data item. this
    // is intended to be used with Redux type stores, where the whole data can be changed. we are
    // guaranteed that the data is the same entity (so grid doesn't need to worry about the id of the
    // underlying data changing, hence doesn't need to worry about selection). the grid, upon receiving
    // dataChanged event, refreshes the cells rather than rip them all out (so user can show transitions).
    /**
     * Updates the data on the `rowNode`. When this method is called, the grid refreshes the entire rendered row if it is displayed.
     */
    updateData(data) {
        this.setDataCommon(data, true);
    }
    setDataCommon(data, update) {
        const { valueCache, eventSvc } = this.beans;
        const oldData = this.data;
        this.data = data;
        valueCache?.onDataChanged();
        this.updateDataOnDetailNode();
        this.resetQuickFilterAggregateText();
        const event = this.createDataChangedEvent(data, oldData, update);
        this.__localEventService?.dispatchEvent(event);
        if (this.sibling) {
            this.sibling.data = data;
            const event = this.sibling.createDataChangedEvent(data, oldData, update);
            this.sibling.__localEventService?.dispatchEvent(event);
        }
        eventSvc.dispatchEvent({ type: 'rowNodeDataChanged', node: this });
        const pinnedSibling = this.pinnedSibling;
        if (pinnedSibling) {
            pinnedSibling.data = data;
            pinnedSibling.__localEventService?.dispatchEvent(pinnedSibling.createDataChangedEvent(data, oldData, update));
            eventSvc.dispatchEvent({ type: 'rowNodeDataChanged', node: pinnedSibling });
        }
    }
    // when we are doing master / detail, the detail node is lazy created, but then kept around.
    // so if we show / hide the detail, the same detail rowNode is used. so we need to keep the data
    // in sync, otherwise expand/collapse of the detail would still show the old values.
    updateDataOnDetailNode() {
        if (this.detailNode) {
            this.detailNode.data = this.data;
        }
    }
    createDataChangedEvent(newData, oldData, update) {
        return {
            type: 'dataChanged',
            node: this,
            oldData: oldData,
            newData: newData,
            update: update,
        };
    }
    getRowIndexString() {
        if (this.rowIndex == null) {
            // Row has been removed so no index
            (0, logging_1._error)(13);
            return null;
        }
        if (this.rowPinned === 'top') {
            return exports.ROW_ID_PREFIX_TOP_PINNED + this.rowIndex;
        }
        if (this.rowPinned === 'bottom') {
            return exports.ROW_ID_PREFIX_BOTTOM_PINNED + this.rowIndex;
        }
        return this.rowIndex.toString();
    }
    setDataAndId(data, id) {
        const { selectionSvc } = this.beans;
        const oldNode = selectionSvc?.createDaemonNode?.(this);
        const oldData = this.data;
        this.data = data;
        this.updateDataOnDetailNode();
        this.setId(id);
        if (selectionSvc) {
            selectionSvc.updateRowSelectable(this);
            selectionSvc.syncInRowNode(this, oldNode);
        }
        const event = this.createDataChangedEvent(data, oldData, false);
        this.__localEventService?.dispatchEvent(event);
    }
    setId(id) {
        // see if user is providing the id's
        const getRowIdFunc = (0, gridOptionsUtils_1._getRowIdCallback)(this.beans.gos);
        if (getRowIdFunc) {
            // if user is providing the id's, then we set the id only after the data has been set.
            // this is important for virtual pagination and viewport, where empty rows exist.
            if (this.data) {
                // we pass 'true' as we skip this level when generating keys,
                // as we don't always have the key for this level (eg when updating
                // data via transaction on SSRM, we are getting key to look up the
                // RowNode, don't have the RowNode yet, thus no way to get the current key)
                const parentKeys = this.parent?.getRoute() ?? [];
                this.id = getRowIdFunc({
                    data: this.data,
                    parentKeys: parentKeys.length > 0 ? parentKeys : undefined,
                    level: this.level,
                    rowPinned: this.rowPinned,
                });
                // make sure id provided doesn't start with 'row-group-' as this is reserved.
                if (this.id.startsWith(exports.ROW_ID_PREFIX_ROW_GROUP)) {
                    (0, logging_1._error)(14, {
                        groupPrefix: exports.ROW_ID_PREFIX_ROW_GROUP,
                    });
                }
            }
            else {
                // this can happen if user has set blank into the rowNode after the row previously
                // having data. this happens in virtual page row model, when data is delete and
                // the page is refreshed.
                this.id = undefined;
            }
        }
        else {
            this.id = id;
        }
    }
    setRowTop(rowTop) {
        this.oldRowTop = this.rowTop;
        if (this.rowTop === rowTop) {
            return;
        }
        this.rowTop = rowTop;
        this.dispatchRowEvent('topChanged');
        this.setDisplayed(rowTop !== null);
    }
    clearRowTopAndRowIndex() {
        this.oldRowTop = null;
        this.setRowTop(null);
        this.setRowIndex(null);
    }
    setHovered(hovered) {
        this.hovered = hovered;
    }
    isHovered() {
        return this.hovered;
    }
    /**
     * Sets the row height.
     * Call if you want to change the height initially assigned to the row.
     * After calling, you must call `api.onRowHeightChanged()` so the grid knows it needs to work out the placement of the rows. */
    setRowHeight(rowHeight, estimated = false) {
        this.rowHeight = rowHeight;
        this.rowHeightEstimated = estimated;
        this.dispatchRowEvent('heightChanged');
    }
    setExpanded(expanded, e, forceSync) {
        this.beans.expansionSvc?.setExpanded(this, expanded, e, forceSync);
    }
    /**
     * Replaces the value on the `rowNode` for the specified column. When complete,
     * the grid refreshes the rendered cell on the required row only.
     * **Note**: This method only fires `onCellEditRequest` when the Grid is in **Read Only** mode.
     * **Note**: This method defers to EditModule if available and batches the edit when `fullRow` or `batchEdit` is enabled.
     *
     * @param colKey The column where the value should be updated
     * @param newValue The new value
     * @param eventSource The source of the event
     * @returns `true` if the value was changed, otherwise `false`.
     */
    setDataValue(colKey, newValue, eventSource) {
        const { colModel, valueSvc, gos, editSvc } = this.beans;
        // if in pivot mode, grid columns wont include primary columns
        const column = typeof colKey !== 'string' ? colKey : colModel.getCol(colKey) ?? colModel.getColDefCol(colKey);
        if (!column) {
            return false;
        }
        const oldValue = valueSvc.getValueForDisplay(column, this).value;
        if (gos.get('readOnlyEdit')) {
            const { beans: { eventSvc }, data, rowIndex, rowPinned, } = this;
            eventSvc.dispatchEvent({
                type: 'cellEditRequest',
                event: null,
                rowIndex,
                rowPinned,
                column,
                colDef: column.colDef,
                data,
                node: this,
                oldValue,
                newValue,
                value: newValue,
                source: eventSource,
            });
            return false;
        }
        if (editSvc) {
            const result = editSvc.setDataValue({ rowNode: this, column }, newValue, eventSource);
            if (result != null) {
                return result;
            }
        }
        const valueChanged = valueSvc.setValue(this, column, newValue, eventSource);
        this.dispatchCellChangedEvent(column, newValue, oldValue);
        const pinnedSibling = this.pinnedSibling;
        if (pinnedSibling) {
            // pinned sibling shares a reference to the same data object as the
            if (valueChanged) {
                pinnedSibling.dispatchCellChangedEvent(column, newValue, oldValue);
            }
        }
        return valueChanged;
    }
    updateHasChildren() {
        // in CSRM, the group property is set before the childrenAfterGroup property, check both to prevent flickering
        let newValue = (this.group && !this.footer) || (this.childrenAfterGroup && this.childrenAfterGroup.length > 0);
        const { rowChildrenSvc } = this.beans;
        if (rowChildrenSvc) {
            newValue = rowChildrenSvc.getHasChildrenValue(this);
        }
        if (newValue !== this.__hasChildren) {
            this.__hasChildren = !!newValue;
            this.dispatchRowEvent('hasChildrenChanged');
        }
    }
    hasChildren() {
        if (this.__hasChildren == null) {
            this.updateHasChildren();
        }
        return this.__hasChildren;
    }
    dispatchCellChangedEvent(column, newValue, oldValue) {
        const cellChangedEvent = {
            type: 'cellChanged',
            node: this,
            column: column,
            newValue: newValue,
            oldValue: oldValue,
        };
        this.__localEventService?.dispatchEvent(cellChangedEvent);
    }
    /**
     * The first time `quickFilter` runs, the grid creates a one-off string representation of the row.
     * This string is then used for the quick filter instead of hitting each column separately.
     * When you edit, using grid editing, this string gets cleared down.
     * However, if you edit without using grid editing, you need to clear this string down for the row to be updated with the new values.
     * Otherwise, new values would not work with the `quickFilter`. */
    resetQuickFilterAggregateText() {
        this.quickFilterAggregateText = null;
    }
    /** Returns:
     * - `true` if the node can be expanded, i.e it is a group or master row.
     * - `false` if the node cannot be expanded
     */
    isExpandable() {
        return this.beans.expansionSvc?.isExpandable(this) ?? false;
    }
    /** Returns:
     * - `true` if node is selected,
     * - `false` if the node isn't selected
     * - `undefined` if it's partially selected (group where not all children are selected). */
    isSelected() {
        // for footers, we just return what our sibling selected state is, as cannot select a footer
        if (this.footer) {
            return this.sibling.isSelected();
        }
        // similarly for manually pinned rows
        if (this.rowPinned && this.pinnedSibling) {
            return this.pinnedSibling.isSelected();
        }
        return this.__selected;
    }
    /** Perform a depth-first search of this node and its children. */
    depthFirstSearch(callback) {
        this.childrenAfterGroup?.forEach((child) => child.depthFirstSearch(callback));
        callback(this);
    }
    dispatchRowEvent(type) {
        this.__localEventService?.dispatchEvent({
            type: type,
            node: this,
        });
    }
    /**
     * Select (or deselect) the node.
     * @param newValue -`true` for selection, `false` for deselection.
     * @param clearSelection - If selecting, then passing `true` selects the node exclusively (i.e. NOT do multi select). If doing deselection, `clearSelection` has no impact.
     * @param source - Source property that appears in the `selectionChanged` event.
     */
    setSelected(newValue, clearSelection = false, source = 'api') {
        this.beans.selectionSvc?.setNodesSelected({
            nodes: [this],
            newValue,
            clearSelection,
            source,
        });
    }
    /**
     * Returns:
     * - `true` if node is either pinned to the `top` or `bottom`
     * - `false` if the node isn't pinned
     */
    isRowPinned() {
        return !!this.rowPinned;
    }
    __addEventListener(eventType, listener) {
        if (!this.__localEventService) {
            this.__localEventService = new localEventService_1.LocalEventService();
        }
        this.__localEventService.addEventListener(eventType, listener);
    }
    __removeEventListener(eventType, listener) {
        this.removeLocalListener(eventType, listener);
    }
    /**
     * PUBLIC USE ONLY: for internal use within AG Grid use the `__addEventListener` and `__removeEventListener` methods.
     */
    addEventListener(eventType, userListener) {
        this.beans.validation?.checkRowEvents(eventType);
        if (!this.__localEventService) {
            this.__localEventService = new localEventService_1.LocalEventService();
        }
        this.frameworkEventListenerService = this.beans.frameworkOverrides.createLocalEventListenerWrapper?.(this.frameworkEventListenerService, this.__localEventService);
        const listener = this.frameworkEventListenerService?.wrap(eventType, userListener) ?? userListener;
        this.__localEventService.addEventListener(eventType, listener);
    }
    /**
     * PUBLIC USE ONLY: for internal use within AG Grid use the `__addEventListener` and `__removeEventListener` methods.
     */
    removeEventListener(eventType, userListener) {
        const listener = this.frameworkEventListenerService?.unwrap(eventType, userListener) ?? userListener;
        this.removeLocalListener(eventType, listener);
    }
    removeLocalListener(eventType, listener) {
        this.__localEventService?.removeEventListener(eventType, listener);
        if (this.__localEventService?.noRegisteredListenersExist()) {
            this.__localEventService = null;
        }
    }
    /**
     * @deprecated v32.2.0 Check `node.detail` then user provided callback `isFullWidthRow` instead.
     *
     * Returns:
     * - `true` if the node is a full width cell
     * - `false` if the node is not a full width cell
     */
    isFullWidthCell() {
        // log deprecation
        (0, logging_1._warn)(61);
        if (this.detail) {
            return true;
        }
        const isFullWidthCellFunc = this.beans.gos.getCallback('isFullWidthRow');
        return isFullWidthCellFunc ? isFullWidthCellFunc({ rowNode: this }) : false;
    }
    /**
     * Returns the route of keys to the row node. Returns undefined if the node has no key.
     */
    getRoute() {
        // root node is still a valid route
        if (this.level === -1) {
            return [];
        }
        if (this.key == null) {
            return undefined;
        }
        const res = [];
        let pointer = this;
        while (pointer && pointer.key != null) {
            res.push(pointer.key);
            pointer = pointer.parent;
        }
        return res.reverse();
    }
    setFirstChild(firstChild) {
        if (this.firstChild !== firstChild) {
            this.firstChild = firstChild;
            this.dispatchRowEvent('firstChildChanged');
        }
    }
    setDisplayed(displayed) {
        if (this.displayed !== displayed) {
            this.displayed = displayed;
            this.dispatchRowEvent('displayedChanged');
        }
    }
    setRowIndex(rowIndex) {
        if (this.rowIndex !== rowIndex) {
            this.rowIndex = rowIndex;
            this.dispatchRowEvent('rowIndexChanged');
        }
    }
    setAllChildrenCount(allChildrenCount) {
        if (this.allChildrenCount !== allChildrenCount) {
            this.allChildrenCount = allChildrenCount;
            this.dispatchRowEvent('allChildrenCountChanged');
        }
    }
    setUiLevel(uiLevel) {
        if (this.uiLevel !== uiLevel) {
            this.uiLevel = uiLevel;
            this.dispatchRowEvent('uiLevelChanged');
        }
    }
    getFirstChild() {
        if (this.childStore) {
            return this.childStore.getFirstNode();
        }
        return this.childrenAfterSort?.[0] ?? null;
    }
}
exports.RowNode = RowNode;


/***/ }),

/***/ 9888:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._createRowNodeSibling = exports._createGlobalRowEvent = void 0;
const gridOptionsUtils_1 = __webpack_require__(67274);
const rowNode_1 = __webpack_require__(3373);
function _createGlobalRowEvent(rowNode, gos, type) {
    return (0, gridOptionsUtils_1._addGridCommonParams)(gos, {
        type,
        node: rowNode,
        data: rowNode.data,
        rowIndex: rowNode.rowIndex,
        rowPinned: rowNode.rowPinned,
    });
}
exports._createGlobalRowEvent = _createGlobalRowEvent;
/**
 * When creating sibling nodes (e.g. footers), we don't copy these properties as they
 * cause the sibling to have properties which should be unique to the row.
 *
 * Note that `keyof T` does not include private members of `T`, so these need to be
 * added explicitly to this list. Take care when adding or renaming private properties
 * of `RowNode`.
 */
const IGNORED_SIBLING_PROPERTIES = new Set(['__localEventService', '__objectId', 'sticky', '__autoHeights', '__checkAutoHeightsDebounced', 'childStore']);
function _createRowNodeSibling(rowNode, beans) {
    const sibling = new rowNode_1.RowNode(beans);
    Object.keys(rowNode).forEach((key) => {
        if (IGNORED_SIBLING_PROPERTIES.has(key)) {
            return;
        }
        sibling[key] = rowNode[key];
    });
    // manually set oldRowTop to null so we discard any
    // previous information about its position.
    sibling.oldRowTop = null;
    return sibling;
}
exports._createRowNodeSibling = _createRowNodeSibling;


/***/ }),

/***/ 89024:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Environment = void 0;
const beanStub_1 = __webpack_require__(68731);
const Theme_1 = __webpack_require__(39621);
const inject_1 = __webpack_require__(68951);
const themes_1 = __webpack_require__(2525);
const dom_1 = __webpack_require__(33507);
const logging_1 = __webpack_require__(47764);
const CELL_HORIZONTAL_PADDING = {
    cssName: '--ag-cell-horizontal-padding',
    changeKey: 'cellHorizontalPaddingChanged',
    defaultValue: 16,
};
const INDENTATION_LEVEL = {
    cssName: '--ag-indentation-level',
    changeKey: 'indentationLevelChanged',
    defaultValue: 0,
    noWarn: true,
    cacheDefault: true,
};
const ROW_GROUP_INDENT_SIZE = {
    cssName: '--ag-row-group-indent-size',
    changeKey: 'rowGroupIndentSizeChanged',
    defaultValue: 0,
};
const ROW_HEIGHT = {
    cssName: '--ag-row-height',
    changeKey: 'rowHeightChanged',
    defaultValue: 42,
};
const HEADER_HEIGHT = {
    cssName: '--ag-header-height',
    changeKey: 'headerHeightChanged',
    defaultValue: 48,
};
const LIST_ITEM_HEIGHT = {
    cssName: '--ag-list-item-height',
    changeKey: 'listItemHeightChanged',
    defaultValue: 24,
};
const ROW_BORDER_WIDTH = {
    cssName: '--ag-row-border',
    changeKey: 'rowBorderWidthChanged',
    defaultValue: 1,
    border: true,
};
const PINNED_BORDER_WIDTH = {
    cssName: '--ag-pinned-row-border',
    changeKey: 'pinnedRowBorderWidthChanged',
    defaultValue: 1,
    border: true,
};
let paramsId = 0;
class Environment extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'environment';
        this.sizeEls = new Map();
        this.lastKnownValues = new Map();
        this.sizesMeasured = false;
        this.paramsClass = `ag-theme-params-${++paramsId}`;
        this.globalCSS = [];
    }
    wireBeans(beans) {
        const { eGridDiv, gridOptions } = beans;
        this.eGridDiv = eGridDiv;
        // NOTE: need to use beans.gridOptions because beans.gos not yet initialised
        this.eStyleContainer =
            gridOptions.themeStyleContainer ?? (eGridDiv.getRootNode() === document ? document.head : eGridDiv);
        this.cssLayer = gridOptions.themeCssLayer;
        this.styleNonce = gridOptions.styleNonce;
    }
    postConstruct() {
        this.addManagedPropertyListener('theme', () => this.handleThemeGridOptionChange());
        this.handleThemeGridOptionChange();
        this.addManagedPropertyListener('rowHeight', () => this.refreshRowHeightVariable());
        this.getSizeEl(ROW_HEIGHT);
        this.getSizeEl(HEADER_HEIGHT);
        this.getSizeEl(LIST_ITEM_HEIGHT);
        this.getSizeEl(ROW_BORDER_WIDTH);
        this.getSizeEl(PINNED_BORDER_WIDTH);
        this.refreshRowBorderWidthVariable();
        this.addDestroyFunc(() => (0, inject_1._unregisterGridUsingThemingAPI)(this));
        this.mutationObserver = new MutationObserver(() => {
            this.fireGridStylesChangedEvent('themeChanged');
        });
        this.addDestroyFunc(() => this.mutationObserver.disconnect());
    }
    getPinnedRowBorderWidth() {
        return this.getCSSVariablePixelValue(PINNED_BORDER_WIDTH);
    }
    getRowBorderWidth() {
        return this.getCSSVariablePixelValue(ROW_BORDER_WIDTH);
    }
    getDefaultRowHeight() {
        return this.getCSSVariablePixelValue(ROW_HEIGHT);
    }
    getDefaultHeaderHeight() {
        return this.getCSSVariablePixelValue(HEADER_HEIGHT);
    }
    getDefaultCellHorizontalPadding() {
        return this.getCSSVariablePixelValue(CELL_HORIZONTAL_PADDING);
    }
    getCellPaddingLeft() {
        // calc(var(--ag-cell-horizontal-padding) - 1px + var(--ag-row-group-indent-size)*var(--ag-indentation-level))
        const cellHorizontalPadding = this.getDefaultCellHorizontalPadding();
        const indentationLevel = this.getCSSVariablePixelValue(INDENTATION_LEVEL);
        const rowGroupIndentSize = this.getCSSVariablePixelValue(ROW_GROUP_INDENT_SIZE);
        return cellHorizontalPadding - 1 + rowGroupIndentSize * indentationLevel;
    }
    getCellPadding() {
        const cellPaddingRight = this.getDefaultCellHorizontalPadding() - 1;
        return this.getCellPaddingLeft() + cellPaddingRight;
    }
    getDefaultColumnMinWidth() {
        // This replaces a table of hard-coded defaults for each theme, and is a
        // reasonable default that somewhat approximates the old table. This
        // value only needs to be a non-insane default - Applications are
        // expected to set column-specific defaults based on the icons and
        // header cell text they need to display
        return Math.min(36, this.getDefaultRowHeight());
    }
    getDefaultListItemHeight() {
        return this.getCSSVariablePixelValue(LIST_ITEM_HEIGHT);
    }
    applyThemeClasses(el) {
        const { gridTheme } = this;
        let themeClass = '';
        if (gridTheme) {
            // Theming API mode
            themeClass = `${this.paramsClass} ${gridTheme._getCssClass()}`;
        }
        else {
            // legacy mode
            this.mutationObserver.disconnect();
            let node = this.eGridDiv;
            while (node) {
                let isThemeEl = false;
                for (const className of Array.from(node.classList)) {
                    if (className.startsWith('ag-theme-')) {
                        isThemeEl = true;
                        themeClass = themeClass ? `${themeClass} ${className}` : className;
                    }
                }
                if (isThemeEl) {
                    this.mutationObserver.observe(node, {
                        attributes: true,
                        attributeFilter: ['class'],
                    });
                }
                node = node.parentElement;
            }
        }
        for (const className of Array.from(el.classList)) {
            if (className.startsWith('ag-theme-')) {
                el.classList.remove(className);
            }
        }
        if (themeClass) {
            const oldClass = el.className;
            el.className = oldClass + (oldClass ? ' ' : '') + themeClass;
        }
    }
    refreshRowHeightVariable() {
        const { eGridDiv } = this;
        const oldRowHeight = eGridDiv.style.getPropertyValue('--ag-line-height').trim();
        const height = this.gos.get('rowHeight');
        if (height == null || isNaN(height) || !isFinite(height)) {
            if (oldRowHeight !== null) {
                eGridDiv.style.setProperty('--ag-line-height', null);
            }
            return -1;
        }
        const newRowHeight = `${height}px`;
        if (oldRowHeight != newRowHeight) {
            eGridDiv.style.setProperty('--ag-line-height', newRowHeight);
            return height;
        }
        return oldRowHeight != '' ? parseFloat(oldRowHeight) : -1;
    }
    addGlobalCSS(css, debugId) {
        if (this.gridTheme) {
            (0, inject_1._injectGlobalCSS)(css, this.eStyleContainer, debugId, this.cssLayer, 0, this.styleNonce);
        }
        else {
            this.globalCSS.push([css, debugId]);
        }
    }
    getCSSVariablePixelValue(variable) {
        const cached = this.lastKnownValues.get(variable);
        if (cached != null) {
            return cached;
        }
        const measurement = this.measureSizeEl(variable);
        if (measurement === 'detached' || measurement === 'no-styles') {
            if (variable.cacheDefault) {
                this.lastKnownValues.set(variable, variable.defaultValue);
            }
            return variable.defaultValue;
        }
        this.lastKnownValues.set(variable, measurement);
        return measurement;
    }
    measureSizeEl(variable) {
        const sizeEl = this.getSizeEl(variable);
        if (sizeEl.offsetParent == null) {
            return 'detached';
        }
        const newSize = sizeEl.offsetWidth;
        if (newSize === NO_VALUE_SENTINEL)
            return 'no-styles';
        this.sizesMeasured = true;
        return newSize;
    }
    getMeasurementContainer() {
        let container = this.eMeasurementContainer;
        if (!container) {
            container = this.eMeasurementContainer = (0, dom_1._createElement)({ tag: 'div', cls: 'ag-measurement-container' });
            this.eGridDiv.appendChild(container);
        }
        return container;
    }
    getSizeEl(variable) {
        let sizeEl = this.sizeEls.get(variable);
        if (sizeEl) {
            return sizeEl;
        }
        const container = this.getMeasurementContainer();
        sizeEl = (0, dom_1._createElement)({ tag: 'div' });
        const { border, noWarn } = variable;
        if (border) {
            sizeEl.className = 'ag-measurement-element-border';
            sizeEl.style.setProperty('--ag-internal-measurement-border', `var(${variable.cssName}, solid ${NO_VALUE_SENTINEL}px)`);
        }
        else {
            sizeEl.style.width = `var(${variable.cssName}, ${NO_VALUE_SENTINEL}px)`;
        }
        container.appendChild(sizeEl);
        this.sizeEls.set(variable, sizeEl);
        let lastMeasurement = this.measureSizeEl(variable);
        if (lastMeasurement === 'no-styles' && !noWarn) {
            // No value for the variable
            (0, logging_1._warn)(9, { variable });
        }
        const unsubscribe = (0, dom_1._observeResize)(this.beans, sizeEl, () => {
            const newMeasurement = this.measureSizeEl(variable);
            if (newMeasurement === 'detached' || newMeasurement === 'no-styles') {
                return;
            }
            this.lastKnownValues.set(variable, newMeasurement);
            if (newMeasurement !== lastMeasurement) {
                lastMeasurement = newMeasurement;
                this.fireGridStylesChangedEvent(variable.changeKey);
            }
        });
        this.addDestroyFunc(() => unsubscribe());
        return sizeEl;
    }
    fireGridStylesChangedEvent(change) {
        if (change === 'rowBorderWidthChanged') {
            this.refreshRowBorderWidthVariable();
        }
        this.eventSvc.dispatchEvent({
            type: 'gridStylesChanged',
            [change]: true,
        });
    }
    refreshRowBorderWidthVariable() {
        const width = this.getCSSVariablePixelValue(ROW_BORDER_WIDTH);
        this.eGridDiv.style.setProperty('--ag-internal-row-border-width', `${width}px`);
    }
    handleThemeGridOptionChange() {
        const { gos, eGridDiv, globalCSS, gridTheme: oldGridTheme } = this;
        const themeGridOption = gos.get('theme');
        let newGridTheme;
        if (themeGridOption === 'legacy') {
            newGridTheme = undefined;
        }
        else {
            const themeOrDefault = themeGridOption ?? themes_1.themeQuartz;
            if (themeOrDefault instanceof Theme_1.ThemeImpl) {
                newGridTheme = themeOrDefault;
            }
            else {
                (0, logging_1._error)(240, { theme: themeOrDefault });
            }
        }
        if (newGridTheme !== oldGridTheme) {
            if (newGridTheme) {
                (0, inject_1._registerGridUsingThemingAPI)(this);
                (0, inject_1._injectCoreAndModuleCSS)(this.eStyleContainer, this.cssLayer, this.styleNonce);
                for (const [css, debugId] of globalCSS) {
                    (0, inject_1._injectGlobalCSS)(css, this.eStyleContainer, debugId, this.cssLayer, 0, this.styleNonce);
                }
                globalCSS.length = 0;
            }
            this.gridTheme = newGridTheme;
            newGridTheme?._startUse({
                loadThemeGoogleFonts: gos.get('loadThemeGoogleFonts'),
                styleContainer: this.eStyleContainer,
                cssLayer: this.cssLayer,
                nonce: this.styleNonce,
            });
            let eParamsStyle = this.eParamsStyle;
            if (!eParamsStyle) {
                eParamsStyle = this.eParamsStyle = (0, dom_1._createElement)({ tag: 'style' });
                const styleNonce = this.gos.get('styleNonce');
                if (styleNonce) {
                    eParamsStyle.setAttribute('nonce', styleNonce);
                }
                eGridDiv.appendChild(eParamsStyle);
            }
            if (!inject_1.IS_SSR) {
                eParamsStyle.textContent = newGridTheme?._getPerGridCss(this.paramsClass) || '';
            }
            this.applyThemeClasses(eGridDiv);
            this.fireGridStylesChangedEvent('themeChanged');
        }
        // --ag-legacy-styles-loaded is defined on .ag-measurement-container by the
        // legacy themes which shouldn't be used at the same time as Theming API
        if (newGridTheme &&
            getComputedStyle(this.getMeasurementContainer()).getPropertyValue('--ag-legacy-styles-loaded')) {
            if (themeGridOption) {
                (0, logging_1._error)(106);
            }
            else {
                (0, logging_1._error)(239);
            }
        }
    }
}
exports.Environment = Environment;
const NO_VALUE_SENTINEL = 15538;


/***/ }),

/***/ 8778:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventService = void 0;
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const localEventService_1 = __webpack_require__(85889);
class EventService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'eventSvc';
        this.globalSvc = new localEventService_1.LocalEventService();
    }
    postConstruct() {
        const { globalListener, globalSyncListener } = this.beans;
        if (globalListener) {
            this.addGlobalListener(globalListener, true);
        }
        if (globalSyncListener) {
            this.addGlobalListener(globalSyncListener, false);
        }
    }
    addEventListener(eventType, listener, async) {
        this.globalSvc.addEventListener(eventType, listener, async);
    }
    removeEventListener(eventType, listener, async) {
        this.globalSvc.removeEventListener(eventType, listener, async);
    }
    addGlobalListener(listener, async = false) {
        this.globalSvc.addGlobalListener(listener, async);
    }
    removeGlobalListener(listener, async = false) {
        this.globalSvc.removeGlobalListener(listener, async);
    }
    /** @deprecated DO NOT FIRE LOCAL EVENTS OFF THE EVENT SERVICE */
    dispatchLocalEvent() {
        // only the destroy event from BeanStub should flow through here
    }
    dispatchEvent(event) {
        this.globalSvc.dispatchEvent((0, gridOptionsUtils_1._addGridCommonParams)(this.gos, event));
    }
    dispatchEventOnce(event) {
        this.globalSvc.dispatchEventOnce((0, gridOptionsUtils_1._addGridCommonParams)(this.gos, event));
    }
}
exports.EventService = EventService;


/***/ }),

/***/ 73080:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._GET_ALL_EVENTS = exports._INTERNAL_EVENTS = exports._PUBLIC_EVENTS = void 0;
// events that are available for use by users of AG Grid and so should be documented
/** EVENTS that should be exposed via code generation for the framework components.  */
exports._PUBLIC_EVENTS = [
    'columnEverythingChanged',
    'newColumnsLoaded',
    'columnPivotModeChanged',
    'pivotMaxColumnsExceeded',
    'columnRowGroupChanged',
    'expandOrCollapseAll',
    'columnPivotChanged',
    'gridColumnsChanged',
    'columnValueChanged',
    'columnMoved',
    'columnVisible',
    'columnPinned',
    'columnGroupOpened',
    'columnResized',
    'displayedColumnsChanged',
    'virtualColumnsChanged',
    'columnHeaderMouseOver',
    'columnHeaderMouseLeave',
    'columnHeaderClicked',
    'columnHeaderContextMenu',
    'asyncTransactionsFlushed',
    'rowGroupOpened',
    'rowDataUpdated',
    'pinnedRowDataChanged',
    'pinnedRowsChanged',
    'rangeSelectionChanged',
    'cellSelectionChanged',
    'chartCreated',
    'chartRangeSelectionChanged',
    'chartOptionsChanged',
    'chartDestroyed',
    'toolPanelVisibleChanged',
    'toolPanelSizeChanged',
    'modelUpdated',
    'cutStart',
    'cutEnd',
    'pasteStart',
    'pasteEnd',
    'fillStart',
    'fillEnd',
    'cellSelectionDeleteStart',
    'cellSelectionDeleteEnd',
    'rangeDeleteStart',
    'rangeDeleteEnd',
    'undoStarted',
    'undoEnded',
    'redoStarted',
    'redoEnded',
    'cellClicked',
    'cellDoubleClicked',
    'cellMouseDown',
    'cellContextMenu',
    'cellValueChanged',
    'cellEditRequest',
    'rowValueChanged',
    'headerFocused',
    'cellFocused',
    'rowSelected',
    'selectionChanged',
    'tooltipShow',
    'tooltipHide',
    'cellKeyDown',
    'cellMouseOver',
    'cellMouseOut',
    'filterChanged',
    'filterModified',
    'filterUiChanged',
    'filterOpened',
    'floatingFilterUiChanged',
    'advancedFilterBuilderVisibleChanged',
    'sortChanged',
    'virtualRowRemoved',
    'rowClicked',
    'rowDoubleClicked',
    'gridReady',
    'gridPreDestroyed',
    'gridSizeChanged',
    'viewportChanged',
    'firstDataRendered',
    'dragStarted',
    'dragStopped',
    'dragCancelled',
    'rowEditingStarted',
    'rowEditingStopped',
    'cellEditingStarted',
    'cellEditingStopped',
    'bodyScroll',
    'bodyScrollEnd',
    'paginationChanged',
    'componentStateChanged',
    'storeRefreshed',
    'stateUpdated',
    'columnMenuVisibleChanged',
    'contextMenuVisibleChanged',
    'rowDragEnter',
    'rowDragMove',
    'rowDragLeave',
    'rowDragEnd',
    'rowDragCancel',
    'findChanged',
    'rowResizeStarted',
    'rowResizeEnded',
    'columnsReset',
];
// events that are internal to AG Grid and should not be exposed to users via documentation or generated framework components
// These events are still available to users via the API if the eventName is cast to any to stop Typescript from complaining, but they are not intended for general use
/** Exclude the following internal events from code generation to prevent exposing these events via framework components */
exports._INTERNAL_EVENTS = [
    'scrollbarWidthChanged',
    'keyShortcutChangedCellStart',
    'keyShortcutChangedCellEnd',
    'pinnedHeightChanged',
    'cellFocusCleared',
    'fullWidthRowFocused',
    'checkboxChanged',
    'heightScaleChanged',
    'suppressMovableColumns',
    'suppressMenuHide',
    'suppressFieldDotNotation',
    'columnPanelItemDragStart',
    'columnPanelItemDragEnd',
    'bodyHeightChanged',
    'columnContainerWidthChanged',
    'displayedColumnsWidthChanged',
    'scrollVisibilityChanged',
    'scrollGapChanged',
    'columnHoverChanged',
    'flashCells',
    'paginationPixelOffsetChanged',
    'displayedRowsChanged',
    'leftPinnedWidthChanged',
    'rightPinnedWidthChanged',
    'rowContainerHeightChanged',
    'headerHeightChanged',
    'columnGroupHeaderHeightChanged',
    'columnHeaderHeightChanged',
    'gridStylesChanged',
    'storeUpdated',
    'filterDestroyed',
    'rowDataUpdateStarted',
    'rowCountReady',
    'advancedFilterEnabledChanged',
    'dataTypesInferred',
    'fieldValueChanged',
    'fieldPickerValueSelected',
    'richSelectListRowSelected',
    'sideBarUpdated',
    'alignedGridScroll',
    'alignedGridColumn',
    'gridOptionsChanged',
    'chartTitleEdit',
    'recalculateRowBounds',
    'stickyTopOffsetChanged',
    'overlayExclusiveChanged',
    'beforeRefreshModel',
    'rowNodeDataChanged',
    'cellEditValuesChanged',
    'filterSwitched',
    'batchEditingStarted',
    'batchEditingStopped',
    'filterClosed',
];
// We define as a callback to help with tree shaking (esbuild)
const _GET_ALL_EVENTS = () => [...exports._PUBLIC_EVENTS, ...exports._INTERNAL_EVENTS];
exports._GET_ALL_EVENTS = _GET_ALL_EVENTS;


/***/ }),

/***/ 57968:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ALWAYS_SYNC_GLOBAL_EVENTS = void 0;
exports.ALWAYS_SYNC_GLOBAL_EVENTS = new Set(['gridPreDestroyed', 'fillStart', 'pasteStart']);


/***/ }),

/***/ 47331:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseCreator = void 0;
const beanStub_1 = __webpack_require__(68731);
class BaseCreator extends beanStub_1.BeanStub {
    getFileName(fileName) {
        const extension = this.getDefaultFileExtension();
        if (fileName == null || !fileName.length) {
            fileName = this.getDefaultFileName();
        }
        return fileName.indexOf('.') === -1 ? `${fileName}.${extension}` : fileName;
    }
    getData(params) {
        const serializingSession = this.createSerializingSession(params);
        return this.beans.gridSerializer.serialize(serializingSession, params);
    }
    getDefaultFileName() {
        return `export.${this.getDefaultFileExtension()}`;
    }
}
exports.BaseCreator = BaseCreator;


/***/ }),

/***/ 68376:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseGridSerializingSession = void 0;
const gridOptionsUtils_1 = __webpack_require__(67274);
class BaseGridSerializingSession {
    constructor(config) {
        const { colModel, rowGroupColsSvc, colNames, valueSvc, gos, processCellCallback, processHeaderCallback, processGroupHeaderCallback, processRowGroupCallback, } = config;
        this.colModel = colModel;
        this.rowGroupColsSvc = rowGroupColsSvc;
        this.colNames = colNames;
        this.valueSvc = valueSvc;
        this.gos = gos;
        this.processCellCallback = processCellCallback;
        this.processHeaderCallback = processHeaderCallback;
        this.processGroupHeaderCallback = processGroupHeaderCallback;
        this.processRowGroupCallback = processRowGroupCallback;
    }
    prepare(_columnsToExport) { }
    extractHeaderValue(column) {
        const value = this.getHeaderName(this.processHeaderCallback, column);
        return value ?? '';
    }
    extractRowCellValue(column, currentColumnIndex, accumulatedRowIndex, type, node) {
        if (this.processRowGroupCallback &&
            (this.gos.get('treeData') || node.group) &&
            column.isRowGroupDisplayed(node.rowGroupColumn?.getColId() ?? '')) {
            return { value: this.processRowGroupCallback((0, gridOptionsUtils_1._addGridCommonParams)(this.gos, { column, node })) ?? '' };
        }
        if (this.processCellCallback) {
            return {
                value: this.processCellCallback((0, gridOptionsUtils_1._addGridCommonParams)(this.gos, {
                    accumulatedRowIndex,
                    column,
                    node,
                    value: this.valueSvc.getValueForDisplay(column, node, undefined, undefined).value,
                    type,
                    parseValue: (valueToParse) => this.valueSvc.parseValue(column, node, valueToParse, this.valueSvc.getValue(column, node, undefined)),
                    formatValue: (valueToFormat) => this.valueSvc.formatValue(column, node, valueToFormat) ?? valueToFormat,
                })) ?? '',
            };
        }
        const isTreeData = this.gos.get('treeData');
        const valueService = this.valueSvc;
        const isGrandTotalRow = node.level === -1 && node.footer;
        const isFullWidthGroup = currentColumnIndex === 0 && (0, gridOptionsUtils_1._isFullWidthGroupRow)(this.gos, node, this.colModel.isPivotMode());
        const isMultiAutoCol = column.colDef.showRowGroup === true && (node.group || isTreeData);
        // when using single auto group column or group row, create arrow separated string of group vals
        if (!isGrandTotalRow && (isFullWidthGroup || isMultiAutoCol)) {
            let concatenatedGroupValue = '';
            let pointer = node;
            while (pointer && pointer.level !== -1) {
                const { value, valueFormatted } = valueService.getValueForDisplay(isFullWidthGroup ? undefined : column, // full width group doesn't have a column
                pointer, true, true);
                concatenatedGroupValue = ` -> ${valueFormatted ?? value ?? ''}${concatenatedGroupValue}`;
                pointer = pointer.parent;
            }
            return {
                value: concatenatedGroupValue,
                valueFormatted: concatenatedGroupValue,
            };
        }
        const { value, valueFormatted } = valueService.getValueForDisplay(column, node, true, true);
        return {
            value: value ?? '',
            valueFormatted,
        };
    }
    getHeaderName(callback, column) {
        if (callback) {
            return callback((0, gridOptionsUtils_1._addGridCommonParams)(this.gos, { column }));
        }
        return this.colNames.getDisplayNameForColumn(column, 'csv', true);
    }
}
exports.BaseGridSerializingSession = BaseGridSerializingSession;


/***/ }),

/***/ 3885:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._downloadFile = void 0;
const logging_1 = __webpack_require__(47764);
function _downloadFile(fileName, content) {
    const win = document.defaultView || window;
    if (!win) {
        (0, logging_1._warn)(52);
        return;
    }
    const element = document.createElement('a');
    const url = win.URL.createObjectURL(content);
    element.setAttribute('href', url);
    element.setAttribute('download', fileName);
    element.style.display = 'none';
    document.body.appendChild(element);
    element.dispatchEvent(new MouseEvent('click', {
        bubbles: false,
        cancelable: true,
        view: win,
    }));
    document.body.removeChild(element);
    win.setTimeout(() => {
        win.URL.revokeObjectURL(url);
    }, 0);
}
exports._downloadFile = _downloadFile;


/***/ }),

/***/ 92728:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SharedExportModule = void 0;
const version_1 = __webpack_require__(97205);
const gridSerializer_1 = __webpack_require__(90826);
// Shared CSV and Excel logic
/**
 * @internal
 */
exports.SharedExportModule = {
    moduleName: 'SharedExport',
    version: version_1.VERSION,
    beans: [gridSerializer_1.GridSerializer],
};


/***/ }),

/***/ 90826:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GridSerializer = void 0;
const columnUtils_1 = __webpack_require__(73146);
const groupInstanceIdCreator_1 = __webpack_require__(96034);
const beanStub_1 = __webpack_require__(68731);
const agColumnGroup_1 = __webpack_require__(56908);
const gridOptionsUtils_1 = __webpack_require__(67274);
const array_1 = __webpack_require__(31502);
class GridSerializer extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'gridSerializer';
    }
    wireBeans(beans) {
        this.visibleCols = beans.visibleCols;
        this.colModel = beans.colModel;
        this.rowModel = beans.rowModel;
        this.pinnedRowModel = beans.pinnedRowModel;
    }
    serialize(gridSerializingSession, params = {}) {
        const { allColumns, columnKeys, skipRowGroups, exportRowNumbers } = params;
        const columnsToExport = this.getColumnsToExport({
            allColumns,
            skipRowGroups,
            columnKeys: columnKeys,
            exportRowNumbers,
        });
        return [
            // first pass, put in the header names of the cols
            this.prepareSession(columnsToExport),
            this.prependContent(params),
            this.exportColumnGroups(params, columnsToExport),
            this.exportHeaders(params, columnsToExport),
            this.processPinnedTopRows(params, columnsToExport),
            this.processRows(params, columnsToExport),
            this.processPinnedBottomRows(params, columnsToExport),
            this.appendContent(params),
        ]
            .reduce((composed, f) => f(composed), gridSerializingSession)
            .parse();
    }
    processRow(gridSerializingSession, params, columnsToExport, node) {
        const rowSkipper = params.shouldRowBeSkipped || (() => false);
        // if onlySelected, we ignore groupHideOpenParents as the user has explicitly selected the rows they wish to export.
        // similarly, if specific rowNodes are provided we do the same. (the clipboard service uses rowNodes to define which rows to export)
        const isClipboardExport = params.rowPositions != null;
        const isExplicitExportSelection = isClipboardExport || !!params.onlySelected;
        const hideOpenParents = this.gos.get('groupHideOpenParents') && !isExplicitExportSelection;
        const isLeafNode = this.colModel.isPivotMode() ? node.leafGroup : !node.group;
        const isFooter = !!node.footer;
        const shouldSkipCurrentGroup = node.allChildrenCount === 1 &&
            node.childrenAfterGroup?.length === 1 &&
            (0, gridOptionsUtils_1._canSkipShowingRowGroup)(this.gos, node);
        if ((!isLeafNode && !isFooter && (params.skipRowGroups || shouldSkipCurrentGroup || hideOpenParents)) ||
            (params.onlySelected && !node.isSelected()) ||
            (params.skipPinnedTop && node.rowPinned === 'top') ||
            (params.skipPinnedBottom && node.rowPinned === 'bottom') ||
            node.stub // skip SSRM stub/loading rows
        ) {
            return;
        }
        // if we are in pivotMode, then the grid will show the root node only
        // if it's not a leaf group
        const nodeIsRootNode = node.level === -1;
        if (nodeIsRootNode && !isLeafNode && !isFooter) {
            return;
        }
        const shouldRowBeSkipped = rowSkipper((0, gridOptionsUtils_1._addGridCommonParams)(this.gos, { node }));
        if (shouldRowBeSkipped) {
            return;
        }
        const rowAccumulator = gridSerializingSession.onNewBodyRow(node);
        columnsToExport.forEach((column, index) => {
            rowAccumulator.onColumn(column, index, node);
        });
        if (params.getCustomContentBelowRow) {
            const content = params.getCustomContentBelowRow((0, gridOptionsUtils_1._addGridCommonParams)(this.gos, { node }));
            if (content) {
                gridSerializingSession.addCustomContent(content);
            }
        }
    }
    appendContent(params) {
        return (gridSerializingSession) => {
            const appendContent = params.appendContent;
            if (appendContent) {
                gridSerializingSession.addCustomContent(appendContent);
            }
            return gridSerializingSession;
        };
    }
    prependContent(params) {
        return (gridSerializingSession) => {
            const prependContent = params.prependContent;
            if (prependContent) {
                gridSerializingSession.addCustomContent(prependContent);
            }
            return gridSerializingSession;
        };
    }
    prepareSession(columnsToExport) {
        return (gridSerializingSession) => {
            gridSerializingSession.prepare(columnsToExport);
            return gridSerializingSession;
        };
    }
    exportColumnGroups(params, columnsToExport) {
        return (gridSerializingSession) => {
            if (!params.skipColumnGroupHeaders) {
                const idCreator = new groupInstanceIdCreator_1.GroupInstanceIdCreator();
                const { colGroupSvc } = this.beans;
                const displayedGroups = colGroupSvc
                    ? colGroupSvc.createColumnGroups({
                        columns: columnsToExport,
                        idCreator,
                        pinned: null,
                        isStandaloneStructure: true,
                    })
                    : columnsToExport;
                this.recursivelyAddHeaderGroups(displayedGroups, gridSerializingSession, params.processGroupHeaderCallback);
            }
            return gridSerializingSession;
        };
    }
    exportHeaders(params, columnsToExport) {
        return (gridSerializingSession) => {
            if (!params.skipColumnHeaders) {
                const gridRowIterator = gridSerializingSession.onNewHeaderRow();
                columnsToExport.forEach((column, index) => {
                    gridRowIterator.onColumn(column, index, undefined);
                });
            }
            return gridSerializingSession;
        };
    }
    processPinnedTopRows(params, columnsToExport) {
        return (gridSerializingSession) => {
            const processRow = this.processRow.bind(this, gridSerializingSession, params, columnsToExport);
            if (params.rowPositions) {
                params.rowPositions
                    // only pinnedTop rows, other models are processed by `processRows` and `processPinnedBottomsRows`
                    .filter((position) => position.rowPinned === 'top')
                    .sort((a, b) => a.rowIndex - b.rowIndex)
                    .map((position) => this.pinnedRowModel?.getPinnedTopRow(position.rowIndex))
                    .forEach(processRow);
            }
            else if (!this.pinnedRowModel?.isManual()) {
                // only process pinned rows if they are statically pinned
                this.pinnedRowModel?.forEachPinnedRow('top', processRow);
            }
            return gridSerializingSession;
        };
    }
    processRows(params, columnsToExport) {
        return (gridSerializingSession) => {
            // when in pivot mode, we always render cols on screen, never 'all columns'
            const rowModel = this.rowModel;
            const usingCsrm = (0, gridOptionsUtils_1._isClientSideRowModel)(this.gos, rowModel);
            const usingSsrm = (0, gridOptionsUtils_1._isServerSideRowModel)(this.gos, rowModel);
            const onlySelectedNonStandardModel = !usingCsrm && params.onlySelected;
            const processRow = this.processRow.bind(this, gridSerializingSession, params, columnsToExport);
            const { exportedRows = 'filteredAndSorted' } = params;
            if (params.rowPositions) {
                params.rowPositions
                    // pinnedRows are processed by `processPinnedTopRows` and `processPinnedBottomsRows`
                    .filter((position) => position.rowPinned == null)
                    .sort((a, b) => a.rowIndex - b.rowIndex)
                    .map((position) => rowModel.getRow(position.rowIndex))
                    .forEach(processRow);
                return gridSerializingSession;
            }
            if (this.colModel.isPivotMode()) {
                if (usingCsrm) {
                    rowModel.forEachPivotNode(processRow, true, exportedRows === 'filteredAndSorted');
                }
                else if (usingSsrm) {
                    rowModel.forEachNodeAfterFilterAndSort(processRow, true);
                }
                else {
                    // must be enterprise, so we can just loop through all the nodes
                    rowModel.forEachNode(processRow);
                }
                return gridSerializingSession;
            }
            // onlySelectedAllPages: user doing pagination and wants selected items from
            // other pages, so cannot use the standard row model as it won't have rows from
            // other pages.
            // onlySelectedNonStandardModel: if user wants selected in non standard row model
            // (eg viewport) then again RowModel cannot be used, so need to use selected instead.
            if (params.onlySelectedAllPages || onlySelectedNonStandardModel) {
                const selectedNodes = this.beans.selectionSvc?.getSelectedNodes() ?? [];
                this.replicateSortedOrder(selectedNodes);
                // serialize each node
                selectedNodes.forEach(processRow);
            }
            else {
                // here is everything else - including standard row model and selected. we don't use
                // the selection model even when just using selected, so that the result is the order
                // of the rows appearing on the screen.
                if (exportedRows === 'all') {
                    rowModel.forEachNode(processRow);
                }
                else if (usingCsrm || usingSsrm) {
                    rowModel.forEachNodeAfterFilterAndSort(processRow, true);
                }
                else {
                    rowModel.forEachNode(processRow);
                }
            }
            return gridSerializingSession;
        };
    }
    replicateSortedOrder(rows) {
        const { sortSvc, rowNodeSorter } = this.beans;
        if (!sortSvc || !rowNodeSorter) {
            return;
        }
        const sortOptions = sortSvc.getSortOptions();
        const compareNodes = (rowA, rowB) => {
            if (rowA.rowIndex != null && rowB.rowIndex != null) {
                // if the rows have rowIndexes, this is the easiest way to compare,
                // as they're already ordered
                return rowA.rowIndex - rowB.rowIndex;
            }
            // if the level is the same, compare these nodes, or their parents
            if (rowA.level === rowB.level) {
                if (rowA.parent?.id === rowB.parent?.id) {
                    return rowNodeSorter.compareRowNodes(sortOptions, {
                        rowNode: rowA,
                        currentPos: rowA.rowIndex ?? -1,
                    }, {
                        rowNode: rowB,
                        currentPos: rowB.rowIndex ?? -1,
                    });
                }
                // level is same, but parent isn't, compare parents
                return compareNodes(rowA.parent, rowB.parent);
            }
            // if level is different, match levels
            if (rowA.level > rowB.level) {
                return compareNodes(rowA.parent, rowB);
            }
            return compareNodes(rowA, rowB.parent);
        };
        // sort the nodes either by existing row index or compare them
        rows.sort(compareNodes);
    }
    processPinnedBottomRows(params, columnsToExport) {
        return (gridSerializingSession) => {
            const processRow = this.processRow.bind(this, gridSerializingSession, params, columnsToExport);
            if (params.rowPositions) {
                params.rowPositions
                    // only pinnedBottom rows, other models are processed by `processRows` and `processPinnedTopRows`
                    .filter((position) => position.rowPinned === 'bottom')
                    .sort((a, b) => a.rowIndex - b.rowIndex)
                    .map((position) => this.pinnedRowModel?.getPinnedBottomRow(position.rowIndex))
                    .forEach(processRow);
            }
            else if (!this.pinnedRowModel?.isManual()) {
                // only process pinned rows if they are statically pinned
                this.pinnedRowModel?.forEachPinnedRow('bottom', processRow);
            }
            return gridSerializingSession;
        };
    }
    getColumnsToExport(params) {
        const { allColumns = false, skipRowGroups = false, exportRowNumbers = false, columnKeys } = params;
        const { colModel, gos, visibleCols } = this;
        const isPivotMode = colModel.isPivotMode();
        const filterSpecialColumns = (col) => {
            if ((0, columnUtils_1.isColumnSelectionCol)(col)) {
                return false;
            }
            return !(0, columnUtils_1.isRowNumberCol)(col) || exportRowNumbers;
        };
        if (columnKeys && columnKeys.length) {
            return colModel.getColsForKeys(columnKeys).filter(filterSpecialColumns);
        }
        const isTreeData = gos.get('treeData');
        let columnsToExport = [];
        if (allColumns && !isPivotMode) {
            columnsToExport = colModel.getCols();
        }
        else {
            columnsToExport = visibleCols.allCols;
        }
        columnsToExport = columnsToExport.filter((column) => filterSpecialColumns(column) && (skipRowGroups && !isTreeData ? !(0, columnUtils_1.isColumnGroupAutoCol)(column) : true));
        return columnsToExport;
    }
    recursivelyAddHeaderGroups(displayedGroups, gridSerializingSession, processGroupHeaderCallback) {
        const directChildrenHeaderGroups = [];
        displayedGroups.forEach((columnGroupChild) => {
            const columnGroup = columnGroupChild;
            if (!columnGroup.getChildren) {
                return;
            }
            columnGroup.getChildren().forEach((it) => directChildrenHeaderGroups.push(it));
        });
        if (displayedGroups.length > 0 && (0, agColumnGroup_1.isColumnGroup)(displayedGroups[0])) {
            this.doAddHeaderHeader(gridSerializingSession, displayedGroups, processGroupHeaderCallback);
        }
        if (directChildrenHeaderGroups && directChildrenHeaderGroups.length > 0) {
            this.recursivelyAddHeaderGroups(directChildrenHeaderGroups, gridSerializingSession, processGroupHeaderCallback);
        }
    }
    doAddHeaderHeader(gridSerializingSession, displayedGroups, processGroupHeaderCallback) {
        const gridRowIterator = gridSerializingSession.onNewHeaderGroupingRow();
        let columnIndex = 0;
        displayedGroups.forEach((columnGroupChild) => {
            const columnGroup = columnGroupChild;
            let name;
            if (processGroupHeaderCallback) {
                name = processGroupHeaderCallback((0, gridOptionsUtils_1._addGridCommonParams)(this.gos, {
                    columnGroup: columnGroup,
                }));
            }
            else {
                name = this.beans.colNames.getDisplayNameForColumnGroup(columnGroup, 'header');
            }
            const collapsibleGroupRanges = columnGroup
                .getLeafColumns()
                .reduce((collapsibleGroups, currentColumn, currentIdx, arr) => {
                let lastGroup = (0, array_1._last)(collapsibleGroups);
                const groupShow = currentColumn.getColumnGroupShow() === 'open';
                if (!groupShow) {
                    if (lastGroup && lastGroup[1] == null) {
                        lastGroup[1] = currentIdx - 1;
                    }
                }
                else if (!lastGroup || lastGroup[1] != null) {
                    lastGroup = [currentIdx];
                    collapsibleGroups.push(lastGroup);
                }
                if (currentIdx === arr.length - 1 && lastGroup && lastGroup[1] == null) {
                    lastGroup[1] = currentIdx;
                }
                return collapsibleGroups;
            }, []);
            gridRowIterator.onColumn(columnGroup, name || '', columnIndex++, columnGroup.getLeafColumns().length - 1, collapsibleGroupRanges);
        });
    }
}
exports.GridSerializer = GridSerializer;


/***/ }),

/***/ 36331:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.columnFiltersCSS = void 0;
exports.columnFiltersCSS = `.ag-set-filter{--ag-indentation-level:0}.ag-set-filter-item{align-items:center;display:flex;height:100%}:where(.ag-ltr) .ag-set-filter-item{padding-left:calc(var(--ag-widget-container-horizontal-padding) + var(--ag-indentation-level)*var(--ag-set-filter-indent-size))}:where(.ag-rtl) .ag-set-filter-item{padding-right:calc(var(--ag-widget-container-horizontal-padding) + var(--ag-indentation-level)*var(--ag-set-filter-indent-size))}.ag-set-filter-item-checkbox{display:flex;height:100%;width:100%}.ag-set-filter-group-icons{display:block;>*{cursor:pointer}}:where(.ag-ltr) .ag-set-filter-group-icons{margin-right:var(--ag-widget-container-horizontal-padding)}:where(.ag-rtl) .ag-set-filter-group-icons{margin-left:var(--ag-widget-container-horizontal-padding)}.ag-filter-body-wrapper{display:flex;flex-direction:column}:where(.ag-menu:not(.ag-tabs) .ag-filter) .ag-filter-body-wrapper,:where(.ag-menu:not(.ag-tabs) .ag-filter)>:not(.ag-filter-wrapper){min-width:180px}.ag-filter-filter{flex:1 1 0px}.ag-filter-condition{display:flex;justify-content:center}.ag-floating-filter-body{display:flex;flex:1 1 auto;height:100%;position:relative}.ag-floating-filter-full-body{align-items:center;display:flex;flex:1 1 auto;height:100%;overflow:hidden;width:100%}:where(.ag-floating-filter-full-body)>div{flex:1 1 auto}.ag-floating-filter-input{align-items:center;display:flex;width:100%;>*{flex:1 1 auto}:where(.ag-input-field-input[type=date]),:where(.ag-input-field-input[type=datetime-local]){width:1px}}.ag-floating-filter-button{display:flex;flex:none}.ag-date-floating-filter-wrapper{display:flex}.ag-set-floating-filter-input :where(input)[disabled]{pointer-events:none}.ag-floating-filter-button-button{-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none;height:var(--ag-icon-size);width:var(--ag-icon-size)}.ag-filter-loading{align-items:unset;background-color:var(--ag-chrome-background-color);height:100%;padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding);position:absolute;width:100%;z-index:1;:where(.ag-menu) &{background-color:var(--ag-menu-background-color)}}.ag-filter-separator{border-top:solid var(--ag-border-width) var(--menu-separator-color)}:where(.ag-filter-select) .ag-picker-field-wrapper{width:0}.ag-filter-condition-operator{height:17px}:where(.ag-ltr) .ag-filter-condition-operator-or{margin-left:calc(var(--ag-spacing)*2)}:where(.ag-rtl) .ag-filter-condition-operator-or{margin-right:calc(var(--ag-spacing)*2)}.ag-set-filter-select-all{padding-top:var(--ag-widget-container-vertical-padding)}.ag-filter-no-matches,.ag-set-filter-list{height:calc(var(--ag-list-item-height)*6)}.ag-filter-no-matches{padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding)}.ag-set-filter-tree-list{height:calc(var(--ag-list-item-height)*10)}.ag-set-filter-filter{margin-left:var(--ag-widget-container-horizontal-padding);margin-right:var(--ag-widget-container-horizontal-padding);margin-top:var(--ag-widget-container-vertical-padding)}.ag-filter-to{margin-top:var(--ag-widget-vertical-spacing)}.ag-mini-filter{margin:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding)}:where(.ag-ltr) .ag-set-filter-add-group-indent{margin-left:calc(var(--ag-icon-size) + var(--ag-widget-container-horizontal-padding))}:where(.ag-rtl) .ag-set-filter-add-group-indent{margin-right:calc(var(--ag-icon-size) + var(--ag-widget-container-horizontal-padding))}:where(.ag-filter-menu) .ag-set-filter-list{min-width:200px}.ag-filter-virtual-list-item:focus-visible{box-shadow:inset var(--ag-focus-shadow)}.ag-filter-apply-panel{display:flex;justify-content:flex-end;overflow:hidden;padding:var(--ag-widget-vertical-spacing) var(--ag-widget-container-horizontal-padding) var(--ag-widget-container-vertical-padding)}.ag-filter-apply-panel-button{line-height:1.5}:where(.ag-ltr) .ag-filter-apply-panel-button{margin-left:calc(var(--ag-spacing)*2)}:where(.ag-rtl) .ag-filter-apply-panel-button{margin-right:calc(var(--ag-spacing)*2)}.ag-simple-filter-body-wrapper{display:flex;flex-direction:column;min-height:calc(var(--ag-list-item-height) + var(--ag-widget-container-vertical-padding) + var(--ag-widget-vertical-spacing));overflow-y:auto;padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding);padding-bottom:calc(var(--ag-widget-container-vertical-padding) - var(--ag-widget-vertical-spacing));&>*{margin-bottom:var(--ag-widget-vertical-spacing)}:where(.ag-resizer-wrapper){margin:0}}.ag-multi-filter-menu-item{margin:var(--ag-spacing) 0}.ag-multi-filter-group-title-bar{background-color:transparent;color:var(--ag-header-text-color);font-weight:500;padding:calc(var(--ag-spacing)*1.5) var(--ag-spacing)}.ag-group-filter-field-select-wrapper{display:flex;flex-direction:column;gap:var(--ag-widget-vertical-spacing);padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding)}`;


/***/ }),

/***/ 46908:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.doFilterAction = exports.getColumnFilterHandler = exports.showColumnFilter = exports.setColumnFilterModel = exports.getColumnFilterModel = exports.getFilterModel = exports.setFilterModel = exports.destroyFilter = exports.getColumnFilterInstance = exports.isColumnFilterPresent = void 0;
const logging_1 = __webpack_require__(47764);
function isColumnFilterPresent(beans) {
    const filterManager = beans.filterManager;
    return !!filterManager?.isColumnFilterPresent() || !!filterManager?.isAggregateFilterPresent();
}
exports.isColumnFilterPresent = isColumnFilterPresent;
function getColumnFilterInstance(beans, key) {
    return (beans.filterManager?.getColumnFilterInstance(key) ?? Promise.resolve(undefined));
}
exports.getColumnFilterInstance = getColumnFilterInstance;
function destroyFilter(beans, key) {
    const column = beans.colModel.getColDefCol(key);
    if (column) {
        return beans.colFilter?.destroyFilter(column, 'api');
    }
}
exports.destroyFilter = destroyFilter;
function setFilterModel(beans, model) {
    beans.frameworkOverrides.wrapIncoming(() => beans.filterManager?.setFilterModel(model));
}
exports.setFilterModel = setFilterModel;
function getFilterModel(beans) {
    return beans.filterManager?.getFilterModel() ?? {};
}
exports.getFilterModel = getFilterModel;
function getColumnFilterModel(beans, key, useUnapplied) {
    const { gos, colModel, colFilter } = beans;
    if (useUnapplied && !gos.get('enableFilterHandlers')) {
        (0, logging_1._warn)(288);
        useUnapplied = false;
    }
    const column = colModel.getColDefCol(key);
    return column ? colFilter?.getModelForColumn(column, useUnapplied) ?? null : null;
}
exports.getColumnFilterModel = getColumnFilterModel;
function setColumnFilterModel(beans, column, model) {
    return beans.filterManager?.setColumnFilterModel(column, model) ?? Promise.resolve();
}
exports.setColumnFilterModel = setColumnFilterModel;
function showColumnFilter(beans, colKey) {
    const column = beans.colModel.getCol(colKey);
    if (!column) {
        // Column not found, can't show filter
        (0, logging_1._error)(12, { colKey });
        return;
    }
    beans.menuSvc?.showFilterMenu({
        column,
        containerType: 'columnFilter',
        positionBy: 'auto',
    });
}
exports.showColumnFilter = showColumnFilter;
function getColumnFilterHandler(beans, colKey) {
    const column = beans.colModel.getCol(colKey);
    if (!column) {
        // Column not found, can't show filter
        (0, logging_1._error)(12, { colKey });
        return undefined;
    }
    return beans.colFilter?.getHandler(column, true);
}
exports.getColumnFilterHandler = getColumnFilterHandler;
function doFilterAction(beans, params) {
    const { colModel, colFilter, gos } = beans;
    if (!gos.get('enableFilterHandlers')) {
        (0, logging_1._warn)(287);
        return;
    }
    const { colId, action } = params;
    if (colId) {
        const column = colModel.getColById(colId);
        if (column) {
            colFilter?.updateModel(column, action);
        }
    }
    else {
        colFilter?.updateAllModels(action);
    }
}
exports.doFilterAction = doFilterAction;


/***/ }),

/***/ 40219:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColumnFilterService = void 0;
const unwrapUserComp_1 = __webpack_require__(54126);
const userCompUtils_1 = __webpack_require__(12036);
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const iFilter_1 = __webpack_require__(25679);
const generic_1 = __webpack_require__(34422);
const promise_1 = __webpack_require__(57990);
const logging_1 = __webpack_require__(47764);
const columnFilterUtils_1 = __webpack_require__(4985);
const filterDataTypeUtils_1 = __webpack_require__(26771);
const floatingFilterMapper_1 = __webpack_require__(59990);
/** Used for non-CSRM handlers */
const DUMMY_HANDLER = {
    filterHandler: () => ({
        doesFilterPass: () => true,
    }),
};
class ColumnFilterService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'colFilter';
        this.allColumnFilters = new Map();
        this.allColumnListeners = new Map();
        this.activeAggregateFilters = [];
        this.activeColumnFilters = [];
        // this is true when the grid is processing the filter change. this is used by the cell comps, so that they
        // don't flash when data changes due to filter changes. there is no need to flash when filter changes as the
        // user is in control, so doesn't make sense to show flashing changes. for example, go to main demo where
        // this feature is turned off (hack code to always return false for isSuppressFlashingCellsBecauseFiltering(), put in)
        // 100,000 rows and group by country. then do some filtering. all the cells flash, which is silly.
        this.processingFilterChange = false;
        // when we're waiting for cell data types to be inferred, we need to defer filter model updates
        this.modelUpdates = [];
        this.columnModelUpdates = [];
        /** This contains the UI state for handler columns */
        this.state = new Map();
        this.handlerMap = {
            ...columnFilterUtils_1.FILTER_HANDLER_MAP,
        };
        this.isGlobalButtons = false;
        this.activeFilterComps = new Set();
    }
    postConstruct() {
        this.addManagedEventListeners({
            gridColumnsChanged: this.onColumnsChanged.bind(this),
            beforeRefreshModel: ({ params, groupsChanged }) => {
                // We listen to both row data updated and treeData changed as the SetFilter needs it
                if (groupsChanged || params.rowDataUpdated) {
                    this.onNewRowsLoaded('rowDataUpdated');
                }
            },
            dataTypesInferred: this.processFilterModelUpdateQueue.bind(this),
        });
        const gos = this.gos;
        const initialFilterModel = {
            ...(gos.get('initialState')?.filter?.filterModel ?? {}),
        };
        this.initialModel = initialFilterModel;
        this.model = {
            ...initialFilterModel,
        };
        if (!gos.get('enableFilterHandlers')) {
            delete this.handlerMap['agMultiColumnFilter'];
        }
    }
    setModel(model, source = 'api') {
        const { colModel, dataTypeSvc, filterManager } = this.beans;
        if (dataTypeSvc?.isPendingInference) {
            this.modelUpdates.push({ model, source });
            return;
        }
        const allPromises = [];
        const previousModel = this.getModel(true);
        if (model) {
            // mark the filters as we set them, so any active filters left over we stop
            const modelKeys = new Set(Object.keys(model));
            this.allColumnFilters.forEach((filterWrapper, colId) => {
                const newModel = model[colId];
                allPromises.push(this.setModelOnFilterWrapper(filterWrapper, newModel));
                modelKeys.delete(colId);
            });
            // at this point, processedFields contains data for which we don't have a filter working yet
            modelKeys.forEach((colId) => {
                const column = colModel.getColDefCol(colId) || colModel.getCol(colId);
                if (!column) {
                    (0, logging_1._warn)(62, { colId });
                    return;
                }
                if (!column.isFilterAllowed()) {
                    (0, logging_1._warn)(63, { colId });
                    return;
                }
                const filterWrapper = this.getOrCreateFilterWrapper(column, true);
                if (!filterWrapper) {
                    (0, logging_1._warn)(64, { colId });
                    return;
                }
                allPromises.push(this.setModelOnFilterWrapper(filterWrapper, model[colId], true));
            });
        }
        else {
            this.model = {};
            this.allColumnFilters.forEach((filterWrapper) => {
                allPromises.push(this.setModelOnFilterWrapper(filterWrapper, null));
            });
        }
        promise_1.AgPromise.all(allPromises).then(() => {
            const currentModel = this.getModel(true);
            const columns = [];
            this.allColumnFilters.forEach((filterWrapper, colId) => {
                const before = previousModel ? previousModel[colId] : null;
                const after = currentModel ? currentModel[colId] : null;
                if (!(0, generic_1._jsonEquals)(before, after)) {
                    columns.push(filterWrapper.column);
                }
            });
            if (columns.length > 0) {
                filterManager?.onFilterChanged({ columns, source });
            }
        });
    }
    getModel(excludeInitialState) {
        const result = {};
        const { allColumnFilters, initialModel, beans: { colModel }, } = this;
        allColumnFilters.forEach((filterWrapper, key) => {
            const model = this.getModelFromFilterWrapper(filterWrapper);
            if ((0, generic_1._exists)(model)) {
                result[key] = model;
            }
        });
        if (!excludeInitialState) {
            for (const colId of Object.keys(initialModel)) {
                const model = initialModel[colId];
                if ((0, generic_1._exists)(model) && !allColumnFilters.has(colId) && colModel.getCol(colId)?.isFilterAllowed()) {
                    result[colId] = model;
                }
            }
        }
        return result;
    }
    setState(model, state, source = 'api') {
        this.state.clear();
        if (state) {
            for (const colId of Object.keys(state)) {
                const newState = state[colId];
                this.state.set(colId, {
                    model: (0, columnFilterUtils_1._getFilterModel)(this.model, colId),
                    state: newState,
                });
            }
        }
        this.setModel(model, source);
    }
    getState() {
        const state = this.state;
        if (!state.size) {
            return undefined;
        }
        const newState = {};
        let hasNewState = false;
        state.forEach((colState, colId) => {
            const actualState = colState.state;
            if (actualState != null) {
                hasNewState = true;
                newState[colId] = actualState;
            }
        });
        return hasNewState ? newState : undefined;
    }
    getModelFromFilterWrapper(filterWrapper) {
        const column = filterWrapper.column;
        const colId = column.getColId();
        if (filterWrapper.isHandler) {
            return (0, columnFilterUtils_1._getFilterModel)(this.model, colId);
        }
        const filter = filterWrapper.filter;
        if (filter) {
            if (typeof filter.getModel !== 'function') {
                (0, logging_1._warn)(66);
                return null;
            }
            return filter.getModel();
        }
        // filter still being created. return initial state if it exists and hasn't been applied yet
        return (0, columnFilterUtils_1._getFilterModel)(this.initialModel, colId);
    }
    isFilterPresent() {
        return this.activeColumnFilters.length > 0;
    }
    isAggFilterPresent() {
        return !!this.activeAggregateFilters.length;
    }
    disableFilters() {
        this.initialModel = {};
        const { allColumnFilters } = this;
        if (allColumnFilters.size) {
            allColumnFilters.forEach((filterWrapper) => this.disposeFilterWrapper(filterWrapper, 'advancedFilterEnabled'));
            return true;
        }
        return false;
    }
    updateActiveFilters() {
        const isFilterActive = (filter) => {
            if (!filter) {
                return false;
            } // this never happens, including to avoid compile error
            if (!filter.isFilterActive) {
                (0, logging_1._warn)(67);
                return false;
            }
            return filter.isFilterActive();
        };
        const { colModel, gos } = this.beans;
        const groupFilterEnabled = !!(0, gridOptionsUtils_1._getGroupAggFiltering)(gos);
        const isAggFilter = (column) => {
            const isSecondary = !column.isPrimary();
            // the only filters that can appear on secondary columns are groupAgg filters
            if (isSecondary) {
                return true;
            }
            const isShowingPrimaryColumns = !colModel.isPivotActive();
            const isValueActive = column.isValueActive();
            // primary columns are only ever groupAgg filters if a) value is active and b) showing primary columns
            if (!isValueActive || !isShowingPrimaryColumns) {
                return false;
            }
            // from here on we know: isPrimary=true, isValueActive=true, isShowingPrimaryColumns=true
            if (colModel.isPivotMode()) {
                // primary column is pretending to be a pivot column, ie pivotMode=true, but we are
                // still showing primary columns
                return true;
            }
            // we are not pivoting, so we groupFilter when it's an agg column
            return groupFilterEnabled;
        };
        const activeAggregateFilters = [];
        const activeColumnFilters = [];
        const addFilter = (column, filterActive, doesFilterPassWrapper) => {
            if (filterActive) {
                if (isAggFilter(column)) {
                    activeAggregateFilters.push(doesFilterPassWrapper);
                }
                else {
                    activeColumnFilters.push(doesFilterPassWrapper);
                }
            }
        };
        const promises = [];
        this.allColumnFilters.forEach((filterWrapper) => {
            const column = filterWrapper.column;
            const colId = column.getColId();
            if (filterWrapper.isHandler) {
                promises.push(promise_1.AgPromise.resolve().then(() => {
                    addFilter(column, this.isHandlerActive(column), {
                        colId,
                        isHandler: true,
                        handler: filterWrapper.handler,
                        handlerParams: filterWrapper.handlerParams,
                    });
                }));
            }
            else {
                const promise = (0, columnFilterUtils_1.getFilterUiFromWrapper)(filterWrapper);
                if (promise) {
                    promises.push(promise.then((filter) => {
                        addFilter(column, isFilterActive(filter), {
                            colId,
                            isHandler: false,
                            comp: filter,
                        });
                    }));
                }
            }
        });
        return promise_1.AgPromise.all(promises).then(() => {
            this.activeAggregateFilters = activeAggregateFilters;
            this.activeColumnFilters = activeColumnFilters;
        });
    }
    updateFilterFlagInColumns(source, additionalEventAttributes) {
        const promises = [];
        this.allColumnFilters.forEach((filterWrapper) => {
            const column = filterWrapper.column;
            if (filterWrapper.isHandler) {
                promises.push(promise_1.AgPromise.resolve().then(() => {
                    this.setColFilterActive(column, this.isHandlerActive(column), source, additionalEventAttributes);
                }));
            }
            else {
                const promise = (0, columnFilterUtils_1.getFilterUiFromWrapper)(filterWrapper);
                if (promise) {
                    promises.push(promise.then((filter) => {
                        this.setColFilterActive(column, filter.isFilterActive(), source, additionalEventAttributes);
                    }));
                }
            }
        });
        this.beans.groupFilter?.updateFilterFlags(source, additionalEventAttributes);
        return promise_1.AgPromise.all(promises);
    }
    doFiltersPass(node, colIdToSkip, targetAggregates) {
        const { data, aggData } = node;
        const targetedFilters = targetAggregates ? this.activeAggregateFilters : this.activeColumnFilters;
        const targetedData = targetAggregates ? aggData : data;
        const model = this.model;
        for (let i = 0; i < targetedFilters.length; i++) {
            const filter = targetedFilters[i];
            const { colId, isHandler } = filter;
            if (colId === colIdToSkip) {
                continue;
            }
            if (isHandler) {
                const { handler, handlerParams } = filter;
                if (!handler.doesFilterPass({
                    node,
                    data: targetedData,
                    model: (0, columnFilterUtils_1._getFilterModel)(model, colId),
                    handlerParams,
                })) {
                    return false;
                }
            }
            else {
                const comp = filter.comp;
                if (typeof comp.doesFilterPass !== 'function') {
                    // because users can do custom filters, give nice error message
                    (0, logging_1._error)(91);
                    continue;
                }
                if (!comp.doesFilterPass({ node, data: targetedData })) {
                    return false;
                }
            }
        }
        return true;
    }
    getHandlerParams(column) {
        const wrapper = this.allColumnFilters.get(column.getColId());
        return wrapper?.isHandler ? wrapper.handlerParams : undefined;
    }
    // sometimes (especially in React) the filter can call onFilterChanged when we are in the middle
    // of a render cycle. this would be bad, so we wait for render cycle to complete when this happens.
    // this happens in react when we change React State in the grid (eg setting RowCtrl's in RowContainer)
    // which results in React State getting applied in the main application, triggering a useEffect() to
    // be kicked off adn then the application calling the grid's API. in AG-6554, the custom filter was
    // getting it's useEffect() triggered in this way.
    callOnFilterChangedOutsideRenderCycle(params) {
        const { rowRenderer, filterManager } = this.beans;
        const action = () => {
            if (this.isAlive()) {
                filterManager?.onFilterChanged(params);
            }
        };
        if (rowRenderer.isRefreshInProgress()) {
            setTimeout(action, 0);
        }
        else {
            action();
        }
    }
    updateBeforeFilterChanged(params = {}) {
        const { column, additionalEventAttributes } = params;
        const colId = column?.getColId();
        return this.updateActiveFilters().then(() => this.updateFilterFlagInColumns('filterChanged', additionalEventAttributes).then(() => {
            this.allColumnFilters.forEach((filterWrapper) => {
                const { column: filterColumn, isHandler } = filterWrapper;
                if (colId === filterColumn.getColId()) {
                    return;
                }
                if (isHandler) {
                    filterWrapper.handler.onAnyFilterChanged?.();
                }
                (0, columnFilterUtils_1.getFilterUiFromWrapper)(filterWrapper, isHandler)?.then((filter) => {
                    if (typeof filter?.onAnyFilterChanged === 'function') {
                        filter.onAnyFilterChanged();
                    }
                });
            });
            // because internal events are not async in ag-grid, when the dispatchEvent
            // method comes back, we know all listeners have finished executing.
            this.processingFilterChange = true;
        }));
    }
    updateAfterFilterChanged() {
        this.processingFilterChange = false;
    }
    isSuppressFlashingCellsBecauseFiltering() {
        // if user has elected to always flash cell changes, then always return false, otherwise we suppress flashing
        // changes when filtering
        const allowShowChangeAfterFilter = this.gos.get('allowShowChangeAfterFilter') ?? false;
        return !allowShowChangeAfterFilter && this.processingFilterChange;
    }
    onNewRowsLoaded(source) {
        const promises = [];
        this.allColumnFilters.forEach((filterWrapper) => {
            const isHandler = filterWrapper.isHandler;
            if (isHandler) {
                filterWrapper.handler.onNewRowsLoaded?.();
            }
            const promise = (0, columnFilterUtils_1.getFilterUiFromWrapper)(filterWrapper, isHandler);
            if (promise) {
                promises.push(promise.then((filter) => {
                    filter.onNewRowsLoaded?.();
                }));
            }
        });
        promise_1.AgPromise.all(promises)
            .then(() => this.updateFilterFlagInColumns(source, { afterDataChange: true }))
            .then(() => this.updateActiveFilters());
    }
    createGetValue(filterColumn, filterValueGetterOverride) {
        const { filterValueSvc, colModel } = this.beans;
        return (rowNode, column) => {
            const columnToUse = column ? colModel.getCol(column) : filterColumn;
            return columnToUse ? filterValueSvc.getValue(columnToUse, rowNode, filterValueGetterOverride) : undefined;
        };
    }
    isFilterActive(column) {
        const filterWrapper = this.cachedFilter(column);
        if (filterWrapper?.isHandler) {
            return this.isHandlerActive(column);
        }
        const filter = filterWrapper?.filter;
        if (filter) {
            return filter.isFilterActive();
        }
        // if not created, should only be active if there's a model
        return (0, columnFilterUtils_1._getFilterModel)(this.initialModel, column.getColId()) != null;
    }
    isHandlerActive(column) {
        // all the existing filter code uses `_exists` rather than not null,
        // so need to keep handling `''` until all the code is updated to do a simple null check
        const active = (0, generic_1._exists)((0, columnFilterUtils_1._getFilterModel)(this.model, column.getColId()));
        if (active) {
            return active;
        }
        const groupFilter = this.beans.groupFilter;
        return groupFilter?.isGroupFilter(column) ? groupFilter.isFilterActive(column) : false;
    }
    getOrCreateFilterUi(column) {
        const filterWrapper = this.getOrCreateFilterWrapper(column, true);
        return filterWrapper ? (0, columnFilterUtils_1.getFilterUiFromWrapper)(filterWrapper) : null;
    }
    getFilterUiForDisplay(column) {
        const filterWrapper = this.getOrCreateFilterWrapper(column, true);
        if (!filterWrapper) {
            return null;
        }
        const compPromise = (0, columnFilterUtils_1.getFilterUiFromWrapper)(filterWrapper);
        if (!compPromise) {
            return null;
        }
        return compPromise.then((comp) => ({
            comp: comp,
            params: filterWrapper.filterUi.filterParams,
            isHandler: filterWrapper.isHandler,
        }));
    }
    getHandler(column, createIfMissing) {
        const filterWrapper = this.getOrCreateFilterWrapper(column, createIfMissing);
        return filterWrapper?.isHandler ? filterWrapper.handler : undefined;
    }
    getOrCreateFilterWrapper(column, createIfMissing) {
        if (!column.isFilterAllowed()) {
            return undefined;
        }
        let filterWrapper = this.cachedFilter(column);
        if (!filterWrapper && createIfMissing) {
            filterWrapper = this.createFilterWrapper(column);
            this.setColumnFilterWrapper(column, filterWrapper);
        }
        return filterWrapper;
    }
    cachedFilter(column) {
        return this.allColumnFilters.get(column.getColId());
    }
    getDefaultFilter(column, isFloating = false) {
        return this.getDefaultFilterFromDataType(() => this.beans.dataTypeSvc?.getBaseDataType(column), isFloating);
    }
    getDefaultFilterFromDataType(getCellDataType, isFloating = false) {
        if ((0, gridOptionsUtils_1._isSetFilterByDefault)(this.gos)) {
            return isFloating ? 'agSetColumnFloatingFilter' : 'agSetColumnFilter';
        }
        return (0, filterDataTypeUtils_1._getDefaultSimpleFilter)(getCellDataType(), isFloating);
    }
    getDefaultFloatingFilter(column) {
        return this.getDefaultFilter(column, true);
    }
    createFilterComp(column, filterDef, defaultFilter, getFilterParams, isHandler, source) {
        const createFilterCompDetails = () => {
            const params = this.createFilterCompParams(column, isHandler, source);
            const updatedParams = getFilterParams(params, isHandler);
            return (0, userCompUtils_1._getFilterDetails)(this.beans.userCompFactory, filterDef, updatedParams, defaultFilter);
        };
        const compDetails = createFilterCompDetails();
        if (!compDetails) {
            return null;
        }
        const createFilterUi = (update) => {
            return (update ? createFilterCompDetails() : compDetails).newAgStackInstance();
        };
        return {
            compDetails,
            createFilterUi,
        };
    }
    createFilterInstance(column, filterDef, defaultFilter, getFilterParams) {
        const selectableFilter = this.beans.selectableFilter;
        if (selectableFilter?.isSelectable(filterDef)) {
            filterDef = selectableFilter.getFilterDef(column, filterDef);
        }
        const { handler, handlerParams, handlerGenerator } = this.createHandler(column, filterDef, defaultFilter) ?? {};
        const filterCompDetails = this.createFilterComp(column, filterDef, defaultFilter, getFilterParams, !!handler, 'init');
        if (!filterCompDetails) {
            return {
                compDetails: null,
                createFilterUi: null,
                handler,
                handlerGenerator,
                handlerParams,
            };
        }
        const { compDetails, createFilterUi } = filterCompDetails;
        if (this.isGlobalButtons) {
            const hasLocalButtons = !!compDetails.params?.buttons?.length;
            if (!hasLocalButtons) {
                (0, logging_1._warn)(281, { colId: column.getColId() });
            }
        }
        return {
            compDetails,
            handler,
            handlerGenerator,
            handlerParams,
            createFilterUi,
        };
    }
    createBaseFilterParams(column, forFloatingFilter) {
        const { filterManager, rowModel } = this.beans;
        return (0, gridOptionsUtils_1._addGridCommonParams)(this.gos, {
            column,
            colDef: column.getColDef(),
            getValue: this.createGetValue(column),
            doesRowPassOtherFilter: forFloatingFilter
                ? () => true
                : (node) => filterManager?.doesRowPassOtherFilters(column.getColId(), node) ?? true,
            // to avoid breaking changes to `filterParams` defined as functions
            // we need to provide the below options even though they are not valid for handlers
            rowModel,
        });
    }
    createFilterCompParams(column, useHandler, source, forFloatingFilter) {
        const filterChangedCallback = this.filterChangedCallbackFactory(column);
        const params = this.createBaseFilterParams(column, forFloatingFilter);
        params.filterChangedCallback = filterChangedCallback;
        params.filterModifiedCallback = forFloatingFilter
            ? () => { }
            : (additionalEventAttributes) => this.filterModified(column, additionalEventAttributes);
        if (useHandler) {
            const displayParams = params;
            const colId = column.getColId();
            const model = (0, columnFilterUtils_1._getFilterModel)(this.model, colId);
            displayParams.model = model;
            displayParams.state = this.state.get(colId) ?? {
                model,
            };
            displayParams.onModelChange = (model, additionalEventAttributes) => {
                this.updateStoredModel(colId, model);
                this.refreshHandlerAndUi(column, model, 'ui').then(() => {
                    filterChangedCallback({ ...additionalEventAttributes, source: 'columnFilter' });
                });
            };
            displayParams.onStateChange = (state) => {
                this.updateState(column, state);
                this.updateOrRefreshFilterUi(column);
            };
            displayParams.onAction = (action, additionalEventAttributes, event) => {
                this.updateModel(column, action, additionalEventAttributes);
                this.dispatchLocalEvent({
                    type: 'filterAction',
                    column,
                    action,
                    event,
                });
            };
            displayParams.getHandler = () => this.getHandler(column, true);
            displayParams.onUiChange = (additionalEventAttributes) => this.filterUiChanged(column, additionalEventAttributes);
            displayParams.source = source;
        }
        return params;
    }
    createFilterUiForHandler(compDetails, createFilterUi) {
        return createFilterUi
            ? {
                created: false,
                create: createFilterUi,
                filterParams: compDetails.params,
                compDetails: compDetails,
            }
            : null;
    }
    createFilterUiLegacy(compDetails, createFilterUi, updateInstanceCallback) {
        const promise = createFilterUi();
        const filterUi = {
            created: true,
            create: createFilterUi,
            filterParams: compDetails.params,
            compDetails: compDetails,
            promise,
        };
        promise.then(updateInstanceCallback);
        return filterUi;
    }
    createFilterWrapper(column) {
        const { compDetails, handler, handlerGenerator, handlerParams, createFilterUi } = this.createFilterInstance(column, column.getColDef(), this.getDefaultFilter(column), (params) => params);
        const colId = column.getColId();
        if (handler) {
            delete this.initialModel[colId];
            handler.init?.({
                ...handlerParams,
                source: 'init',
                model: (0, columnFilterUtils_1._getFilterModel)(this.model, colId),
            });
            return {
                column,
                isHandler: true,
                handler,
                handlerGenerator: handlerGenerator,
                handlerParams: handlerParams,
                filterUi: this.createFilterUiForHandler(compDetails, createFilterUi),
            };
        }
        if (createFilterUi) {
            const filterWrapper = {
                column,
                filterUi: null,
                isHandler: false,
            };
            filterWrapper.filterUi = this.createFilterUiLegacy(compDetails, createFilterUi, (filterComp) => {
                filterWrapper.filter = filterComp ?? undefined;
            });
            return filterWrapper;
        }
        return {
            column,
            filterUi: null,
            isHandler: false,
        };
    }
    createHandlerFunc(filterDef, defaultFilter) {
        const { gos, frameworkOverrides, registry } = this.beans;
        // need to keep track of this so we can compare when col defs change
        let doesFilterPass;
        const getFilterHandlerFromDef = (filterDef) => {
            const filter = filterDef.filter;
            if ((0, iFilter_1.isColumnFilterComp)(filter)) {
                const handler = filter.handler;
                // handler takes priority
                if (handler) {
                    return handler;
                }
                doesFilterPass = filter.doesFilterPass;
                if (doesFilterPass) {
                    // wrap to create a handler
                    return () => ({
                        doesFilterPass: doesFilterPass,
                    });
                }
                return undefined;
            }
            return typeof filter === 'string' ? filter : undefined;
        };
        const providedFilterHandler = gos.get('enableFilterHandlers') ? getFilterHandlerFromDef(filterDef) : undefined;
        const resolveProvidedFilterHandler = (handlerName) => () => this.createBean(registry.createDynamicBean(handlerName, true));
        let filterHandler;
        let handlerName;
        if (typeof providedFilterHandler === 'string') {
            const userFilterHandler = gos.get('filterHandlers')?.[providedFilterHandler];
            if (userFilterHandler != null) {
                filterHandler = userFilterHandler;
            }
            else {
                if (columnFilterUtils_1.FILTER_HANDLERS.has(providedFilterHandler)) {
                    filterHandler = resolveProvidedFilterHandler(providedFilterHandler);
                    handlerName = providedFilterHandler;
                }
            }
        }
        else {
            filterHandler = providedFilterHandler;
        }
        if (!filterHandler) {
            let filterName;
            const { compName, jsComp, fwComp } = (0, userCompUtils_1._getFilterCompKeys)(frameworkOverrides, filterDef);
            if (compName) {
                filterName = compName;
            }
            else {
                const usingDefaultFilter = jsComp == null && fwComp == null && filterDef.filter === true;
                if (usingDefaultFilter) {
                    filterName = defaultFilter;
                }
            }
            handlerName = this.handlerMap[filterName];
            if (handlerName) {
                filterHandler = resolveProvidedFilterHandler(handlerName);
            }
        }
        if (!filterHandler) {
            return undefined;
        }
        return { filterHandler, handlerNameOrCallback: doesFilterPass ?? handlerName };
    }
    createHandler(column, filterDef, defaultFilter) {
        let handlerFunc = this.createHandlerFunc(filterDef, defaultFilter);
        if (!handlerFunc) {
            const gos = this.gos;
            if (!gos.get('enableFilterHandlers')) {
                return undefined;
            }
            if ((0, gridOptionsUtils_1._isClientSideRowModel)(gos)) {
                (0, logging_1._warn)(277, { colId: column.getColId() });
            }
            // create dummy handler for server side,
            // or to prevent blowing up for CSRM custom with missing props
            handlerFunc = DUMMY_HANDLER;
        }
        const filterParams = (0, userCompUtils_1._mergeFilterParamsWithApplicationProvidedParams)(this.beans.userCompFactory, filterDef, this.createFilterCompParams(column, true, 'init'));
        const { handlerNameOrCallback, filterHandler } = handlerFunc;
        const { handler, handlerParams } = this.createHandlerFromFunc(column, filterHandler, filterParams);
        return {
            handler,
            handlerParams,
            handlerGenerator: handlerNameOrCallback ?? filterHandler,
        };
    }
    createHandlerFromFunc(column, filterHandler, filterParams) {
        const colDef = column.getColDef();
        const handler = filterHandler((0, gridOptionsUtils_1._addGridCommonParams)(this.gos, { column, colDef }));
        const handlerParams = this.createHandlerParams(column, filterParams);
        return { handler, handlerParams };
    }
    createHandlerParams(column, filterParams) {
        const colDef = column.getColDef();
        const colId = column.getColId();
        const filterChangedCallback = this.filterChangedCallbackFactory(column);
        return (0, gridOptionsUtils_1._addGridCommonParams)(this.gos, {
            colDef,
            column,
            getValue: this.createGetValue(column),
            doesRowPassOtherFilter: (node) => this.beans.filterManager?.doesRowPassOtherFilters(colId, node) ?? true,
            onModelChange: (newModel, additionalEventAttributes) => {
                this.updateStoredModel(colId, newModel);
                this.refreshHandlerAndUi(column, newModel, 'handler').then(() => {
                    filterChangedCallback({ ...additionalEventAttributes, source: 'columnFilter' });
                });
            },
            filterParams,
        });
    }
    onColumnsChanged() {
        const columns = [];
        const { colModel, filterManager, groupFilter } = this.beans;
        this.allColumnFilters.forEach((wrapper, colId) => {
            let currentColumn;
            if (wrapper.column.isPrimary()) {
                currentColumn = colModel.getColDefCol(colId);
            }
            else {
                currentColumn = colModel.getCol(colId);
            }
            // group columns can be recreated with the same colId
            if (currentColumn && currentColumn === wrapper.column) {
                return;
            }
            columns.push(wrapper.column);
            this.disposeFilterWrapper(wrapper, 'columnChanged');
            this.disposeColumnListener(colId);
        });
        const allFiltersAreGroupFilters = groupFilter && columns.every((col) => groupFilter.isGroupFilter(col));
        // don't call `onFilterChanged` if only group column filter is present as it has no model
        if (columns.length > 0 && !allFiltersAreGroupFilters) {
            // When a filter changes as a side effect of a column changes,
            // we report 'api' as the source, so that the client can distinguish
            filterManager?.onFilterChanged({ columns, source: 'api' });
        }
    }
    isFilterAllowed(column) {
        const isFilterAllowed = column.isFilterAllowed();
        if (!isFilterAllowed) {
            return false;
        }
        // for group filters, can change dynamically whether they are allowed or not
        const groupFilter = this.beans.groupFilter;
        if (groupFilter?.isGroupFilter(column)) {
            return groupFilter.isFilterAllowed(column);
        }
        return true;
    }
    getFloatingFilterCompDetails(column, showParentFilter) {
        const { userCompFactory, frameworkOverrides, selectableFilter } = this.beans;
        const parentFilterInstance = (callback) => {
            const filterComponent = this.getOrCreateFilterUi(column);
            if (filterComponent == null) {
                return;
            }
            filterComponent.then((instance) => {
                callback((0, unwrapUserComp_1._unwrapUserComp)(instance));
            });
        };
        const colDef = column.getColDef();
        const filterDef = selectableFilter?.isSelectable(colDef)
            ? selectableFilter.getFilterDef(column, colDef)
            : colDef;
        const defaultFloatingFilterType = (0, floatingFilterMapper_1._getDefaultFloatingFilterType)(frameworkOverrides, filterDef, () => this.getDefaultFloatingFilter(column)) ??
            'agReadOnlyFloatingFilter';
        const isReactive = this.gos.get('enableFilterHandlers');
        const filterParams = (0, userCompUtils_1._mergeFilterParamsWithApplicationProvidedParams)(userCompFactory, filterDef, this.createFilterCompParams(column, isReactive, 'init', true));
        const params = (0, gridOptionsUtils_1._addGridCommonParams)(this.gos, {
            column,
            filterParams,
            currentParentModel: () => this.getCurrentFloatingFilterParentModel(column),
            parentFilterInstance,
            showParentFilter,
        });
        if (isReactive) {
            const displayParams = params;
            const colId = column.getColId();
            const filterChangedCallback = this.filterChangedCallbackFactory(column);
            displayParams.onUiChange = (additionalEventAttributes) => this.floatingFilterUiChanged(column, additionalEventAttributes);
            displayParams.model = (0, columnFilterUtils_1._getFilterModel)(this.model, colId);
            displayParams.onModelChange = (model, additionalEventAttributes) => {
                this.updateStoredModel(colId, model);
                this.refreshHandlerAndUi(column, model, 'floating', true).then(() => {
                    filterChangedCallback({ ...additionalEventAttributes, source: 'columnFilter' });
                });
            };
            displayParams.getHandler = () => this.getHandler(column, true);
            displayParams.source = 'init';
        }
        return (0, userCompUtils_1._getFloatingFilterCompDetails)(userCompFactory, colDef, params, defaultFloatingFilterType);
    }
    getCurrentFloatingFilterParentModel(column) {
        return this.getModelFromFilterWrapper(this.cachedFilter(column) ?? { column });
    }
    destroyFilterUi(filterWrapper, column, compDetails, createFilterUi) {
        if (filterWrapper.isHandler) {
            const colId = column.getColId();
            delete this.initialModel[colId];
            this.state.delete(colId);
            const filterUi = filterWrapper.filterUi;
            const newFilterUi = this.createFilterUiForHandler(compDetails, createFilterUi);
            filterWrapper.filterUi = newFilterUi;
            // destroy the old one after creating the new one
            // so that anything listening to the destroyed event will receive the new comp
            if (filterUi?.created) {
                filterUi.promise.then((filter) => {
                    this.destroyBean(filter);
                    this.eventSvc.dispatchEvent({
                        type: 'filterDestroyed',
                        source: 'paramsUpdated',
                        column: filterWrapper.column,
                    });
                });
            }
        }
        else {
            this.destroyFilter(column, 'paramsUpdated');
        }
    }
    // destroys the filter, so it no longer takes part
    destroyFilter(column, source = 'api') {
        const colId = column.getColId();
        const filterWrapper = this.allColumnFilters.get(colId);
        this.disposeColumnListener(colId);
        delete this.initialModel[colId];
        if (filterWrapper) {
            this.disposeFilterWrapper(filterWrapper, source).then((wasActive) => {
                if (wasActive && this.isAlive()) {
                    this.beans.filterManager?.onFilterChanged({
                        columns: [column],
                        source: 'api',
                    });
                }
            });
        }
    }
    disposeColumnListener(colId) {
        const columnListener = this.allColumnListeners.get(colId);
        if (columnListener) {
            this.allColumnListeners.delete(colId);
            columnListener();
        }
    }
    disposeFilterWrapper(filterWrapper, source) {
        let isActive = false;
        const { column, isHandler, filterUi } = filterWrapper;
        const colId = column.getColId();
        if (isHandler) {
            isActive = this.isHandlerActive(column);
            this.destroyBean(filterWrapper.handler);
            delete this.model[colId];
            this.state.delete(colId);
        }
        const removeFilter = () => {
            this.setColFilterActive(column, false, 'filterDestroyed');
            this.allColumnFilters.delete(colId);
            this.eventSvc.dispatchEvent({
                type: 'filterDestroyed',
                source,
                column,
            });
        };
        if (filterUi) {
            if (filterUi.created) {
                return filterUi.promise.then((filter) => {
                    isActive = isHandler ? isActive : !!filter?.isFilterActive();
                    this.destroyBean(filter);
                    removeFilter();
                    return isActive;
                });
            }
            else {
                removeFilter();
            }
        }
        return promise_1.AgPromise.resolve(isActive);
    }
    filterChangedCallbackFactory(column) {
        return (additionalEventAttributes) => {
            this.callOnFilterChangedOutsideRenderCycle({
                additionalEventAttributes,
                columns: [column],
                column,
                source: additionalEventAttributes?.source ?? 'columnFilter',
            });
        };
    }
    filterParamsChanged(colId, source = 'api') {
        const filterWrapper = this.allColumnFilters.get(colId);
        if (!filterWrapper) {
            return;
        }
        const beans = this.beans;
        const column = filterWrapper.column;
        const colDef = column.getColDef();
        const isFilterAllowed = column.isFilterAllowed();
        const defaultFilter = this.getDefaultFilter(column);
        const selectableFilter = beans.selectableFilter;
        const filterDef = selectableFilter?.isSelectable(colDef)
            ? selectableFilter.getFilterDef(column, colDef)
            : colDef;
        const handlerFunc = isFilterAllowed
            ? this.createHandlerFunc(filterDef, this.getDefaultFilter(column))
            : undefined;
        const isHandler = !!handlerFunc;
        const wasHandler = filterWrapper.isHandler;
        if (wasHandler != isHandler) {
            this.destroyFilter(column, 'paramsUpdated');
            return;
        }
        const { compDetails, createFilterUi } = (isFilterAllowed
            ? this.createFilterComp(column, filterDef, defaultFilter, (params) => params, isHandler, 'colDef')
            : null) ?? { compDetails: null, createFilterUi: null };
        const newFilterParams = compDetails?.params ??
            (0, userCompUtils_1._mergeFilterParamsWithApplicationProvidedParams)(beans.userCompFactory, filterDef, this.createFilterCompParams(column, isHandler, 'colDef'));
        if (wasHandler) {
            const handlerGenerator = handlerFunc?.handlerNameOrCallback ?? handlerFunc?.filterHandler;
            const existingModel = (0, columnFilterUtils_1._getFilterModel)(this.model, colId);
            if (filterWrapper.handlerGenerator != handlerGenerator) {
                // handler has changed
                const oldHandler = filterWrapper.handler;
                const { handler, handlerParams } = this.createHandlerFromFunc(column, handlerFunc.filterHandler, newFilterParams);
                filterWrapper.handler = handler;
                filterWrapper.handlerParams = handlerParams;
                filterWrapper.handlerGenerator = handlerGenerator;
                delete this.model[colId];
                handler.init?.({ ...handlerParams, source: 'init', model: null });
                // destroy the old handler after creating and assigning the new one in case anything
                // is listening to events on the handler and needs to resubscribe to the new one
                this.destroyBean(oldHandler);
                if (existingModel != null) {
                    this.beans.filterManager?.onFilterChanged({
                        columns: [column],
                        source,
                    });
                }
            }
            else {
                const handlerParams = this.createHandlerParams(column, compDetails?.params);
                // handler exists and is the same
                filterWrapper.handlerParams = handlerParams;
                filterWrapper.handler.refresh?.({
                    ...handlerParams,
                    source: 'colDef',
                    model: existingModel,
                });
            }
        }
        // Case when filter component changes
        // or when filter wrapper does not have promise to retrieve FilterComp, destroy
        if (this.areFilterCompsDifferent(filterWrapper.filterUi?.compDetails ?? null, compDetails) ||
            !filterWrapper.filterUi ||
            !compDetails) {
            this.destroyFilterUi(filterWrapper, column, compDetails, createFilterUi);
            return;
        }
        filterWrapper.filterUi.filterParams = newFilterParams;
        // Otherwise - Check for refresh method before destruction
        // If refresh() method is implemented - call it and destroy filter if it returns false
        // Otherwise - do nothing ( filter will not be destroyed - we assume new params are compatible with old ones )
        (0, columnFilterUtils_1.getFilterUiFromWrapper)(filterWrapper, wasHandler)?.then((filter) => {
            const shouldRefreshFilter = filter?.refresh ? filter.refresh(newFilterParams) : true;
            // framework wrapper always implements optional methods, but returns null if no underlying method
            if (shouldRefreshFilter === false) {
                this.destroyFilterUi(filterWrapper, column, compDetails, createFilterUi);
            }
            else {
                this.dispatchLocalEvent({
                    type: 'filterParamsChanged',
                    column,
                    params: newFilterParams,
                });
            }
        });
    }
    refreshHandlerAndUi(column, model, source, createIfMissing) {
        const filterWrapper = this.cachedFilter(column);
        if (!filterWrapper) {
            if (createIfMissing) {
                // create one. Don't need to refresh as it will be created with the latest details
                this.getOrCreateFilterWrapper(column, true);
            }
            return promise_1.AgPromise.resolve();
        }
        if (!filterWrapper.isHandler) {
            return promise_1.AgPromise.resolve();
        }
        const { filterUi, handler, handlerParams } = filterWrapper;
        return (0, columnFilterUtils_1._refreshHandlerAndUi)(() => {
            if (filterUi) {
                const { created, filterParams } = filterUi;
                if (created) {
                    return filterUi.promise.then((filter) => {
                        return filter ? { filter, filterParams } : undefined;
                    });
                }
                else {
                    filterUi.refreshed = true;
                }
            }
            return promise_1.AgPromise.resolve(undefined);
        }, handler, handlerParams, model, this.state.get(column.getColId()) ?? { model }, source);
    }
    setColumnFilterWrapper(column, filterWrapper) {
        const colId = column.getColId();
        this.allColumnFilters.set(colId, filterWrapper);
        this.allColumnListeners.set(colId, this.addManagedListeners(column, { colDefChanged: () => this.filterParamsChanged(colId) })[0]);
    }
    areFilterCompsDifferent(oldCompDetails, newCompDetails) {
        if (!newCompDetails || !oldCompDetails) {
            return true;
        }
        const { componentClass: oldComponentClass } = oldCompDetails;
        const { componentClass: newComponentClass } = newCompDetails;
        const isSameComponentClass = oldComponentClass === newComponentClass ||
            // react hooks returns new wrappers, so check nested render method
            (oldComponentClass?.render &&
                newComponentClass?.render &&
                oldComponentClass.render === newComponentClass.render);
        return !isSameComponentClass;
    }
    hasFloatingFilters() {
        const gridColumns = this.beans.colModel.getCols();
        return gridColumns.some((col) => col.getColDef().floatingFilter);
    }
    getFilterInstance(key) {
        const column = this.beans.colModel.getColDefCol(key);
        if (!column) {
            return Promise.resolve(undefined);
        }
        const filterPromise = this.getOrCreateFilterUi(column);
        if (!filterPromise) {
            return Promise.resolve(null);
        }
        return new Promise((resolve) => {
            filterPromise.then((filter) => {
                resolve((0, unwrapUserComp_1._unwrapUserComp)(filter));
            });
        });
    }
    processFilterModelUpdateQueue() {
        this.modelUpdates.forEach(({ model, source }) => this.setModel(model, source));
        this.modelUpdates = [];
        this.columnModelUpdates.forEach(({ key, model, resolve }) => {
            this.setModelForColumn(key, model).then(() => resolve());
        });
        this.columnModelUpdates = [];
    }
    getModelForColumn(column, useUnapplied) {
        if (useUnapplied) {
            const { state, model } = this;
            const colId = column.getColId();
            const colState = state.get(colId);
            if (colState) {
                return colState.model ?? null;
            }
            return (0, columnFilterUtils_1._getFilterModel)(model, colId);
        }
        const filterWrapper = this.cachedFilter(column);
        return filterWrapper ? this.getModelFromFilterWrapper(filterWrapper) : null;
    }
    setModelForColumn(key, model) {
        if (this.beans.dataTypeSvc?.isPendingInference) {
            let resolve = () => { };
            const promise = new Promise((res) => {
                resolve = res;
            });
            this.columnModelUpdates.push({ key, model, resolve });
            return promise;
        }
        return new Promise((resolve) => {
            this.setModelForColumnLegacy(key, model).then((result) => resolve(result));
        });
    }
    getStateForColumn(colId) {
        return (this.state.get(colId) ?? {
            model: (0, columnFilterUtils_1._getFilterModel)(this.model, colId),
        });
    }
    setModelForColumnLegacy(key, model) {
        const column = this.beans.colModel.getColDefCol(key);
        const filterWrapper = column ? this.getOrCreateFilterWrapper(column, true) : null;
        return filterWrapper ? this.setModelOnFilterWrapper(filterWrapper, model) : promise_1.AgPromise.resolve();
    }
    setColDefPropsForDataType(colDef, dataTypeDefinition, formatValue) {
        const providedFilter = colDef.filter;
        const filter = providedFilter === true
            ? this.getDefaultFilterFromDataType(() => dataTypeDefinition.baseDataType)
            : providedFilter;
        if (typeof filter !== 'string') {
            return;
        }
        let filterParams;
        let filterValueGetter;
        const beans = this.beans;
        const { filterParams: colDefFilterParams, filterValueGetter: colDefFilterValueGetter } = colDef;
        if (filter === 'agMultiColumnFilter') {
            ({ filterParams, filterValueGetter } =
                beans.multiFilter?.getParamsForDataType(colDefFilterParams, colDefFilterValueGetter, dataTypeDefinition, formatValue) ?? {});
        }
        else {
            ({ filterParams, filterValueGetter } = (0, filterDataTypeUtils_1._getFilterParamsForDataType)(filter, colDefFilterParams, colDefFilterValueGetter, dataTypeDefinition, formatValue, beans, this.getLocaleTextFunc()));
        }
        colDef.filterParams = filterParams;
        if (filterValueGetter) {
            colDef.filterValueGetter = filterValueGetter;
        }
    }
    // additionalEventAttributes is used by provided simple floating filter, so it can add 'floatingFilter=true' to the event
    setColFilterActive(column, active, source, additionalEventAttributes) {
        if (column.filterActive !== active) {
            column.filterActive = active;
            column.dispatchColEvent('filterActiveChanged', source);
        }
        column.dispatchColEvent('filterChanged', source, additionalEventAttributes);
    }
    setModelOnFilterWrapper(filterWrapper, newModel, justCreated) {
        return new promise_1.AgPromise((resolve) => {
            if (filterWrapper.isHandler) {
                const column = filterWrapper.column;
                const colId = column.getColId();
                const existingModel = this.model[colId];
                this.updateStoredModel(colId, newModel);
                if (justCreated && newModel === existingModel) {
                    // don't need to refresh as already has the new model
                    resolve();
                    return;
                }
                this.refreshHandlerAndUi(column, newModel, 'api').then(() => resolve());
                return;
            }
            const uiPromise = (0, columnFilterUtils_1.getFilterUiFromWrapper)(filterWrapper);
            if (uiPromise) {
                uiPromise.then((filter) => {
                    if (typeof filter?.setModel !== 'function') {
                        (0, logging_1._warn)(65);
                        resolve();
                        return;
                    }
                    (filter.setModel(newModel) || promise_1.AgPromise.resolve()).then(() => resolve());
                });
                return;
            }
            // no handler and no filter comp
            resolve();
        });
    }
    /** for handlers only */
    updateStoredModel(colId, model) {
        if ((0, generic_1._exists)(model)) {
            this.model[colId] = model;
        }
        else {
            delete this.model[colId];
        }
        const oldState = this.state.get(colId);
        const newState = {
            model,
            state: oldState?.state,
        };
        this.state.set(colId, newState);
    }
    filterModified(column, additionalEventAttributes) {
        this.getOrCreateFilterUi(column)?.then((filterInstance) => {
            this.eventSvc.dispatchEvent({
                type: 'filterModified',
                column,
                filterInstance,
                ...additionalEventAttributes,
            });
        });
    }
    filterUiChanged(column, additionalEventAttributes) {
        if (this.gos.get('enableFilterHandlers')) {
            this.eventSvc.dispatchEvent({
                type: 'filterUiChanged',
                column,
                ...additionalEventAttributes,
            });
        }
    }
    floatingFilterUiChanged(column, additionalEventAttributes) {
        if (this.gos.get('enableFilterHandlers')) {
            this.eventSvc.dispatchEvent({
                type: 'floatingFilterUiChanged',
                column,
                ...additionalEventAttributes,
            });
        }
    }
    updateModel(column, action, additionalEventAttributes) {
        const colId = column.getColId();
        const getFilterUi = () => this.cachedFilter(column)?.filterUi;
        (0, columnFilterUtils_1._updateFilterModel)(action, getFilterUi, () => (0, columnFilterUtils_1._getFilterModel)(this.model, colId), () => this.state.get(colId), (state) => this.updateState(column, state), (model) => getFilterUi()?.filterParams?.onModelChange(model, additionalEventAttributes));
    }
    updateAllModels(action, additionalEventAttributes) {
        const promises = [];
        this.allColumnFilters.forEach((filter, colId) => {
            const column = this.beans.colModel.getColDefCol(colId);
            if (column) {
                (0, columnFilterUtils_1._updateFilterModel)(action, () => filter.filterUi, () => (0, columnFilterUtils_1._getFilterModel)(this.model, colId), () => this.state.get(colId), (state) => this.updateState(column, state), (model) => {
                    this.updateStoredModel(colId, model);
                    this.dispatchLocalEvent({
                        type: 'filterAction',
                        column,
                        action,
                    });
                    promises.push(this.refreshHandlerAndUi(column, model, 'ui'));
                });
            }
        });
        if (promises.length) {
            promise_1.AgPromise.all(promises).then(() => {
                this.callOnFilterChangedOutsideRenderCycle({
                    source: 'columnFilter',
                    additionalEventAttributes,
                    columns: [],
                });
            });
        }
    }
    updateOrRefreshFilterUi(column) {
        const colId = column.getColId();
        (0, columnFilterUtils_1.getAndRefreshFilterUi)(() => this.cachedFilter(column)?.filterUi, () => (0, columnFilterUtils_1._getFilterModel)(this.model, colId), () => this.state.get(colId));
    }
    updateState(column, state) {
        this.state.set(column.getColId(), state);
        this.dispatchLocalEvent({
            type: 'filterStateChanged',
            column,
            state,
        });
    }
    // for tool panel only
    canApplyAll() {
        const { state, model, activeFilterComps } = this;
        for (const comp of activeFilterComps) {
            if (comp.source === 'COLUMN_MENU') {
                // if open in column menu, can't apply as unapplied state will be cleared when the filter closes
                return false;
            }
        }
        let hasChanges = false;
        for (const colId of state.keys()) {
            const colState = state.get(colId);
            // undefined is true
            if (colState.valid === false) {
                return false;
            }
            if ((colState.model ?? null) !== (0, columnFilterUtils_1._getFilterModel)(model, colId)) {
                hasChanges = true;
            }
        }
        return hasChanges;
    }
    hasUnappliedModel(colId) {
        const { model, state } = this;
        return (state.get(colId)?.model ?? null) !== (0, columnFilterUtils_1._getFilterModel)(model, colId);
    }
    setGlobalButtons(isGlobal) {
        this.isGlobalButtons = isGlobal;
        this.dispatchLocalEvent({
            type: 'filterGlobalButtons',
            isGlobal,
        });
    }
    shouldKeepStateOnDetach(column, lastContainerType) {
        if (lastContainerType === 'newFiltersToolPanel') {
            // don't reset for new filters tool panel
            return true;
        }
        const filterPanelSvc = this.beans.filterPanelSvc;
        if (filterPanelSvc?.isActive) {
            // if in tool panel, then keep
            return !!filterPanelSvc.getState(column.getColId());
        }
        return false;
    }
    destroy() {
        super.destroy();
        this.allColumnFilters.forEach((filterWrapper) => this.disposeFilterWrapper(filterWrapper, 'gridDestroyed'));
        // don't need to destroy the listeners as they are managed listeners
        this.allColumnListeners.clear();
        this.state.clear();
        this.activeFilterComps.clear();
    }
}
exports.ColumnFilterService = ColumnFilterService;


/***/ }),

/***/ 4985:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._getFilterModel = exports._updateFilterModel = exports.getAndRefreshFilterUi = exports._refreshFilterUi = exports._refreshHandlerAndUi = exports.getFilterUiFromWrapper = exports.FILTER_HANDLERS = exports.FILTER_HANDLER_MAP = void 0;
exports.FILTER_HANDLER_MAP = {
    agSetColumnFilter: 'agSetColumnFilterHandler',
    agMultiColumnFilter: 'agMultiColumnFilterHandler',
    agGroupColumnFilter: 'agGroupColumnFilterHandler',
    agNumberColumnFilter: 'agNumberColumnFilterHandler',
    agDateColumnFilter: 'agDateColumnFilterHandler',
    agTextColumnFilter: 'agTextColumnFilterHandler',
};
exports.FILTER_HANDLERS = new Set(Object.values(exports.FILTER_HANDLER_MAP));
function getFilterUiFromWrapper(filterWrapper, skipCreate) {
    const filterUi = filterWrapper.filterUi;
    if (!filterUi) {
        return null;
    }
    if (filterUi.created) {
        return filterUi.promise;
    }
    if (skipCreate) {
        return null;
    }
    const promise = filterUi.create(filterUi.refreshed);
    const createdFilterUi = filterUi;
    createdFilterUi.created = true;
    createdFilterUi.promise = promise;
    return promise;
}
exports.getFilterUiFromWrapper = getFilterUiFromWrapper;
function _refreshHandlerAndUi(getFilterUi, handler, handlerParams, model, state, source) {
    handler.refresh?.({ ...handlerParams, model, source });
    return getFilterUi().then((filterUi) => {
        if (filterUi) {
            const { filter, filterParams } = filterUi;
            _refreshFilterUi(filter, filterParams, model, state, source);
        }
    });
}
exports._refreshHandlerAndUi = _refreshHandlerAndUi;
function _refreshFilterUi(filter, filterParams, model, state, source) {
    filter?.refresh?.({
        ...filterParams,
        model,
        state,
        source,
    });
}
exports._refreshFilterUi = _refreshFilterUi;
function getAndRefreshFilterUi(getFilterUi, getModel, getState) {
    const filterUi = getFilterUi();
    if (filterUi?.created) {
        filterUi.promise.then((filter) => {
            const model = getModel();
            _refreshFilterUi(filter, filterUi.filterParams, model, getState() ?? { model }, 'ui');
        });
    }
}
exports.getAndRefreshFilterUi = getAndRefreshFilterUi;
function _updateFilterModel(action, getFilterUi, getModel, getState, updateState, updateModel) {
    let state;
    let shouldUpdateModel = false;
    let model;
    switch (action) {
        case 'apply': {
            const oldState = getState();
            model = oldState?.model ?? null;
            state = {
                // keep the other UI state
                state: oldState?.state,
                model,
            };
            shouldUpdateModel = true;
            break;
        }
        case 'clear': {
            state = {
                // wipe other UI state
                model: null,
            };
            break;
        }
        case 'reset': {
            state = {
                // wipe other UI state
                model: null,
            };
            shouldUpdateModel = true;
            model = null;
            break;
        }
        case 'cancel': {
            state = {
                // wipe other UI state
                model: getModel(),
            };
            break;
        }
    }
    updateState(state);
    if (shouldUpdateModel) {
        updateModel(model);
    }
    else {
        getAndRefreshFilterUi(getFilterUi, getModel, getState);
    }
}
exports._updateFilterModel = _updateFilterModel;
function _getFilterModel(model, colId) {
    return model[colId] ?? null;
}
exports._getFilterModel = _getFilterModel;


/***/ }),

/***/ 49002:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.onFilterChanged = exports.isAnyFilterPresent = void 0;
function isAnyFilterPresent(beans) {
    return !!beans.filterManager?.isAnyFilterPresent();
}
exports.isAnyFilterPresent = isAnyFilterPresent;
function onFilterChanged(beans, source = 'api') {
    beans.filterManager?.onFilterChanged({ source });
}
exports.onFilterChanged = onFilterChanged;


/***/ }),

/***/ 71371:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FilterButtonComp = void 0;
const keyCode_1 = __webpack_require__(39853);
const dom_1 = __webpack_require__(33507);
const logging_1 = __webpack_require__(47764);
const component_1 = __webpack_require__(78020);
const filterLocaleText_1 = __webpack_require__(75741);
function getElement(className) {
    return {
        tag: 'div',
        cls: className,
    };
}
class FilterButtonComp extends component_1.Component {
    constructor(config) {
        const { className = 'ag-filter-apply-panel' } = config ?? {};
        super(getElement(className));
        this.listeners = [];
        this.className = className;
    }
    updateButtons(buttons, useForm) {
        const oldButtons = this.buttons;
        this.buttons = buttons;
        if (oldButtons === buttons) {
            return;
        }
        const eGui = this.getGui();
        (0, dom_1._clearElement)(eGui);
        let eApplyButton;
        this.destroyListeners();
        // Instead of appending each button to the DOM individually, we create a fragment and append that
        // to the DOM once. This is much faster than appending each button individually.
        const fragment = document.createDocumentFragment();
        const className = this.className;
        const addButton = (type) => {
            const localeKey = `${type}Filter`;
            const text = type ? (0, filterLocaleText_1.translateForFilter)(this, localeKey) : undefined;
            const clickListener = (event) => {
                this.dispatchLocalEvent({
                    type,
                    event,
                });
            };
            if (!['apply', 'clear', 'reset', 'cancel'].includes(type)) {
                (0, logging_1._warn)(75);
            }
            const isApply = type === 'apply';
            const buttonType = isApply && useForm ? 'submit' : 'button';
            const button = (0, dom_1._createElement)({
                tag: 'button',
                attrs: { type: buttonType },
                ref: `${type}FilterButton`,
                cls: `ag-button ag-standard-button ${className}-button${isApply ? ' ' + className + '-apply-button' : ''}`,
                children: text,
            });
            this.activateTabIndex([button]);
            if (isApply) {
                eApplyButton = button;
            }
            const keydownListener = (event) => {
                if (event.key === keyCode_1.KeyCode.ENTER) {
                    // this is needed to ensure a keyboard event is passed through, rather than a click event.
                    // otherwise focus won't be restored if a popup is closed
                    event.preventDefault();
                    clickListener(event);
                }
            };
            const listeners = this.listeners;
            button.addEventListener('click', clickListener);
            listeners.push(() => button.removeEventListener('click', clickListener));
            button.addEventListener('keydown', keydownListener);
            listeners.push(() => button.removeEventListener('keydown', keydownListener));
            fragment.append(button);
        };
        buttons.forEach((type) => addButton(type));
        this.eApply = eApplyButton;
        eGui.append(fragment);
    }
    updateValidity(valid) {
        const eApplyButton = this.eApply;
        if (!eApplyButton) {
            return;
        }
        (0, dom_1._setDisabled)(eApplyButton, valid === false);
    }
    destroyListeners() {
        this.listeners.forEach((destroyFunc) => destroyFunc());
        this.listeners = [];
    }
    destroy() {
        this.destroyListeners();
        super.destroy();
    }
}
exports.FilterButtonComp = FilterButtonComp;


/***/ }),

/***/ 62231:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FilterComp = void 0;
const dom_1 = __webpack_require__(33507);
const generic_1 = __webpack_require__(34422);
const promise_1 = __webpack_require__(57990);
const logging_1 = __webpack_require__(47764);
const component_1 = __webpack_require__(78020);
const filterWrapperComp_1 = __webpack_require__(21854);
const FilterElement = { tag: 'div', cls: 'ag-filter' };
/** Wraps column filters for use in menus, tool panel etc. */
class FilterComp extends component_1.Component {
    constructor(column, source, enableGlobalButtonCheck) {
        super(FilterElement);
        this.column = column;
        this.source = source;
        this.enableGlobalButtonCheck = enableGlobalButtonCheck;
        this.wrapper = null;
    }
    postConstruct() {
        this.beans.colFilter?.activeFilterComps.add(this);
        this.createFilter(true);
        this.addManagedEventListeners({ filterDestroyed: this.onFilterDestroyed.bind(this) });
    }
    hasFilter() {
        return this.wrapper != null;
    }
    getFilter() {
        return this.wrapper?.then((wrapper) => wrapper.comp) ?? null;
    }
    afterInit() {
        return this.wrapper?.then(() => { }) ?? promise_1.AgPromise.resolve();
    }
    afterGuiAttached(params) {
        this.afterGuiAttachedParams = params;
        this.wrapper?.then((wrapper) => {
            this.comp?.afterGuiAttached(params);
            wrapper?.comp?.afterGuiAttached?.(params);
        });
    }
    afterGuiDetached() {
        this.wrapper?.then((wrapper) => {
            wrapper?.comp?.afterGuiDetached?.();
        });
    }
    createFilter(init) {
        const { column, source, beans: { colFilter }, } = this;
        const filterPromise = colFilter.getFilterUiForDisplay(column) ?? null;
        this.wrapper = filterPromise;
        filterPromise?.then((wrapper) => {
            if (!wrapper) {
                return;
            }
            const { isHandler, comp } = wrapper;
            let filterGui;
            if (isHandler) {
                const enableGlobalButtonCheck = !!this.enableGlobalButtonCheck;
                const displayComp = this.createBean(new filterWrapperComp_1.FilterWrapperComp(column, wrapper, colFilter, colFilter.updateModel.bind(colFilter), enableGlobalButtonCheck && colFilter.isGlobalButtons, enableGlobalButtonCheck));
                this.comp = displayComp;
                filterGui = displayComp.getGui();
            }
            else {
                filterGui = comp.getGui();
                if (!(0, generic_1._exists)(filterGui)) {
                    (0, logging_1._warn)(69, { guiFromFilter: filterGui });
                }
            }
            this.appendChild(filterGui);
            if (init) {
                this.eventSvc.dispatchEvent({
                    type: 'filterOpened',
                    column,
                    source,
                    eGui: this.getGui(),
                });
            }
            else {
                // parent is already attached, and switching filter comps, so fire for the new comp
                comp.afterGuiAttached?.(this.afterGuiAttachedParams);
            }
        });
    }
    onFilterDestroyed(event) {
        const { source, column } = event;
        if ((source === 'api' || source === 'paramsUpdated') &&
            column.getId() === this.column.getId() &&
            this.beans.colModel.getColDefCol(this.column)) {
            // filter has been destroyed by the API or params changing. If the column still exists, need to recreate UI component
            (0, dom_1._clearElement)(this.getGui());
            this.comp = this.destroyBean(this.comp);
            this.createFilter();
        }
    }
    destroy() {
        this.beans.colFilter?.activeFilterComps.delete(this);
        this.eventSvc.dispatchEvent({
            type: 'filterClosed',
            column: this.column,
        });
        this.wrapper = null;
        this.comp = this.destroyBean(this.comp);
        this.afterGuiAttachedParams = undefined;
        super.destroy();
    }
}
exports.FilterComp = FilterComp;


/***/ }),

/***/ 26771:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._getDefaultSimpleFilter = exports._getFilterParamsForDataType = void 0;
const date_1 = __webpack_require__(39827);
const generic_1 = __webpack_require__(34422);
const MONTH_LOCALE_TEXT = {
    january: 'January',
    february: 'February',
    march: 'March',
    april: 'April',
    may: 'May',
    june: 'June',
    july: 'July',
    august: 'August',
    september: 'September',
    october: 'October',
    november: 'November',
    december: 'December',
};
const MONTH_KEYS = [
    'january',
    'february',
    'march',
    'april',
    'may',
    'june',
    'july',
    'august',
    'september',
    'october',
    'november',
    'december',
];
function setFilterNumberComparator(a, b) {
    if (a == null) {
        return -1;
    }
    if (b == null) {
        return 1;
    }
    return parseFloat(a) - parseFloat(b);
}
function isValidDate(value) {
    return value instanceof Date && !isNaN(value.getTime());
}
// using an object here to enforce dev to not forget to implement new types as they are added
const filterParamsForEachDataType = {
    number: () => undefined,
    boolean: () => ({
        maxNumConditions: 1,
        debounceMs: 0,
        filterOptions: [
            'empty',
            {
                displayKey: 'true',
                displayName: 'True',
                predicate: (_filterValues, cellValue) => cellValue,
                numberOfInputs: 0,
            },
            {
                displayKey: 'false',
                displayName: 'False',
                predicate: (_filterValues, cellValue) => cellValue === false,
                numberOfInputs: 0,
            },
        ],
    }),
    date: () => ({ isValidDate }),
    dateString: ({ dataTypeDefinition }) => ({
        comparator: (filterDate, cellValue) => {
            const cellAsDate = dataTypeDefinition.dateParser(cellValue);
            if (cellValue == null || cellAsDate < filterDate) {
                return -1;
            }
            if (cellAsDate > filterDate) {
                return 1;
            }
            return 0;
        },
        isValidDate: (value) => typeof value === 'string' &&
            isValidDate(dataTypeDefinition.dateParser(value)),
    }),
    dateTime: (args) => filterParamsForEachDataType.date(args),
    dateTimeString: (args) => filterParamsForEachDataType.dateString(args),
    object: () => undefined,
    text: () => undefined,
};
// using an object here to enforce dev to not forget to implement new types as they are added
const setFilterParamsForEachDataType = {
    number: () => ({ comparator: setFilterNumberComparator }),
    boolean: ({ t }) => ({
        valueFormatter: (params) => (0, generic_1._exists)(params.value) ? t(String(params.value), params.value ? 'True' : 'False') : t('blanks', '(Blanks)'),
    }),
    date: ({ formatValue, t }) => ({
        valueFormatter: (params) => {
            const valueFormatted = formatValue(params);
            return (0, generic_1._exists)(valueFormatted) ? valueFormatted : t('blanks', '(Blanks)');
        },
        treeList: true,
        treeListFormatter: (pathKey, level) => {
            if (pathKey === 'NaN') {
                return t('invalidDate', 'Invalid Date');
            }
            if (level === 1 && pathKey != null) {
                const monthKey = MONTH_KEYS[Number(pathKey) - 1];
                return t(monthKey, MONTH_LOCALE_TEXT[monthKey]);
            }
            return pathKey ?? t('blanks', '(Blanks)');
        },
        treeListPathGetter: (date) => (0, date_1._getDateParts)(date, false),
    }),
    dateString: ({ formatValue, dataTypeDefinition, t }) => ({
        valueFormatter: (params) => {
            const valueFormatted = formatValue(params);
            return (0, generic_1._exists)(valueFormatted) ? valueFormatted : t('blanks', '(Blanks)');
        },
        treeList: true,
        treeListPathGetter: (value) => (0, date_1._getDateParts)(dataTypeDefinition.dateParser(value ?? undefined), false),
        treeListFormatter: (pathKey, level) => {
            if (level === 1 && pathKey != null) {
                const monthKey = MONTH_KEYS[Number(pathKey) - 1];
                return t(monthKey, MONTH_LOCALE_TEXT[monthKey]);
            }
            return pathKey ?? t('blanks', '(Blanks)');
        },
    }),
    dateTime: (args) => {
        const params = setFilterParamsForEachDataType.date(args);
        params.treeListPathGetter = date_1._getDateParts;
        return params;
    },
    dateTimeString(args) {
        const convertToDate = args.dataTypeDefinition.dateParser;
        const params = setFilterParamsForEachDataType.dateString(args);
        params.treeListPathGetter = (value) => (0, date_1._getDateParts)(convertToDate(value ?? undefined));
        return params;
    },
    object: ({ formatValue, t }) => ({
        valueFormatter: (params) => {
            const valueFormatted = formatValue(params);
            return (0, generic_1._exists)(valueFormatted) ? valueFormatted : t('blanks', '(Blanks)');
        },
    }),
    text: () => undefined,
};
function _getFilterParamsForDataType(filter, existingFilterParams, existingFilterValueGetter, dataTypeDefinition, formatValue, beans, translate) {
    let filterParams = existingFilterParams;
    let filterValueGetter = existingFilterValueGetter;
    const usingSetFilter = filter === 'agSetColumnFilter';
    if (!filterValueGetter && dataTypeDefinition.baseDataType === 'object' && !usingSetFilter) {
        filterValueGetter = ({ column, node }) => formatValue({ column, node, value: beans.valueSvc.getValue(column, node) });
    }
    const filterParamsMap = usingSetFilter ? setFilterParamsForEachDataType : filterParamsForEachDataType;
    const filterParamsGetter = filterParamsMap[dataTypeDefinition.baseDataType];
    const newFilterParams = filterParamsGetter({ dataTypeDefinition, formatValue, t: translate });
    filterParams =
        typeof existingFilterParams === 'object'
            ? {
                ...newFilterParams,
                ...existingFilterParams,
            }
            : newFilterParams;
    return { filterParams, filterValueGetter };
}
exports._getFilterParamsForDataType = _getFilterParamsForDataType;
const defaultFilters = {
    boolean: 'agTextColumnFilter',
    date: 'agDateColumnFilter',
    dateString: 'agDateColumnFilter',
    dateTime: 'agDateColumnFilter',
    dateTimeString: 'agDateColumnFilter',
    number: 'agNumberColumnFilter',
    object: 'agTextColumnFilter',
    text: 'agTextColumnFilter',
};
const defaultFloatingFilters = {
    boolean: 'agTextColumnFloatingFilter',
    date: 'agDateColumnFloatingFilter',
    dateString: 'agDateColumnFloatingFilter',
    dateTime: 'agDateColumnFloatingFilter',
    dateTimeString: 'agDateColumnFloatingFilter',
    number: 'agNumberColumnFloatingFilter',
    object: 'agTextColumnFloatingFilter',
    text: 'agTextColumnFloatingFilter',
};
function _getDefaultSimpleFilter(cellDataType, isFloating = false) {
    const filterSet = isFloating ? defaultFloatingFilters : defaultFilters;
    return filterSet[cellDataType ?? 'text'];
}
exports._getDefaultSimpleFilter = _getDefaultSimpleFilter;


/***/ }),

/***/ 75741:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.translateForFilter = void 0;
const localeUtils_1 = __webpack_require__(87230);
const FILTER_LOCALE_TEXT = {
    applyFilter: 'Apply',
    clearFilter: 'Clear',
    resetFilter: 'Reset',
    cancelFilter: 'Cancel',
    textFilter: 'Text Filter',
    numberFilter: 'Number Filter',
    dateFilter: 'Date Filter',
    setFilter: 'Set Filter',
    filterOoo: 'Filter...',
    empty: 'Choose one',
    equals: 'Equals',
    notEqual: 'Does not equal',
    lessThan: 'Less than',
    greaterThan: 'Greater than',
    inRange: 'Between',
    inRangeStart: 'From',
    inRangeEnd: 'To',
    lessThanOrEqual: 'Less than or equal to',
    greaterThanOrEqual: 'Greater than or equal to',
    contains: 'Contains',
    notContains: 'Does not contain',
    startsWith: 'Begins with',
    endsWith: 'Ends with',
    blank: 'Blank',
    notBlank: 'Not blank',
    before: 'Before',
    after: 'After',
    andCondition: 'AND',
    orCondition: 'OR',
    dateFormatOoo: 'yyyy-mm-dd',
    filterSummaryInactive: 'is (All)',
    filterSummaryContains: 'contains',
    filterSummaryNotContains: 'does not contain',
    filterSummaryTextEquals: 'equals',
    filterSummaryTextNotEqual: 'does not equal',
    filterSummaryStartsWith: 'begins with',
    filterSummaryEndsWith: 'ends with',
    filterSummaryBlank: 'is blank',
    filterSummaryNotBlank: 'is not blank',
    filterSummaryEquals: '=',
    filterSummaryNotEqual: '!=',
    filterSummaryGreaterThan: '>',
    filterSummaryGreaterThanOrEqual: '>=',
    filterSummaryLessThan: '<',
    filterSummaryLessThanOrEqual: '<=',
    filterSummaryInRange: 'between',
    filterSummaryInRangeValues: (variableValues) => `(${variableValues[0]}, ${variableValues[1]})`,
    filterSummaryTextQuote: (variableValues) => `"${variableValues[0]}"`,
};
function translateForFilter(bean, key, variableValues) {
    return (0, localeUtils_1._translate)(bean, FILTER_LOCALE_TEXT, key, variableValues);
}
exports.translateForFilter = translateForFilter;


/***/ }),

/***/ 58681:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FilterManager = void 0;
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const object_1 = __webpack_require__(6996);
const promise_1 = __webpack_require__(57990);
const logging_1 = __webpack_require__(47764);
class FilterManager extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'filterManager';
        // when we're waiting for cell data types to be inferred, we need to defer filter model updates
        this.advFilterModelUpdateQueue = [];
    }
    wireBeans(beans) {
        this.quickFilter = beans.quickFilter;
        this.advancedFilter = beans.advancedFilter;
        this.colFilter = beans.colFilter;
    }
    postConstruct() {
        const refreshFiltersForAggregations = this.refreshFiltersForAggregations.bind(this);
        const updateAdvFilterColumns = this.updateAdvFilterColumns.bind(this);
        this.addManagedEventListeners({
            columnValueChanged: refreshFiltersForAggregations,
            columnPivotChanged: refreshFiltersForAggregations,
            columnPivotModeChanged: refreshFiltersForAggregations,
            newColumnsLoaded: updateAdvFilterColumns,
            columnVisible: updateAdvFilterColumns,
            advancedFilterEnabledChanged: ({ enabled }) => this.onAdvFilterEnabledChanged(enabled),
            dataTypesInferred: this.processFilterModelUpdateQueue.bind(this),
        });
        this.externalFilterPresent = this.isExternalFilterPresentCallback();
        this.addManagedPropertyListeners(['isExternalFilterPresent', 'doesExternalFilterPass'], () => {
            this.onFilterChanged({ source: 'api' });
        });
        this.updateAggFiltering();
        this.addManagedPropertyListener('groupAggFiltering', () => {
            this.updateAggFiltering();
            this.onFilterChanged();
        });
        if (this.quickFilter) {
            this.addManagedListeners(this.quickFilter, {
                quickFilterChanged: () => this.onFilterChanged({ source: 'quickFilter' }),
            });
        }
        const { gos } = this;
        this.alwaysPassFilter = gos.get('alwaysPassFilter');
        this.addManagedPropertyListener('alwaysPassFilter', () => {
            this.alwaysPassFilter = gos.get('alwaysPassFilter');
            this.onFilterChanged({ source: 'api' });
        });
    }
    isExternalFilterPresentCallback() {
        const isFilterPresent = this.gos.getCallback('isExternalFilterPresent');
        return typeof isFilterPresent === 'function' && isFilterPresent({});
    }
    doesExternalFilterPass(node) {
        const doesFilterPass = this.gos.get('doesExternalFilterPass');
        return typeof doesFilterPass === 'function' && doesFilterPass(node);
    }
    setFilterState(model, state, source = 'api') {
        if (this.isAdvFilterEnabled()) {
            return;
        }
        this.colFilter?.setState(model, state, source);
    }
    setFilterModel(model, source = 'api', skipWarning) {
        if (this.isAdvFilterEnabled()) {
            if (!skipWarning) {
                this.warnAdvFilters();
            }
            return;
        }
        this.colFilter?.setModel(model, source);
    }
    getFilterModel() {
        return this.colFilter?.getModel() ?? {};
    }
    getFilterState() {
        return this.colFilter?.getState();
    }
    isColumnFilterPresent() {
        return !!this.colFilter?.isFilterPresent();
    }
    isAggregateFilterPresent() {
        return !!this.colFilter?.isAggFilterPresent();
    }
    isChildFilterPresent() {
        return (this.isColumnFilterPresent() ||
            this.isQuickFilterPresent() ||
            this.externalFilterPresent ||
            this.isAdvFilterPresent());
    }
    isAnyFilterPresent() {
        return this.isChildFilterPresent() || this.isAggregateFilterPresent();
    }
    isAdvFilterPresent() {
        return this.isAdvFilterEnabled() && this.advancedFilter.isFilterPresent();
    }
    onAdvFilterEnabledChanged(enabled) {
        if (enabled) {
            if (this.colFilter?.disableFilters()) {
                this.onFilterChanged({ source: 'advancedFilter' });
            }
        }
        else {
            if (this.advancedFilter?.isFilterPresent()) {
                this.advancedFilter.setModel(null);
                this.onFilterChanged({ source: 'advancedFilter' });
            }
        }
    }
    isAdvFilterEnabled() {
        return !!this.advancedFilter?.isEnabled();
    }
    isAdvFilterHeaderActive() {
        return this.isAdvFilterEnabled() && this.advancedFilter.isHeaderActive();
    }
    refreshFiltersForAggregations() {
        const isAggFiltering = (0, gridOptionsUtils_1._getGroupAggFiltering)(this.gos);
        if (isAggFiltering) {
            this.onFilterChanged();
        }
    }
    onFilterChanged(params = {}) {
        const { source, additionalEventAttributes, columns = [] } = params;
        this.externalFilterPresent = this.isExternalFilterPresentCallback();
        (this.colFilter ? this.colFilter.updateBeforeFilterChanged(params) : promise_1.AgPromise.resolve()).then(() => {
            const filterChangedEvent = {
                source,
                type: 'filterChanged',
                columns,
            };
            if (additionalEventAttributes) {
                (0, object_1._mergeDeep)(filterChangedEvent, additionalEventAttributes);
            }
            this.eventSvc.dispatchEvent(filterChangedEvent);
            this.colFilter?.updateAfterFilterChanged();
        });
    }
    isSuppressFlashingCellsBecauseFiltering() {
        return !!this.colFilter?.isSuppressFlashingCellsBecauseFiltering();
    }
    isQuickFilterPresent() {
        return !!this.quickFilter?.isFilterPresent();
    }
    updateAggFiltering() {
        this.aggFiltering = !!(0, gridOptionsUtils_1._getGroupAggFiltering)(this.gos);
    }
    isAggregateQuickFilterPresent() {
        return this.isQuickFilterPresent() && this.shouldApplyQuickFilterAfterAgg();
    }
    isNonAggregateQuickFilterPresent() {
        return this.isQuickFilterPresent() && !this.shouldApplyQuickFilterAfterAgg();
    }
    shouldApplyQuickFilterAfterAgg() {
        return ((this.aggFiltering || this.beans.colModel.isPivotMode()) &&
            !this.gos.get('applyQuickFilterBeforePivotOrAgg'));
    }
    doesRowPassOtherFilters(colIdToSkip, rowNode) {
        return this.doesRowPassFilter({ rowNode, colIdToSkip });
    }
    doesRowPassAggregateFilters(params) {
        const { rowNode } = params;
        if (this.alwaysPassFilter?.(rowNode)) {
            return true;
        }
        // check quick filter
        if (this.isAggregateQuickFilterPresent() && !this.quickFilter.doesRowPass(rowNode)) {
            return false;
        }
        if (this.isAggregateFilterPresent() && !this.colFilter.doFiltersPass(rowNode, params.colIdToSkip, true)) {
            return false;
        }
        // got this far, all filters pass
        return true;
    }
    doesRowPassFilter(params) {
        const { rowNode } = params;
        if (this.alwaysPassFilter?.(rowNode)) {
            return true;
        }
        // the row must pass ALL of the filters, so if any of them fail,
        // we return true. that means if a row passes the quick filter,
        // but fails the column filter, it fails overall
        // first up, check quick filter
        if (this.isNonAggregateQuickFilterPresent() && !this.quickFilter.doesRowPass(rowNode)) {
            return false;
        }
        // secondly, give the client a chance to reject this row
        if (this.externalFilterPresent && !this.doesExternalFilterPass(rowNode)) {
            return false;
        }
        // lastly, check column filter
        if (this.isColumnFilterPresent() && !this.colFilter.doFiltersPass(rowNode, params.colIdToSkip)) {
            return false;
        }
        if (this.isAdvFilterPresent() && !this.advancedFilter.doesFilterPass(rowNode)) {
            return false;
        }
        // got this far, all filters pass
        return true;
    }
    // for group filters, can change dynamically whether they are allowed or not
    isFilterAllowed(column) {
        if (this.isAdvFilterEnabled()) {
            return false;
        }
        return !!this.colFilter?.isFilterAllowed(column);
    }
    getAdvFilterModel() {
        return this.isAdvFilterEnabled() ? this.advancedFilter.getModel() : null;
    }
    setAdvFilterModel(expression, source = 'api') {
        if (!this.isAdvFilterEnabled()) {
            return;
        }
        if (this.beans.dataTypeSvc?.isPendingInference) {
            this.advFilterModelUpdateQueue.push(expression);
            return;
        }
        this.advancedFilter.setModel(expression ?? null);
        this.onFilterChanged({ source });
    }
    toggleAdvFilterBuilder(show, source) {
        if (!this.isAdvFilterEnabled()) {
            return;
        }
        this.advancedFilter.getCtrl().toggleFilterBuilder({ source, force: show });
    }
    updateAdvFilterColumns() {
        if (!this.isAdvFilterEnabled()) {
            return;
        }
        if (this.advancedFilter.updateValidity()) {
            this.onFilterChanged({ source: 'advancedFilter' });
        }
    }
    hasFloatingFilters() {
        if (this.isAdvFilterEnabled()) {
            return false;
        }
        return !!this.colFilter?.hasFloatingFilters();
    }
    getColumnFilterInstance(key) {
        if (this.isAdvFilterEnabled()) {
            this.warnAdvFilters();
            return Promise.resolve(undefined);
        }
        return this.colFilter?.getFilterInstance(key) ?? Promise.resolve(undefined);
    }
    warnAdvFilters() {
        // Column Filter API methods have been disabled as Advanced Filters are enabled
        (0, logging_1._warn)(68);
    }
    setupAdvFilterHeaderComp(eCompToInsertBefore) {
        this.advancedFilter?.getCtrl().setupHeaderComp(eCompToInsertBefore);
    }
    getHeaderRowCount() {
        return this.isAdvFilterHeaderActive() ? 1 : 0;
    }
    getHeaderHeight() {
        return this.isAdvFilterHeaderActive() ? this.advancedFilter.getCtrl().getHeaderHeight() : 0;
    }
    processFilterModelUpdateQueue() {
        this.advFilterModelUpdateQueue.forEach((model) => this.setAdvFilterModel(model));
        this.advFilterModelUpdateQueue = [];
    }
    setColumnFilterModel(key, model) {
        if (this.isAdvFilterEnabled()) {
            this.warnAdvFilters();
            return Promise.resolve();
        }
        return this.colFilter?.setModelForColumn(key, model) ?? Promise.resolve();
    }
}
exports.FilterManager = FilterManager;


/***/ }),

/***/ 89665:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FilterMenuFactory = void 0;
const keyCode_1 = __webpack_require__(39853);
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const menuService_1 = __webpack_require__(8994);
const dom_1 = __webpack_require__(33507);
const focus_1 = __webpack_require__(82331);
const logging_1 = __webpack_require__(47764);
const filterComp_1 = __webpack_require__(62231);
class FilterMenuFactory extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'filterMenuFactory';
    }
    wireBeans(beans) {
        this.popupSvc = beans.popupSvc;
    }
    hideActiveMenu() {
        this.hidePopup?.();
    }
    showMenuAfterMouseEvent(column, mouseEvent, containerType, onClosedCallback) {
        if (column && !column.isColumn) {
            // not supported
            return;
        }
        this.showPopup(column, (eMenu) => {
            this.popupSvc?.positionPopupUnderMouseEvent({
                column,
                type: containerType,
                mouseEvent,
                ePopup: eMenu,
            });
        }, containerType, mouseEvent.target, (0, gridOptionsUtils_1._isLegacyMenuEnabled)(this.gos), onClosedCallback);
    }
    showMenuAfterButtonClick(column, eventSource, containerType, onClosedCallback) {
        if (column && !column.isColumn) {
            // not supported
            return;
        }
        let multiplier = -1;
        let alignSide = 'left';
        const isLegacyMenuEnabled = (0, gridOptionsUtils_1._isLegacyMenuEnabled)(this.gos);
        if (!isLegacyMenuEnabled && this.gos.get('enableRtl')) {
            multiplier = 1;
            alignSide = 'right';
        }
        const nudgeX = isLegacyMenuEnabled ? undefined : 4 * multiplier;
        const nudgeY = isLegacyMenuEnabled ? undefined : 4;
        this.showPopup(column, (eMenu) => {
            this.popupSvc?.positionPopupByComponent({
                type: containerType,
                eventSource,
                ePopup: eMenu,
                nudgeX,
                nudgeY,
                alignSide,
                keepWithinBounds: true,
                position: 'under',
                column,
            });
        }, containerType, eventSource, isLegacyMenuEnabled, onClosedCallback);
    }
    showPopup(column, positionCallback, containerType, eventSource, isLegacyMenuEnabled, onClosedCallback) {
        const comp = column ? this.createBean(new filterComp_1.FilterComp(column, 'COLUMN_MENU')) : undefined;
        this.activeMenu = comp;
        if (!comp?.hasFilter() || !column) {
            (0, logging_1._error)(57);
            return;
        }
        const eMenu = (0, dom_1._createElement)({
            tag: 'div',
            cls: `ag-menu${!isLegacyMenuEnabled ? ' ag-filter-menu' : ''}`,
            role: 'presentation',
        });
        [this.tabListener] = this.addManagedElementListeners(eMenu, {
            keydown: (e) => this.trapFocusWithin(e, eMenu),
        });
        // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
        eMenu.appendChild(comp?.getGui());
        let hidePopup;
        const afterGuiDetached = () => comp?.afterGuiDetached();
        const anchorToElement = (0, gridOptionsUtils_1._isColumnMenuAnchoringEnabled)(this.gos)
            ? eventSource ?? this.beans.ctrlsSvc.getGridBodyCtrl().eGridBody
            : undefined;
        const closedCallback = (e) => {
            (0, menuService_1._setColMenuVisible)(column, false, 'contextMenu');
            const isKeyboardEvent = e instanceof KeyboardEvent;
            if (this.tabListener) {
                this.tabListener = this.tabListener();
            }
            if (isKeyboardEvent && eventSource && (0, dom_1._isVisible)(eventSource)) {
                const focusableEl = (0, focus_1._findTabbableParent)(eventSource);
                focusableEl?.focus({ preventScroll: true });
            }
            afterGuiDetached();
            this.destroyBean(this.activeMenu);
            this.dispatchVisibleChangedEvent(false, containerType, column);
            onClosedCallback?.();
        };
        const translate = this.getLocaleTextFunc();
        const ariaLabel = isLegacyMenuEnabled && containerType !== 'columnFilter'
            ? translate('ariaLabelColumnMenu', 'Column Menu')
            : translate('ariaLabelColumnFilter', 'Column Filter');
        const addPopupRes = this.popupSvc?.addPopup({
            modal: true,
            eChild: eMenu,
            closeOnEsc: true,
            closedCallback,
            positionCallback: () => positionCallback(eMenu),
            anchorToElement,
            ariaLabel,
        });
        if (addPopupRes) {
            this.hidePopup = hidePopup = addPopupRes.hideFunc;
        }
        comp.afterInit().then(() => {
            // need to make sure the filter is present before positioning, as only
            // after filter it is visible can we find out what the width of it is
            positionCallback(eMenu);
            comp.afterGuiAttached({ container: containerType, hidePopup });
        });
        (0, menuService_1._setColMenuVisible)(column, true, 'contextMenu');
        this.dispatchVisibleChangedEvent(true, containerType, column);
    }
    trapFocusWithin(e, menu) {
        if (e.key !== keyCode_1.KeyCode.TAB ||
            e.defaultPrevented ||
            (0, focus_1._findNextFocusableElement)(this.beans, menu, false, e.shiftKey)) {
            return;
        }
        e.preventDefault();
        (0, focus_1._focusInto)(menu, e.shiftKey);
    }
    dispatchVisibleChangedEvent(visible, containerType, column) {
        this.eventSvc.dispatchEvent({
            type: 'columnMenuVisibleChanged',
            visible,
            switchingTab: false,
            key: containerType,
            column: column ?? null,
            columnGroup: null,
        });
    }
    isMenuEnabled(column) {
        // for standard, we show menu if filter is enabled, and the menu is not suppressed by passing an empty array
        return column.isFilterAllowed() && (column.getColDef().menuTabs ?? ['filterMenuTab']).includes('filterMenuTab');
    }
    showMenuAfterContextMenuEvent() {
        // not supported in standard menu
    }
    destroy() {
        this.destroyBean(this.activeMenu);
        super.destroy();
    }
}
exports.FilterMenuFactory = FilterMenuFactory;


/***/ }),

/***/ 45432:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExternalFilterModule = exports.QuickFilterModule = exports.DateFilterModule = exports.NumberFilterModule = exports.TextFilterModule = exports.CustomFilterModule = exports.ColumnFilterModule = exports.FilterValueModule = exports.FilterCoreModule = exports.ClientSideRowModelFilterModule = void 0;
const filterStage_1 = __webpack_require__(48287);
const headerFilterCellCtrl_1 = __webpack_require__(33868);
const sharedMenuModule_1 = __webpack_require__(23472);
const version_1 = __webpack_require__(97205);
const popupModule_1 = __webpack_require__(3137);
const column_filters_css_GENERATED_1 = __webpack_require__(36331);
const columnFilterApi_1 = __webpack_require__(46908);
const columnFilterService_1 = __webpack_require__(40219);
const filterApi_1 = __webpack_require__(49002);
const filterManager_1 = __webpack_require__(58681);
const filterMenuFactory_1 = __webpack_require__(89665);
const filterValueService_1 = __webpack_require__(63508);
const readOnlyFloatingFilter_1 = __webpack_require__(36657);
const dateFilter_1 = __webpack_require__(83725);
const dateFilterHandler_1 = __webpack_require__(46977);
const dateFloatingFilter_1 = __webpack_require__(23091);
const defaultDateComponent_1 = __webpack_require__(75459);
const numberFilter_1 = __webpack_require__(56607);
const numberFilterHandler_1 = __webpack_require__(42927);
const numberFloatingFilter_1 = __webpack_require__(64789);
const textFilter_1 = __webpack_require__(42811);
const textFilterHandler_1 = __webpack_require__(54259);
const textFloatingFilter_1 = __webpack_require__(38305);
const quickFilterApi_1 = __webpack_require__(5381);
const quickFilterService_1 = __webpack_require__(91238);
/**
 * @internal
 */
exports.ClientSideRowModelFilterModule = {
    moduleName: 'ClientSideRowModelFilter',
    version: version_1.VERSION,
    rowModels: ['clientSide'],
    beans: [filterStage_1.FilterStage],
};
/**
 * @internal
 */
exports.FilterCoreModule = {
    moduleName: 'FilterCore',
    version: version_1.VERSION,
    beans: [filterManager_1.FilterManager],
    apiFunctions: {
        isAnyFilterPresent: filterApi_1.isAnyFilterPresent,
        onFilterChanged: filterApi_1.onFilterChanged,
    },
    css: [column_filters_css_GENERATED_1.columnFiltersCSS],
    dependsOn: [exports.ClientSideRowModelFilterModule],
};
/**
 * @internal
 */
exports.FilterValueModule = {
    moduleName: 'FilterValue',
    version: version_1.VERSION,
    beans: [filterValueService_1.FilterValueService],
};
/**
 * @internal
 */
exports.ColumnFilterModule = {
    moduleName: 'ColumnFilter',
    version: version_1.VERSION,
    beans: [columnFilterService_1.ColumnFilterService, filterMenuFactory_1.FilterMenuFactory],
    dynamicBeans: { headerFilterCellCtrl: headerFilterCellCtrl_1.HeaderFilterCellCtrl },
    icons: {
        // open filter button - header, floating filter, menu
        filter: 'filter',
        // filter is applied - header (legacy column menu), filter tool panel
        filterActive: 'filter',
    },
    apiFunctions: {
        isColumnFilterPresent: columnFilterApi_1.isColumnFilterPresent,
        getColumnFilterInstance: columnFilterApi_1.getColumnFilterInstance,
        destroyFilter: columnFilterApi_1.destroyFilter,
        setFilterModel: columnFilterApi_1.setFilterModel,
        getFilterModel: columnFilterApi_1.getFilterModel,
        getColumnFilterModel: columnFilterApi_1.getColumnFilterModel,
        setColumnFilterModel: columnFilterApi_1.setColumnFilterModel,
        showColumnFilter: columnFilterApi_1.showColumnFilter,
        getColumnFilterHandler: columnFilterApi_1.getColumnFilterHandler,
        doFilterAction: columnFilterApi_1.doFilterAction,
    },
    dependsOn: [exports.FilterCoreModule, popupModule_1.PopupModule, exports.FilterValueModule, sharedMenuModule_1.SharedMenuModule],
};
/**
 * @feature Filtering -> Custom Column Filters
 */
exports.CustomFilterModule = {
    moduleName: 'CustomFilter',
    version: version_1.VERSION,
    userComponents: { agReadOnlyFloatingFilter: readOnlyFloatingFilter_1.ReadOnlyFloatingFilter },
    dependsOn: [exports.ColumnFilterModule],
};
/**
 * @feature Filtering -> Text Filter
 */
exports.TextFilterModule = {
    moduleName: 'TextFilter',
    version: version_1.VERSION,
    dependsOn: [exports.ColumnFilterModule],
    userComponents: {
        agTextColumnFilter: {
            classImp: textFilter_1.TextFilter,
            params: {
                useForm: true,
            },
        },
        agTextColumnFloatingFilter: textFloatingFilter_1.TextFloatingFilter,
    },
    dynamicBeans: {
        agTextColumnFilterHandler: textFilterHandler_1.TextFilterHandler,
    },
};
/**
 * @feature Filtering -> Number Filter
 */
exports.NumberFilterModule = {
    moduleName: 'NumberFilter',
    version: version_1.VERSION,
    dependsOn: [exports.ColumnFilterModule],
    userComponents: {
        agNumberColumnFilter: {
            classImp: numberFilter_1.NumberFilter,
            params: {
                useForm: true,
            },
        },
        agNumberColumnFloatingFilter: numberFloatingFilter_1.NumberFloatingFilter,
    },
    dynamicBeans: {
        agNumberColumnFilterHandler: numberFilterHandler_1.NumberFilterHandler,
    },
};
/**
 * @feature Filtering -> Date Filter
 */
exports.DateFilterModule = {
    moduleName: 'DateFilter',
    version: version_1.VERSION,
    dependsOn: [exports.ColumnFilterModule],
    userComponents: {
        agDateColumnFilter: {
            classImp: dateFilter_1.DateFilter,
            params: {
                useForm: true,
            },
        },
        agDateInput: defaultDateComponent_1.DefaultDateComponent,
        agDateColumnFloatingFilter: dateFloatingFilter_1.DateFloatingFilter,
    },
    dynamicBeans: {
        agDateColumnFilterHandler: dateFilterHandler_1.DateFilterHandler,
    },
};
/**
 * @internal
 */
const QuickFilterCoreModule = {
    moduleName: 'QuickFilterCore',
    version: version_1.VERSION,
    rowModels: ['clientSide'],
    beans: [quickFilterService_1.QuickFilterService],
    dependsOn: [exports.FilterCoreModule, exports.FilterValueModule],
};
/**
 * @feature Filtering -> Quick Filter
 * @gridOption quickFilterText
 */
exports.QuickFilterModule = {
    moduleName: 'QuickFilter',
    version: version_1.VERSION,
    apiFunctions: {
        isQuickFilterPresent: quickFilterApi_1.isQuickFilterPresent,
        getQuickFilter: quickFilterApi_1.getQuickFilter,
        resetQuickFilter: quickFilterApi_1.resetQuickFilter,
    },
    dependsOn: [QuickFilterCoreModule],
};
/**
 * @feature Filtering -> External Filter
 * @gridOption doesExternalFilterPass
 */
exports.ExternalFilterModule = {
    moduleName: 'ExternalFilter',
    version: version_1.VERSION,
    dependsOn: [exports.FilterCoreModule],
};


/***/ }),

/***/ 63508:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FilterValueService = void 0;
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
class FilterValueService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'filterValueSvc';
    }
    getValue(column, rowNode, filterValueGetterOverride) {
        if (!rowNode) {
            return;
        }
        const colDef = column.getColDef();
        const { selectableFilter, valueSvc } = this.beans;
        const filterValueGetter = filterValueGetterOverride ??
            selectableFilter?.getFilterValueGetter(column.getColId()) ??
            colDef.filterValueGetter;
        if (filterValueGetter) {
            return this.executeFilterValueGetter(filterValueGetter, rowNode.data, column, rowNode, colDef);
        }
        return valueSvc.getValue(column, rowNode);
    }
    executeFilterValueGetter(
    // eslint-disable-next-line @typescript-eslint/ban-types
    valueGetter, data, column, node, colDef) {
        const { expressionSvc, valueSvc } = this.beans;
        const params = (0, gridOptionsUtils_1._addGridCommonParams)(this.gos, {
            data,
            node,
            column,
            colDef,
            getValue: valueSvc.getValueCallback.bind(valueSvc, node),
        });
        if (typeof valueGetter === 'function') {
            return valueGetter(params);
        }
        return expressionSvc?.evaluate(valueGetter, params);
    }
}
exports.FilterValueService = FilterValueService;


/***/ }),

/***/ 21854:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FilterWrapperComp = void 0;
const keyCode_1 = __webpack_require__(39853);
const dom_1 = __webpack_require__(33507);
const generic_1 = __webpack_require__(34422);
const component_1 = __webpack_require__(78020);
const filterButtonComp_1 = __webpack_require__(71371);
const providedFilterUtils_1 = __webpack_require__(96808);
/** Used with filter handlers. This adds filter buttons. */
class FilterWrapperComp extends component_1.Component {
    constructor(column, wrapper, eventParent, updateModel, isGlobalButtons, enableGlobalButtonCheck) {
        super();
        this.column = column;
        this.wrapper = wrapper;
        this.eventParent = eventParent;
        this.updateModel = updateModel;
        this.isGlobalButtons = isGlobalButtons;
        this.enableGlobalButtonCheck = enableGlobalButtonCheck;
        this.hidePopup = null;
        this.applyActive = false;
    }
    postConstruct() {
        const { comp, params: originalParams } = this.wrapper;
        const params = originalParams;
        const useForm = params.useForm;
        const tag = useForm ? 'form' : 'div';
        this.setTemplate({
            tag,
            cls: 'ag-filter-wrapper',
        });
        if (useForm) {
            this.addManagedElementListeners(this.getGui(), {
                submit: (e) => {
                    e?.preventDefault();
                },
                keydown: this.handleKeyDown.bind(this),
            });
        }
        this.appendChild(comp.getGui());
        this.params = params;
        this.resetButtonsPanel(params);
        this.addManagedListeners(this.eventParent, {
            filterParamsChanged: ({ column, params: eventParams }) => {
                if (column === this.column) {
                    this.resetButtonsPanel(eventParams, this.params);
                }
            },
            filterStateChanged: ({ column, state }) => {
                if (column === this.column) {
                    this.eButtons?.updateValidity(state.valid);
                }
            },
            filterAction: ({ column, action, event: keyboardEvent }) => {
                if (column === this.column) {
                    this.afterAction(action, keyboardEvent);
                }
            },
            ...(this.enableGlobalButtonCheck
                ? {
                    filterGlobalButtons: ({ isGlobal }) => {
                        if (isGlobal !== this.isGlobalButtons) {
                            this.isGlobalButtons = isGlobal;
                            const currentParams = this.params;
                            this.resetButtonsPanel(currentParams, currentParams, true);
                        }
                    },
                }
                : undefined),
        });
    }
    afterGuiAttached(params) {
        if (params) {
            this.hidePopup = params.hidePopup;
        }
    }
    resetButtonsPanel(newParams, oldParams, forceUpdate) {
        const { buttons: oldButtons, readOnly: oldReadOnly } = oldParams ?? {};
        const { buttons, readOnly, useForm } = newParams;
        if (!forceUpdate && oldReadOnly === readOnly && (0, generic_1._jsonEquals)(oldButtons, buttons)) {
            return;
        }
        const hasButtons = buttons && buttons.length > 0 && !newParams.readOnly && !this.isGlobalButtons;
        let eButtonsPanel = this.eButtons;
        if (hasButtons) {
            this.applyActive = (0, providedFilterUtils_1._isUseApplyButton)(this.params);
            if (!eButtonsPanel) {
                eButtonsPanel = this.createBean(new filterButtonComp_1.FilterButtonComp());
                this.appendChild(eButtonsPanel.getGui());
                const column = this.column;
                const getListener = (action) => ({ event }) => {
                    this.updateModel(column, action);
                    this.afterAction(action, event);
                };
                eButtonsPanel?.addManagedListeners(eButtonsPanel, {
                    apply: getListener('apply'),
                    clear: getListener('clear'),
                    reset: getListener('reset'),
                    cancel: getListener('cancel'),
                });
                this.eButtons = eButtonsPanel;
            }
            eButtonsPanel.updateButtons(buttons, useForm);
        }
        else {
            this.applyActive = false;
            if (eButtonsPanel) {
                (0, dom_1._removeFromParent)(eButtonsPanel.getGui());
                this.eButtons = this.destroyBean(eButtonsPanel);
            }
        }
    }
    close(e) {
        const hidePopup = this.hidePopup;
        if (!hidePopup) {
            return;
        }
        const keyboardEvent = e;
        const key = keyboardEvent && keyboardEvent.key;
        let params;
        if (key === keyCode_1.KeyCode.ENTER || key === keyCode_1.KeyCode.SPACE) {
            params = { keyboardEvent };
        }
        hidePopup(params);
        this.hidePopup = null;
    }
    afterAction(action, event) {
        const { params, applyActive } = this;
        const closeOnApply = params?.closeOnApply;
        switch (action) {
            case 'apply': {
                // Prevent form submission
                event?.preventDefault();
                if (closeOnApply && applyActive) {
                    this.close(event);
                }
                break;
            }
            case 'reset': {
                if (closeOnApply && applyActive) {
                    this.close();
                }
                break;
            }
            case 'cancel': {
                if (closeOnApply) {
                    this.close(event);
                }
                break;
            }
        }
    }
    handleKeyDown(event) {
        if (!event.defaultPrevented && event.key === keyCode_1.KeyCode.ENTER && this.applyActive) {
            // trigger apply. Can't do this via form submit as it will use click event, which prevents restoring focus on close
            this.updateModel(this.column, 'apply');
            this.afterAction('apply', event);
        }
    }
    destroy() {
        this.hidePopup = null;
        this.eButtons = this.destroyBean(this.eButtons);
    }
}
exports.FilterWrapperComp = FilterWrapperComp;


/***/ }),

/***/ 59990:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._getDefaultFloatingFilterType = void 0;
const userCompUtils_1 = __webpack_require__(12036);
function _getDefaultFloatingFilterType(frameworkOverrides, def, getFromDefault) {
    if (def == null) {
        return null;
    }
    let defaultFloatingFilterType = null;
    const { compName, jsComp, fwComp } = (0, userCompUtils_1._getFilterCompKeys)(frameworkOverrides, def);
    if (compName) {
        const floatingFilterTypeMap = {
            agSetColumnFilter: 'agSetColumnFloatingFilter',
            agMultiColumnFilter: 'agMultiColumnFloatingFilter',
            agGroupColumnFilter: 'agGroupColumnFloatingFilter',
            agNumberColumnFilter: 'agNumberColumnFloatingFilter',
            agDateColumnFilter: 'agDateColumnFloatingFilter',
            agTextColumnFilter: 'agTextColumnFloatingFilter',
        };
        // will be undefined if not in the map
        defaultFloatingFilterType = floatingFilterTypeMap[compName];
    }
    else {
        const usingDefaultFilter = jsComp == null && fwComp == null && def.filter === true;
        if (usingDefaultFilter) {
            defaultFloatingFilterType = getFromDefault();
        }
    }
    return defaultFloatingFilterType;
}
exports._getDefaultFloatingFilterType = _getDefaultFloatingFilterType;


/***/ }),

/***/ 97287:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FloatingFilterTextInputService = void 0;
const beanStub_1 = __webpack_require__(68731);
const agInputTextField_1 = __webpack_require__(45946);
const component_1 = __webpack_require__(78020);
class FloatingFilterTextInputService extends beanStub_1.BeanStub {
    constructor(params) {
        super();
        this.params = params;
        this.eInput = component_1.RefPlaceholder;
        this.onValueChanged = () => { };
    }
    setupGui(parentElement) {
        this.eInput = this.createManagedBean(new agInputTextField_1.AgInputTextField(this.params?.config));
        const eInput = this.eInput.getGui();
        parentElement.appendChild(eInput);
        const listener = (e) => this.onValueChanged(e);
        this.addManagedListeners(eInput, {
            input: listener,
            keydown: listener,
        });
    }
    setEditable(editable) {
        this.eInput.setDisabled(!editable);
    }
    getValue() {
        return this.eInput.getValue();
    }
    setValue(value, silent) {
        this.eInput.setValue(value, silent);
    }
    setValueChangedListener(listener) {
        this.onValueChanged = listener;
    }
    setParams({ ariaLabel, autoComplete }) {
        const { eInput } = this;
        eInput.setInputAriaLabel(ariaLabel);
        if (autoComplete !== undefined) {
            eInput.setAutoComplete(autoComplete);
        }
    }
}
exports.FloatingFilterTextInputService = FloatingFilterTextInputService;


/***/ }),

/***/ 36657:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReadOnlyFloatingFilter = void 0;
const agInputTextField_1 = __webpack_require__(45946);
const component_1 = __webpack_require__(78020);
const ReadOnlyFloatingFilterElement = {
    tag: 'div',
    cls: 'ag-floating-filter-input',
    role: 'presentation',
    children: [
        {
            tag: 'ag-input-text-field',
            ref: 'eFloatingFilterText',
        },
    ],
};
// optional floating filter for user provided filters - instead of providing a floating filter,
// they can provide a getModelAsString() method on the filter instead. this class just displays
// the string returned from getModelAsString()
class ReadOnlyFloatingFilter extends component_1.Component {
    constructor() {
        super(ReadOnlyFloatingFilterElement, [agInputTextField_1.AgInputTextFieldSelector]);
        this.eFloatingFilterText = component_1.RefPlaceholder;
    }
    init(params) {
        this.params = params;
        const displayName = this.beans.colNames.getDisplayNameForColumn(params.column, 'header', true);
        this.eFloatingFilterText
            .setDisabled(true)
            .setInputAriaLabel(`${displayName} ${this.getLocaleTextFunc()('ariaFilterInput', 'Filter Input')}`);
        if (this.gos.get('enableFilterHandlers')) {
            const reactiveParams = params;
            const handler = reactiveParams.getHandler();
            if (handler.getModelAsString) {
                const modelAsString = handler.getModelAsString(reactiveParams.model);
                this.eFloatingFilterText.setValue(modelAsString);
            }
        }
    }
    onParentModelChanged(parentModel) {
        if (parentModel == null) {
            this.eFloatingFilterText.setValue('');
            return;
        }
        this.params.parentFilterInstance((filterInstance) => {
            // it would be nice to check if getModelAsString was present before creating this component,
            // however that is not possible, as React Hooks and VueJS don't attached the methods to the Filter until
            // AFTER the filter is created, not allowing inspection before this (we create floating filters as columns
            // are drawn, but the parent filters are only created when needed).
            if (filterInstance.getModelAsString) {
                const modelAsString = filterInstance.getModelAsString(parentModel);
                this.eFloatingFilterText.setValue(modelAsString);
            }
        });
    }
    refresh(params) {
        this.init(params);
    }
}
exports.ReadOnlyFloatingFilter = ReadOnlyFloatingFilter;


/***/ }),

/***/ 83141:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SimpleFloatingFilter = void 0;
const component_1 = __webpack_require__(78020);
const optionsFactory_1 = __webpack_require__(74824);
class SimpleFloatingFilter extends component_1.Component {
    constructor() {
        super(...arguments);
        this.defaultDebounceMs = 0;
    }
    setLastTypeFromModel(model) {
        // if no model provided by the parent filter use default
        if (!model) {
            this.lastType = this.optionsFactory.defaultOption;
            return;
        }
        const isCombined = model.operator;
        let condition;
        if (isCombined) {
            const combinedModel = model;
            condition = combinedModel.conditions[0];
        }
        else {
            condition = model;
        }
        this.lastType = condition.type;
    }
    canWeEditAfterModelFromParentFilter(model) {
        if (!model) {
            // if no model, then we can edit as long as the lastType is something we can edit, as this
            // is the type we will provide to the parent filter if the user decides to use the floating filter.
            return this.isTypeEditable(this.lastType);
        }
        // never allow editing if the filter is combined (ie has two parts)
        const isCombined = model.operator;
        if (isCombined) {
            return false;
        }
        const simpleModel = model;
        return this.isTypeEditable(simpleModel.type);
    }
    init(params) {
        this.params = params;
        const reactive = this.gos.get('enableFilterHandlers');
        this.reactive = reactive;
        this.setParams(params);
        if (reactive) {
            const reactiveParams = params;
            this.onModelUpdated(reactiveParams.model);
        }
    }
    setParams(params) {
        const optionsFactory = new optionsFactory_1.OptionsFactory();
        this.optionsFactory = optionsFactory;
        optionsFactory.init(params.filterParams, this.defaultOptions);
        this.filterModelFormatter = this.createManagedBean(new this.FilterModelFormatterClass(optionsFactory, params.filterParams));
        this.setSimpleParams(params, false);
    }
    setSimpleParams(params, update = true) {
        const defaultOption = this.optionsFactory.defaultOption;
        // Initial call
        if (!update) {
            this.lastType = defaultOption;
        }
        // readOnly is a property of IProvidedFilterParams - we need to find a better (type-safe)
        // way to support reading this in the future.
        this.readOnly = !!params.filterParams.readOnly;
        // we are editable if:
        // 1) there is a type (user has configured filter wrong if not type)
        //  AND
        // 2) the default type is not 'inRange'
        const editable = this.isTypeEditable(defaultOption);
        this.setEditable(editable);
    }
    refresh(params) {
        this.params = params;
        const reactiveParams = params;
        const reactive = this.reactive;
        if (!reactive || reactiveParams.source === 'colDef') {
            this.updateParams(params);
        }
        if (reactive) {
            const { source, model } = reactiveParams;
            if (source === 'dataChanged' || source === 'ui') {
                return;
            }
            this.onModelUpdated(model);
        }
    }
    updateParams(params) {
        const optionsFactory = this.optionsFactory;
        optionsFactory.refresh(params.filterParams, this.defaultOptions);
        this.setSimpleParams(params);
        this.filterModelFormatter.updateParams({
            optionsFactory,
            filterParams: params.filterParams,
        });
    }
    onParentModelChanged(model, event) {
        // We don't want to update the floating filter if the floating filter caused the change,
        // because the UI is already in sync. if we didn't do this, the UI would behave strangely
        // as it would be updating as the user is typing.
        // This is similar for data changes, which don't affect simple floating filters
        if (event?.afterFloatingFilter || event?.afterDataChange) {
            return;
        }
        this.onModelUpdated(model);
    }
    hasSingleInput(filterType) {
        const numberOfInputs = this.optionsFactory.getCustomOption(filterType)?.numberOfInputs;
        return numberOfInputs == null || numberOfInputs == 1;
    }
    isTypeEditable(type) {
        const uneditableTypes = ['inRange', 'empty', 'blank', 'notBlank'];
        return (!!type &&
            !this.readOnly &&
            this.hasSingleInput(type) &&
            uneditableTypes.indexOf(type) < 0);
    }
    getAriaLabel(params) {
        const displayName = this.beans.colNames.getDisplayNameForColumn(params.column, 'header', true);
        return `${displayName} ${this.getLocaleTextFunc()('ariaFilterInput', 'Filter Input')}`;
    }
}
exports.SimpleFloatingFilter = SimpleFloatingFilter;


/***/ }),

/***/ 48922:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextInputFloatingFilter = void 0;
const keyCode_1 = __webpack_require__(39853);
const dom_1 = __webpack_require__(33507);
const function_1 = __webpack_require__(92043);
const component_1 = __webpack_require__(78020);
const providedFilterUtils_1 = __webpack_require__(96808);
const textFilterUtils_1 = __webpack_require__(2470);
const simpleFloatingFilter_1 = __webpack_require__(83141);
const TextInputFloatingFilterElement = {
    tag: 'div',
    ref: 'eFloatingFilterInputContainer',
    cls: 'ag-floating-filter-input',
    role: 'presentation',
};
class TextInputFloatingFilter extends simpleFloatingFilter_1.SimpleFloatingFilter {
    constructor() {
        super(...arguments);
        this.eFloatingFilterInputContainer = component_1.RefPlaceholder;
        this.defaultDebounceMs = 500;
    }
    postConstruct() {
        this.setTemplate(TextInputFloatingFilterElement);
    }
    onModelUpdated(model) {
        this.setLastTypeFromModel(model);
        this.setEditable(this.canWeEditAfterModelFromParentFilter(model));
        this.inputSvc.setValue(this.filterModelFormatter.getModelAsString(model));
    }
    setParams(params) {
        this.setupFloatingFilterInputService(params);
        super.setParams(params);
        this.setTextInputParams(params);
    }
    setupFloatingFilterInputService(params) {
        this.inputSvc = this.createFloatingFilterInputService(params);
        this.inputSvc.setupGui(this.eFloatingFilterInputContainer);
    }
    setTextInputParams(params) {
        const autoComplete = params.browserAutoComplete ?? false;
        const { inputSvc, defaultDebounceMs, readOnly } = this;
        inputSvc.setParams({
            ariaLabel: this.getAriaLabel(params),
            autoComplete,
        });
        this.applyActive = (0, providedFilterUtils_1._isUseApplyButton)(params.filterParams);
        if (!readOnly) {
            const debounceMs = (0, providedFilterUtils_1.getDebounceMs)(params.filterParams, defaultDebounceMs);
            const toDebounce = (0, function_1._debounce)(this, this.syncUpWithParentFilter.bind(this), debounceMs);
            inputSvc.setValueChangedListener(toDebounce);
        }
    }
    updateParams(params) {
        super.updateParams(params);
        this.setTextInputParams(params);
    }
    recreateFloatingFilterInputService(params) {
        const { inputSvc } = this;
        const value = inputSvc.getValue();
        (0, dom_1._clearElement)(this.eFloatingFilterInputContainer);
        this.destroyBean(inputSvc);
        this.setupFloatingFilterInputService(params);
        inputSvc.setValue(value, true);
    }
    syncUpWithParentFilter(e) {
        const isEnterKey = e.key === keyCode_1.KeyCode.ENTER;
        const reactive = this.reactive;
        if (reactive) {
            const reactiveParams = this.params;
            reactiveParams.onUiChange();
        }
        if (this.applyActive && !isEnterKey) {
            return;
        }
        const { inputSvc, params, lastType } = this;
        let value = inputSvc.getValue();
        if (params.filterParams.trimInput) {
            value = (0, textFilterUtils_1.trimInputForFilter)(value);
            inputSvc.setValue(value, true); // ensure visible value is trimmed
        }
        if (reactive) {
            const reactiveParams = params;
            const model = reactiveParams.model;
            const parsedValue = this.convertValue(value);
            const newModel = parsedValue == null
                ? null
                : {
                    ...(model ?? {
                        filterType: this.filterType,
                        type: lastType ?? this.optionsFactory.defaultOption,
                    }),
                    filter: parsedValue,
                };
            reactiveParams.onModelChange(newModel, { afterFloatingFilter: true });
        }
        else {
            params.parentFilterInstance((filterInstance) => {
                // NumberFilter is typed as number, but actually receives string values
                filterInstance?.onFloatingFilterChanged(lastType || null, value || null);
            });
        }
    }
    convertValue(value) {
        return value || null; // '' to null
    }
    setEditable(editable) {
        this.inputSvc.setEditable(editable);
    }
}
exports.TextInputFloatingFilter = TextInputFloatingFilter;


/***/ }),

/***/ 38713:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DateCompWrapper = void 0;
const userCompUtils_1 = __webpack_require__(12036);
const dom_1 = __webpack_require__(33507);
/** Provides sync access to async component. Date component can be lazy created - this class encapsulates
 * this by keeping value locally until DateComp has loaded, then passing DateComp the value. */
class DateCompWrapper {
    constructor(context, userCompFactory, colDef, dateComponentParams, eParent, onReady) {
        this.alive = true;
        this.context = context;
        this.eParent = eParent;
        const compDetails = (0, userCompUtils_1._getDateCompDetails)(userCompFactory, colDef, dateComponentParams);
        if (!compDetails) {
            return;
        }
        compDetails.newAgStackInstance().then((dateComp) => {
            // because async, check the filter still exists after component comes back
            if (!this.alive) {
                context.destroyBean(dateComp);
                return;
            }
            this.dateComp = dateComp;
            if (!dateComp) {
                return;
            }
            eParent.appendChild(dateComp.getGui());
            dateComp?.afterGuiAttached?.();
            const { tempValue, disabled } = this;
            if (tempValue) {
                dateComp.setDate(tempValue);
            }
            if (disabled != null) {
                dateComp.setDisabled?.(disabled);
            }
            onReady?.(this);
        });
    }
    destroy() {
        this.alive = false;
        this.dateComp = this.context.destroyBean(this.dateComp);
    }
    getDate() {
        return this.dateComp ? this.dateComp.getDate() : this.tempValue;
    }
    setDate(value) {
        const dateComp = this.dateComp;
        if (dateComp) {
            dateComp.setDate(value);
        }
        else {
            this.tempValue = value;
        }
    }
    setDisabled(disabled) {
        const dateComp = this.dateComp;
        if (dateComp) {
            dateComp.setDisabled?.(disabled);
        }
        else {
            this.disabled = disabled;
        }
    }
    setDisplayed(displayed) {
        (0, dom_1._setDisplayed)(this.eParent, displayed);
    }
    setInputPlaceholder(placeholder) {
        this.dateComp?.setInputPlaceholder?.(placeholder);
    }
    setInputAriaLabel(label) {
        this.dateComp?.setInputAriaLabel?.(label);
    }
    afterGuiAttached(params) {
        this.dateComp?.afterGuiAttached?.(params);
    }
    updateParams(params) {
        this.dateComp?.refresh?.(params);
    }
}
exports.DateCompWrapper = DateCompWrapper;


/***/ }),

/***/ 83725:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DateFilter = void 0;
const gridOptionsUtils_1 = __webpack_require__(67274);
const date_1 = __webpack_require__(39827);
const dom_1 = __webpack_require__(33507);
const logging_1 = __webpack_require__(47764);
const simpleFilter_1 = __webpack_require__(95220);
const simpleFilterUtils_1 = __webpack_require__(97535);
const dateCompWrapper_1 = __webpack_require__(38713);
const dateFilterConstants_1 = __webpack_require__(54200);
const dateFilterUtils_1 = __webpack_require__(27392);
const DEFAULT_MIN_YEAR = 1000;
const DEFAULT_MAX_YEAR = Infinity;
class DateFilter extends simpleFilter_1.SimpleFilter {
    constructor() {
        super('dateFilter', dateFilterUtils_1.mapValuesFromDateFilterModel, dateFilterConstants_1.DEFAULT_DATE_FILTER_OPTIONS);
        this.eConditionPanelsFrom = [];
        this.eConditionPanelsTo = [];
        this.dateConditionFromComps = [];
        this.dateConditionToComps = [];
        this.minValidYear = DEFAULT_MIN_YEAR;
        this.maxValidYear = DEFAULT_MAX_YEAR;
        this.minValidDate = null;
        this.maxValidDate = null;
        this.filterType = 'date';
    }
    afterGuiAttached(params) {
        super.afterGuiAttached(params);
        this.dateConditionFromComps[0].afterGuiAttached(params);
    }
    commonUpdateSimpleParams(params) {
        super.commonUpdateSimpleParams(params);
        const yearParser = (param, fallback) => {
            const value = params[param];
            if (value != null) {
                if (!isNaN(value)) {
                    return value == null ? fallback : Number(value);
                }
                else {
                    (0, logging_1._warn)(82, { param });
                }
            }
            return fallback;
        };
        const minValidYear = yearParser('minValidYear', DEFAULT_MIN_YEAR);
        const maxValidYear = yearParser('maxValidYear', DEFAULT_MAX_YEAR);
        this.minValidYear = minValidYear;
        this.maxValidYear = maxValidYear;
        if (minValidYear > maxValidYear) {
            (0, logging_1._warn)(83);
        }
        const { minValidDate, maxValidDate } = params;
        const parsedMinValidDate = minValidDate instanceof Date ? minValidDate : (0, date_1._parseDateTimeFromString)(minValidDate);
        this.minValidDate = parsedMinValidDate;
        const parsedMaxValidDate = maxValidDate instanceof Date ? maxValidDate : (0, date_1._parseDateTimeFromString)(maxValidDate);
        this.maxValidDate = parsedMaxValidDate;
        if (parsedMinValidDate && parsedMaxValidDate && parsedMinValidDate > parsedMaxValidDate) {
            (0, logging_1._warn)(84);
        }
    }
    createDateCompWrapper(element) {
        const { beans: { userCompFactory, context, gos }, params, } = this;
        const dateCompWrapper = new dateCompWrapper_1.DateCompWrapper(context, userCompFactory, params.colDef, (0, gridOptionsUtils_1._addGridCommonParams)(gos, {
            onDateChanged: () => this.onUiChanged(),
            filterParams: params,
            location: 'filter',
        }), element);
        this.addDestroyFunc(() => dateCompWrapper.destroy());
        return dateCompWrapper;
    }
    setElementValue(element, value) {
        element.setDate(value);
    }
    setElementDisplayed(element, displayed) {
        element.setDisplayed(displayed);
    }
    setElementDisabled(element, disabled) {
        element.setDisabled(disabled);
    }
    createEValue() {
        const eCondition = (0, dom_1._createElement)({ tag: 'div', cls: 'ag-filter-body' });
        this.createFromToElement(eCondition, this.eConditionPanelsFrom, this.dateConditionFromComps, 'from');
        this.createFromToElement(eCondition, this.eConditionPanelsTo, this.dateConditionToComps, 'to');
        return eCondition;
    }
    createFromToElement(eCondition, eConditionPanels, dateConditionComps, fromTo) {
        const eConditionPanel = (0, dom_1._createElement)({ tag: 'div', cls: `ag-filter-${fromTo} ag-filter-date-${fromTo}` });
        eConditionPanels.push(eConditionPanel);
        eCondition.appendChild(eConditionPanel);
        dateConditionComps.push(this.createDateCompWrapper(eConditionPanel));
    }
    removeEValues(startPosition, deleteCount) {
        this.removeDateComps(this.dateConditionFromComps, startPosition, deleteCount);
        this.removeDateComps(this.dateConditionToComps, startPosition, deleteCount);
        (0, simpleFilterUtils_1.removeItems)(this.eConditionPanelsFrom, startPosition, deleteCount);
        (0, simpleFilterUtils_1.removeItems)(this.eConditionPanelsTo, startPosition, deleteCount);
    }
    removeDateComps(components, startPosition, deleteCount) {
        const removedComponents = (0, simpleFilterUtils_1.removeItems)(components, startPosition, deleteCount);
        removedComponents.forEach((comp) => comp.destroy());
    }
    isValidDateValue(value) {
        if (value === null) {
            return false;
        }
        const { minValidDate, maxValidDate, minValidYear, maxValidYear } = this;
        if (minValidDate) {
            if (value < minValidDate) {
                return false;
            }
        }
        else {
            if (value.getUTCFullYear() < minValidYear) {
                return false;
            }
        }
        if (maxValidDate) {
            if (value > maxValidDate) {
                return false;
            }
        }
        else {
            if (value.getUTCFullYear() > maxValidYear) {
                return false;
            }
        }
        return true;
    }
    isConditionUiComplete(position) {
        if (!super.isConditionUiComplete(position)) {
            return false;
        }
        let valid = true;
        this.forEachInput((element, index, elPosition, numberOfInputs) => {
            if (elPosition !== position || !valid || index >= numberOfInputs) {
                return;
            }
            valid = valid && this.isValidDateValue(element.getDate());
        });
        return valid;
    }
    areSimpleModelsEqual(aSimple, bSimple) {
        return (aSimple.dateFrom === bSimple.dateFrom && aSimple.dateTo === bSimple.dateTo && aSimple.type === bSimple.type);
    }
    createCondition(position) {
        const type = this.getConditionType(position);
        const model = {};
        const values = this.getValues(position);
        if (values.length > 0) {
            model.dateFrom = (0, date_1._serialiseDate)(values[0]);
        }
        if (values.length > 1) {
            model.dateTo = (0, date_1._serialiseDate)(values[1]);
        }
        return {
            dateFrom: null,
            dateTo: null,
            filterType: this.filterType,
            type,
            ...model,
        };
    }
    resetPlaceholder() {
        const globalTranslate = this.getLocaleTextFunc();
        const placeholder = this.translate('dateFormatOoo');
        const ariaLabel = globalTranslate('ariaFilterValue', 'Filter Value');
        this.forEachInput((element) => {
            element.setInputPlaceholder(placeholder);
            element.setInputAriaLabel(ariaLabel);
        });
    }
    getInputs(position) {
        const { dateConditionFromComps, dateConditionToComps } = this;
        if (position >= dateConditionFromComps.length) {
            return [null, null];
        }
        return [dateConditionFromComps[position], dateConditionToComps[position]];
    }
    getValues(position) {
        const result = [];
        this.forEachPositionInput(position, (element, index, _elPosition, numberOfInputs) => {
            if (index < numberOfInputs) {
                result.push(element.getDate());
            }
        });
        return result;
    }
    translate(key) {
        if (key === 'lessThan') {
            return super.translate('before');
        }
        if (key === 'greaterThan') {
            return super.translate('after');
        }
        return super.translate(key);
    }
}
exports.DateFilter = DateFilter;


/***/ }),

/***/ 54200:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DEFAULT_DATE_FILTER_OPTIONS = void 0;
exports.DEFAULT_DATE_FILTER_OPTIONS = [
    'equals',
    'notEqual',
    'lessThan',
    'greaterThan',
    'inRange',
    'blank',
    'notBlank',
];


/***/ }),

/***/ 46977:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DateFilterHandler = void 0;
const scalarFilterHandler_1 = __webpack_require__(93820);
const dateFilterConstants_1 = __webpack_require__(54200);
const dateFilterModelFormatter_1 = __webpack_require__(64392);
const dateFilterUtils_1 = __webpack_require__(27392);
function defaultDateComparator(filterDate, cellValue) {
    // The default comparator assumes that the cellValue is a date
    const cellAsDate = cellValue;
    if (cellAsDate < filterDate) {
        return -1;
    }
    if (cellAsDate > filterDate) {
        return 1;
    }
    return 0;
}
class DateFilterHandler extends scalarFilterHandler_1.ScalarFilterHandler {
    constructor() {
        super(dateFilterUtils_1.mapValuesFromDateFilterModel, dateFilterConstants_1.DEFAULT_DATE_FILTER_OPTIONS);
        this.filterType = 'date';
        this.FilterModelFormatterClass = dateFilterModelFormatter_1.DateFilterModelFormatter;
    }
    comparator() {
        return this.params.filterParams.comparator ?? defaultDateComparator;
    }
    isValid(value) {
        const isValidDate = this.params.filterParams.isValidDate;
        return !isValidDate || isValidDate(value);
    }
}
exports.DateFilterHandler = DateFilterHandler;


/***/ }),

/***/ 64392:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DateFilterModelFormatter = void 0;
const date_1 = __webpack_require__(39827);
const simpleFilterModelFormatter_1 = __webpack_require__(70405);
class DateFilterModelFormatter extends simpleFilterModelFormatter_1.SimpleFilterModelFormatter {
    constructor(optionsFactory, filterParams) {
        super(optionsFactory, filterParams, (value) => {
            const { dataTypeSvc, valueSvc } = this.beans;
            const column = filterParams.column;
            const dateFormatFn = dataTypeSvc?.getDateFormatterFunction(column);
            const dateStringStringValue = dateFormatFn?.(value ?? undefined);
            return valueSvc.formatValue(column, null, dateStringStringValue);
        });
        this.filterTypeKeys = simpleFilterModelFormatter_1.SCALAR_FILTER_TYPE_KEYS;
    }
    conditionToString(condition, forToolPanel, isRange, customDisplayKey, customDisplayName) {
        const { type } = condition;
        const dateFrom = (0, date_1._parseDateTimeFromString)(condition.dateFrom);
        const dateTo = (0, date_1._parseDateTimeFromString)(condition.dateTo);
        const format = this.filterParams.inRangeFloatingFilterDateFormat;
        const formatDate = forToolPanel
            ? this.formatValue.bind(this)
            : (value) => (0, date_1._dateToFormattedString)(value, format);
        const formattedFrom = () => (dateFrom !== null ? formatDate(dateFrom) : 'null');
        const formattedTo = () => (dateTo !== null ? formatDate(dateTo) : 'null');
        if (forToolPanel) {
            const valueForToolPanel = this.conditionForToolPanel(type, isRange, formattedFrom, formattedTo, customDisplayKey, customDisplayName);
            if (valueForToolPanel != null) {
                return valueForToolPanel;
            }
        }
        if (isRange) {
            return `${formattedFrom()}-${formattedTo()}`;
        }
        if (dateFrom != null) {
            return formatDate(dateFrom);
        }
        // cater for when the type doesn't need a value
        return `${type}`;
    }
}
exports.DateFilterModelFormatter = DateFilterModelFormatter;


/***/ }),

/***/ 27392:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mapValuesFromDateFilterModel = void 0;
const date_1 = __webpack_require__(39827);
const simpleFilterUtils_1 = __webpack_require__(97535);
function mapValuesFromDateFilterModel(filterModel, optionsFactory) {
    // unlike the other filters, we do two things here:
    // 1) allow for different attribute names (same as done for other filters) (eg the 'from' and 'to'
    //    are in different locations in Date and Number filter models)
    // 2) convert the type (because Date filter uses Dates, however model is 'string')
    //
    // NOTE: The conversion of string to date also removes the timezone - i.e. when user picks
    //       a date from the UI, it will have timezone info in it. This is lost when creating
    //       the model. When we recreate the date again here, it's without a timezone.
    const { dateFrom, dateTo, type } = filterModel || {};
    return [
        (dateFrom && (0, date_1._parseDateTimeFromString)(dateFrom)) || null,
        (dateTo && (0, date_1._parseDateTimeFromString)(dateTo)) || null,
    ].slice(0, (0, simpleFilterUtils_1.getNumberOfInputs)(type, optionsFactory));
}
exports.mapValuesFromDateFilterModel = mapValuesFromDateFilterModel;


/***/ }),

/***/ 23091:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DateFloatingFilter = void 0;
const gridOptionsUtils_1 = __webpack_require__(67274);
const date_1 = __webpack_require__(39827);
const dom_1 = __webpack_require__(33507);
const function_1 = __webpack_require__(92043);
const agInputTextField_1 = __webpack_require__(45946);
const component_1 = __webpack_require__(78020);
const simpleFloatingFilter_1 = __webpack_require__(83141);
const providedFilterUtils_1 = __webpack_require__(96808);
const dateCompWrapper_1 = __webpack_require__(38713);
const dateFilterConstants_1 = __webpack_require__(54200);
const dateFilterModelFormatter_1 = __webpack_require__(64392);
const DateFloatingFilterElement = {
    tag: 'div',
    cls: 'ag-floating-filter-input',
    role: 'presentation',
    children: [
        {
            tag: 'ag-input-text-field',
            ref: 'eReadOnlyText',
        },
        { tag: 'div', ref: 'eDateWrapper', cls: 'ag-date-floating-filter-wrapper' },
    ],
};
class DateFloatingFilter extends simpleFloatingFilter_1.SimpleFloatingFilter {
    constructor() {
        super(DateFloatingFilterElement, [agInputTextField_1.AgInputTextFieldSelector]);
        this.eReadOnlyText = component_1.RefPlaceholder;
        this.eDateWrapper = component_1.RefPlaceholder;
        this.FilterModelFormatterClass = dateFilterModelFormatter_1.DateFilterModelFormatter;
        this.filterType = 'date';
        this.defaultOptions = dateFilterConstants_1.DEFAULT_DATE_FILTER_OPTIONS;
    }
    setParams(params) {
        super.setParams(params);
        this.createDateComponent();
        const translate = this.getLocaleTextFunc();
        this.eReadOnlyText.setDisabled(true).setInputAriaLabel(translate('ariaDateFilterInput', 'Date Filter Input'));
    }
    updateParams(params) {
        super.updateParams(params);
        this.dateComp.updateParams(this.getDateComponentParams());
        this.updateCompOnModelChange(params.currentParentModel());
    }
    updateCompOnModelChange(model) {
        // Update the read-only text field
        const allowEditing = !this.readOnly && this.canWeEditAfterModelFromParentFilter(model);
        this.setEditable(allowEditing);
        if (allowEditing) {
            const dateModel = model ? (0, date_1._parseDateTimeFromString)(model.dateFrom) : null;
            this.dateComp.setDate(dateModel);
            this.eReadOnlyText.setValue('');
        }
        else {
            this.eReadOnlyText.setValue(this.filterModelFormatter.getModelAsString(model));
            this.dateComp.setDate(null);
        }
    }
    setEditable(editable) {
        (0, dom_1._setDisplayed)(this.eDateWrapper, editable);
        (0, dom_1._setDisplayed)(this.eReadOnlyText.getGui(), !editable);
    }
    onModelUpdated(model) {
        super.setLastTypeFromModel(model);
        this.updateCompOnModelChange(model);
    }
    onDateChanged() {
        const filterValueDate = this.dateComp.getDate();
        if (this.reactive) {
            const reactiveParams = this.params;
            reactiveParams.onUiChange();
            const model = reactiveParams.model;
            const filterValueText = (0, date_1._serialiseDate)(filterValueDate);
            const newModel = filterValueText == null
                ? null
                : {
                    ...(model ?? {
                        filterType: this.filterType,
                        type: this.lastType ?? this.optionsFactory.defaultOption,
                    }),
                    dateFrom: filterValueText,
                };
            reactiveParams.onModelChange(newModel, { afterFloatingFilter: true });
        }
        else {
            this.params.parentFilterInstance((filterInstance) => {
                filterInstance?.onFloatingFilterChanged(this.lastType || null, filterValueDate);
            });
        }
    }
    getDateComponentParams() {
        const { filterParams } = this.params;
        const debounceMs = (0, providedFilterUtils_1.getDebounceMs)(filterParams, this.defaultDebounceMs);
        return (0, gridOptionsUtils_1._addGridCommonParams)(this.gos, {
            onDateChanged: (0, function_1._debounce)(this, this.onDateChanged.bind(this), debounceMs),
            filterParams,
            location: 'floatingFilter',
        });
    }
    createDateComponent() {
        const { beans: { context, userCompFactory }, eDateWrapper, params, } = this;
        this.dateComp = new dateCompWrapper_1.DateCompWrapper(context, userCompFactory, params.column.getColDef(), this.getDateComponentParams(), eDateWrapper, (dateComp) => {
            dateComp.setInputAriaLabel(this.getAriaLabel(params));
        });
        this.addDestroyFunc(() => this.dateComp.destroy());
    }
}
exports.DateFloatingFilter = DateFloatingFilter;


/***/ }),

/***/ 75459:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultDateComponent = void 0;
const browser_1 = __webpack_require__(98667);
const date_1 = __webpack_require__(39827);
const logging_1 = __webpack_require__(47764);
const agInputTextField_1 = __webpack_require__(45946);
const component_1 = __webpack_require__(78020);
const DefaultDateElement = {
    tag: 'div',
    cls: 'ag-filter-filter',
    children: [
        {
            tag: 'ag-input-text-field',
            ref: 'eDateInput',
            cls: 'ag-date-filter',
        },
    ],
};
class DefaultDateComponent extends component_1.Component {
    constructor() {
        super(DefaultDateElement, [agInputTextField_1.AgInputTextFieldSelector]);
        this.eDateInput = component_1.RefPlaceholder;
        this.isApply = false;
        this.applyOnFocusOut = false;
    }
    init(params) {
        this.params = params;
        this.setParams(params);
        const inputElement = this.eDateInput.getInputElement();
        this.addManagedListeners(inputElement, {
            // ensures that the input element is focussed when a clear button is clicked,
            // unless using safari as there is no clear button and focus does not work properly
            mouseDown: () => {
                if (this.eDateInput.isDisabled() || this.usingSafariDatePicker) {
                    return;
                }
                inputElement.focus({ preventScroll: true });
            },
            input: this.handleInput.bind(this, false),
            change: this.handleInput.bind(this, true),
            focusout: this.handleFocusOut.bind(this),
        });
    }
    handleInput(isChange) {
        if (this.eDateInput.isDisabled()) {
            return;
        }
        if (this.isApply) {
            // If it's input event, queue up apply on focus out.
            // If it's change, clear and run.
            this.applyOnFocusOut = !isChange;
            if (isChange) {
                this.params.onDateChanged();
            }
            return;
        }
        if (!isChange) {
            // if not apply, execute on input
            this.params.onDateChanged();
        }
    }
    handleFocusOut() {
        if (this.applyOnFocusOut) {
            this.applyOnFocusOut = false;
            this.params.onDateChanged();
        }
    }
    setParams(params) {
        const inputElement = this.eDateInput.getInputElement();
        const shouldUseBrowserDatePicker = this.shouldUseBrowserDatePicker(params);
        this.usingSafariDatePicker = shouldUseBrowserDatePicker && (0, browser_1._isBrowserSafari)();
        const { minValidYear, maxValidYear, minValidDate, maxValidDate, buttons, includeTime, colDef } = params.filterParams || {};
        const dataTypeSvc = this.beans.dataTypeSvc;
        const shouldUseDateTimeLocal = includeTime ?? dataTypeSvc?.getDateIncludesTimeFlag?.(colDef.cellDataType) ?? false;
        if (shouldUseBrowserDatePicker) {
            if (shouldUseDateTimeLocal) {
                inputElement.type = 'datetime-local';
                inputElement.step = '1'; // enforce seconds part to show up by default
            }
            else {
                inputElement.type = 'date';
            }
        }
        else {
            inputElement.type = 'text';
        }
        if (minValidDate && minValidYear) {
            (0, logging_1._warn)(85);
        }
        if (maxValidDate && maxValidYear) {
            (0, logging_1._warn)(86);
        }
        if (minValidDate && maxValidDate) {
            const [parsedMinValidDate, parsedMaxValidDate] = [minValidDate, maxValidDate].map((v) => v instanceof Date ? v : (0, date_1._parseDateTimeFromString)(v));
            if (parsedMinValidDate &&
                parsedMaxValidDate &&
                parsedMinValidDate.getTime() > parsedMaxValidDate.getTime()) {
                (0, logging_1._warn)(87);
            }
        }
        if (minValidDate) {
            if (minValidDate instanceof Date) {
                inputElement.min = (0, date_1._dateToFormattedString)(minValidDate);
            }
            else {
                inputElement.min = minValidDate;
            }
        }
        else {
            if (minValidYear) {
                inputElement.min = `${minValidYear}-01-01`;
            }
        }
        if (maxValidDate) {
            if (maxValidDate instanceof Date) {
                inputElement.max = (0, date_1._dateToFormattedString)(maxValidDate);
            }
            else {
                inputElement.max = maxValidDate;
            }
        }
        else {
            if (maxValidYear) {
                inputElement.max = `${maxValidYear}-12-31`;
            }
        }
        this.isApply = params.location === 'floatingFilter' && !!buttons?.includes('apply');
    }
    refresh(params) {
        this.params = params;
        this.setParams(params);
    }
    getDate() {
        return (0, date_1._parseDateTimeFromString)(this.eDateInput.getValue());
    }
    setDate(date) {
        const colType = this.params.filterParams.colDef.cellDataType;
        const includeTime = this.beans.dataTypeSvc?.getDateIncludesTimeFlag(colType) ?? false;
        this.eDateInput.setValue((0, date_1._serialiseDate)(date, includeTime));
    }
    setInputPlaceholder(placeholder) {
        this.eDateInput.setInputPlaceholder(placeholder);
    }
    setInputAriaLabel(ariaLabel) {
        this.eDateInput.setAriaLabel(ariaLabel);
    }
    setDisabled(disabled) {
        this.eDateInput.setDisabled(disabled);
    }
    afterGuiAttached(params) {
        if (!params || !params.suppressFocus) {
            this.eDateInput.getInputElement().focus({ preventScroll: true });
        }
    }
    shouldUseBrowserDatePicker(params) {
        return params?.filterParams?.browserDatePicker ?? true;
    }
}
exports.DefaultDateComponent = DefaultDateComponent;


/***/ }),

/***/ 78845:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isCombinedFilterModel = void 0;
function isCombinedFilterModel(model) {
    return !!model.operator;
}
exports.isCombinedFilterModel = isCombinedFilterModel;


/***/ }),

/***/ 56607:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NumberFilter = void 0;
const dom_1 = __webpack_require__(33507);
const generic_1 = __webpack_require__(34422);
const agInputNumberField_1 = __webpack_require__(18792);
const agInputTextField_1 = __webpack_require__(45946);
const simpleFilter_1 = __webpack_require__(95220);
const numberFilterConstants_1 = __webpack_require__(40846);
const numberFilterUtils_1 = __webpack_require__(730);
class NumberFilter extends simpleFilter_1.SimpleFilter {
    constructor() {
        super('numberFilter', numberFilterUtils_1.mapValuesFromNumberFilterModel, numberFilterConstants_1.DEFAULT_NUMBER_FILTER_OPTIONS);
        this.eValuesFrom = [];
        this.eValuesTo = [];
        this.filterType = 'number';
        this.defaultDebounceMs = 500;
    }
    setElementValue(element, value, fromFloatingFilter) {
        // values from floating filter are directly from the input, not from the model
        const { numberFormatter } = this.params;
        const valueToSet = !fromFloatingFilter && numberFormatter ? numberFormatter(value ?? null) : value;
        super.setElementValue(element, valueToSet);
    }
    createEValue() {
        const allowedCharPattern = (0, numberFilterUtils_1.getAllowedCharPattern)(this.params);
        const eCondition = (0, dom_1._createElement)({ tag: 'div', cls: 'ag-filter-body', role: 'presentation' });
        this.createFromToElement(eCondition, this.eValuesFrom, 'from', allowedCharPattern);
        this.createFromToElement(eCondition, this.eValuesTo, 'to', allowedCharPattern);
        return eCondition;
    }
    createFromToElement(eCondition, eValues, fromTo, allowedCharPattern) {
        const eValue = this.createManagedBean(allowedCharPattern ? new agInputTextField_1.AgInputTextField({ allowedCharPattern }) : new agInputNumberField_1.AgInputNumberField());
        eValue.addCss(`ag-filter-${fromTo}`);
        eValue.addCss('ag-filter-filter');
        eValues.push(eValue);
        eCondition.appendChild(eValue.getGui());
    }
    removeEValues(startPosition, deleteCount) {
        const removeComps = (eGui) => this.removeComponents(eGui, startPosition, deleteCount);
        removeComps(this.eValuesFrom);
        removeComps(this.eValuesTo);
    }
    getValues(position) {
        const result = [];
        this.forEachPositionInput(position, (element, index, _elPosition, numberOfInputs) => {
            if (index < numberOfInputs) {
                result.push((0, numberFilterUtils_1.processNumberFilterValue)(this.stringToFloat(element.getValue())));
            }
        });
        return result;
    }
    areSimpleModelsEqual(aSimple, bSimple) {
        return (aSimple.filter === bSimple.filter && aSimple.filterTo === bSimple.filterTo && aSimple.type === bSimple.type);
    }
    stringToFloat(value) {
        if (typeof value === 'number') {
            return value;
        }
        let filterText = (0, generic_1._makeNull)(value);
        if (filterText != null && filterText.trim() === '') {
            filterText = null;
        }
        const numberParser = this.params.numberParser;
        if (numberParser) {
            return numberParser(filterText);
        }
        return filterText == null || filterText.trim() === '-' ? null : parseFloat(filterText);
    }
    createCondition(position) {
        const type = this.getConditionType(position);
        const model = {
            filterType: this.filterType,
            type,
        };
        const values = this.getValues(position);
        if (values.length > 0) {
            model.filter = values[0];
        }
        if (values.length > 1) {
            model.filterTo = values[1];
        }
        return model;
    }
    getInputs(position) {
        const { eValuesFrom, eValuesTo } = this;
        if (position >= eValuesFrom.length) {
            return [null, null];
        }
        return [eValuesFrom[position], eValuesTo[position]];
    }
    hasInvalidInputs() {
        let invalidInputs = false;
        this.forEachInput((element) => {
            if (!element.getInputElement().validity.valid) {
                invalidInputs = true;
                return;
            }
        });
        return invalidInputs;
    }
}
exports.NumberFilter = NumberFilter;


/***/ }),

/***/ 40846:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DEFAULT_NUMBER_FILTER_OPTIONS = void 0;
exports.DEFAULT_NUMBER_FILTER_OPTIONS = [
    'equals',
    'notEqual',
    'greaterThan',
    'greaterThanOrEqual',
    'lessThan',
    'lessThanOrEqual',
    'inRange',
    'blank',
    'notBlank',
];


/***/ }),

/***/ 42927:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NumberFilterHandler = void 0;
const scalarFilterHandler_1 = __webpack_require__(93820);
const numberFilterConstants_1 = __webpack_require__(40846);
const numberFilterModelFormatter_1 = __webpack_require__(51862);
const numberFilterUtils_1 = __webpack_require__(730);
class NumberFilterHandler extends scalarFilterHandler_1.ScalarFilterHandler {
    constructor() {
        super(numberFilterUtils_1.mapValuesFromNumberFilterModel, numberFilterConstants_1.DEFAULT_NUMBER_FILTER_OPTIONS);
        this.filterType = 'number';
        this.FilterModelFormatterClass = numberFilterModelFormatter_1.NumberFilterModelFormatter;
    }
    comparator() {
        return (left, right) => {
            if (left === right) {
                return 0;
            }
            return left < right ? 1 : -1;
        };
    }
    isValid(value) {
        return !isNaN(value);
    }
}
exports.NumberFilterHandler = NumberFilterHandler;


/***/ }),

/***/ 51862:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NumberFilterModelFormatter = void 0;
const simpleFilterModelFormatter_1 = __webpack_require__(70405);
class NumberFilterModelFormatter extends simpleFilterModelFormatter_1.SimpleFilterModelFormatter {
    constructor(optionsFactory, filterParams) {
        super(optionsFactory, filterParams, filterParams.numberFormatter);
        this.filterTypeKeys = simpleFilterModelFormatter_1.SCALAR_FILTER_TYPE_KEYS;
    }
    conditionToString(condition, forToolPanel, isRange, customDisplayKey, customDisplayName) {
        const { filter, filterTo, type } = condition;
        const formatValue = this.formatValue.bind(this);
        if (forToolPanel) {
            const valueForToolPanel = this.conditionForToolPanel(type, isRange, () => formatValue(filter), () => formatValue(filterTo), customDisplayKey, customDisplayName);
            if (valueForToolPanel != null) {
                return valueForToolPanel;
            }
        }
        if (isRange) {
            return `${formatValue(filter)}-${formatValue(filterTo)}`;
        }
        // cater for when the type doesn't need a value
        if (filter != null) {
            return formatValue(filter);
        }
        return `${type}`;
    }
}
exports.NumberFilterModelFormatter = NumberFilterModelFormatter;


/***/ }),

/***/ 730:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mapValuesFromNumberFilterModel = exports.processNumberFilterValue = exports.getAllowedCharPattern = void 0;
const simpleFilterUtils_1 = __webpack_require__(97535);
function getAllowedCharPattern(filterParams) {
    const { allowedCharPattern } = filterParams ?? {};
    return allowedCharPattern ?? null;
}
exports.getAllowedCharPattern = getAllowedCharPattern;
function processNumberFilterValue(value) {
    if (value == null) {
        return null;
    }
    return isNaN(value) ? null : value;
}
exports.processNumberFilterValue = processNumberFilterValue;
function mapValuesFromNumberFilterModel(filterModel, optionsFactory) {
    const { filter, filterTo, type } = filterModel || {};
    return [processNumberFilterValue(filter), processNumberFilterValue(filterTo)].slice(0, (0, simpleFilterUtils_1.getNumberOfInputs)(type, optionsFactory));
}
exports.mapValuesFromNumberFilterModel = mapValuesFromNumberFilterModel;


/***/ }),

/***/ 64789:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NumberFloatingFilter = void 0;
const beanStub_1 = __webpack_require__(68731);
const agInputNumberField_1 = __webpack_require__(18792);
const agInputTextField_1 = __webpack_require__(45946);
const floatingFilterTextInputService_1 = __webpack_require__(97287);
const textInputFloatingFilter_1 = __webpack_require__(48922);
const numberFilterConstants_1 = __webpack_require__(40846);
const numberFilterModelFormatter_1 = __webpack_require__(51862);
const numberFilterUtils_1 = __webpack_require__(730);
class FloatingFilterNumberInputService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.onValueChanged = () => { };
        this.numberInputActive = true;
    }
    setupGui(parentElement) {
        this.eNumberInput = this.createManagedBean(new agInputNumberField_1.AgInputNumberField());
        this.eTextInput = this.createManagedBean(new agInputTextField_1.AgInputTextField());
        this.eTextInput.setDisabled(true);
        const eNumberInput = this.eNumberInput.getGui();
        const eTextInput = this.eTextInput.getGui();
        parentElement.appendChild(eNumberInput);
        parentElement.appendChild(eTextInput);
        this.setupListeners(eNumberInput, (e) => this.onValueChanged(e));
        this.setupListeners(eTextInput, (e) => this.onValueChanged(e));
    }
    setEditable(editable) {
        this.numberInputActive = editable;
        this.eNumberInput.setDisplayed(this.numberInputActive);
        this.eTextInput.setDisplayed(!this.numberInputActive);
    }
    setAutoComplete(autoComplete) {
        this.eNumberInput.setAutoComplete(autoComplete);
        this.eTextInput.setAutoComplete(autoComplete);
    }
    getValue() {
        return this.getActiveInputElement().getValue();
    }
    setValue(value, silent) {
        this.getActiveInputElement().setValue(value, silent);
    }
    getActiveInputElement() {
        return this.numberInputActive ? this.eNumberInput : this.eTextInput;
    }
    setValueChangedListener(listener) {
        this.onValueChanged = listener;
    }
    setupListeners(element, listener) {
        this.addManagedListeners(element, {
            input: listener,
            keydown: listener,
        });
    }
    setParams(params) {
        this.setAriaLabel(params.ariaLabel);
        if (params.autoComplete !== undefined) {
            this.setAutoComplete(params.autoComplete);
        }
    }
    setAriaLabel(ariaLabel) {
        this.eNumberInput.setInputAriaLabel(ariaLabel);
        this.eTextInput.setInputAriaLabel(ariaLabel);
    }
}
class NumberFloatingFilter extends textInputFloatingFilter_1.TextInputFloatingFilter {
    constructor() {
        super(...arguments);
        this.FilterModelFormatterClass = numberFilterModelFormatter_1.NumberFilterModelFormatter;
        this.filterType = 'number';
        this.defaultOptions = numberFilterConstants_1.DEFAULT_NUMBER_FILTER_OPTIONS;
    }
    updateParams(params) {
        const allowedCharPattern = (0, numberFilterUtils_1.getAllowedCharPattern)(params.filterParams);
        if (allowedCharPattern !== this.allowedCharPattern) {
            this.recreateFloatingFilterInputService(params);
        }
        super.updateParams(params);
    }
    createFloatingFilterInputService(params) {
        this.allowedCharPattern = (0, numberFilterUtils_1.getAllowedCharPattern)(params.filterParams);
        if (this.allowedCharPattern) {
            // need to use text input
            return this.createManagedBean(new floatingFilterTextInputService_1.FloatingFilterTextInputService({
                config: { allowedCharPattern: this.allowedCharPattern },
            }));
        }
        return this.createManagedBean(new FloatingFilterNumberInputService());
    }
    convertValue(value) {
        return value ? Number(value) : null;
    }
}
exports.NumberFloatingFilter = NumberFloatingFilter;


/***/ }),

/***/ 74824:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OptionsFactory = void 0;
const logging_1 = __webpack_require__(47764);
/* Common logic for options, used by both filters and floating filters. */
class OptionsFactory {
    constructor() {
        this.customFilterOptions = {};
    }
    init(params, defaultOptions) {
        this.filterOptions = params.filterOptions ?? defaultOptions;
        this.mapCustomOptions();
        this.defaultOption = this.getDefaultItem(params.defaultOption);
    }
    refresh(params, defaultOptions) {
        const filterOptions = params.filterOptions ?? defaultOptions;
        if (this.filterOptions !== filterOptions) {
            this.filterOptions = filterOptions;
            this.customFilterOptions = {};
            this.mapCustomOptions();
        }
        this.defaultOption = this.getDefaultItem(params.defaultOption);
    }
    mapCustomOptions() {
        const { filterOptions } = this;
        if (!filterOptions) {
            return;
        }
        filterOptions.forEach((filterOption) => {
            if (typeof filterOption === 'string') {
                return;
            }
            const requiredProperties = [['displayKey'], ['displayName'], ['predicate', 'test']];
            const propertyCheck = (keys) => {
                if (!keys.some((key) => filterOption[key] != null)) {
                    (0, logging_1._warn)(72, { keys });
                    return false;
                }
                return true;
            };
            if (!requiredProperties.every(propertyCheck)) {
                this.filterOptions = filterOptions.filter((v) => v === filterOption) || [];
                return;
            }
            this.customFilterOptions[filterOption.displayKey] = filterOption;
        });
    }
    getDefaultItem(defaultOption) {
        const { filterOptions } = this;
        if (defaultOption) {
            return defaultOption;
        }
        else if (filterOptions.length >= 1) {
            const firstFilterOption = filterOptions[0];
            if (typeof firstFilterOption === 'string') {
                return firstFilterOption;
            }
            else if (firstFilterOption.displayKey) {
                return firstFilterOption.displayKey;
            }
            else {
                // invalid FilterOptionDef supplied as it doesn't contain a 'displayKey
                (0, logging_1._warn)(73);
            }
        }
        else {
            //no filter options for filter
            (0, logging_1._warn)(74);
        }
        return undefined;
    }
    getCustomOption(name) {
        return this.customFilterOptions[name];
    }
}
exports.OptionsFactory = OptionsFactory;


/***/ }),

/***/ 2245:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProvidedFilter = void 0;
const positionableFeature_1 = __webpack_require__(2147);
const function_1 = __webpack_require__(92043);
const logging_1 = __webpack_require__(47764);
const component_1 = __webpack_require__(78020);
const managedFocusFeature_1 = __webpack_require__(31772);
const filterLocaleText_1 = __webpack_require__(75741);
const providedFilterUtils_1 = __webpack_require__(96808);
/**
 * Contains common logic to all provided filters (apply button, clear button, etc).
 * All the filters that come with AG Grid extend this class. User filters do not
 * extend this class.
 *
 * @param M type of filter-model managed by the concrete sub-class that extends this type
 * @param V type of value managed by the concrete sub-class that extends this type
 */
class ProvidedFilter extends component_1.Component {
    constructor(filterNameKey, cssIdentifier) {
        super();
        this.filterNameKey = filterNameKey;
        this.cssIdentifier = cssIdentifier;
        this.applyActive = false;
        this.debouncePending = false;
        // subclasses can override this to provide alternative debounce defaults
        this.defaultDebounceMs = 0;
    }
    postConstruct() {
        const element = {
            tag: 'div',
            cls: `ag-filter-body-wrapper ag-${this.cssIdentifier}-body-wrapper`,
            children: [this.createBodyTemplate()],
        };
        this.setTemplate(element, this.getAgComponents());
        this.createManagedBean(new managedFocusFeature_1.ManagedFocusFeature(this.getFocusableElement(), {
            handleKeyDown: this.handleKeyDown.bind(this),
        }));
        this.positionableFeature = this.createBean(new positionableFeature_1.PositionableFeature(this.getPositionableElement(), {
            forcePopupParentAsOffsetParent: true,
        }));
    }
    handleKeyDown(_e) { }
    init(legacyParams) {
        const params = legacyParams;
        this.setParams(params);
        this.setModelIntoUi(params.state.model, true).then(() => this.updateUiVisibility());
    }
    refresh(legacyNewParams) {
        const newParams = legacyNewParams;
        const oldParams = this.params;
        this.params = newParams;
        const source = newParams.source;
        if (source === 'colDef') {
            this.updateParams(newParams, oldParams);
        }
        const newState = newParams.state;
        const oldState = this.state;
        this.state = newState;
        if (newState.model !== oldState.model || newState.state !== oldState.state) {
            this.setModelIntoUi(newState.model);
        }
        return true;
    }
    /** Called on init only. Override in subclasses */
    setParams(params) {
        this.params = params;
        this.state = params.state;
        this.commonUpdateParams(params);
    }
    /** Called on refresh only. Override in subclasses */
    updateParams(newParams, oldParams) {
        this.commonUpdateParams(newParams, oldParams);
    }
    commonUpdateParams(newParams, _oldParams) {
        this.applyActive = (0, providedFilterUtils_1._isUseApplyButton)(newParams);
        this.setupApplyDebounced();
    }
    /**
     * @deprecated v34 Use the same method on the filter handler (`api.getColumnFilterHandler()`) instead.
     */
    doesFilterPass(params) {
        (0, logging_1._warn)(283);
        const { getHandler, model, column } = this.params;
        return getHandler().doesFilterPass({
            ...params,
            model: model,
            handlerParams: this.beans.colFilter.getHandlerParams(column),
        });
    }
    getFilterTitle() {
        return this.translate(this.filterNameKey);
    }
    /**
     * @deprecated v34 Filters are active when they have a model. Use `api.getColumnFilterModel()` instead.
     */
    isFilterActive() {
        (0, logging_1._warn)(284);
        return this.params.model != null;
    }
    setupApplyDebounced() {
        const debounceMs = (0, providedFilterUtils_1.getDebounceMs)(this.params, this.defaultDebounceMs);
        const debounceFunc = (0, function_1._debounce)(this, this.checkApplyDebounce.bind(this), debounceMs);
        this.applyDebounced = () => {
            this.debouncePending = true;
            debounceFunc();
        };
    }
    checkApplyDebounce() {
        if (this.debouncePending) {
            // May already have been applied, so don't apply again (e.g. closing filter before debounce timeout)
            this.debouncePending = false;
            this.doApplyModel();
        }
    }
    /**
     * @deprecated v34 Use (`api.getColumnFilterModel()`) instead.
     */
    getModel() {
        (0, logging_1._warn)(285);
        return this.params.model;
    }
    /**
     * @deprecated v34 Use (`api.setColumnFilterModel()`) instead.
     */
    setModel(model) {
        (0, logging_1._warn)(286);
        const { beans, params } = this;
        return beans.colFilter.setModelForColumnLegacy(params.column, model);
    }
    /**
     * Applies changes made in the UI to the filter, and returns true if the model has changed.
     */
    applyModel(_source = 'api') {
        return this.doApplyModel();
    }
    canApply(_model) {
        return true;
    }
    doApplyModel(additionalEventAttributes) {
        const { params, state } = this;
        const changed = !this.areModelsEqual(params.model, state.model);
        if (changed) {
            params.onAction('apply', additionalEventAttributes);
        }
        return changed;
    }
    /**
     * @deprecated v34 Internal method - should only be called by the grid.
     */
    onNewRowsLoaded() {
        // we don't warn here because the multi filter can call this
    }
    /**
     * By default, if the change came from a floating filter it will be applied immediately, otherwise if there is no
     * apply button it will be applied after a debounce, otherwise it will not be applied at all. This behaviour can
     * be adjusted by using the apply parameter.
     */
    onUiChanged(apply, afterFloatingFilter = false) {
        this.updateUiVisibility();
        const model = this.getModelFromUi();
        const state = {
            model,
            state: this.getState(),
            valid: this.canApply(model),
        };
        this.state = state;
        const params = this.params;
        params.onStateChange(state);
        params.onUiChange(this.getUiChangeEventParams());
        if (!this.gos.get('enableFilterHandlers')) {
            this.eventSvc.dispatchEvent({
                type: 'filterModified',
                column: params.column,
                filterInstance: this,
            });
        }
        apply ?? (apply = this.applyActive ? undefined : 'debounce');
        if (apply === 'immediately') {
            this.doApplyModel({ afterFloatingFilter, afterDataChange: false });
        }
        else if (apply === 'debounce') {
            this.applyDebounced();
        }
    }
    getState() {
        return undefined;
    }
    getUiChangeEventParams() {
        return undefined;
    }
    afterGuiAttached(params) {
        this.lastContainerType = params?.container;
        this.refreshFilterResizer(params?.container);
    }
    refreshFilterResizer(containerType) {
        // tool panel is scrollable, so don't need to size
        const { positionableFeature, gos } = this;
        if (!positionableFeature) {
            return;
        }
        const isResizable = containerType === 'floatingFilter' || containerType === 'columnFilter';
        if (isResizable) {
            positionableFeature.restoreLastSize();
            positionableFeature.setResizable(gos.get('enableRtl')
                ? { bottom: true, bottomLeft: true, left: true }
                : { bottom: true, bottomRight: true, right: true });
        }
        else {
            positionableFeature.removeSizeFromEl();
            positionableFeature.setResizable(false);
        }
        positionableFeature.constrainSizeToAvailableHeight(isResizable);
    }
    afterGuiDetached() {
        this.checkApplyDebounce();
        this.positionableFeature?.constrainSizeToAvailableHeight(false);
    }
    destroy() {
        this.positionableFeature = this.destroyBean(this.positionableFeature);
        super.destroy();
    }
    translate(key) {
        return (0, filterLocaleText_1.translateForFilter)(this, key);
    }
    // override to control positionable feature
    getPositionableElement() {
        return this.getGui();
    }
    areModelsEqual(a, b) {
        // same or both missing
        if (a === b || (a == null && b == null)) {
            return true;
        }
        // one is missing, other present
        if (a == null || b == null) {
            return false;
        }
        return this.areNonNullModelsEqual(a, b);
    }
}
exports.ProvidedFilter = ProvidedFilter;


/***/ }),

/***/ 96808:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._isUseApplyButton = exports.getDebounceMs = void 0;
const logging_1 = __webpack_require__(47764);
function getDebounceMs(params, debounceDefault) {
    const { debounceMs } = params;
    if (_isUseApplyButton(params)) {
        if (debounceMs != null) {
            (0, logging_1._warn)(71);
        }
        return 0;
    }
    return debounceMs ?? debounceDefault;
}
exports.getDebounceMs = getDebounceMs;
function _isUseApplyButton(params) {
    return (params.buttons?.indexOf('apply') ?? -1) >= 0;
}
exports._isUseApplyButton = _isUseApplyButton;


/***/ }),

/***/ 93820:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScalarFilterHandler = void 0;
const logging_1 = __webpack_require__(47764);
const simpleFilterHandler_1 = __webpack_require__(62322);
const simpleFilterUtils_1 = __webpack_require__(97535);
class ScalarFilterHandler extends simpleFilterHandler_1.SimpleFilterHandler {
    evaluateNullValue(filterType) {
        const { includeBlanksInEquals, includeBlanksInNotEqual, includeBlanksInGreaterThan, includeBlanksInLessThan, includeBlanksInRange, } = this.params.filterParams;
        switch (filterType) {
            case 'equals':
                if (includeBlanksInEquals) {
                    return true;
                }
                break;
            case 'notEqual':
                if (includeBlanksInNotEqual) {
                    return true;
                }
                break;
            case 'greaterThan':
            case 'greaterThanOrEqual':
                if (includeBlanksInGreaterThan) {
                    return true;
                }
                break;
            case 'lessThan':
            case 'lessThanOrEqual':
                if (includeBlanksInLessThan) {
                    return true;
                }
                break;
            case 'inRange':
                if (includeBlanksInRange) {
                    return true;
                }
                break;
            case 'blank':
                return true;
            case 'notBlank':
                return false;
        }
        return false;
    }
    evaluateNonNullValue(values, cellValue, filterModel) {
        const type = filterModel.type;
        if (!this.isValid(cellValue)) {
            return type === 'notEqual' || type === 'notBlank';
        }
        const comparator = this.comparator();
        const compareResult = values[0] != null ? comparator(values[0], cellValue) : 0;
        switch (type) {
            case 'equals':
                return compareResult === 0;
            case 'notEqual':
                return compareResult !== 0;
            case 'greaterThan':
                return compareResult > 0;
            case 'greaterThanOrEqual':
                return compareResult >= 0;
            case 'lessThan':
                return compareResult < 0;
            case 'lessThanOrEqual':
                return compareResult <= 0;
            case 'inRange': {
                const compareToResult = comparator(values[1], cellValue);
                return this.params.filterParams.inRangeInclusive
                    ? compareResult >= 0 && compareToResult <= 0
                    : compareResult > 0 && compareToResult < 0;
            }
            case 'blank':
                return (0, simpleFilterUtils_1.isBlank)(cellValue);
            case 'notBlank':
                return !(0, simpleFilterUtils_1.isBlank)(cellValue);
            default:
                (0, logging_1._warn)(76, { filterModelType: type });
                return true;
        }
    }
}
exports.ScalarFilterHandler = ScalarFilterHandler;


/***/ }),

/***/ 95220:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SimpleFilter = void 0;
const array_1 = __webpack_require__(31502);
const dom_1 = __webpack_require__(33507);
const promise_1 = __webpack_require__(57990);
const logging_1 = __webpack_require__(47764);
const agAbstractInputField_1 = __webpack_require__(98085);
const agRadioButton_1 = __webpack_require__(77336);
const agSelect_1 = __webpack_require__(70159);
const component_1 = __webpack_require__(78020);
const optionsFactory_1 = __webpack_require__(74824);
const providedFilter_1 = __webpack_require__(2245);
const simpleFilterUtils_1 = __webpack_require__(97535);
/**
 * Every filter with a dropdown where the user can specify a comparing type against the filter values.
 *
 * @param M type of filter-model managed by the concrete sub-class that extends this type
 * @param V type of value managed by the concrete sub-class that extends this type
 * @param E type of UI element used for collecting user-input
 */
class SimpleFilter extends providedFilter_1.ProvidedFilter {
    constructor(filterNameKey, mapValuesFromModel, defaultOptions) {
        super(filterNameKey, 'simple-filter');
        this.mapValuesFromModel = mapValuesFromModel;
        this.defaultOptions = defaultOptions;
        this.eTypes = [];
        this.eJoinPanels = [];
        this.eJoinAnds = [];
        this.eJoinOrs = [];
        this.eConditionBodies = [];
        this.listener = () => this.onUiChanged();
        this.lastUiCompletePosition = null;
        this.joinOperatorId = 0;
    }
    setParams(params) {
        super.setParams(params);
        const optionsFactory = new optionsFactory_1.OptionsFactory();
        this.optionsFactory = optionsFactory;
        optionsFactory.init(params, this.defaultOptions);
        this.commonUpdateSimpleParams(params);
        this.createOption();
        this.createMissingConditionsAndOperators();
    }
    updateParams(newParams, oldParams) {
        this.optionsFactory.refresh(newParams, this.defaultOptions);
        super.updateParams(newParams, oldParams);
        this.commonUpdateSimpleParams(newParams);
    }
    commonUpdateSimpleParams(params) {
        this.setNumConditions(params);
        this.defaultJoinOperator = (0, simpleFilterUtils_1.getDefaultJoinOperator)(params.defaultJoinOperator);
        this.filterPlaceholder = params.filterPlaceholder;
        this.createFilterListOptions();
        const eGui = this.getGui();
        if (this.isReadOnly()) {
            // only do this when read only (so no other focusable elements), otherwise the tab order breaks
            // as the tabbed layout managed focus feature will focus the body when it shouldn't
            eGui.setAttribute('tabindex', '-1');
        }
        else {
            eGui.removeAttribute('tabindex');
        }
    }
    // floating filter calls this when user applies filter from floating filter
    onFloatingFilterChanged(type, value) {
        this.setTypeFromFloatingFilter(type);
        this.setValueFromFloatingFilter(value);
        this.onUiChanged('immediately', true);
    }
    setTypeFromFloatingFilter(type) {
        this.eTypes.forEach((eType, position) => {
            const value = position === 0 ? type : this.optionsFactory.defaultOption;
            eType.setValue(value, true);
        });
    }
    getModelFromUi() {
        const conditions = this.getUiCompleteConditions();
        if (conditions.length === 0) {
            return null;
        }
        if (this.maxNumConditions > 1 && conditions.length > 1) {
            return {
                filterType: this.filterType,
                operator: this.getJoinOperator(),
                conditions,
            };
        }
        return conditions[0];
    }
    getConditionTypes() {
        return this.eTypes.map((eType) => eType.getValue());
    }
    getConditionType(position) {
        return this.eTypes[position].getValue();
    }
    getJoinOperator() {
        const { eJoinOrs: eJoinOperatorsOr, defaultJoinOperator } = this;
        return eJoinOperatorsOr.length === 0
            ? defaultJoinOperator
            : eJoinOperatorsOr[0].getValue() === true
                ? 'OR'
                : 'AND';
    }
    areNonNullModelsEqual(a, b) {
        // one is combined, the other is not
        const aIsSimple = !a.operator;
        const bIsSimple = !b.operator;
        const oneSimpleOneCombined = (!aIsSimple && bIsSimple) || (aIsSimple && !bIsSimple);
        if (oneSimpleOneCombined) {
            return false;
        }
        let res;
        // otherwise both present, so compare
        if (aIsSimple) {
            const aSimple = a;
            const bSimple = b;
            res = this.areSimpleModelsEqual(aSimple, bSimple);
        }
        else {
            const aCombined = a;
            const bCombined = b;
            res =
                aCombined.operator === bCombined.operator &&
                    (0, array_1._areEqual)(aCombined.conditions, bCombined.conditions, (aModel, bModel) => this.areSimpleModelsEqual(aModel, bModel));
        }
        return res;
    }
    setModelIntoUi(model, isInitialLoad) {
        if (model == null) {
            this.resetUiToDefaults(isInitialLoad);
            return promise_1.AgPromise.resolve();
        }
        const isCombined = model.operator;
        if (isCombined) {
            const combinedModel = model;
            let conditions = combinedModel.conditions;
            if (conditions == null) {
                conditions = [];
                (0, logging_1._warn)(77);
            }
            const numConditions = (0, simpleFilterUtils_1.validateAndUpdateConditions)(conditions, this.maxNumConditions);
            const numPrevConditions = this.getNumConditions();
            if (numConditions < numPrevConditions) {
                this.removeConditionsAndOperators(numConditions);
            }
            else if (numConditions > numPrevConditions) {
                for (let i = numPrevConditions; i < numConditions; i++) {
                    this.createJoinOperatorPanel();
                    this.createOption();
                }
            }
            const orChecked = combinedModel.operator === 'OR';
            this.eJoinAnds.forEach((eJoinOperatorAnd) => eJoinOperatorAnd.setValue(!orChecked, true));
            this.eJoinOrs.forEach((eJoinOperatorOr) => eJoinOperatorOr.setValue(orChecked, true));
            conditions.forEach((condition, position) => {
                this.eTypes[position].setValue(condition.type, true);
                this.setConditionIntoUi(condition, position);
            });
        }
        else {
            const simpleModel = model;
            if (this.getNumConditions() > 1) {
                this.removeConditionsAndOperators(1);
            }
            this.eTypes[0].setValue(simpleModel.type, true);
            this.setConditionIntoUi(simpleModel, 0);
        }
        this.lastUiCompletePosition = this.getNumConditions() - 1;
        this.createMissingConditionsAndOperators();
        this.updateUiVisibility();
        if (!isInitialLoad) {
            this.params.onUiChange(this.getUiChangeEventParams());
        }
        return promise_1.AgPromise.resolve();
    }
    setNumConditions(params) {
        let maxNumConditions = params.maxNumConditions ?? 2;
        if (maxNumConditions < 1) {
            (0, logging_1._warn)(79);
            maxNumConditions = 1;
        }
        this.maxNumConditions = maxNumConditions;
        let numAlwaysVisibleConditions = params.numAlwaysVisibleConditions ?? 1;
        if (numAlwaysVisibleConditions < 1) {
            (0, logging_1._warn)(80);
            numAlwaysVisibleConditions = 1;
        }
        if (numAlwaysVisibleConditions > maxNumConditions) {
            (0, logging_1._warn)(81);
            numAlwaysVisibleConditions = maxNumConditions;
        }
        this.numAlwaysVisibleConditions = numAlwaysVisibleConditions;
    }
    createOption() {
        const eGui = this.getGui();
        const eType = this.createManagedBean(new agSelect_1.AgSelect());
        this.eTypes.push(eType);
        eType.addCss('ag-filter-select');
        eGui.appendChild(eType.getGui());
        const eConditionBody = this.createEValue();
        this.eConditionBodies.push(eConditionBody);
        eGui.appendChild(eConditionBody);
        this.putOptionsIntoDropdown(eType);
        this.resetType(eType);
        const position = this.getNumConditions() - 1;
        this.forEachPositionInput(position, (element) => this.resetInput(element));
        this.addChangedListeners(eType, position);
    }
    createJoinOperatorPanel() {
        const eJoinOperatorPanel = (0, dom_1._createElement)({ tag: 'div', cls: 'ag-filter-condition' });
        this.eJoinPanels.push(eJoinOperatorPanel);
        const eJoinOperatorAnd = this.createJoinOperator(this.eJoinAnds, eJoinOperatorPanel, 'and');
        const eJoinOperatorOr = this.createJoinOperator(this.eJoinOrs, eJoinOperatorPanel, 'or');
        this.getGui().appendChild(eJoinOperatorPanel);
        const index = this.eJoinPanels.length - 1;
        const uniqueGroupId = this.joinOperatorId++;
        this.resetJoinOperatorAnd(eJoinOperatorAnd, index, uniqueGroupId);
        this.resetJoinOperatorOr(eJoinOperatorOr, index, uniqueGroupId);
        if (!this.isReadOnly()) {
            eJoinOperatorAnd.onValueChange(this.listener);
            eJoinOperatorOr.onValueChange(this.listener);
        }
    }
    createJoinOperator(eJoinOperators, eJoinOperatorPanel, andOr) {
        const eJoinOperator = this.createManagedBean(new agRadioButton_1.AgRadioButton());
        eJoinOperators.push(eJoinOperator);
        const baseClass = 'ag-filter-condition-operator';
        eJoinOperator.addCss(baseClass);
        eJoinOperator.addCss(`${baseClass}-${andOr}`);
        eJoinOperatorPanel.appendChild(eJoinOperator.getGui());
        return eJoinOperator;
    }
    createFilterListOptions() {
        this.filterListOptions = this.optionsFactory.filterOptions.map((option) => typeof option === 'string' ? this.createBoilerplateListOption(option) : this.createCustomListOption(option));
    }
    putOptionsIntoDropdown(eType) {
        const { filterListOptions } = this;
        // Add specified options to condition drop-down.
        filterListOptions.forEach((listOption) => {
            eType.addOption(listOption);
        });
        // Make drop-downs read-only if there is only one option.
        eType.setDisabled(filterListOptions.length <= 1);
    }
    createBoilerplateListOption(option) {
        return { value: option, text: this.translate(option) };
    }
    createCustomListOption(option) {
        const { displayKey } = option;
        const customOption = this.optionsFactory.getCustomOption(option.displayKey);
        return {
            value: displayKey,
            text: customOption
                ? this.getLocaleTextFunc()(customOption.displayKey, customOption.displayName)
                : this.translate(displayKey),
        };
    }
    createBodyTemplate() {
        // created dynamically
        return null;
    }
    getAgComponents() {
        // created dynamically
        return [];
    }
    updateUiVisibility() {
        const joinOperator = this.getJoinOperator();
        this.updateNumConditions();
        // from here, the number of elements in all the collections is correct, so can just update the values/statuses
        this.updateConditionStatusesAndValues(this.lastUiCompletePosition, joinOperator);
    }
    updateNumConditions() {
        // Collection sizes are already correct if updated via API, so only need to handle UI updates here
        let lastUiCompletePosition = -1;
        let areAllConditionsUiComplete = true;
        for (let position = 0; position < this.getNumConditions(); position++) {
            if (this.isConditionUiComplete(position)) {
                lastUiCompletePosition = position;
            }
            else {
                areAllConditionsUiComplete = false;
            }
        }
        if (this.shouldAddNewConditionAtEnd(areAllConditionsUiComplete)) {
            this.createJoinOperatorPanel();
            this.createOption();
        }
        else {
            const activePosition = this.lastUiCompletePosition ?? this.getNumConditions() - 2;
            if (lastUiCompletePosition < activePosition) {
                // remove any incomplete conditions at the end, excluding the active position
                this.removeConditionsAndOperators(activePosition + 1);
                const removeStartPosition = lastUiCompletePosition + 1;
                const numConditionsToRemove = activePosition - removeStartPosition;
                if (numConditionsToRemove > 0) {
                    this.removeConditionsAndOperators(removeStartPosition, numConditionsToRemove);
                }
                this.createMissingConditionsAndOperators();
            }
        }
        this.lastUiCompletePosition = lastUiCompletePosition;
    }
    updateConditionStatusesAndValues(lastUiCompletePosition, joinOperator) {
        this.eTypes.forEach((eType, position) => {
            const disabled = this.isConditionDisabled(position, lastUiCompletePosition);
            eType.setDisabled(disabled || this.filterListOptions.length <= 1);
            if (position === 1) {
                (0, dom_1._setDisabled)(this.eJoinPanels[0], disabled);
                this.eJoinAnds[0].setDisabled(disabled);
                this.eJoinOrs[0].setDisabled(disabled);
            }
        });
        this.eConditionBodies.forEach((element, index) => {
            (0, dom_1._setDisplayed)(element, this.isConditionBodyVisible(index));
        });
        const orChecked = (joinOperator ?? this.getJoinOperator()) === 'OR';
        this.eJoinAnds.forEach((eJoinOperatorAnd) => {
            eJoinOperatorAnd.setValue(!orChecked, true);
        });
        this.eJoinOrs.forEach((eJoinOperatorOr) => {
            eJoinOperatorOr.setValue(orChecked, true);
        });
        this.forEachInput((element, index, position, numberOfInputs) => {
            this.setElementDisplayed(element, index < numberOfInputs);
            this.setElementDisabled(element, this.isConditionDisabled(position, lastUiCompletePosition));
        });
        this.resetPlaceholder();
    }
    shouldAddNewConditionAtEnd(areAllConditionsUiComplete) {
        return areAllConditionsUiComplete && this.getNumConditions() < this.maxNumConditions && !this.isReadOnly();
    }
    removeConditionsAndOperators(startPosition, deleteCount) {
        if (startPosition >= this.getNumConditions()) {
            return;
        }
        const { eTypes, eConditionBodies, eJoinPanels: eJoinOperatorPanels, eJoinAnds: eJoinOperatorsAnd, eJoinOrs: eJoinOperatorsOr, } = this;
        this.removeComponents(eTypes, startPosition, deleteCount);
        this.removeElements(eConditionBodies, startPosition, deleteCount);
        this.removeEValues(startPosition, deleteCount);
        const joinOperatorIndex = Math.max(startPosition - 1, 0);
        this.removeElements(eJoinOperatorPanels, joinOperatorIndex, deleteCount);
        this.removeComponents(eJoinOperatorsAnd, joinOperatorIndex, deleteCount);
        this.removeComponents(eJoinOperatorsOr, joinOperatorIndex, deleteCount);
    }
    removeElements(elements, startPosition, deleteCount) {
        const removedElements = (0, simpleFilterUtils_1.removeItems)(elements, startPosition, deleteCount);
        removedElements.forEach((element) => (0, dom_1._removeFromParent)(element));
    }
    removeComponents(components, startPosition, deleteCount) {
        const removedComponents = (0, simpleFilterUtils_1.removeItems)(components, startPosition, deleteCount);
        removedComponents.forEach((comp) => {
            (0, dom_1._removeFromParent)(comp.getGui());
            this.destroyBean(comp);
        });
    }
    afterGuiAttached(params) {
        super.afterGuiAttached(params);
        this.resetPlaceholder();
        if (!params?.suppressFocus) {
            let elementToFocus;
            if (!this.isReadOnly()) {
                const firstInput = this.getInputs(0)[0];
                if (firstInput instanceof agAbstractInputField_1.AgAbstractInputField && this.isConditionBodyVisible(0)) {
                    elementToFocus = firstInput.getInputElement();
                }
                else {
                    // focus the dropdown instead
                    elementToFocus = this.eTypes[0]?.getFocusableElement();
                }
            }
            // something needs focus otherwise keyboard navigation breaks, so focus the filter body if missing
            (elementToFocus ?? this.getGui()).focus({ preventScroll: true });
        }
    }
    afterGuiDetached() {
        super.afterGuiDetached();
        const params = this.params;
        if (this.beans.colFilter?.shouldKeepStateOnDetach(params.column)) {
            return;
        }
        // Reset temporary UI state that was applied to the DOM but not committed to the model
        params.onStateChange({
            model: params.model,
        });
        // remove incomplete positions
        let lastUiCompletePosition = -1;
        // as we remove incomplete positions, the last UI complete position will change
        let updatedLastUiCompletePosition = -1;
        let conditionsRemoved = false;
        const joinOperator = this.getJoinOperator();
        for (let position = this.getNumConditions() - 1; position >= 0; position--) {
            if (this.isConditionUiComplete(position)) {
                if (lastUiCompletePosition === -1) {
                    lastUiCompletePosition = position;
                    updatedLastUiCompletePosition = position;
                }
            }
            else {
                const shouldRemovePositionAtEnd = position >= this.numAlwaysVisibleConditions && !this.isConditionUiComplete(position - 1);
                const positionBeforeLastUiCompletePosition = position < lastUiCompletePosition;
                if (shouldRemovePositionAtEnd || positionBeforeLastUiCompletePosition) {
                    this.removeConditionsAndOperators(position, 1);
                    conditionsRemoved = true;
                    if (positionBeforeLastUiCompletePosition) {
                        updatedLastUiCompletePosition--;
                    }
                }
            }
        }
        let shouldUpdateConditionStatusesAndValues = false;
        if (this.getNumConditions() < this.numAlwaysVisibleConditions) {
            // if conditions have been removed, need to recreate new ones at the end up to the number required
            this.createMissingConditionsAndOperators();
            shouldUpdateConditionStatusesAndValues = true;
        }
        if (this.shouldAddNewConditionAtEnd(updatedLastUiCompletePosition === this.getNumConditions() - 1)) {
            this.createJoinOperatorPanel();
            this.createOption();
            shouldUpdateConditionStatusesAndValues = true;
        }
        if (shouldUpdateConditionStatusesAndValues) {
            this.updateConditionStatusesAndValues(updatedLastUiCompletePosition, joinOperator);
        }
        if (conditionsRemoved) {
            this.updateJoinOperatorsDisabled();
        }
        this.lastUiCompletePosition = updatedLastUiCompletePosition;
    }
    getModelAsString(model) {
        return this.params.getHandler()?.getModelAsString?.(model) ?? '';
    }
    getPlaceholderText(defaultPlaceholder, position) {
        let placeholder = this.translate(defaultPlaceholder);
        if (typeof this.filterPlaceholder === 'function') {
            const filterOptionKey = this.eTypes[position].getValue();
            const filterOption = this.translate(filterOptionKey);
            placeholder = this.filterPlaceholder({
                filterOptionKey,
                filterOption,
                placeholder,
            });
        }
        else if (typeof this.filterPlaceholder === 'string') {
            placeholder = this.filterPlaceholder;
        }
        return placeholder;
    }
    // allow sub-classes to reset HTML placeholders after UI update.
    resetPlaceholder() {
        const globalTranslate = this.getLocaleTextFunc();
        this.forEachInput((element, index, position, numberOfInputs) => {
            if (!(element instanceof agAbstractInputField_1.AgAbstractInputField)) {
                return;
            }
            const placeholder = index === 0 && numberOfInputs > 1 ? 'inRangeStart' : index === 0 ? 'filterOoo' : 'inRangeEnd';
            const ariaLabel = index === 0 && numberOfInputs > 1
                ? globalTranslate('ariaFilterFromValue', 'Filter from value')
                : index === 0
                    ? globalTranslate('ariaFilterValue', 'Filter Value')
                    : globalTranslate('ariaFilterToValue', 'Filter to Value');
            element.setInputPlaceholder(this.getPlaceholderText(placeholder, position));
            element.setInputAriaLabel(ariaLabel);
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setElementValue(element, value, fromFloatingFilter) {
        if (element instanceof agAbstractInputField_1.AgAbstractInputField) {
            element.setValue(value != null ? String(value) : null, true);
        }
    }
    setElementDisplayed(element, displayed) {
        if (element instanceof component_1.Component) {
            (0, dom_1._setDisplayed)(element.getGui(), displayed);
        }
    }
    setElementDisabled(element, disabled) {
        if (element instanceof component_1.Component) {
            (0, dom_1._setDisabled)(element.getGui(), disabled);
        }
    }
    attachElementOnChange(element, listener) {
        if (element instanceof agAbstractInputField_1.AgAbstractInputField) {
            element.onValueChange(listener);
        }
    }
    forEachInput(cb) {
        this.getConditionTypes().forEach((type, position) => {
            this.forEachPositionTypeInput(position, type, cb);
        });
    }
    forEachPositionInput(position, cb) {
        const type = this.getConditionType(position);
        this.forEachPositionTypeInput(position, type, cb);
    }
    forEachPositionTypeInput(position, type, cb) {
        const numberOfInputs = (0, simpleFilterUtils_1.getNumberOfInputs)(type, this.optionsFactory);
        const inputs = this.getInputs(position);
        for (let index = 0; index < inputs.length; index++) {
            const input = inputs[index];
            if (input != null) {
                cb(input, index, position, numberOfInputs);
            }
        }
    }
    isConditionDisabled(position, lastUiCompletePosition) {
        if (this.isReadOnly()) {
            return true;
        } // Read-only mode trumps everything.
        if (position === 0) {
            return false;
        } // Position 0 should typically be editable.
        // Only allow editing of a 2nd or later condition if the previous condition is complete and no subsequent conditions are complete.
        return position > lastUiCompletePosition + 1;
    }
    isConditionBodyVisible(position) {
        // Check that the condition needs inputs.
        const type = this.getConditionType(position);
        const numberOfInputs = (0, simpleFilterUtils_1.getNumberOfInputs)(type, this.optionsFactory);
        return numberOfInputs > 0;
    }
    // returns true if the UI represents a working filter, eg all parts are filled out.
    // eg if text filter and textfield blank then returns false.
    isConditionUiComplete(position) {
        if (position >= this.getNumConditions()) {
            return false;
        } // Condition doesn't exist.
        const type = this.getConditionType(position);
        if (type === 'empty') {
            return false;
        }
        if (this.getValues(position).some((v) => v == null)) {
            return false;
        }
        return true;
    }
    getNumConditions() {
        return this.eTypes.length;
    }
    getUiCompleteConditions() {
        const conditions = [];
        for (let position = 0; position < this.getNumConditions(); position++) {
            if (this.isConditionUiComplete(position)) {
                conditions.push(this.createCondition(position));
            }
        }
        return conditions;
    }
    createMissingConditionsAndOperators() {
        if (this.isReadOnly()) {
            return;
        } // don't show incomplete conditions when read only
        for (let i = this.getNumConditions(); i < this.numAlwaysVisibleConditions; i++) {
            this.createJoinOperatorPanel();
            this.createOption();
        }
    }
    resetUiToDefaults(silent) {
        this.removeConditionsAndOperators(this.isReadOnly() ? 1 : this.numAlwaysVisibleConditions);
        this.eTypes.forEach((eType) => this.resetType(eType));
        this.eJoinAnds.forEach((eJoinOperatorAnd, index) => this.resetJoinOperatorAnd(eJoinOperatorAnd, index, this.joinOperatorId + index));
        this.eJoinOrs.forEach((eJoinOperatorOr, index) => this.resetJoinOperatorOr(eJoinOperatorOr, index, this.joinOperatorId + index));
        this.joinOperatorId++;
        this.forEachInput((element) => this.resetInput(element));
        this.resetPlaceholder();
        this.createMissingConditionsAndOperators();
        this.lastUiCompletePosition = null;
        this.updateUiVisibility();
        if (!silent) {
            this.params.onUiChange(this.getUiChangeEventParams());
        }
    }
    resetType(eType) {
        const translate = this.getLocaleTextFunc();
        const filteringLabel = translate('ariaFilteringOperator', 'Filtering operator');
        eType
            .setValue(this.optionsFactory.defaultOption, true)
            .setAriaLabel(filteringLabel)
            .setDisabled(this.isReadOnly() || this.filterListOptions.length <= 1);
    }
    resetJoinOperatorAnd(eJoinOperatorAnd, index, uniqueGroupId) {
        this.resetJoinOperator(eJoinOperatorAnd, index, this.defaultJoinOperator === 'AND', this.translate('andCondition'), uniqueGroupId);
    }
    resetJoinOperatorOr(eJoinOperatorOr, index, uniqueGroupId) {
        this.resetJoinOperator(eJoinOperatorOr, index, this.defaultJoinOperator === 'OR', this.translate('orCondition'), uniqueGroupId);
    }
    resetJoinOperator(eJoinOperator, index, value, label, uniqueGroupId) {
        this.updateJoinOperatorDisabled(eJoinOperator
            .setValue(value, true)
            .setName(`ag-simple-filter-and-or-${this.getCompId()}-${uniqueGroupId}`)
            .setLabel(label), index);
    }
    updateJoinOperatorsDisabled() {
        const updater = (eJoinOperator, index) => this.updateJoinOperatorDisabled(eJoinOperator, index);
        this.eJoinAnds.forEach(updater);
        this.eJoinOrs.forEach(updater);
    }
    updateJoinOperatorDisabled(eJoinOperator, index) {
        eJoinOperator.setDisabled(this.isReadOnly() || index > 0);
    }
    resetInput(element) {
        this.setElementValue(element, null);
        this.setElementDisabled(element, this.isReadOnly());
    }
    // puts model values into the UI
    setConditionIntoUi(model, position) {
        const values = this.mapValuesFromModel(model, this.optionsFactory);
        this.forEachInput((element, index, elPosition) => {
            if (elPosition !== position) {
                return;
            }
            this.setElementValue(element, values[index] != null ? values[index] : null);
        });
    }
    // after floating filter changes, this sets the 'value' section. this is implemented by the base class
    // (as that's where value is controlled), the 'type' part from the floating filter is dealt with in this class.
    setValueFromFloatingFilter(value) {
        this.forEachInput((element, index, position) => {
            this.setElementValue(element, index === 0 && position === 0 ? value : null, true);
        });
    }
    addChangedListeners(eType, position) {
        if (this.isReadOnly()) {
            return;
        }
        eType.onValueChange(this.listener);
        this.forEachPositionInput(position, (element) => {
            this.attachElementOnChange(element, this.listener);
        });
    }
    hasInvalidInputs() {
        return false;
    }
    isReadOnly() {
        return !!this.params.readOnly;
    }
}
exports.SimpleFilter = SimpleFilter;


/***/ }),

/***/ 62322:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SimpleFilterHandler = void 0;
const beanStub_1 = __webpack_require__(68731);
const iSimpleFilter_1 = __webpack_require__(78845);
const optionsFactory_1 = __webpack_require__(74824);
const simpleFilterUtils_1 = __webpack_require__(97535);
class SimpleFilterHandler extends beanStub_1.BeanStub {
    constructor(mapValuesFromModel, defaultOptions) {
        super();
        this.mapValuesFromModel = mapValuesFromModel;
        this.defaultOptions = defaultOptions;
    }
    init(params) {
        const filterParams = params.filterParams;
        const optionsFactory = new optionsFactory_1.OptionsFactory();
        this.optionsFactory = optionsFactory;
        optionsFactory.init(filterParams, this.defaultOptions);
        this.filterModelFormatter = this.createManagedBean(new this.FilterModelFormatterClass(optionsFactory, filterParams));
        this.updateParams(params);
        this.validateModel(params);
    }
    refresh(params) {
        if (params.source === 'colDef') {
            const filterParams = params.filterParams;
            const optionsFactory = this.optionsFactory;
            optionsFactory.refresh(filterParams, this.defaultOptions);
            this.filterModelFormatter.updateParams({ optionsFactory, filterParams });
            this.updateParams(params);
        }
        this.validateModel(params);
    }
    updateParams(params) {
        this.params = params;
    }
    doesFilterPass(params) {
        const model = params.model;
        if (model == null) {
            return true;
        }
        const { operator } = model;
        const models = [];
        if (operator) {
            const combinedModel = model;
            models.push(...(combinedModel.conditions ?? []));
        }
        else {
            models.push(model);
        }
        const combineFunction = operator && operator === 'OR' ? 'some' : 'every';
        const cellValue = this.params.getValue(params.node);
        return models[combineFunction]((m) => this.individualConditionPasses(params, m, cellValue));
    }
    getModelAsString(model, source) {
        return this.filterModelFormatter.getModelAsString(model, source) ?? '';
    }
    validateModel(params) {
        const { model, filterParams: { filterOptions, maxNumConditions }, } = params;
        if (model == null) {
            return;
        }
        const isCombined = (0, iSimpleFilter_1.isCombinedFilterModel)(model);
        let conditions = isCombined ? model.conditions : [model];
        // Invalid when one of the existing condition options is not in new options list
        const newOptionsList = filterOptions?.map((option) => (typeof option === 'string' ? option : option.displayKey)) ??
            this.defaultOptions;
        const allConditionsExistInNewOptionsList = !conditions ||
            conditions.every((condition) => newOptionsList.find((option) => option === condition.type) !== undefined);
        if (!allConditionsExistInNewOptionsList) {
            this.params = {
                ...params,
                model: null,
            };
            params.onModelChange(null);
            return;
        }
        let needsUpdate = false;
        const filterType = this.filterType;
        if ((conditions && !conditions.every((condition) => condition.filterType === filterType)) ||
            model.filterType !== filterType) {
            // need to add filterType to model
            conditions = conditions.map((condition) => ({ ...condition, filterType }));
            needsUpdate = true;
        }
        // Check number of conditions vs maxNumConditions
        if (typeof maxNumConditions === 'number' && conditions && conditions.length > maxNumConditions) {
            conditions = conditions.slice(0, maxNumConditions);
            needsUpdate = true;
        }
        if (needsUpdate) {
            const updatedModel = conditions.length > 1
                ? {
                    ...model,
                    filterType,
                    conditions,
                }
                : {
                    ...conditions[0],
                    filterType,
                };
            this.params = {
                ...params,
                model: updatedModel,
            };
            params.onModelChange(updatedModel);
            return;
        }
    }
    /** returns true if the row passes the said condition */
    individualConditionPasses(params, filterModel, cellValue) {
        const optionsFactory = this.optionsFactory;
        const values = this.mapValuesFromModel(filterModel, optionsFactory);
        const customFilterOption = optionsFactory.getCustomOption(filterModel.type);
        const customFilterResult = (0, simpleFilterUtils_1.evaluateCustomFilter)(customFilterOption, values, cellValue);
        if (customFilterResult != null) {
            return customFilterResult;
        }
        if (cellValue == null) {
            return this.evaluateNullValue(filterModel.type);
        }
        return this.evaluateNonNullValue(values, cellValue, filterModel, params);
    }
}
exports.SimpleFilterHandler = SimpleFilterHandler;


/***/ }),

/***/ 70405:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SimpleFilterModelFormatter = exports.TEXT_FILTER_TYPE_KEYS = exports.SCALAR_FILTER_TYPE_KEYS = void 0;
const beanStub_1 = __webpack_require__(68731);
const filterLocaleText_1 = __webpack_require__(75741);
exports.SCALAR_FILTER_TYPE_KEYS = {
    equals: 'Equals',
    notEqual: 'NotEqual',
    greaterThan: 'GreaterThan',
    greaterThanOrEqual: 'GreaterThanOrEqual',
    lessThan: 'LessThan',
    lessThanOrEqual: 'LessThanOrEqual',
    inRange: 'InRange',
};
exports.TEXT_FILTER_TYPE_KEYS = {
    contains: 'Contains',
    notContains: 'NotContains',
    equals: 'TextEquals',
    notEqual: 'TextNotEqual',
    startsWith: 'StartsWith',
    endsWith: 'EndsWith',
    inRange: 'InRange',
};
class SimpleFilterModelFormatter extends beanStub_1.BeanStub {
    constructor(optionsFactory, filterParams, valueFormatter) {
        super();
        this.optionsFactory = optionsFactory;
        this.filterParams = filterParams;
        this.valueFormatter = valueFormatter;
    }
    // used by:
    // 1) NumberFloatingFilter & TextFloatingFilter: Always, for both when editable and read only.
    // 2) DateFloatingFilter: Only when read only (as we show text rather than a date picker when read only)
    getModelAsString(model, source) {
        const translate = this.getLocaleTextFunc();
        const forToolPanel = source === 'filterToolPanel';
        if (!model) {
            return forToolPanel ? (0, filterLocaleText_1.translateForFilter)(this, 'filterSummaryInactive') : null;
        }
        const isCombined = model.operator != null;
        if (isCombined) {
            const combinedModel = model;
            const conditions = combinedModel.conditions ?? [];
            const customOptions = conditions.map((condition) => this.getModelAsString(condition, source));
            const joinOperatorTranslateKey = combinedModel.operator === 'AND' ? 'andCondition' : 'orCondition';
            return customOptions.join(` ${(0, filterLocaleText_1.translateForFilter)(this, joinOperatorTranslateKey)} `);
        }
        else if (model.type === 'blank' || model.type === 'notBlank') {
            return forToolPanel
                ? (0, filterLocaleText_1.translateForFilter)(this, model.type === 'blank' ? 'filterSummaryBlank' : 'filterSummaryNotBlank')
                : translate(model.type, model.type);
        }
        else {
            const condition = model;
            const customOption = this.optionsFactory.getCustomOption(condition.type);
            // For custom filter options we display the Name of the filter instead
            // of displaying the `from` value, as it wouldn't be relevant
            const { displayKey, displayName, numberOfInputs } = customOption || {};
            if (displayKey && displayName && numberOfInputs === 0) {
                return translate(displayKey, displayName);
            }
            return this.conditionToString(condition, forToolPanel, condition.type === 'inRange' || numberOfInputs === 2, displayKey, displayName);
        }
    }
    updateParams(params) {
        const { optionsFactory, filterParams } = params;
        this.optionsFactory = optionsFactory;
        this.filterParams = filterParams;
    }
    conditionForToolPanel(type, isRange, getFilter, getFilterTo, customDisplayKey, customDisplayName) {
        let typeValue;
        const typeKey = this.getTypeKey(type);
        if (typeKey) {
            typeValue = (0, filterLocaleText_1.translateForFilter)(this, typeKey);
        }
        if (customDisplayKey && customDisplayName) {
            typeValue = this.getLocaleTextFunc()(customDisplayKey, customDisplayName);
        }
        if (typeValue != null) {
            // 0 inputs covered by parent
            if (isRange) {
                return `${typeValue} ${(0, filterLocaleText_1.translateForFilter)(this, 'filterSummaryInRangeValues', [getFilter(), getFilterTo()])}`;
            }
            else {
                return `${typeValue} ${getFilter()}`;
            }
        }
        return null;
    }
    getTypeKey(type) {
        const suffix = this.filterTypeKeys[type];
        return suffix ? `filterSummary${suffix}` : null;
    }
    formatValue(value) {
        const valueFormatter = this.valueFormatter;
        return valueFormatter ? valueFormatter(value ?? null) ?? '' : String(value);
    }
}
exports.SimpleFilterModelFormatter = SimpleFilterModelFormatter;


/***/ }),

/***/ 97535:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getNumberOfInputs = exports.validateAndUpdateConditions = exports.evaluateCustomFilter = exports.getDefaultJoinOperator = exports.isBlank = exports.removeItems = void 0;
const logging_1 = __webpack_require__(47764);
function removeItems(items, startPosition, deleteCount) {
    return deleteCount == null ? items.splice(startPosition) : items.splice(startPosition, deleteCount);
}
exports.removeItems = removeItems;
function isBlank(cellValue) {
    return cellValue == null || (typeof cellValue === 'string' && cellValue.trim().length === 0);
}
exports.isBlank = isBlank;
function getDefaultJoinOperator(defaultJoinOperator) {
    return defaultJoinOperator === 'AND' || defaultJoinOperator === 'OR' ? defaultJoinOperator : 'AND';
}
exports.getDefaultJoinOperator = getDefaultJoinOperator;
function evaluateCustomFilter(customFilterOption, values, cellValue) {
    if (customFilterOption == null) {
        return;
    }
    const { predicate } = customFilterOption;
    // only execute the custom filter if a value exists or a value isn't required, i.e. input is hidden
    if (predicate != null && !values.some((v) => v == null)) {
        return predicate(values, cellValue);
    }
    // No custom filter invocation, indicate that to the caller.
    return;
}
exports.evaluateCustomFilter = evaluateCustomFilter;
function validateAndUpdateConditions(conditions, maxNumConditions) {
    let numConditions = conditions.length;
    if (numConditions > maxNumConditions) {
        conditions.splice(maxNumConditions);
        // 'Filter Model contains more conditions than "filterParams.maxNumConditions". Additional conditions have been ignored.'
        (0, logging_1._warn)(78);
        numConditions = maxNumConditions;
    }
    return numConditions;
}
exports.validateAndUpdateConditions = validateAndUpdateConditions;
function getNumberOfInputs(type, optionsFactory) {
    const customOpts = optionsFactory.getCustomOption(type);
    if (customOpts) {
        const { numberOfInputs } = customOpts;
        return numberOfInputs != null ? numberOfInputs : 1;
    }
    const zeroInputTypes = ['empty', 'notBlank', 'blank'];
    if (type && zeroInputTypes.indexOf(type) >= 0) {
        return 0;
    }
    else if (type === 'inRange') {
        return 2;
    }
    return 1;
}
exports.getNumberOfInputs = getNumberOfInputs;


/***/ }),

/***/ 42811:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextFilter = void 0;
const dom_1 = __webpack_require__(33507);
const generic_1 = __webpack_require__(34422);
const agInputTextField_1 = __webpack_require__(45946);
const simpleFilter_1 = __webpack_require__(95220);
const textFilterConstants_1 = __webpack_require__(30650);
const textFilterUtils_1 = __webpack_require__(2470);
class TextFilter extends simpleFilter_1.SimpleFilter {
    constructor() {
        super('textFilter', textFilterUtils_1.mapValuesFromTextFilterModel, textFilterConstants_1.DEFAULT_TEXT_FILTER_OPTIONS);
        this.filterType = 'text';
        this.eValuesFrom = [];
        this.eValuesTo = [];
        this.defaultDebounceMs = 500;
    }
    createCondition(position) {
        const type = this.getConditionType(position);
        const model = {
            filterType: this.filterType,
            type,
        };
        const values = this.getValuesWithSideEffects(position, true);
        if (values.length > 0) {
            model.filter = values[0];
        }
        if (values.length > 1) {
            model.filterTo = values[1];
        }
        return model;
    }
    areSimpleModelsEqual(aSimple, bSimple) {
        return (aSimple.filter === bSimple.filter && aSimple.filterTo === bSimple.filterTo && aSimple.type === bSimple.type);
    }
    getInputs(position) {
        const { eValuesFrom, eValuesTo } = this;
        if (position >= eValuesFrom.length) {
            return [null, null];
        }
        return [eValuesFrom[position], eValuesTo[position]];
    }
    getValues(position) {
        return this.getValuesWithSideEffects(position, false);
    }
    getValuesWithSideEffects(position, applySideEffects) {
        const result = [];
        this.forEachPositionInput(position, (element, index, _elPosition, numberOfInputs) => {
            if (index < numberOfInputs) {
                let value = (0, generic_1._makeNull)(element.getValue());
                if (applySideEffects && this.params.trimInput) {
                    value = (0, textFilterUtils_1.trimInputForFilter)(value) ?? null;
                    element.setValue(value, true); // ensure clean value is visible
                }
                result.push(value);
            }
        });
        return result;
    }
    createEValue() {
        const eCondition = (0, dom_1._createElement)({ tag: 'div', cls: 'ag-filter-body', role: 'presentation' });
        const { eValuesFrom, eValuesTo } = this;
        this.createFromToElement(eCondition, eValuesFrom, 'from');
        this.createFromToElement(eCondition, eValuesTo, 'to');
        return eCondition;
    }
    createFromToElement(eCondition, eValues, fromTo) {
        const eValue = this.createManagedBean(new agInputTextField_1.AgInputTextField());
        eValue.addCss(`ag-filter-${fromTo}`);
        eValue.addCss('ag-filter-filter');
        eValues.push(eValue);
        eCondition.appendChild(eValue.getGui());
    }
    removeEValues(startPosition, deleteCount) {
        const removeComps = (eGui) => this.removeComponents(eGui, startPosition, deleteCount);
        const { eValuesFrom, eValuesTo } = this;
        removeComps(eValuesFrom);
        removeComps(eValuesTo);
    }
}
exports.TextFilter = TextFilter;


/***/ }),

/***/ 30650:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DEFAULT_TEXT_FILTER_OPTIONS = void 0;
exports.DEFAULT_TEXT_FILTER_OPTIONS = [
    'contains',
    'notContains',
    'equals',
    'notEqual',
    'startsWith',
    'endsWith',
    'blank',
    'notBlank',
];


/***/ }),

/***/ 54259:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextFilterHandler = void 0;
const simpleFilterHandler_1 = __webpack_require__(62322);
const simpleFilterUtils_1 = __webpack_require__(97535);
const textFilterConstants_1 = __webpack_require__(30650);
const textFilterModelFormatter_1 = __webpack_require__(30330);
const textFilterUtils_1 = __webpack_require__(2470);
const defaultMatcher = ({ filterOption, value, filterText }) => {
    if (filterText == null) {
        return false;
    }
    switch (filterOption) {
        case 'contains':
            return value.indexOf(filterText) >= 0;
        case 'notContains':
            return value.indexOf(filterText) < 0;
        case 'equals':
            return value === filterText;
        case 'notEqual':
            return value != filterText;
        case 'startsWith':
            return value.indexOf(filterText) === 0;
        case 'endsWith': {
            const index = value.lastIndexOf(filterText);
            return index >= 0 && index === value.length - filterText.length;
        }
        default:
            return false;
    }
};
const defaultFormatter = (from) => from;
const defaultLowercaseFormatter = (from) => from == null ? null : from.toString().toLowerCase();
class TextFilterHandler extends simpleFilterHandler_1.SimpleFilterHandler {
    constructor() {
        super(textFilterUtils_1.mapValuesFromTextFilterModel, textFilterConstants_1.DEFAULT_TEXT_FILTER_OPTIONS);
        this.filterType = 'text';
        this.FilterModelFormatterClass = textFilterModelFormatter_1.TextFilterModelFormatter;
    }
    updateParams(params) {
        super.updateParams(params);
        this.matcher = params.textMatcher ?? defaultMatcher;
        this.formatter = params.textFormatter ?? (params.caseSensitive ? defaultFormatter : defaultLowercaseFormatter);
    }
    evaluateNullValue(filterType) {
        const filterTypesAllowNulls = ['notEqual', 'notContains', 'blank'];
        return filterType ? filterTypesAllowNulls.indexOf(filterType) >= 0 : false;
    }
    evaluateNonNullValue(values, cellValue, filterModel, params) {
        const formattedValues = values.map((v) => this.formatter(v)) || [];
        const cellValueFormatted = this.formatter(cellValue);
        const { api, colDef, column, context, filterParams: { textFormatter }, } = this.params;
        if (filterModel.type === 'blank') {
            return (0, simpleFilterUtils_1.isBlank)(cellValue);
        }
        else if (filterModel.type === 'notBlank') {
            return !(0, simpleFilterUtils_1.isBlank)(cellValue);
        }
        const matcherParams = {
            api,
            colDef,
            column,
            context,
            node: params.node,
            data: params.data,
            filterOption: filterModel.type,
            value: cellValueFormatted,
            textFormatter,
        };
        return formattedValues.some((v) => this.matcher({ ...matcherParams, filterText: v }));
    }
}
exports.TextFilterHandler = TextFilterHandler;


/***/ }),

/***/ 30330:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextFilterModelFormatter = void 0;
const filterLocaleText_1 = __webpack_require__(75741);
const simpleFilterModelFormatter_1 = __webpack_require__(70405);
class TextFilterModelFormatter extends simpleFilterModelFormatter_1.SimpleFilterModelFormatter {
    constructor() {
        super(...arguments);
        this.filterTypeKeys = simpleFilterModelFormatter_1.TEXT_FILTER_TYPE_KEYS;
    }
    conditionToString(condition, forToolPanel, isRange, customDisplayKey, customDisplayName) {
        const { filter, filterTo, type } = condition;
        if (forToolPanel) {
            const getValueFunc = (value) => () => (0, filterLocaleText_1.translateForFilter)(this, 'filterSummaryTextQuote', [value]);
            const valueForToolPanel = this.conditionForToolPanel(type, isRange, getValueFunc(filter), getValueFunc(filterTo), customDisplayKey, customDisplayName);
            if (valueForToolPanel != null) {
                return valueForToolPanel;
            }
        }
        if (isRange) {
            return `${filter}-${filterTo}`;
        }
        // cater for when the type doesn't need a value
        if (filter != null) {
            return `${filter}`;
        }
        return `${type}`;
    }
}
exports.TextFilterModelFormatter = TextFilterModelFormatter;


/***/ }),

/***/ 2470:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mapValuesFromTextFilterModel = exports.trimInputForFilter = void 0;
const simpleFilterUtils_1 = __webpack_require__(97535);
function trimInputForFilter(value) {
    const trimmedInput = value?.trim();
    // trim the input, unless it is all whitespace (this is consistent with Excel behaviour)
    return trimmedInput === '' ? value : trimmedInput;
}
exports.trimInputForFilter = trimInputForFilter;
function mapValuesFromTextFilterModel(filterModel, optionsFactory) {
    const { filter, filterTo, type } = filterModel || {};
    return [filter || null, filterTo || null].slice(0, (0, simpleFilterUtils_1.getNumberOfInputs)(type, optionsFactory));
}
exports.mapValuesFromTextFilterModel = mapValuesFromTextFilterModel;


/***/ }),

/***/ 38305:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextFloatingFilter = void 0;
const floatingFilterTextInputService_1 = __webpack_require__(97287);
const textInputFloatingFilter_1 = __webpack_require__(48922);
const textFilterConstants_1 = __webpack_require__(30650);
const textFilterModelFormatter_1 = __webpack_require__(30330);
class TextFloatingFilter extends textInputFloatingFilter_1.TextInputFloatingFilter {
    constructor() {
        super(...arguments);
        this.FilterModelFormatterClass = textFilterModelFormatter_1.TextFilterModelFormatter;
        this.filterType = 'text';
        this.defaultOptions = textFilterConstants_1.DEFAULT_TEXT_FILTER_OPTIONS;
    }
    createFloatingFilterInputService() {
        return this.createManagedBean(new floatingFilterTextInputService_1.FloatingFilterTextInputService());
    }
}
exports.TextFloatingFilter = TextFloatingFilter;


/***/ }),

/***/ 5381:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resetQuickFilter = exports.getQuickFilter = exports.isQuickFilterPresent = void 0;
function isQuickFilterPresent(beans) {
    return !!beans.quickFilter?.isFilterPresent();
}
exports.isQuickFilterPresent = isQuickFilterPresent;
function getQuickFilter(beans) {
    return beans.quickFilter?.getText();
}
exports.getQuickFilter = getQuickFilter;
function resetQuickFilter(beans) {
    beans.quickFilter?.resetCache();
}
exports.resetQuickFilter = resetQuickFilter;


/***/ }),

/***/ 91238:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.QuickFilterService = void 0;
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const generic_1 = __webpack_require__(34422);
const logging_1 = __webpack_require__(47764);
class QuickFilterService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'quickFilter';
        this.quickFilter = null;
        this.quickFilterParts = null;
    }
    postConstruct() {
        const resetListener = this.resetCache.bind(this);
        const gos = this.gos;
        this.addManagedEventListeners({
            columnPivotModeChanged: resetListener,
            newColumnsLoaded: resetListener,
            columnRowGroupChanged: resetListener,
            columnVisible: () => {
                if (!gos.get('includeHiddenColumnsInQuickFilter')) {
                    this.resetCache();
                }
            },
        });
        this.addManagedPropertyListener('quickFilterText', (e) => this.setFilter(e.currentValue));
        this.addManagedPropertyListeners(['includeHiddenColumnsInQuickFilter', 'applyQuickFilterBeforePivotOrAgg'], () => this.onColumnConfigChanged());
        this.quickFilter = this.parseFilter(gos.get('quickFilterText'));
        this.parser = gos.get('quickFilterParser');
        this.matcher = gos.get('quickFilterMatcher');
        this.setFilterParts();
        this.addManagedPropertyListeners(['quickFilterMatcher', 'quickFilterParser'], () => this.setParserAndMatcher());
    }
    // if we are using autoGroupCols, then they should be included for quick filter. this covers the
    // following scenarios:
    // a) user provides 'field' into autoGroupCol of normal grid, so now because a valid col to filter leafs on
    // b) using tree data and user depends on autoGroupCol for first col, and we also want to filter on this
    //    (tree data is a bit different, as parent rows can be filtered on, unlike row grouping)
    refreshCols() {
        const { autoColSvc, colModel, gos, pivotResultCols } = this.beans;
        const pivotMode = colModel.isPivotMode();
        const groupAutoCols = autoColSvc?.getColumns();
        const providedCols = colModel.getColDefCols();
        let columnsForQuickFilter = (pivotMode && !gos.get('applyQuickFilterBeforePivotOrAgg')
            ? pivotResultCols?.getPivotResultCols()?.list
            : providedCols) ?? [];
        if (groupAutoCols) {
            columnsForQuickFilter = columnsForQuickFilter.concat(groupAutoCols);
        }
        this.colsToUse = gos.get('includeHiddenColumnsInQuickFilter')
            ? columnsForQuickFilter
            : columnsForQuickFilter.filter((col) => col.isVisible() || col.isRowGroupActive());
    }
    isFilterPresent() {
        return this.quickFilter !== null;
    }
    doesRowPass(node) {
        const usingCache = this.gos.get('cacheQuickFilter');
        if (this.matcher) {
            return this.doesRowPassMatcher(usingCache, node);
        }
        // each part must pass, if any fails, then the whole filter fails
        return this.quickFilterParts.every((part) => usingCache ? this.doesRowPassCache(node, part) : this.doesRowPassNoCache(node, part));
    }
    resetCache() {
        this.beans.rowModel.forEachNode((node) => (node.quickFilterAggregateText = null));
    }
    getText() {
        return this.gos.get('quickFilterText');
    }
    setFilterParts() {
        const { quickFilter, parser } = this;
        if (quickFilter) {
            this.quickFilterParts = parser ? parser(quickFilter) : quickFilter.split(' ');
        }
        else {
            this.quickFilterParts = null;
        }
    }
    parseFilter(newFilter) {
        if (!(0, generic_1._exists)(newFilter)) {
            return null;
        }
        return newFilter.toUpperCase();
    }
    setFilter(newFilter) {
        if (newFilter != null && typeof newFilter !== 'string') {
            (0, logging_1._warn)(70, { newFilter });
            return;
        }
        const parsedFilter = this.parseFilter(newFilter);
        if (this.quickFilter !== parsedFilter) {
            this.quickFilter = parsedFilter;
            this.setFilterParts();
            this.dispatchLocalEvent({ type: 'quickFilterChanged' });
        }
    }
    setParserAndMatcher() {
        const parser = this.gos.get('quickFilterParser');
        const matcher = this.gos.get('quickFilterMatcher');
        const hasChanged = parser !== this.parser || matcher !== this.matcher;
        this.parser = parser;
        this.matcher = matcher;
        if (hasChanged) {
            this.setFilterParts();
            this.dispatchLocalEvent({ type: 'quickFilterChanged' });
        }
    }
    onColumnConfigChanged() {
        this.refreshCols();
        this.resetCache();
        if (this.isFilterPresent()) {
            this.dispatchLocalEvent({ type: 'quickFilterChanged' });
        }
    }
    doesRowPassNoCache(node, filterPart) {
        return this.colsToUse.some((column) => {
            const part = this.getTextForColumn(column, node);
            return (0, generic_1._exists)(part) && part.indexOf(filterPart) >= 0;
        });
    }
    doesRowPassCache(node, filterPart) {
        this.checkGenerateAggText(node);
        return node.quickFilterAggregateText.indexOf(filterPart) >= 0;
    }
    doesRowPassMatcher(usingCache, node) {
        let quickFilterAggregateText;
        if (usingCache) {
            this.checkGenerateAggText(node);
            quickFilterAggregateText = node.quickFilterAggregateText;
        }
        else {
            quickFilterAggregateText = this.getAggText(node);
        }
        const { quickFilterParts, matcher } = this;
        return matcher(quickFilterParts, quickFilterAggregateText);
    }
    checkGenerateAggText(node) {
        if (!node.quickFilterAggregateText) {
            node.quickFilterAggregateText = this.getAggText(node);
        }
    }
    getTextForColumn(column, node) {
        let value = this.beans.filterValueSvc.getValue(column, node);
        const colDef = column.getColDef();
        if (colDef.getQuickFilterText) {
            const params = (0, gridOptionsUtils_1._addGridCommonParams)(this.gos, {
                value,
                node,
                data: node.data,
                column,
                colDef,
            });
            value = colDef.getQuickFilterText(params);
        }
        return (0, generic_1._exists)(value) ? value.toString().toUpperCase() : null;
    }
    getAggText(node) {
        const stringParts = [];
        this.colsToUse.forEach((column) => {
            const part = this.getTextForColumn(column, node);
            if ((0, generic_1._exists)(part)) {
                stringParts.push(part);
            }
        });
        return stringParts.join('\n');
    }
}
exports.QuickFilterService = QuickFilterService;


/***/ }),

/***/ 45626:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FocusService = void 0;
const keyCode_1 = __webpack_require__(39853);
const beanStub_1 = __webpack_require__(68731);
const positionUtils_1 = __webpack_require__(6257);
const gridOptionsUtils_1 = __webpack_require__(67274);
const abstractHeaderCellCtrl_1 = __webpack_require__(83534);
const headerUtils_1 = __webpack_require__(1323);
const headerNavigationService_1 = __webpack_require__(93990);
const cellCtrl_1 = __webpack_require__(60814);
const rowCtrl_1 = __webpack_require__(7632);
const array_1 = __webpack_require__(31502);
const focus_1 = __webpack_require__(82331);
const generic_1 = __webpack_require__(34422);
class FocusService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'focusSvc';
        /** If a cell was destroyed that previously had focus, focus needs restored when the cell reappears */
        this.focusFallbackTimeout = null;
        this.needsFocusRestored = false;
    }
    wireBeans(beans) {
        this.colModel = beans.colModel;
        this.visibleCols = beans.visibleCols;
        this.rowRenderer = beans.rowRenderer;
        this.navigation = beans.navigation;
        this.filterManager = beans.filterManager;
        this.overlays = beans.overlays;
    }
    postConstruct() {
        const clearFocusedCellListener = this.clearFocusedCell.bind(this);
        this.addManagedEventListeners({
            columnPivotModeChanged: clearFocusedCellListener,
            newColumnsLoaded: this.onColumnEverythingChanged.bind(this),
            columnGroupOpened: clearFocusedCellListener,
            columnRowGroupChanged: clearFocusedCellListener,
        });
        this.addDestroyFunc((0, focus_1._registerKeyboardFocusEvents)(this.beans));
    }
    attemptToRecoverFocus() {
        this.needsFocusRestored = true;
        if (this.focusFallbackTimeout != null) {
            clearTimeout(this.focusFallbackTimeout);
        }
        // fallback; don't want to leave this flag hanging for a long time as the grid may steal focus later
        // if this doesn't get consumed
        this.focusFallbackTimeout = window.setTimeout(this.setFocusRecovered.bind(this), 100);
    }
    setFocusRecovered() {
        this.needsFocusRestored = false;
        if (this.focusFallbackTimeout != null) {
            clearTimeout(this.focusFallbackTimeout);
            this.focusFallbackTimeout = null;
        }
    }
    /**
     * Specifies whether to take focus, as grid either already has focus, or lost it due
     * to a destroyed cell
     * @returns true if the grid should re-take focus, otherwise false
     */
    shouldTakeFocus() {
        if (this.gos.get('suppressFocusAfterRefresh')) {
            this.setFocusRecovered();
            return false;
        }
        if (this.needsFocusRestored) {
            this.setFocusRecovered();
            return true;
        }
        return this.doesRowOrCellHaveBrowserFocus();
    }
    onColumnEverythingChanged() {
        // if the columns change, check and see if this column still exists. if it does, then
        // we can keep the focused cell. if it doesn't, then we need to drop the focused cell.
        if (!this.focusedCell) {
            return;
        }
        const col = this.focusedCell.column;
        const colFromColumnModel = this.colModel.getCol(col.getId());
        if (col !== colFromColumnModel) {
            this.clearFocusedCell();
        }
    }
    // we check if the browser is focusing something, and if it is, and
    // it's the cell we think is focused, then return the cell. so this
    // methods returns the cell if a) we think it has focus and b) the
    // browser thinks it has focus. this then returns nothing if we
    // first focus a cell, then second click outside the grid, as then the
    // grid cell will still be focused as far as the grid is concerned,
    // however the browser focus will have moved somewhere else.
    getFocusCellToUseAfterRefresh() {
        const { gos, focusedCell } = this;
        if (gos.get('suppressFocusAfterRefresh') || gos.get('suppressCellFocus') || !focusedCell) {
            return null;
        }
        // we check that the browser is actually focusing on the grid, if it is not, then
        // we have nothing to worry about. we check for ROW data, as this covers both focused Rows (for Full Width Rows)
        // and Cells (covers cells as cells live in rows)
        if (!this.doesRowOrCellHaveBrowserFocus()) {
            return null;
        }
        return focusedCell;
    }
    getFocusHeaderToUseAfterRefresh() {
        if (this.gos.get('suppressFocusAfterRefresh') || !this.focusedHeader) {
            return null;
        }
        // we check that the browser is actually focusing on the grid, if it is not, then
        // we have nothing to worry about
        if (!this.isDomDataPresentInHierarchy((0, gridOptionsUtils_1._getActiveDomElement)(this.beans), abstractHeaderCellCtrl_1.DOM_DATA_KEY_HEADER_CTRL)) {
            return null;
        }
        return this.focusedHeader;
    }
    /**
     * Check for both cells and rows, as a row might be destroyed and the dom data removed before the cell if the
     * row is animating out.
     */
    doesRowOrCellHaveBrowserFocus() {
        const activeElement = (0, gridOptionsUtils_1._getActiveDomElement)(this.beans);
        // check for cell first
        if (this.isDomDataPresentInHierarchy(activeElement, cellCtrl_1.DOM_DATA_KEY_CELL_CTRL)) {
            return true;
        }
        // otherwise rows
        return this.isDomDataPresentInHierarchy(activeElement, rowCtrl_1.DOM_DATA_KEY_ROW_CTRL);
    }
    isDomDataPresentInHierarchy(eBrowserCell, key) {
        let ePointer = eBrowserCell;
        while (ePointer) {
            const data = (0, gridOptionsUtils_1._getDomData)(this.gos, ePointer, key);
            if (data) {
                return true;
            }
            ePointer = ePointer.parentNode;
        }
        return false;
    }
    getFocusedCell() {
        return this.focusedCell;
    }
    getFocusEventParams(focusedCellPosition) {
        const { rowIndex, rowPinned, column } = focusedCellPosition;
        const params = {
            rowIndex: rowIndex,
            rowPinned: rowPinned,
            column: column,
            isFullWidthCell: false,
        };
        const rowCtrl = this.rowRenderer.getRowByPosition({ rowIndex, rowPinned });
        if (rowCtrl) {
            params.isFullWidthCell = rowCtrl.isFullWidth();
        }
        return params;
    }
    clearFocusedCell() {
        if (this.focusedCell == null) {
            return;
        }
        const focusEventParams = this.getFocusEventParams(this.focusedCell);
        this.focusedCell = null;
        this.eventSvc.dispatchEvent({
            type: 'cellFocusCleared',
            ...focusEventParams,
        });
    }
    setFocusedCell(params) {
        // as focus has been set, reset the flag
        this.setFocusRecovered();
        const { column, rowIndex, rowPinned, forceBrowserFocus = false, preventScrollOnBrowserFocus = false, sourceEvent, } = params;
        const gridColumn = this.colModel.getCol(column);
        // if column doesn't exist, then blank the focused cell and return. this can happen when user sets new columns,
        // and the focused cell is in a column that no longer exists. after columns change, the grid refreshes and tries
        // to re-focus the focused cell.
        if (!gridColumn) {
            this.focusedCell = null;
            return;
        }
        this.focusedCell = {
            rowIndex: rowIndex,
            rowPinned: (0, generic_1._makeNull)(rowPinned),
            column: gridColumn,
        };
        const focusEventParams = this.getFocusEventParams(this.focusedCell);
        this.eventSvc.dispatchEvent({
            type: 'cellFocused',
            ...focusEventParams,
            ...(this.previousCellFocusParams && { previousParams: this.previousCellFocusParams }),
            forceBrowserFocus,
            preventScrollOnBrowserFocus,
            sourceEvent,
        });
        this.previousCellFocusParams = focusEventParams;
    }
    isCellFocused(cellPosition) {
        if (this.focusedCell == null) {
            return false;
        }
        return (0, positionUtils_1._areCellsEqual)(cellPosition, this.focusedCell);
    }
    isHeaderWrapperFocused(headerCtrl) {
        if (this.focusedHeader == null) {
            return false;
        }
        const { column, rowCtrl: { rowIndex: headerRowIndex, pinned }, } = headerCtrl;
        const { column: focusedColumn, headerRowIndex: focusedHeaderRowIndex } = this.focusedHeader;
        return (column === focusedColumn && headerRowIndex === focusedHeaderRowIndex && pinned == focusedColumn.getPinned());
    }
    focusHeaderPosition(params) {
        // focusing header has been attempted; don't try to recover focus
        this.setFocusRecovered();
        if ((0, focus_1._isHeaderFocusSuppressed)(this.beans)) {
            return false;
        }
        const { direction, fromTab, allowUserOverride, event, fromCell, rowWithoutSpanValue } = params;
        let { headerPosition } = params;
        if (fromCell && this.filterManager?.isAdvFilterHeaderActive()) {
            return this.focusAdvancedFilter(headerPosition);
        }
        if (allowUserOverride) {
            const currentPosition = this.focusedHeader;
            const headerRowCount = (0, headerUtils_1.getFocusHeaderRowCount)(this.beans);
            if (fromTab) {
                const userFunc = this.gos.getCallback('tabToNextHeader');
                if (userFunc) {
                    headerPosition = this.getHeaderPositionFromUserFunc({
                        userFunc,
                        direction,
                        currentPosition,
                        headerPosition,
                        headerRowCount,
                    });
                }
            }
            else {
                const userFunc = this.gos.getCallback('navigateToNextHeader');
                if (userFunc && event) {
                    const params = {
                        key: event.key,
                        previousHeaderPosition: currentPosition,
                        nextHeaderPosition: headerPosition,
                        headerRowCount,
                        event,
                    };
                    headerPosition = userFunc(params);
                }
            }
        }
        if (!headerPosition) {
            return false;
        }
        return this.focusProvidedHeaderPosition({
            headerPosition,
            direction,
            event,
            fromCell,
            rowWithoutSpanValue,
        });
    }
    focusHeaderPositionFromUserFunc(params) {
        if ((0, focus_1._isHeaderFocusSuppressed)(this.beans)) {
            return false;
        }
        const { userFunc, headerPosition, direction, event } = params;
        const currentPosition = this.focusedHeader;
        const headerRowCount = (0, headerUtils_1.getFocusHeaderRowCount)(this.beans);
        const newHeaderPosition = this.getHeaderPositionFromUserFunc({
            userFunc,
            direction,
            currentPosition,
            headerPosition,
            headerRowCount,
        });
        return (!!newHeaderPosition &&
            this.focusProvidedHeaderPosition({
                headerPosition: newHeaderPosition,
                direction,
                event,
            }));
    }
    getHeaderPositionFromUserFunc(params) {
        const { userFunc, direction, currentPosition, headerPosition, headerRowCount } = params;
        const userFuncParams = {
            backwards: direction === 'Before',
            previousHeaderPosition: currentPosition,
            nextHeaderPosition: headerPosition,
            headerRowCount,
        };
        const userResult = userFunc(userFuncParams);
        if (userResult === true) {
            return currentPosition;
        }
        if (userResult === false) {
            return null;
        }
        return userResult;
    }
    focusProvidedHeaderPosition(params) {
        const { headerPosition, direction, fromCell, rowWithoutSpanValue, event } = params;
        const { column, headerRowIndex } = headerPosition;
        const { filterManager, ctrlsSvc, headerNavigation } = this.beans;
        if (headerRowIndex === -1) {
            if (filterManager?.isAdvFilterHeaderActive()) {
                return this.focusAdvancedFilter(headerPosition);
            }
            return this.focusGridView({ column: column, event });
        }
        headerNavigation?.scrollToColumn(column, direction);
        const headerRowContainerCtrl = ctrlsSvc.getHeaderRowContainerCtrl(column.getPinned());
        // this will automatically set the focused header
        const focusSuccess = headerRowContainerCtrl?.focusHeader(headerPosition.headerRowIndex, column, event) || false;
        if (headerNavigation && focusSuccess && (rowWithoutSpanValue != null || fromCell)) {
            headerNavigation.currentHeaderRowWithoutSpan = rowWithoutSpanValue ?? -1;
        }
        return focusSuccess;
    }
    focusFirstHeader() {
        if (this.overlays?.isExclusive() && this.focusOverlay()) {
            return true;
        }
        let firstColumn = this.visibleCols.allCols[0];
        if (!firstColumn) {
            return false;
        }
        const { colGroupSvc } = this.beans;
        if (colGroupSvc && firstColumn.getParent()) {
            firstColumn = colGroupSvc.getColGroupAtLevel(firstColumn, 0);
        }
        const headerPosition = (0, headerNavigationService_1.getHeaderIndexToFocus)(firstColumn, 0);
        return this.focusHeaderPosition({
            headerPosition,
            rowWithoutSpanValue: 0,
        });
    }
    focusLastHeader(event) {
        if (this.overlays?.isExclusive() && this.focusOverlay(true)) {
            return true;
        }
        const headerRowIndex = (0, headerUtils_1.getFocusHeaderRowCount)(this.beans) - 1;
        const column = (0, array_1._last)(this.visibleCols.allCols);
        return this.focusHeaderPosition({
            headerPosition: { headerRowIndex, column },
            rowWithoutSpanValue: -1,
            event,
        });
    }
    focusPreviousFromFirstCell(event) {
        if (this.filterManager?.isAdvFilterHeaderActive()) {
            return this.focusAdvancedFilter(null);
        }
        return this.focusLastHeader(event);
    }
    isAnyCellFocused() {
        return !!this.focusedCell;
    }
    isRowFocused(rowIndex, rowPinnedType) {
        if (this.focusedCell == null) {
            return false;
        }
        return this.focusedCell.rowIndex === rowIndex && this.focusedCell.rowPinned === (0, generic_1._makeNull)(rowPinnedType);
    }
    focusOverlay(backwards) {
        const overlayGui = this.overlays?.isVisible() && this.overlays.eWrapper?.getGui();
        return !!overlayGui && (0, focus_1._focusInto)(overlayGui, backwards);
    }
    focusGridView(params) {
        const { backwards = false, canFocusOverlay = true, event } = params;
        if (this.overlays?.isExclusive()) {
            return canFocusOverlay && this.focusOverlay(backwards);
        }
        // if suppressCellFocus is `true`, it means the user does not want to
        // navigate between the cells using tab. Instead, we put focus on either
        // the header or after the grid, depending on whether tab or shift-tab was pressed.
        if ((0, focus_1._isCellFocusSuppressed)(this.beans)) {
            if (backwards) {
                if (!(0, focus_1._isHeaderFocusSuppressed)(this.beans)) {
                    return this.focusLastHeader();
                }
            }
            if (canFocusOverlay && this.focusOverlay(backwards)) {
                return true;
            }
            if (backwards) {
                return false;
            }
            return (0, focus_1._focusNextGridCoreContainer)(this.beans, backwards);
        }
        const nextRow = backwards ? (0, positionUtils_1._getLastRow)(this.beans) : (0, positionUtils_1._getFirstRow)(this.beans);
        if (nextRow) {
            const column = params.column ?? this.focusedHeader?.column;
            const { rowIndex, rowPinned } = nextRow;
            const rowNode = (0, positionUtils_1._getRowNode)(this.beans, nextRow);
            if (!column || !rowNode || rowIndex == null) {
                return false;
            }
            if (column.isSuppressNavigable(rowNode)) {
                const isRtl = this.gos.get('enableRtl');
                let key;
                if (!event || event.key === keyCode_1.KeyCode.TAB) {
                    key = isRtl ? keyCode_1.KeyCode.LEFT : keyCode_1.KeyCode.RIGHT;
                }
                else {
                    key = event.key;
                }
                this.beans.navigation?.navigateToNextCell(null, key, { rowIndex, column, rowPinned: rowPinned || null }, true);
                return true;
            }
            this.navigation?.ensureCellVisible({ rowIndex, column, rowPinned });
            if (backwards) {
                // if full width we need to focus into the full width cell in the correct direction
                const rowCtrl = this.rowRenderer.getRowByPosition(nextRow);
                if (rowCtrl?.isFullWidth() && this.navigation?.tryToFocusFullWidthRow(nextRow, backwards)) {
                    return true;
                }
            }
            this.setFocusedCell({
                rowIndex,
                column,
                rowPinned: (0, generic_1._makeNull)(rowPinned),
                forceBrowserFocus: true,
            });
            this.beans.rangeSvc?.setRangeToCell({ rowIndex, rowPinned, column });
            return true;
        }
        if (canFocusOverlay && this.focusOverlay(backwards)) {
            return true;
        }
        if (backwards && this.focusLastHeader()) {
            return true;
        }
        return false;
    }
    focusAdvancedFilter(position) {
        this.advFilterFocusColumn = position?.column;
        return this.beans.advancedFilter?.getCtrl().focusHeaderComp() ?? false;
    }
    focusNextFromAdvancedFilter(backwards, forceFirstColumn) {
        const column = (forceFirstColumn ? undefined : this.advFilterFocusColumn) ?? this.visibleCols.allCols?.[0];
        if (backwards) {
            return this.focusHeaderPosition({
                headerPosition: {
                    column: column,
                    headerRowIndex: (0, headerUtils_1.getFocusHeaderRowCount)(this.beans) - 1,
                },
            });
        }
        else {
            return this.focusGridView({ column });
        }
    }
    clearAdvancedFilterColumn() {
        this.advFilterFocusColumn = undefined;
    }
}
exports.FocusService = FocusService;


/***/ }),

/***/ 75518:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._getGlobalGridOption = exports.provideGlobalGridOptions = exports.GlobalGridOptions = void 0;
const object_1 = __webpack_require__(6996);
class GlobalGridOptions {
    /**
     * @param providedOptions
     * @returns Shallow copy of the provided options with global options merged in.
     */
    static applyGlobalGridOptions(providedOptions) {
        if (!GlobalGridOptions.gridOptions) {
            // No global options provided, return a shallow copy of the provided options
            return { ...providedOptions };
        }
        let mergedGridOps = {};
        // Merge deep to avoid leaking changes to the global options
        (0, object_1._mergeDeep)(mergedGridOps, GlobalGridOptions.gridOptions, true, true);
        if (GlobalGridOptions.mergeStrategy === 'deep') {
            (0, object_1._mergeDeep)(mergedGridOps, providedOptions, true, true);
        }
        else {
            // Shallow copy so that provided object properties completely override global options
            mergedGridOps = { ...mergedGridOps, ...providedOptions };
        }
        if (GlobalGridOptions.gridOptions.context) {
            // Ensure context reference is maintained if it was provided
            mergedGridOps.context = GlobalGridOptions.gridOptions.context;
        }
        if (providedOptions.context) {
            if (GlobalGridOptions.mergeStrategy === 'deep' && mergedGridOps.context) {
                // Merge global context properties into the provided context whilst maintaining provided context reference
                (0, object_1._mergeDeep)(providedOptions.context, mergedGridOps.context, true, true);
            }
            mergedGridOps.context = providedOptions.context;
        }
        return mergedGridOps;
    }
}
exports.GlobalGridOptions = GlobalGridOptions;
GlobalGridOptions.gridOptions = undefined;
GlobalGridOptions.mergeStrategy = 'shallow';
/**
 * Provide gridOptions that will be shared by all grid instances.
 * Individually defined GridOptions will take precedence over global options.
 * @param gridOptions - global grid options
 */
function provideGlobalGridOptions(gridOptions, mergeStrategy = 'shallow') {
    GlobalGridOptions.gridOptions = gridOptions;
    GlobalGridOptions.mergeStrategy = mergeStrategy;
}
exports.provideGlobalGridOptions = provideGlobalGridOptions;
function _getGlobalGridOption(gridOption) {
    return GlobalGridOptions.gridOptions?.[gridOption];
}
exports._getGlobalGridOption = _getGlobalGridOption;


/***/ }),

/***/ 21657:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GridCoreCreator = exports.createGrid = void 0;
const apiUtils_1 = __webpack_require__(46433);
const context_1 = __webpack_require__(62342);
const gridBeanComparator_1 = __webpack_require__(23943);
const globalGridOptions_1 = __webpack_require__(75518);
const gridComp_1 = __webpack_require__(1678);
const gridCoreModule_1 = __webpack_require__(91978);
const moduleRegistry_1 = __webpack_require__(2132);
const dom_1 = __webpack_require__(33507);
const generic_1 = __webpack_require__(34422);
const errorText_1 = __webpack_require__(15205);
const logging_1 = __webpack_require__(47764);
const vanillaFrameworkOverrides_1 = __webpack_require__(56511);
// **NOTE** If updating this JsDoc please also update the re-exported createGrid in main-umd-shared.ts
/**
 * Creates a grid inside the provided HTML element.
 * @param eGridDiv Parent element to contain the grid.
 * @param gridOptions Configuration for the grid.
 * @param params Individually register AG Grid Modules to this grid.
 * @returns api to be used to interact with the grid.
 */
function createGrid(eGridDiv, gridOptions, params) {
    if (!gridOptions) {
        // No gridOptions provided, abort creating the grid
        (0, logging_1._error)(11);
        return {};
    }
    const gridParams = params;
    let destroyCallback;
    if (!gridParams?.setThemeOnGridDiv) {
        // frameworks already create an element owned by our code, so we can set
        // the theme class on it. JS users calling createGrid directly are
        // passing an element owned by their application, so we can't set a
        // class name on it and must create a wrapper.
        const newGridDiv = (0, dom_1._createElement)({ tag: 'div' });
        newGridDiv.style.height = '100%';
        eGridDiv.appendChild(newGridDiv);
        eGridDiv = newGridDiv;
        destroyCallback = () => eGridDiv.remove();
    }
    const api = new GridCoreCreator().create(eGridDiv, gridOptions, (context) => {
        const gridComp = new gridComp_1.GridComp(eGridDiv);
        context.createBean(gridComp);
    }, undefined, params, destroyCallback);
    return api;
}
exports.createGrid = createGrid;
let nextGridId = 1;
// creates services of grid only, no UI, so frameworks can use this if providing
// their own UI
class GridCoreCreator {
    create(eGridDiv, providedOptions, createUi, acceptChanges, params, destroyCallback) {
        // Returns a shallow copy of the provided options, with global options merged in
        const gridOptions = globalGridOptions_1.GlobalGridOptions.applyGlobalGridOptions(providedOptions);
        const gridId = gridOptions.gridId ?? String(nextGridId++);
        const registeredModules = this.getRegisteredModules(params, gridId, gridOptions.rowModelType);
        const beanClasses = this.createBeansList(gridOptions.rowModelType, registeredModules, gridId);
        const providedBeanInstances = this.createProvidedBeans(eGridDiv, gridOptions, params);
        if (!beanClasses) {
            // Detailed error message will have been printed by createBeansList
            // Break typing so that the normal return type does not have to handle undefined.
            return undefined;
        }
        const contextParams = {
            providedBeanInstances,
            beanClasses,
            gridId,
            beanInitComparator: gridBeanComparator_1.gridBeanInitComparator,
            beanDestroyComparator: gridBeanComparator_1.gridBeanDestroyComparator,
            derivedBeans: [apiUtils_1.createGridApi],
            destroyCallback,
        };
        const context = new context_1.Context(contextParams);
        this.registerModuleFeatures(context, registeredModules);
        createUi(context);
        context.getBean('syncSvc').start();
        if (acceptChanges) {
            acceptChanges(context);
        }
        return context.getBean('gridApi');
    }
    getRegisteredModules(params, gridId, rowModelType) {
        (0, moduleRegistry_1._registerModule)(gridCoreModule_1.CommunityCoreModule, undefined, true);
        params?.modules?.forEach((m) => (0, moduleRegistry_1._registerModule)(m, gridId));
        return (0, moduleRegistry_1._getRegisteredModules)(gridId, getDefaultRowModelType(rowModelType));
    }
    registerModuleFeatures(context, registeredModules) {
        const registry = context.getBean('registry');
        const apiFunctionSvc = context.getBean('apiFunctionSvc');
        registeredModules.forEach((module) => {
            registry.registerModule(module);
            const apiFunctions = module.apiFunctions;
            if (apiFunctions) {
                const names = Object.keys(apiFunctions);
                names.forEach((name) => {
                    apiFunctionSvc?.addFunction(name, apiFunctions[name]);
                });
            }
        });
    }
    createProvidedBeans(eGridDiv, gridOptions, params) {
        let frameworkOverrides = params ? params.frameworkOverrides : null;
        if ((0, generic_1._missing)(frameworkOverrides)) {
            frameworkOverrides = new vanillaFrameworkOverrides_1.VanillaFrameworkOverrides();
        }
        const seed = {
            gridOptions: gridOptions,
            eGridDiv: eGridDiv,
            globalListener: params ? params.globalListener : null,
            globalSyncListener: params ? params.globalSyncListener : null,
            frameworkOverrides: frameworkOverrides,
        };
        if (params && params.providedBeanInstances) {
            Object.assign(seed, params.providedBeanInstances);
        }
        return seed;
    }
    createBeansList(userProvidedRowModelType, registeredModules, gridId) {
        // assert that the relevant module has been loaded
        const rowModelModuleNames = {
            clientSide: 'ClientSideRowModel',
            infinite: 'InfiniteRowModel',
            serverSide: 'ServerSideRowModel',
            viewport: 'ViewportRowModel',
        };
        const rowModelType = getDefaultRowModelType(userProvidedRowModelType);
        const rowModuleModelName = rowModelModuleNames[rowModelType];
        if (!rowModuleModelName) {
            // can't use validation service here as hasn't been created yet
            (0, logging_1._logPreInitErr)(201, { rowModelType }, `Unknown rowModelType ${rowModelType}.`);
            return;
        }
        if (!(0, moduleRegistry_1._hasUserRegistered)()) {
            (0, logging_1._logPreInitErr)(272, undefined, (0, errorText_1.NoModulesRegisteredError)());
            return;
        }
        if (!userProvidedRowModelType) {
            // If the user has not specified a rowModelType, but have registered one of the RowModel modules, we need to check
            // that the user has registered the correct module for the rowModelType.
            // eslint-disable-next-line no-restricted-properties
            const registeredRowModelModules = Object.entries(rowModelModuleNames).filter(([rowModelType, module]) => (0, moduleRegistry_1._isModuleRegistered)(module, gridId, rowModelType));
            if (registeredRowModelModules.length == 1) {
                const [userRowModelType, moduleName] = registeredRowModelModules[0];
                if (userRowModelType !== rowModelType) {
                    const params = {
                        moduleName,
                        rowModelType: userRowModelType,
                    };
                    (0, logging_1._logPreInitErr)(275, params, (0, errorText_1.missingRowModelTypeError)(params));
                    return;
                }
            }
        }
        if (!(0, moduleRegistry_1._isModuleRegistered)(rowModuleModelName, gridId, rowModelType)) {
            (0, logging_1._logPreInitErr)(200, {
                reasonOrId: `rowModelType = '${rowModelType}'`,
                moduleName: rowModuleModelName,
                gridScoped: (0, moduleRegistry_1._areModulesGridScoped)(),
                gridId,
                rowModelType,
            }, `Missing module ${rowModuleModelName}Module for rowModelType ${rowModelType}.`);
            return;
        }
        const beans = new Set();
        registeredModules.forEach((module) => module.beans?.forEach((bean) => beans.add(bean)));
        return Array.from(beans);
    }
}
exports.GridCoreCreator = GridCoreCreator;
function getDefaultRowModelType(passedRowModelType) {
    return passedRowModelType ?? 'clientSide';
}


/***/ }),

/***/ 20736:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractFakeScrollComp = void 0;
const browser_1 = __webpack_require__(98667);
const dom_1 = __webpack_require__(33507);
const function_1 = __webpack_require__(92043);
const component_1 = __webpack_require__(78020);
class AbstractFakeScrollComp extends component_1.Component {
    constructor(template, direction) {
        super();
        this.direction = direction;
        this.eViewport = component_1.RefPlaceholder;
        this.eContainer = component_1.RefPlaceholder;
        this.hideTimeout = 0;
        this.setTemplate(template);
    }
    postConstruct() {
        this.addManagedEventListeners({
            scrollVisibilityChanged: this.onScrollVisibilityChanged.bind(this),
        });
        this.onScrollVisibilityChanged();
        this.toggleCss('ag-apple-scrollbar', (0, browser_1._isMacOsUserAgent)() || (0, browser_1._isIOSUserAgent)());
    }
    destroy() {
        super.destroy();
        window.clearTimeout(this.hideTimeout);
    }
    initialiseInvisibleScrollbar() {
        if (this.invisibleScrollbar !== undefined) {
            return;
        }
        this.invisibleScrollbar = (0, browser_1._isInvisibleScrollbar)();
        if (this.invisibleScrollbar) {
            this.hideAndShowInvisibleScrollAsNeeded();
            this.addActiveListenerToggles();
        }
    }
    addActiveListenerToggles() {
        const eGui = this.getGui();
        const onActivate = () => this.toggleCss('ag-scrollbar-active', true);
        const onDeactivate = () => this.toggleCss('ag-scrollbar-active', false);
        this.addManagedListeners(eGui, {
            mouseenter: onActivate,
            mousedown: onActivate,
            touchstart: onActivate,
            mouseleave: onDeactivate,
            touchend: onDeactivate,
        });
    }
    onScrollVisibilityChanged() {
        // initialiseInvisibleScrollbar should only be called once, but the reason
        // this can't be inside `setComp` or `postConstruct` is the DOM might not
        // be ready, so we call it until eventually, it gets calculated.
        if (this.invisibleScrollbar === undefined) {
            this.initialiseInvisibleScrollbar();
        }
        (0, dom_1._requestAnimationFrame)(this.beans, () => this.setScrollVisible());
    }
    hideAndShowInvisibleScrollAsNeeded() {
        this.addManagedEventListeners({
            bodyScroll: (params) => {
                if (params.direction === this.direction) {
                    if (this.hideTimeout) {
                        window.clearTimeout(this.hideTimeout);
                        this.hideTimeout = 0;
                    }
                    this.toggleCss('ag-scrollbar-scrolling', true);
                }
            },
            bodyScrollEnd: () => {
                this.hideTimeout = window.setTimeout(() => {
                    this.toggleCss('ag-scrollbar-scrolling', false);
                    this.hideTimeout = 0;
                }, 400);
            },
        });
    }
    attemptSettingScrollPosition(value) {
        const viewport = this.eViewport;
        (0, function_1._waitUntil)(() => (0, dom_1._isVisible)(viewport), () => this.setScrollPosition(value), 100);
    }
    onScrollCallback(fn) {
        this.addManagedElementListeners(this.eViewport, { scroll: fn });
    }
}
exports.AbstractFakeScrollComp = AbstractFakeScrollComp;


/***/ }),

/***/ 42218:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CenterWidthFeature = void 0;
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
class CenterWidthFeature extends beanStub_1.BeanStub {
    constructor(callback, addSpacer = false) {
        super();
        this.callback = callback;
        this.addSpacer = addSpacer;
    }
    postConstruct() {
        const listener = this.setWidth.bind(this);
        this.addManagedPropertyListener('domLayout', listener);
        this.addManagedEventListeners({
            columnContainerWidthChanged: listener,
            displayedColumnsChanged: listener,
            leftPinnedWidthChanged: listener,
        });
        if (this.addSpacer) {
            this.addManagedEventListeners({
                rightPinnedWidthChanged: listener,
                scrollVisibilityChanged: listener,
                scrollbarWidthChanged: listener,
            });
        }
        this.setWidth();
    }
    setWidth() {
        const printLayout = (0, gridOptionsUtils_1._isDomLayout)(this.gos, 'print');
        const { visibleCols, scrollVisibleSvc } = this.beans;
        const centerWidth = visibleCols.bodyWidth;
        const leftWidth = visibleCols.getColsLeftWidth();
        const rightWidth = visibleCols.getDisplayedColumnsRightWidth();
        let totalWidth;
        if (printLayout) {
            totalWidth = centerWidth + leftWidth + rightWidth;
        }
        else {
            totalWidth = centerWidth;
            if (this.addSpacer) {
                const relevantWidth = this.gos.get('enableRtl') ? leftWidth : rightWidth;
                if (relevantWidth === 0 && scrollVisibleSvc.verticalScrollShowing) {
                    totalWidth += scrollVisibleSvc.getScrollbarWidth();
                }
            }
        }
        this.callback(totalWidth);
    }
}
exports.CenterWidthFeature = CenterWidthFeature;


/***/ }),

/***/ 62716:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FakeHScrollSelector = exports.FakeHScrollComp = void 0;
const dom_1 = __webpack_require__(33507);
const component_1 = __webpack_require__(78020);
const abstractFakeScrollComp_1 = __webpack_require__(20736);
const centerWidthFeature_1 = __webpack_require__(42218);
const FakeHScrollElement = {
    tag: 'div',
    cls: 'ag-body-horizontal-scroll',
    attrs: { 'aria-hidden': 'true' },
    children: [
        { tag: 'div', ref: 'eLeftSpacer', cls: 'ag-horizontal-left-spacer' },
        {
            tag: 'div',
            ref: 'eViewport',
            cls: 'ag-body-horizontal-scroll-viewport',
            children: [{ tag: 'div', ref: 'eContainer', cls: 'ag-body-horizontal-scroll-container' }],
        },
        { tag: 'div', ref: 'eRightSpacer', cls: 'ag-horizontal-right-spacer' },
    ],
};
class FakeHScrollComp extends abstractFakeScrollComp_1.AbstractFakeScrollComp {
    wireBeans(beans) {
        this.visibleCols = beans.visibleCols;
        this.scrollVisibleSvc = beans.scrollVisibleSvc;
    }
    constructor() {
        super(FakeHScrollElement, 'horizontal');
        this.eLeftSpacer = component_1.RefPlaceholder;
        this.eRightSpacer = component_1.RefPlaceholder;
        this.setScrollVisibleDebounce = 0;
    }
    postConstruct() {
        super.postConstruct();
        // When doing printing, this changes whether cols are pinned or not
        const spacerWidthsListener = this.setFakeHScrollSpacerWidths.bind(this);
        this.addManagedEventListeners({
            displayedColumnsChanged: spacerWidthsListener,
            displayedColumnsWidthChanged: spacerWidthsListener,
            pinnedRowDataChanged: this.refreshCompBottom.bind(this),
        });
        this.addManagedPropertyListener('domLayout', spacerWidthsListener);
        this.beans.ctrlsSvc.register('fakeHScrollComp', this);
        this.createManagedBean(new centerWidthFeature_1.CenterWidthFeature((width) => (this.eContainer.style.width = `${width}px`)));
        this.addManagedPropertyListeners(['suppressHorizontalScroll'], this.onScrollVisibilityChanged.bind(this));
    }
    destroy() {
        window.clearTimeout(this.setScrollVisibleDebounce);
        super.destroy();
    }
    initialiseInvisibleScrollbar() {
        if (this.invisibleScrollbar !== undefined) {
            return;
        }
        this.enableRtl = this.gos.get('enableRtl');
        super.initialiseInvisibleScrollbar();
        if (this.invisibleScrollbar) {
            this.refreshCompBottom();
        }
    }
    refreshCompBottom() {
        if (!this.invisibleScrollbar) {
            return;
        }
        const bottomPinnedHeight = this.beans.pinnedRowModel?.getPinnedBottomTotalHeight() ?? 0;
        this.getGui().style.bottom = `${bottomPinnedHeight}px`;
    }
    onScrollVisibilityChanged() {
        super.onScrollVisibilityChanged();
        this.setFakeHScrollSpacerWidths();
    }
    setFakeHScrollSpacerWidths() {
        const vScrollShowing = this.scrollVisibleSvc.verticalScrollShowing;
        // we pad the right based on a) if cols are pinned to the right and
        // b) if v scroll is showing on the right (normal position of scroll)
        let rightSpacing = this.visibleCols.getDisplayedColumnsRightWidth();
        const scrollOnRight = !this.enableRtl && vScrollShowing;
        const scrollbarWidth = this.scrollVisibleSvc.getScrollbarWidth();
        if (scrollOnRight) {
            rightSpacing += scrollbarWidth;
        }
        (0, dom_1._setFixedWidth)(this.eRightSpacer, rightSpacing);
        this.eRightSpacer.classList.toggle('ag-scroller-corner', rightSpacing <= scrollbarWidth);
        // we pad the left based on a) if cols are pinned to the left and
        // b) if v scroll is showing on the left (happens in LTR layout only)
        let leftSpacing = this.visibleCols.getColsLeftWidth();
        const scrollOnLeft = this.enableRtl && vScrollShowing;
        if (scrollOnLeft) {
            leftSpacing += scrollbarWidth;
        }
        (0, dom_1._setFixedWidth)(this.eLeftSpacer, leftSpacing);
        this.eLeftSpacer.classList.toggle('ag-scroller-corner', leftSpacing <= scrollbarWidth);
    }
    setScrollVisible() {
        const hScrollShowing = this.scrollVisibleSvc.horizontalScrollShowing;
        const invisibleScrollbar = this.invisibleScrollbar;
        const isSuppressHorizontalScroll = this.gos.get('suppressHorizontalScroll');
        const scrollbarWidth = hScrollShowing ? this.scrollVisibleSvc.getScrollbarWidth() || 0 : 0;
        const adjustedScrollbarWidth = scrollbarWidth === 0 && invisibleScrollbar ? 16 : scrollbarWidth;
        const scrollContainerSize = !isSuppressHorizontalScroll ? adjustedScrollbarWidth : 0;
        // Avoid scrollbars flickering on as we resize the grid. Before showing
        // a scrollbar, give a little time for the grid to resize, after which a
        // scrollbar may no longer be required
        const apply = () => {
            this.setScrollVisibleDebounce = 0;
            this.toggleCss('ag-scrollbar-invisible', invisibleScrollbar);
            (0, dom_1._setFixedHeight)(this.getGui(), scrollContainerSize);
            (0, dom_1._setFixedHeight)(this.eViewport, scrollContainerSize);
            (0, dom_1._setFixedHeight)(this.eContainer, scrollContainerSize);
            if (!scrollContainerSize) {
                // the container needs a min-height of 1px to be
                // able to sync scroll position while hidden
                this.eContainer.style.setProperty('min-height', '1px');
            }
            this.setVisible(hScrollShowing, { skipAriaHidden: true });
        };
        window.clearTimeout(this.setScrollVisibleDebounce);
        if (!hScrollShowing) {
            apply();
        }
        else {
            this.setScrollVisibleDebounce = window.setTimeout(apply, 100);
        }
    }
    getScrollPosition() {
        return (0, dom_1._getScrollLeft)(this.eViewport, this.enableRtl);
    }
    setScrollPosition(value) {
        if (!(0, dom_1._isVisible)(this.eViewport)) {
            this.attemptSettingScrollPosition(value);
        }
        (0, dom_1._setScrollLeft)(this.eViewport, value, this.enableRtl);
    }
}
exports.FakeHScrollComp = FakeHScrollComp;
exports.FakeHScrollSelector = {
    selector: 'AG-FAKE-HORIZONTAL-SCROLL',
    component: FakeHScrollComp,
};


/***/ }),

/***/ 46070:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FakeVScrollSelector = exports.FakeVScrollComp = void 0;
const dom_1 = __webpack_require__(33507);
const abstractFakeScrollComp_1 = __webpack_require__(20736);
const setHeightFeature_1 = __webpack_require__(9622);
const FakeVScrollElement = {
    tag: 'div',
    cls: 'ag-body-vertical-scroll',
    attrs: { 'aria-hidden': 'true' },
    children: [
        {
            tag: 'div',
            ref: 'eViewport',
            cls: 'ag-body-vertical-scroll-viewport',
            children: [{ tag: 'div', ref: 'eContainer', cls: 'ag-body-vertical-scroll-container' }],
        },
    ],
};
class FakeVScrollComp extends abstractFakeScrollComp_1.AbstractFakeScrollComp {
    constructor() {
        super(FakeVScrollElement, 'vertical');
    }
    postConstruct() {
        super.postConstruct();
        this.createManagedBean(new setHeightFeature_1.SetHeightFeature(this.eContainer));
        const { ctrlsSvc } = this.beans;
        ctrlsSvc.register('fakeVScrollComp', this);
        this.addManagedEventListeners({
            rowContainerHeightChanged: this.onRowContainerHeightChanged.bind(this, ctrlsSvc),
        });
    }
    setScrollVisible() {
        const { scrollVisibleSvc } = this.beans;
        const vScrollShowing = scrollVisibleSvc.verticalScrollShowing;
        const invisibleScrollbar = this.invisibleScrollbar;
        const scrollbarWidth = vScrollShowing ? scrollVisibleSvc.getScrollbarWidth() || 0 : 0;
        const adjustedScrollbarWidth = scrollbarWidth === 0 && invisibleScrollbar ? 16 : scrollbarWidth;
        this.toggleCss('ag-scrollbar-invisible', invisibleScrollbar);
        (0, dom_1._setFixedWidth)(this.getGui(), adjustedScrollbarWidth);
        (0, dom_1._setFixedWidth)(this.eViewport, adjustedScrollbarWidth);
        (0, dom_1._setFixedWidth)(this.eContainer, adjustedScrollbarWidth);
        this.setDisplayed(vScrollShowing, { skipAriaHidden: true });
    }
    onRowContainerHeightChanged(ctrlsSvc) {
        const gridBodyCtrl = ctrlsSvc.getGridBodyCtrl();
        const gridBodyViewportEl = gridBodyCtrl.eBodyViewport;
        const eViewportScrollTop = this.getScrollPosition();
        const gridBodyViewportScrollTop = gridBodyViewportEl.scrollTop;
        if (eViewportScrollTop != gridBodyViewportScrollTop) {
            this.setScrollPosition(gridBodyViewportScrollTop, true);
        }
    }
    getScrollPosition() {
        return this.eViewport.scrollTop;
    }
    setScrollPosition(value, force) {
        if (!force && !(0, dom_1._isVisible)(this.eViewport)) {
            this.attemptSettingScrollPosition(value);
        }
        this.eViewport.scrollTop = value;
    }
}
exports.FakeVScrollComp = FakeVScrollComp;
exports.FakeVScrollSelector = {
    selector: 'AG-FAKE-VERTICAL-SCROLL',
    component: FakeVScrollComp,
};


/***/ }),

/***/ 2006:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GridBodySelector = exports.GridBodyComp = void 0;
const gridOptionsUtils_1 = __webpack_require__(67274);
const gridHeaderComp_1 = __webpack_require__(38791);
const layoutFeature_1 = __webpack_require__(59360);
const aria_1 = __webpack_require__(95230);
const dom_1 = __webpack_require__(33507);
const component_1 = __webpack_require__(78020);
const fakeHScrollComp_1 = __webpack_require__(62716);
const fakeVScrollComp_1 = __webpack_require__(46070);
const gridBodyCtrl_1 = __webpack_require__(70520);
const rowContainerComp_1 = __webpack_require__(54633);
function makeRowContainers(paramsMap, names) {
    return names.map((name) => {
        const refName = `e${name[0].toUpperCase() + name.substring(1)}RowContainer`;
        paramsMap[refName] = { name };
        return {
            tag: 'ag-row-container',
            ref: refName,
            attrs: { name },
        };
    });
}
function getGridBodyTemplate(includeOverlay) {
    const paramsMap = {};
    const elementParams = {
        tag: 'div',
        ref: 'eGridRoot',
        cls: 'ag-root ag-unselectable',
        children: [
            { tag: 'ag-header-root' },
            {
                tag: 'div',
                ref: 'eTop',
                cls: 'ag-floating-top',
                role: 'presentation',
                children: makeRowContainers(paramsMap, ['topLeft', 'topCenter', 'topRight', 'topFullWidth']),
            },
            {
                tag: 'div',
                ref: 'eBody',
                cls: 'ag-body',
                role: 'presentation',
                children: [
                    {
                        tag: 'div',
                        ref: 'eBodyViewport',
                        cls: 'ag-body-viewport',
                        role: 'presentation',
                        children: makeRowContainers(paramsMap, ['left', 'center', 'right', 'fullWidth']),
                    },
                    { tag: 'ag-fake-vertical-scroll' },
                ],
            },
            {
                tag: 'div',
                ref: 'eStickyTop',
                cls: 'ag-sticky-top',
                role: 'presentation',
                children: makeRowContainers(paramsMap, [
                    'stickyTopLeft',
                    'stickyTopCenter',
                    'stickyTopRight',
                    'stickyTopFullWidth',
                ]),
            },
            {
                tag: 'div',
                ref: 'eStickyBottom',
                cls: 'ag-sticky-bottom',
                role: 'presentation',
                children: makeRowContainers(paramsMap, [
                    'stickyBottomLeft',
                    'stickyBottomCenter',
                    'stickyBottomRight',
                    'stickyBottomFullWidth',
                ]),
            },
            {
                tag: 'div',
                ref: 'eBottom',
                cls: 'ag-floating-bottom',
                role: 'presentation',
                children: makeRowContainers(paramsMap, [
                    'bottomLeft',
                    'bottomCenter',
                    'bottomRight',
                    'bottomFullWidth',
                ]),
            },
            { tag: 'ag-fake-horizontal-scroll' },
            includeOverlay ? { tag: 'ag-overlay-wrapper' } : null,
        ],
    };
    return { paramsMap, elementParams };
}
class GridBodyComp extends component_1.Component {
    constructor() {
        super(...arguments);
        this.eGridRoot = component_1.RefPlaceholder;
        this.eBodyViewport = component_1.RefPlaceholder;
        this.eStickyTop = component_1.RefPlaceholder;
        this.eStickyBottom = component_1.RefPlaceholder;
        this.eTop = component_1.RefPlaceholder;
        this.eBottom = component_1.RefPlaceholder;
        this.eBody = component_1.RefPlaceholder;
    }
    postConstruct() {
        const { overlays, rangeSvc } = this.beans;
        const overlaySelector = overlays?.getOverlayWrapperSelector();
        const { paramsMap, elementParams } = getGridBodyTemplate(!!overlaySelector);
        this.setTemplate(elementParams, [
            ...(overlaySelector ? [overlaySelector] : []),
            fakeHScrollComp_1.FakeHScrollSelector,
            fakeVScrollComp_1.FakeVScrollSelector,
            gridHeaderComp_1.GridHeaderSelector,
            rowContainerComp_1.RowContainerSelector,
        ], paramsMap);
        const setHeight = (height, element) => {
            const heightString = `${height}px`;
            element.style.minHeight = heightString;
            element.style.height = heightString;
        };
        const compProxy = {
            setRowAnimationCssOnBodyViewport: (cssClass, animate) => this.setRowAnimationCssOnBodyViewport(cssClass, animate),
            setColumnCount: (count) => (0, aria_1._setAriaColCount)(this.getGui(), count),
            setRowCount: (count) => (0, aria_1._setAriaRowCount)(this.getGui(), count),
            setTopHeight: (height) => setHeight(height, this.eTop),
            setBottomHeight: (height) => setHeight(height, this.eBottom),
            setTopInvisible: (invisible) => this.eTop.classList.toggle('ag-invisible', invisible),
            setBottomInvisible: (invisible) => this.eBottom.classList.toggle('ag-invisible', invisible),
            setStickyTopHeight: (height) => (this.eStickyTop.style.height = height),
            setStickyTopTop: (top) => (this.eStickyTop.style.top = top),
            setStickyTopWidth: (width) => (this.eStickyTop.style.width = width),
            setStickyBottomHeight: (height) => {
                this.eStickyBottom.style.height = height;
                this.eStickyBottom.classList.toggle('ag-invisible', height === '0px');
            },
            setStickyBottomBottom: (bottom) => (this.eStickyBottom.style.bottom = bottom),
            setStickyBottomWidth: (width) => (this.eStickyBottom.style.width = width),
            setColumnMovingCss: (cssClass, flag) => this.toggleCss(cssClass, flag),
            updateLayoutClasses: (cssClass, params) => {
                const classLists = [this.eBodyViewport.classList, this.eBody.classList];
                for (const classList of classLists) {
                    classList.toggle(layoutFeature_1.LayoutCssClasses.AUTO_HEIGHT, params.autoHeight);
                    classList.toggle(layoutFeature_1.LayoutCssClasses.NORMAL, params.normal);
                    classList.toggle(layoutFeature_1.LayoutCssClasses.PRINT, params.print);
                }
                this.toggleCss(layoutFeature_1.LayoutCssClasses.AUTO_HEIGHT, params.autoHeight);
                this.toggleCss(layoutFeature_1.LayoutCssClasses.NORMAL, params.normal);
                this.toggleCss(layoutFeature_1.LayoutCssClasses.PRINT, params.print);
            },
            setAlwaysVerticalScrollClass: (cssClass, on) => this.eBodyViewport.classList.toggle(gridBodyCtrl_1.CSS_CLASS_FORCE_VERTICAL_SCROLL, on),
            registerBodyViewportResizeListener: (listener) => {
                const unsubscribeFromResize = (0, dom_1._observeResize)(this.beans, this.eBodyViewport, listener);
                this.addDestroyFunc(() => unsubscribeFromResize());
            },
            setPinnedTopBottomOverflowY: (overflow) => (this.eTop.style.overflowY = this.eBottom.style.overflowY = overflow),
            setCellSelectableCss: (cssClass, selectable) => {
                [this.eTop, this.eBodyViewport, this.eBottom].forEach((ct) => ct.classList.toggle(cssClass, selectable));
            },
            setBodyViewportWidth: (width) => (this.eBodyViewport.style.width = width),
            setGridRootRole: (role) => (0, aria_1._setAriaRole)(this.eGridRoot, role),
        };
        this.ctrl = this.createManagedBean(new gridBodyCtrl_1.GridBodyCtrl());
        this.ctrl.setComp(compProxy, this.getGui(), this.eBodyViewport, this.eTop, this.eBottom, this.eStickyTop, this.eStickyBottom);
        if ((rangeSvc && (0, gridOptionsUtils_1._isCellSelectionEnabled)(this.gos)) || (0, gridOptionsUtils_1._isMultiRowSelection)(this.gos)) {
            (0, aria_1._setAriaMultiSelectable)(this.getGui(), true);
        }
    }
    setRowAnimationCssOnBodyViewport(cssClass, animateRows) {
        const bodyViewportClassList = this.eBodyViewport.classList;
        bodyViewportClassList.toggle('ag-row-animation', animateRows);
        bodyViewportClassList.toggle('ag-row-no-animation', !animateRows);
    }
}
exports.GridBodyComp = GridBodyComp;
exports.GridBodySelector = {
    selector: 'AG-GRID-BODY',
    component: GridBodyComp,
};


/***/ }),

/***/ 70520:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GridBodyCtrl = exports.CSS_CLASS_FORCE_VERTICAL_SCROLL = void 0;
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const layoutFeature_1 = __webpack_require__(59360);
const browser_1 = __webpack_require__(98667);
const dom_1 = __webpack_require__(33507);
const gridBodyScrollFeature_1 = __webpack_require__(95496);
const mouseEventUtils_1 = __webpack_require__(8399);
const rowContainerCtrl_1 = __webpack_require__(8115);
exports.CSS_CLASS_FORCE_VERTICAL_SCROLL = 'ag-force-vertical-scroll';
const CSS_CLASS_CELL_SELECTABLE = 'ag-selectable';
const CSS_CLASS_COLUMN_MOVING = 'ag-column-moving';
class GridBodyCtrl extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.stickyTopHeight = 0;
        this.stickyBottomHeight = 0;
    }
    wireBeans(beans) {
        this.ctrlsSvc = beans.ctrlsSvc;
        this.colModel = beans.colModel;
        this.scrollVisibleSvc = beans.scrollVisibleSvc;
        this.pinnedRowModel = beans.pinnedRowModel;
        this.filterManager = beans.filterManager;
        this.rowGroupColsSvc = beans.rowGroupColsSvc;
    }
    setComp(comp, eGridBody, eBodyViewport, eTop, eBottom, eStickyTop, eStickyBottom) {
        this.comp = comp;
        this.eGridBody = eGridBody;
        this.eBodyViewport = eBodyViewport;
        this.eTop = eTop;
        this.eBottom = eBottom;
        this.eStickyTop = eStickyTop;
        this.eStickyBottom = eStickyBottom;
        this.eCenterColsViewport = eBodyViewport.querySelector(`.${(0, rowContainerCtrl_1._getRowViewportClass)('center')}`);
        this.eFullWidthContainer = eBodyViewport.querySelector(`.${(0, rowContainerCtrl_1._getRowContainerClass)('fullWidth')}`);
        this.eStickyTopFullWidthContainer = eStickyTop.querySelector(`.${(0, rowContainerCtrl_1._getRowContainerClass)('stickyTopFullWidth')}`);
        this.eStickyBottomFullWidthContainer = eStickyBottom.querySelector(`.${(0, rowContainerCtrl_1._getRowContainerClass)('stickyBottomFullWidth')}`);
        this.setCellTextSelection(this.gos.get('enableCellTextSelection'));
        this.addManagedPropertyListener('enableCellTextSelection', (props) => this.setCellTextSelection(props.currentValue));
        this.createManagedBean(new layoutFeature_1.LayoutFeature(this.comp));
        this.scrollFeature = this.createManagedBean(new gridBodyScrollFeature_1.GridBodyScrollFeature(eBodyViewport));
        this.beans.rowDragSvc?.setupRowDrag(eBodyViewport, this);
        this.setupRowAnimationCssClass();
        this.addEventListeners();
        this.addFocusListeners([eTop, eBodyViewport, eBottom, eStickyTop, eStickyBottom]);
        this.setGridRootRole();
        this.onGridColumnsChanged();
        this.addBodyViewportListener();
        this.setFloatingHeights();
        this.disableBrowserDragging();
        this.addStopEditingWhenGridLosesFocus();
        this.updateScrollingClasses();
        this.filterManager?.setupAdvFilterHeaderComp(eTop);
        this.ctrlsSvc.register('gridBodyCtrl', this);
    }
    addEventListeners() {
        const setFloatingHeights = this.setFloatingHeights.bind(this);
        const setGridRootRole = this.setGridRootRole.bind(this);
        const toggleRowResizeStyle = this.toggleRowResizeStyles.bind(this);
        this.addManagedEventListeners({
            gridColumnsChanged: this.onGridColumnsChanged.bind(this),
            scrollVisibilityChanged: this.onScrollVisibilityChanged.bind(this),
            scrollGapChanged: this.updateScrollingClasses.bind(this),
            pinnedRowDataChanged: setFloatingHeights,
            pinnedHeightChanged: setFloatingHeights,
            pinnedRowsChanged: setFloatingHeights,
            headerHeightChanged: this.setStickyTopOffsetTop.bind(this),
            columnRowGroupChanged: setGridRootRole,
            columnPivotChanged: setGridRootRole,
            rowResizeStarted: toggleRowResizeStyle,
            rowResizeEnded: toggleRowResizeStyle,
        });
        this.addManagedPropertyListener('treeData', setGridRootRole);
    }
    toggleRowResizeStyles(params) {
        const isResizingRow = params.type === 'rowResizeStarted';
        this.eBodyViewport.classList.toggle('ag-prevent-animation', isResizingRow);
    }
    onGridColumnsChanged() {
        const columns = this.beans.colModel.getCols();
        this.comp.setColumnCount(columns.length);
    }
    onScrollVisibilityChanged() {
        const { scrollVisibleSvc } = this;
        const visible = scrollVisibleSvc.verticalScrollShowing;
        this.setVerticalScrollPaddingVisible(visible);
        this.setStickyWidth(visible);
        this.setStickyBottomOffsetBottom();
        const scrollbarWidth = visible ? scrollVisibleSvc.getScrollbarWidth() || 0 : 0;
        const pad = (0, browser_1._isInvisibleScrollbar)() ? 16 : 0;
        const width = `calc(100% + ${scrollbarWidth + pad}px)`;
        (0, dom_1._requestAnimationFrame)(this.beans, () => this.comp.setBodyViewportWidth(width));
        this.updateScrollingClasses();
    }
    setGridRootRole() {
        const { rowGroupColsSvc, colModel } = this;
        let isTreeGrid = this.gos.get('treeData');
        if (!isTreeGrid) {
            const isPivotActive = colModel.isPivotMode();
            const rowGroupColumnLen = !rowGroupColsSvc ? 0 : rowGroupColsSvc.columns.length;
            const columnsNeededForGrouping = isPivotActive ? 2 : 1;
            isTreeGrid = rowGroupColumnLen >= columnsNeededForGrouping;
        }
        this.comp.setGridRootRole(isTreeGrid ? 'treegrid' : 'grid');
    }
    addFocusListeners(elements) {
        elements.forEach((element) => {
            this.addManagedElementListeners(element, {
                focusin: (e) => {
                    const { target } = e;
                    // element being focused is nested?
                    const isFocusedElementNested = (0, dom_1._isElementChildOfClass)(target, 'ag-root', element);
                    element.classList.toggle('ag-has-focus', !isFocusedElementNested);
                },
                focusout: (e) => {
                    const { target, relatedTarget } = e;
                    const gridContainRelatedTarget = element.contains(relatedTarget);
                    const isNestedRelatedTarget = (0, dom_1._isElementChildOfClass)(relatedTarget, 'ag-root', element);
                    const isNestedTarget = (0, dom_1._isElementChildOfClass)(target, 'ag-root', element);
                    // element losing focus belongs to a nested grid,
                    // it should not be handled here.
                    if (isNestedTarget) {
                        return;
                    }
                    // the grid does not contain, or the focus element is within
                    // a nested grid
                    if (!gridContainRelatedTarget || isNestedRelatedTarget) {
                        element.classList.remove('ag-has-focus');
                    }
                },
            });
        });
    }
    // used by ColumnAnimationService
    setColumnMovingCss(moving) {
        this.comp.setColumnMovingCss(CSS_CLASS_COLUMN_MOVING, moving);
    }
    setCellTextSelection(selectable = false) {
        this.comp.setCellSelectableCss(CSS_CLASS_CELL_SELECTABLE, selectable);
    }
    updateScrollingClasses() {
        const { eGridBody: { classList }, scrollVisibleSvc, } = this;
        classList.toggle('ag-body-vertical-content-no-gap', !scrollVisibleSvc.verticalScrollGap);
        classList.toggle('ag-body-horizontal-content-no-gap', !scrollVisibleSvc.horizontalScrollGap);
    }
    // if we do not do this, then the user can select a pic in the grid (eg an image in a custom cell renderer)
    // and then that will start the browser native drag n' drop, which messes up with our own drag and drop.
    disableBrowserDragging() {
        this.addManagedElementListeners(this.eGridBody, {
            dragstart: (event) => {
                if (event.target instanceof HTMLImageElement) {
                    event.preventDefault();
                    return false;
                }
            },
        });
    }
    addStopEditingWhenGridLosesFocus() {
        this.beans.editSvc?.addStopEditingWhenGridLosesFocus([
            this.eBodyViewport,
            this.eBottom,
            this.eTop,
            this.eStickyTop,
            this.eStickyBottom,
        ]);
    }
    updateRowCount() {
        const headerCount = (this.ctrlsSvc.getHeaderRowContainerCtrl()?.getRowCount() ?? 0) +
            (this.filterManager?.getHeaderRowCount() ?? 0);
        const { rowModel } = this.beans;
        const rowCount = rowModel.isLastRowIndexKnown() ? rowModel.getRowCount() : -1;
        const total = rowCount === -1 ? -1 : headerCount + rowCount;
        this.comp.setRowCount(total);
    }
    registerBodyViewportResizeListener(listener) {
        this.comp.registerBodyViewportResizeListener(listener);
    }
    setVerticalScrollPaddingVisible(visible) {
        const overflowY = visible ? 'scroll' : 'hidden';
        this.comp.setPinnedTopBottomOverflowY(overflowY);
    }
    isVerticalScrollShowing() {
        const show = this.gos.get('alwaysShowVerticalScroll');
        const cssClass = show ? exports.CSS_CLASS_FORCE_VERTICAL_SCROLL : null;
        const allowVerticalScroll = (0, gridOptionsUtils_1._isDomLayout)(this.gos, 'normal');
        this.comp.setAlwaysVerticalScrollClass(cssClass, show);
        return show || (allowVerticalScroll && (0, dom_1._isVerticalScrollShowing)(this.eBodyViewport));
    }
    setupRowAnimationCssClass() {
        const { rowContainerHeight, environment } = this.beans;
        let initialSizeMeasurementComplete = environment.sizesMeasured;
        const updateAnimationClass = () => {
            // we don't want to use row animation if scaling, as rows jump strangely as you scroll,
            // when scaling and doing row animation.
            const animateRows = initialSizeMeasurementComplete && (0, gridOptionsUtils_1._isAnimateRows)(this.gos) && !rowContainerHeight.stretching;
            const animateRowsCssClass = animateRows
                ? 'ag-row-animation'
                : 'ag-row-no-animation';
            this.comp.setRowAnimationCssOnBodyViewport(animateRowsCssClass, animateRows);
        };
        updateAnimationClass();
        this.addManagedEventListeners({ heightScaleChanged: updateAnimationClass });
        this.addManagedPropertyListener('animateRows', updateAnimationClass);
        this.addManagedEventListeners({
            gridStylesChanged: () => {
                if (!initialSizeMeasurementComplete && environment.sizesMeasured) {
                    initialSizeMeasurementComplete = true;
                    updateAnimationClass();
                }
            },
        });
    }
    addBodyViewportListener() {
        const { eBodyViewport, eStickyTop, eStickyBottom, eTop, eBottom, beans: { popupSvc, touchSvc }, } = this;
        // we want to listen for clicks directly on the eBodyViewport, so the user has a way of showing
        // the context menu if no rows or columns are displayed, or user simply clicks outside of a cell
        const listener = this.onBodyViewportContextMenu.bind(this);
        this.addManagedElementListeners(eBodyViewport, { contextmenu: listener });
        touchSvc?.mockBodyContextMenu(this, listener);
        this.addManagedElementListeners(eBodyViewport, {
            wheel: this.onBodyViewportWheel.bind(this, popupSvc),
        });
        const onStickyWheel = this.onStickyWheel.bind(this);
        for (const container of [eStickyTop, eStickyBottom, eTop, eBottom]) {
            this.addManagedElementListeners(container, { wheel: onStickyWheel });
        }
        const onHorizontalWheel = this.onHorizontalWheel.bind(this);
        for (const container of ['left', 'right', 'topLeft', 'topRight', 'bottomLeft', 'bottomRight']) {
            this.addManagedElementListeners(this.ctrlsSvc.get(container).eContainer, {
                wheel: onHorizontalWheel,
            });
        }
        // allow mouseWheel on the Full Width Container to Scroll the Viewport
        this.addFullWidthContainerWheelListener();
    }
    addFullWidthContainerWheelListener() {
        this.addManagedElementListeners(this.eFullWidthContainer, {
            wheel: (e) => this.onFullWidthContainerWheel(e),
        });
    }
    onFullWidthContainerWheel(e) {
        const { deltaX, deltaY, shiftKey } = e;
        const isHorizontalScroll = shiftKey || Math.abs(deltaX) > Math.abs(deltaY);
        if (isHorizontalScroll && (0, mouseEventUtils_1._isEventFromThisGrid)(this.gos, e)) {
            this.scrollGridBodyToMatchEvent(e);
        }
    }
    onStickyWheel(e) {
        const { deltaY } = e;
        const scrolled = this.scrollVertically(deltaY);
        if (scrolled > 0) {
            e.preventDefault();
        }
    }
    onHorizontalWheel(e) {
        const { deltaX, deltaY, shiftKey } = e;
        const isHorizontalScroll = shiftKey || Math.abs(deltaX) > Math.abs(deltaY);
        if (!isHorizontalScroll) {
            return;
        }
        this.scrollGridBodyToMatchEvent(e);
    }
    scrollGridBodyToMatchEvent(e) {
        const { deltaX, deltaY } = e;
        e.preventDefault();
        // if it is a horizontal scroll and deltaX is zero,
        // it means the OS has flipped the axis and it's using deltaY
        this.eCenterColsViewport.scrollBy({ left: deltaX || deltaY });
    }
    onBodyViewportContextMenu(mouseEvent, touch, touchEvent) {
        if (!mouseEvent && !touchEvent) {
            return;
        }
        if (this.gos.get('preventDefaultOnContextMenu')) {
            const event = (mouseEvent || touchEvent);
            event.preventDefault();
        }
        const { target } = (mouseEvent || touch);
        if (target === this.eBodyViewport || target === this.ctrlsSvc.get('center').eViewport) {
            // show it
            this.beans.contextMenuSvc?.showContextMenu({
                mouseEvent,
                touchEvent: touchEvent,
                value: null,
                anchorToElement: this.eGridBody,
                source: 'ui',
            });
        }
    }
    onBodyViewportWheel(popupSvc, e) {
        if (!this.gos.get('suppressScrollWhenPopupsAreOpen')) {
            return;
        }
        if (popupSvc?.hasAnchoredPopup()) {
            e.preventDefault();
        }
    }
    // called by rowDragFeature
    scrollVertically(pixels) {
        const oldScrollPosition = this.eBodyViewport.scrollTop;
        this.scrollFeature.setVerticalScrollPosition(oldScrollPosition + pixels);
        return this.eBodyViewport.scrollTop - oldScrollPosition;
    }
    setFloatingHeights() {
        const { pinnedRowModel, beans: { environment }, } = this;
        const floatingTopHeight = pinnedRowModel?.getPinnedTopTotalHeight();
        const floatingBottomHeight = pinnedRowModel?.getPinnedBottomTotalHeight();
        // We need to account for the row border and the pinned row borders.
        // The floating container has box-sizing: border-box, so it's border will be
        // part of its total height. Therefore we add it on to the total floating row heights.
        // However, we don't want a double border on the final row of the pinned container,
        // we instead want the pinned row border to "replace" the row border. As such, we
        // subtract the row border width from the pinned border width to arrive at the final
        // additional height to add to the container.
        const pinnedBorderWidth = environment.getPinnedRowBorderWidth();
        const rowBorderWidth = environment.getRowBorderWidth();
        const additionalHeight = pinnedBorderWidth - rowBorderWidth;
        // We only add the border-related adjustment if there's actually pinned rows visible
        const normalisedFloatingTopHeight = !floatingTopHeight ? 0 : additionalHeight + floatingTopHeight;
        const normalisedFloatingBottomHeight = !floatingBottomHeight ? 0 : additionalHeight + floatingBottomHeight;
        this.comp.setTopHeight(normalisedFloatingTopHeight);
        this.comp.setBottomHeight(normalisedFloatingBottomHeight);
        this.comp.setTopInvisible(normalisedFloatingTopHeight <= 0);
        this.comp.setBottomInvisible(normalisedFloatingBottomHeight <= 0);
        this.setStickyTopOffsetTop();
        this.setStickyBottomOffsetBottom();
    }
    setStickyTopHeight(height = 0) {
        // console.log('setting sticky top height ' + height);
        this.comp.setStickyTopHeight(`${height}px`);
        this.stickyTopHeight = height;
    }
    setStickyBottomHeight(height = 0) {
        this.comp.setStickyBottomHeight(`${height}px`);
        this.stickyBottomHeight = height;
    }
    setStickyWidth(vScrollVisible) {
        if (!vScrollVisible) {
            this.comp.setStickyTopWidth('100%');
            this.comp.setStickyBottomWidth('100%');
        }
        else {
            const scrollbarWidth = this.scrollVisibleSvc.getScrollbarWidth();
            this.comp.setStickyTopWidth(`calc(100% - ${scrollbarWidth}px)`);
            this.comp.setStickyBottomWidth(`calc(100% - ${scrollbarWidth}px)`);
        }
    }
    setStickyTopOffsetTop() {
        const headerCtrl = this.ctrlsSvc.get('gridHeaderCtrl');
        const headerHeight = headerCtrl.headerHeight + (this.filterManager?.getHeaderHeight() ?? 0);
        const pinnedTopHeight = this.pinnedRowModel?.getPinnedTopTotalHeight() ?? 0;
        let height = 0;
        if (headerHeight > 0) {
            height += headerHeight;
        }
        if (pinnedTopHeight > 0) {
            height += pinnedTopHeight;
        }
        if (height > 0) {
            height += 1;
        }
        this.comp.setStickyTopTop(`${height}px`);
    }
    setStickyBottomOffsetBottom() {
        const { pinnedRowModel, scrollVisibleSvc, comp } = this;
        const pinnedBottomHeight = pinnedRowModel?.getPinnedBottomTotalHeight() ?? 0;
        const hScrollShowing = scrollVisibleSvc.horizontalScrollShowing;
        const scrollbarWidth = hScrollShowing ? scrollVisibleSvc.getScrollbarWidth() || 0 : 0;
        const height = pinnedBottomHeight + scrollbarWidth;
        comp.setStickyBottomBottom(`${height}px`);
    }
}
exports.GridBodyCtrl = GridBodyCtrl;


/***/ }),

/***/ 95496:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GridBodyScrollFeature = void 0;
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const browser_1 = __webpack_require__(98667);
const dom_1 = __webpack_require__(33507);
const function_1 = __webpack_require__(92043);
const logging_1 = __webpack_require__(47764);
var ScrollDir;
(function (ScrollDir) {
    ScrollDir[ScrollDir["Vertical"] = 0] = "Vertical";
    ScrollDir[ScrollDir["Horizontal"] = 1] = "Horizontal";
})(ScrollDir || (ScrollDir = {}));
const VIEWPORT = 'Viewport';
const FAKE_V_SCROLLBAR = 'fakeVScrollComp';
const HORIZONTAL_SOURCES = [
    'fakeHScrollComp',
    'centerHeader',
    'topCenter',
    'bottomCenter',
    'stickyTopCenter',
    'stickyBottomCenter',
];
// timeout used for the debounceVerticalScrollbar property
const SCROLL_DEBOUNCE_TIMEOUT = 100;
// timeout used to fire onBodyScrollEnd and to reset last scroll source
const SCROLL_END_TIMEOUT = 150;
class GridBodyScrollFeature extends beanStub_1.BeanStub {
    wireBeans(beans) {
        this.ctrlsSvc = beans.ctrlsSvc;
        this.animationFrameSvc = beans.animationFrameSvc;
        this.visibleCols = beans.visibleCols;
    }
    constructor(eBodyViewport) {
        super();
        // listeners for when ensureIndexVisible is waiting for SSRM data to load
        this.clearRetryListenerFncs = [];
        this.lastScrollSource = [null, null];
        this.scrollLeft = -1;
        this.nextScrollTop = -1;
        this.scrollTop = -1;
        // Used to provide approximate values of scrollTop and offsetHeight
        // without forcing the browser to recalculate styles.
        this.lastOffsetHeight = -1;
        this.lastScrollTop = -1;
        this.lastIsHorizontalScrollShowing = false;
        this.scrollTimer = 0;
        this.isScrollActive = false;
        this.isVerticalPositionInvalidated = true;
        this.isHorizontalPositionInvalidated = true;
        this.eBodyViewport = eBodyViewport;
        this.resetLastHScrollDebounced = (0, function_1._debounce)(this, () => (this.lastScrollSource[ScrollDir.Horizontal] = null), SCROLL_END_TIMEOUT);
        this.resetLastVScrollDebounced = (0, function_1._debounce)(this, () => (this.lastScrollSource[ScrollDir.Vertical] = null), SCROLL_END_TIMEOUT);
    }
    destroy() {
        super.destroy();
        this.clearRetryListenerFncs = [];
        window.clearTimeout(this.scrollTimer);
    }
    postConstruct() {
        this.enableRtl = this.gos.get('enableRtl');
        const invalidateVerticalScroll = this.invalidateVerticalScroll.bind(this);
        const invalidateHorizontalScroll = this.invalidateHorizontalScroll.bind(this);
        this.addManagedEventListeners({
            displayedColumnsWidthChanged: this.onDisplayedColumnsWidthChanged.bind(this),
            gridSizeChanged: invalidateVerticalScroll,
            // We only invalidate horizontal scrolling when the viewport switches
            // between scrollable and non-scrollable, avoiding unnecessary
            // invalidation on every gridSizeChanged event. If more properties
            // require invalidation, read/write DOM cycles may be needed.
            scrollGapChanged: invalidateHorizontalScroll,
        });
        this.addManagedElementListeners(this.eBodyViewport, {
            scroll: invalidateVerticalScroll,
        });
        this.ctrlsSvc.whenReady(this, (p) => {
            this.centerRowsCtrl = p.center;
            this.onDisplayedColumnsWidthChanged();
            this.addScrollListener();
        });
    }
    invalidateHorizontalScroll() {
        this.isHorizontalPositionInvalidated = true;
    }
    invalidateVerticalScroll() {
        this.isVerticalPositionInvalidated = true;
    }
    addScrollListener() {
        this.addHorizontalScrollListeners();
        this.addVerticalScrollListeners();
    }
    addHorizontalScrollListeners() {
        this.addManagedElementListeners(this.centerRowsCtrl.eViewport, {
            scroll: this.onHScroll.bind(this, VIEWPORT),
        });
        for (const source of HORIZONTAL_SOURCES) {
            const scrollPartner = this.ctrlsSvc.get(source);
            this.registerScrollPartner(scrollPartner, this.onHScroll.bind(this, source));
        }
    }
    addVerticalScrollListeners() {
        const fakeVScrollComp = this.ctrlsSvc.get('fakeVScrollComp');
        const isDebounce = this.gos.get('debounceVerticalScrollbar');
        const onVScroll = isDebounce
            ? (0, function_1._debounce)(this, this.onVScroll.bind(this, VIEWPORT), SCROLL_DEBOUNCE_TIMEOUT)
            : this.onVScroll.bind(this, VIEWPORT);
        const onFakeVScroll = isDebounce
            ? (0, function_1._debounce)(this, this.onVScroll.bind(this, FAKE_V_SCROLLBAR), SCROLL_DEBOUNCE_TIMEOUT)
            : this.onVScroll.bind(this, FAKE_V_SCROLLBAR);
        this.addManagedElementListeners(this.eBodyViewport, { scroll: onVScroll });
        this.registerScrollPartner(fakeVScrollComp, onFakeVScroll);
    }
    registerScrollPartner(comp, callback) {
        comp.onScrollCallback(callback);
    }
    onDisplayedColumnsWidthChanged() {
        if (this.enableRtl) {
            // because RTL is all backwards, a change in the width of the row
            // can cause a change in the scroll position, without a scroll event,
            // because the scroll position in RTL is a function that depends on
            // the width. to be convinced of this, take out this line, enable RTL,
            // scroll all the way to the left and then resize a column
            this.horizontallyScrollHeaderCenterAndFloatingCenter();
        }
    }
    horizontallyScrollHeaderCenterAndFloatingCenter(scrollLeft) {
        // when doing RTL, this method gets called once prematurely
        const notYetInitialised = this.centerRowsCtrl == null;
        if (notYetInitialised) {
            return;
        }
        if (scrollLeft === undefined) {
            scrollLeft = this.centerRowsCtrl.getCenterViewportScrollLeft();
        }
        this.setScrollLeftForAllContainersExceptCurrent(Math.abs(scrollLeft));
    }
    setScrollLeftForAllContainersExceptCurrent(scrollLeft) {
        for (const container of [...HORIZONTAL_SOURCES, VIEWPORT]) {
            if (this.lastScrollSource[ScrollDir.Horizontal] === container) {
                continue;
            }
            const viewport = this.getViewportForSource(container);
            (0, dom_1._setScrollLeft)(viewport, scrollLeft, this.enableRtl);
        }
    }
    getViewportForSource(source) {
        if (source === VIEWPORT) {
            return this.centerRowsCtrl.eViewport;
        }
        return this.ctrlsSvc.get(source).eViewport;
    }
    isControllingScroll(source, direction) {
        if (this.lastScrollSource[direction] == null) {
            if (direction === ScrollDir.Vertical) {
                this.lastScrollSource[0] = source;
            }
            else {
                this.lastScrollSource[1] = source;
            }
            return true;
        }
        return this.lastScrollSource[direction] === source;
    }
    onHScroll(source) {
        if (!this.isControllingScroll(source, ScrollDir.Horizontal)) {
            return;
        }
        const centerContainerViewport = this.centerRowsCtrl.eViewport;
        const { scrollLeft } = centerContainerViewport;
        if (this.shouldBlockScrollUpdate(ScrollDir.Horizontal, scrollLeft, true)) {
            return;
        }
        const newScrollLeft = (0, dom_1._getScrollLeft)(this.getViewportForSource(source), this.enableRtl);
        this.doHorizontalScroll(newScrollLeft);
        this.resetLastHScrollDebounced();
    }
    onVScroll(source) {
        if (!this.isControllingScroll(source, ScrollDir.Vertical)) {
            return;
        }
        let scrollTop;
        if (source === VIEWPORT) {
            scrollTop = this.eBodyViewport.scrollTop;
        }
        else {
            scrollTop = this.ctrlsSvc.get('fakeVScrollComp').getScrollPosition();
        }
        if (this.shouldBlockScrollUpdate(ScrollDir.Vertical, scrollTop, true)) {
            return;
        }
        const { animationFrameSvc } = this;
        animationFrameSvc?.setScrollTop(scrollTop);
        this.nextScrollTop = scrollTop;
        if (source === VIEWPORT) {
            this.ctrlsSvc.get('fakeVScrollComp').setScrollPosition(scrollTop);
        }
        else {
            this.eBodyViewport.scrollTop = scrollTop;
        }
        // the `scrollGridIfNeeded` will recalculate the rows to be rendered by the grid
        // so it should only be called after `eBodyViewport` has been scrolled to the correct
        // position, otherwise the `first` and `last` row could be miscalculated.
        if (animationFrameSvc?.active) {
            animationFrameSvc.schedule();
        }
        else {
            this.scrollGridIfNeeded(true);
        }
        this.resetLastVScrollDebounced();
    }
    doHorizontalScroll(scrollLeft) {
        const fakeScrollLeft = this.ctrlsSvc.get('fakeHScrollComp').getScrollPosition();
        if (this.scrollLeft === scrollLeft && scrollLeft === fakeScrollLeft) {
            return;
        }
        this.scrollLeft = scrollLeft;
        this.fireScrollEvent(ScrollDir.Horizontal);
        this.horizontallyScrollHeaderCenterAndFloatingCenter(scrollLeft);
        this.centerRowsCtrl.onHorizontalViewportChanged(true);
    }
    isScrolling() {
        return this.isScrollActive;
    }
    fireScrollEvent(direction) {
        const bodyScrollEvent = {
            type: 'bodyScroll',
            direction: direction === ScrollDir.Horizontal ? 'horizontal' : 'vertical',
            left: this.scrollLeft,
            top: this.scrollTop,
        };
        this.isScrollActive = true;
        this.eventSvc.dispatchEvent(bodyScrollEvent);
        window.clearTimeout(this.scrollTimer);
        this.scrollTimer = window.setTimeout(() => {
            this.scrollTimer = 0;
            this.isScrollActive = false;
            this.eventSvc.dispatchEvent({
                ...bodyScrollEvent,
                type: 'bodyScrollEnd',
            });
        }, SCROLL_END_TIMEOUT);
    }
    shouldBlockScrollUpdate(direction, scrollTo, touchOnly = false) {
        // touch devices allow elastic scroll - which temporally scrolls the panel outside of the viewport
        // (eg user uses touch to go to the left of the grid, but drags past the left, the rows will actually
        // scroll past the left until the user releases the mouse). when this happens, we want ignore the scroll,
        // as otherwise it was causing the rows and header to flicker.
        // sometimes when scrolling, we got values that extended the maximum scroll allowed. we used to
        // ignore these scrolls. problem is the max scroll position could be skipped (eg the previous scroll event
        // could be 10px before the max position, and then current scroll event could be 20px after the max position).
        // if we just ignored the last event, we would be setting the scroll to 10px before the max position, when in
        // actual fact the user has exceeded the max scroll and thus scroll should be set to the max.
        if (touchOnly && !(0, browser_1._isIOSUserAgent)()) {
            return false;
        }
        if (direction === ScrollDir.Vertical) {
            return this.shouldBlockVerticalScroll(scrollTo);
        }
        return this.shouldBlockHorizontalScroll(scrollTo);
    }
    shouldBlockVerticalScroll(scrollTo) {
        const clientHeight = (0, dom_1._getInnerHeight)(this.eBodyViewport);
        const { scrollHeight } = this.eBodyViewport;
        if (scrollTo < 0 || scrollTo + clientHeight > scrollHeight) {
            return true;
        }
        return false;
    }
    shouldBlockHorizontalScroll(scrollTo) {
        const clientWidth = this.centerRowsCtrl.getCenterWidth();
        const { scrollWidth } = this.centerRowsCtrl.eViewport;
        if (this.enableRtl) {
            if (scrollTo > 0) {
                return true;
            }
        }
        else if (scrollTo < 0) {
            return true;
        }
        if (Math.abs(scrollTo) + clientWidth > scrollWidth) {
            return true;
        }
        return false;
    }
    redrawRowsAfterScroll() {
        this.fireScrollEvent(ScrollDir.Vertical);
    }
    // this is to cater for AG-3274, where grid is removed from the dom and then inserted back in again.
    // (which happens with some implementations of tabbing). this can result in horizontal scroll getting
    // reset back to the left, however no scroll event is fired. so we need to get header to also scroll
    // back to the left to be kept in sync.
    // adding and removing the grid from the DOM both resets the scroll position and
    // triggers a resize event, so notify listeners if the scroll position has changed
    checkScrollLeft() {
        if (this.scrollLeft !== this.centerRowsCtrl.getCenterViewportScrollLeft()) {
            this.onHScroll(VIEWPORT);
        }
    }
    scrollGridIfNeeded(suppressedAnimationFrame = false) {
        const frameNeeded = this.scrollTop != this.nextScrollTop;
        if (frameNeeded) {
            this.scrollTop = this.nextScrollTop;
            if (suppressedAnimationFrame) {
                this.invalidateVerticalScroll();
            }
            this.redrawRowsAfterScroll();
        }
        return frameNeeded;
    }
    // called by scrollHorizontally method and alignedGridsService
    setHorizontalScrollPosition(hScrollPosition, fromAlignedGridsService = false) {
        const minScrollLeft = 0;
        const maxScrollLeft = this.centerRowsCtrl.eViewport.scrollWidth - this.centerRowsCtrl.getCenterWidth();
        // if this is call is coming from the alignedGridsSvc, we don't need to validate the
        // scroll, because it has already been validated by the grid firing the scroll event.
        if (!fromAlignedGridsService && this.shouldBlockScrollUpdate(ScrollDir.Horizontal, hScrollPosition)) {
            if (this.enableRtl) {
                hScrollPosition = hScrollPosition > 0 ? 0 : maxScrollLeft;
            }
            else {
                hScrollPosition = Math.min(Math.max(hScrollPosition, minScrollLeft), maxScrollLeft);
            }
        }
        (0, dom_1._setScrollLeft)(this.centerRowsCtrl.eViewport, Math.abs(hScrollPosition), this.enableRtl);
        // we need to manually do the event handling (rather than wait for the event)
        // for the alignedGridsSvc, as if we don't, the aligned grid service gets
        // notified async, and then it's 'consuming' flag doesn't get used right, and
        // we can end up with an infinite loop
        this.doHorizontalScroll(hScrollPosition);
    }
    setVerticalScrollPosition(vScrollPosition) {
        this.invalidateVerticalScroll();
        this.eBodyViewport.scrollTop = vScrollPosition;
    }
    getVScrollPosition() {
        if (!this.isVerticalPositionInvalidated) {
            const { lastOffsetHeight, lastScrollTop } = this;
            return {
                top: lastScrollTop,
                bottom: lastScrollTop + lastOffsetHeight,
            };
        }
        this.isVerticalPositionInvalidated = false;
        const { scrollTop, offsetHeight } = this.eBodyViewport;
        this.lastScrollTop = scrollTop;
        this.lastOffsetHeight = offsetHeight;
        return {
            top: scrollTop,
            bottom: scrollTop + offsetHeight,
        };
    }
    /** Get an approximate scroll position that returns the last real value read.
     * This is useful for avoiding repeated DOM reads that force the browser to recalculate styles.
     * This can have big performance improvements but may not be 100% accurate so only use if this is acceptable.
     */
    getApproximateVScollPosition() {
        if (this.lastScrollTop >= 0 && this.lastOffsetHeight >= 0) {
            return {
                top: this.scrollTop,
                bottom: this.scrollTop + this.lastOffsetHeight,
            };
        }
        return this.getVScrollPosition();
    }
    getHScrollPosition() {
        return this.centerRowsCtrl.getHScrollPosition();
    }
    isHorizontalScrollShowing() {
        if (this.isHorizontalPositionInvalidated) {
            this.lastIsHorizontalScrollShowing = this.centerRowsCtrl.isHorizontalScrollShowing();
            this.isHorizontalPositionInvalidated = false;
        }
        return this.lastIsHorizontalScrollShowing;
    }
    // called by the headerRootComp and moveColumnController
    scrollHorizontally(pixels) {
        const oldScrollPosition = this.centerRowsCtrl.eViewport.scrollLeft;
        this.setHorizontalScrollPosition(oldScrollPosition + pixels);
        return this.centerRowsCtrl.eViewport.scrollLeft - oldScrollPosition;
    }
    // gets called by rowRenderer when new data loaded, as it will want to scroll to the top
    scrollToTop() {
        this.eBodyViewport.scrollTop = 0;
    }
    // Valid values for position are bottom, middle and top
    ensureNodeVisible(comparator, position = null) {
        const { rowModel } = this.beans;
        // look for the node index we want to display
        const rowCount = rowModel.getRowCount();
        let indexToSelect = -1;
        // go through all the nodes, find the one we want to show
        for (let i = 0; i < rowCount; i++) {
            const node = rowModel.getRow(i);
            if (typeof comparator === 'function') {
                // Have to assert type here, as type could be TData & Function
                const predicate = comparator;
                if (node && predicate(node)) {
                    indexToSelect = i;
                    break;
                }
            }
            else {
                // check object equality against node and data
                if (comparator === node || comparator === node.data) {
                    indexToSelect = i;
                    break;
                }
            }
        }
        if (indexToSelect >= 0) {
            this.ensureIndexVisible(indexToSelect, position);
        }
    }
    // Valid values for position are bottom, middle and top
    // position should be {'top','middle','bottom', or undefined/null}.
    // if undefined/null, then the grid will to the minimal amount of scrolling,
    // eg if grid needs to scroll up, it scrolls until row is on top,
    //    if grid needs to scroll down, it scrolls until row is on bottom,
    //    if row is already in view, grid does not scroll
    ensureIndexVisible(index, position, retry = 0) {
        // if for print or auto height, everything is always visible
        if ((0, gridOptionsUtils_1._isDomLayout)(this.gos, 'print')) {
            return;
        }
        const { rowModel } = this.beans;
        const rowCount = rowModel.getRowCount();
        if (typeof index !== 'number' || index < 0 || index >= rowCount) {
            (0, logging_1._warn)(88, { index });
            return;
        }
        this.clearRetryListeners();
        const { frameworkOverrides, pageBounds, rowContainerHeight: heightScaler, rowRenderer } = this.beans;
        frameworkOverrides.wrapIncoming(() => {
            const gridBodyCtrl = this.ctrlsSvc.getGridBodyCtrl();
            const rowNode = rowModel.getRow(index);
            let rowGotShiftedDuringOperation;
            let stickyHeightsChanged;
            let attempt = 0;
            this.invalidateVerticalScroll();
            do {
                const { stickyTopHeight, stickyBottomHeight } = gridBodyCtrl;
                const startingRowTop = rowNode.rowTop;
                const startingRowHeight = rowNode.rowHeight;
                const paginationOffset = pageBounds.getPixelOffset();
                const rowTopPixel = rowNode.rowTop - paginationOffset;
                const rowBottomPixel = rowTopPixel + rowNode.rowHeight;
                const scrollPosition = this.getVScrollPosition();
                const heightOffset = heightScaler.divStretchOffset;
                const vScrollTop = scrollPosition.top + heightOffset;
                const vScrollBottom = scrollPosition.bottom + heightOffset;
                const viewportHeight = vScrollBottom - vScrollTop;
                // work out the pixels for top, middle and bottom up front,
                // make the if/else below easier to read
                const pxTop = heightScaler.getScrollPositionForPixel(rowTopPixel);
                const pxBottom = heightScaler.getScrollPositionForPixel(rowBottomPixel - viewportHeight);
                // make sure if middle, the row is not outside the top of the grid
                const pxMiddle = Math.min((pxTop + pxBottom) / 2, rowTopPixel);
                const rowAboveViewport = vScrollTop + stickyTopHeight > rowTopPixel;
                const rowBelowViewport = vScrollBottom - stickyBottomHeight < rowBottomPixel;
                let newScrollPosition = null;
                if (position === 'top') {
                    newScrollPosition = pxTop - stickyTopHeight;
                }
                else if (position === 'bottom') {
                    newScrollPosition = pxBottom + stickyBottomHeight;
                }
                else if (position === 'middle') {
                    newScrollPosition = pxMiddle;
                }
                else if (rowAboveViewport) {
                    // if row is before, scroll up with row at top
                    newScrollPosition = pxTop - stickyTopHeight;
                }
                else if (rowBelowViewport) {
                    // if row is taller than viewport, scroll down to the top of the row
                    if (pxBottom - pxTop > viewportHeight) {
                        newScrollPosition = pxTop - stickyTopHeight;
                    }
                    else {
                        // if row is after, scroll down with row at bottom
                        newScrollPosition = pxBottom + stickyBottomHeight;
                    }
                }
                if (newScrollPosition !== null) {
                    this.setVerticalScrollPosition(newScrollPosition);
                    rowRenderer.redraw({ afterScroll: true });
                }
                // the row can get shifted if during the rendering (during rowRenderer.redraw()),
                // the height of a row changes due to lazy calculation of row heights when using
                // colDef.autoHeight or gridOptions.getRowHeight.
                // if row was shifted, then the position we scrolled to is incorrect.
                rowGotShiftedDuringOperation =
                    startingRowTop !== rowNode.rowTop || startingRowHeight !== rowNode.rowHeight;
                // `rowRenderer.redraw` can cause sticky heights to change, which means the row may no longer be visible
                stickyHeightsChanged =
                    stickyTopHeight !== gridBodyCtrl.stickyTopHeight ||
                        stickyBottomHeight !== gridBodyCtrl.stickyBottomHeight;
                attempt++;
                // prevent infinite loops
            } while ((rowGotShiftedDuringOperation || stickyHeightsChanged) && attempt < 10);
            // so when we return back to user, the cells have rendered
            this.animationFrameSvc?.flushAllFrames();
            // SSRM - if the node is a stub, give the grid a chance to load the data
            // when data loads, try again to scroll to the row.
            // Cancel if any other scroll event occurs.
            // also retry if the row is not measured yet, as this can happen when using autoHeight
            if (retry < 10 && (rowNode?.stub || !this.beans.rowAutoHeight?.areRowsMeasured())) {
                const scrollTop = this.getVScrollPosition().top;
                this.clearRetryListenerFncs = this.addManagedEventListeners({
                    bodyScroll: () => {
                        const newScrollTop = this.getVScrollPosition().top;
                        // allow horizontal scroll without cancelling/also allow also use scroll top as opposed to event direction
                        // as scrolling from this func will fire a scroll even asynchronously, but scroll top will be up to date
                        if (scrollTop === newScrollTop) {
                            return;
                        }
                        this.clearRetryListeners();
                    },
                    modelUpdated: () => {
                        this.clearRetryListeners();
                        // if index not in count, stop waiting
                        if (index >= rowModel.getRowCount()) {
                            return;
                        }
                        // try again to scroll to the row.
                        this.ensureIndexVisible(index, position, retry + 1);
                    },
                });
            }
        });
    }
    clearRetryListeners() {
        this.clearRetryListenerFncs.forEach((callback) => callback());
        this.clearRetryListenerFncs = [];
    }
    ensureColumnVisible(key, position = 'auto') {
        const { colModel, frameworkOverrides } = this.beans;
        const column = colModel.getCol(key);
        if (!column) {
            return;
        }
        // calling ensureColumnVisible on a pinned column doesn't make sense
        if (column.isPinned()) {
            return;
        }
        // defensive
        if (!this.visibleCols.isColDisplayed(column)) {
            return;
        }
        const newHorizontalScroll = this.getPositionedHorizontalScroll(column, position);
        frameworkOverrides.wrapIncoming(() => {
            if (newHorizontalScroll !== null) {
                this.centerRowsCtrl.setCenterViewportScrollLeft(newHorizontalScroll);
            }
            // this will happen anyway, as the move will cause a 'scroll' event on the body, however
            // it is possible that the ensureColumnVisible method is called from within AG Grid and
            // the caller will need to have the columns rendered to continue, which will be before
            // the event has been worked on (which is the case for cell navigation).
            this.centerRowsCtrl.onHorizontalViewportChanged();
            // so when we return back to user, the cells have rendered
            this.animationFrameSvc?.flushAllFrames();
        });
    }
    getPositionedHorizontalScroll(column, position) {
        const { columnBeforeStart, columnAfterEnd } = this.isColumnOutsideViewport(column);
        const viewportTooSmallForColumn = this.centerRowsCtrl.getCenterWidth() < column.getActualWidth();
        const viewportWidth = this.centerRowsCtrl.getCenterWidth();
        const isRtl = this.enableRtl;
        let alignColToStart = (isRtl ? columnBeforeStart : columnAfterEnd) || viewportTooSmallForColumn;
        let alignColToEnd = isRtl ? columnAfterEnd : columnBeforeStart;
        if (position !== 'auto') {
            alignColToStart = position === 'start';
            alignColToEnd = position === 'end';
        }
        const isMiddle = position === 'middle';
        if (alignColToStart || alignColToEnd || isMiddle) {
            const { colLeft, colMiddle, colRight } = this.getColumnBounds(column);
            if (isMiddle) {
                return colMiddle - viewportWidth / 2;
            }
            if (alignColToStart) {
                return isRtl ? colRight : colLeft;
            }
            return isRtl ? colLeft - viewportWidth : colRight - viewportWidth;
        }
        return null;
    }
    isColumnOutsideViewport(column) {
        const { start: viewportStart, end: viewportEnd } = this.getViewportBounds();
        const { colLeft, colRight } = this.getColumnBounds(column);
        const isRtl = this.enableRtl;
        const columnBeforeStart = isRtl ? viewportStart > colRight : viewportEnd < colRight;
        const columnAfterEnd = isRtl ? viewportEnd < colLeft : viewportStart > colLeft;
        return { columnBeforeStart, columnAfterEnd };
    }
    getColumnBounds(column) {
        const isRtl = this.enableRtl;
        const bodyWidth = this.visibleCols.bodyWidth;
        const colWidth = column.getActualWidth();
        const colLeft = column.getLeft();
        const multiplier = isRtl ? -1 : 1;
        const colLeftPixel = isRtl ? bodyWidth - colLeft : colLeft;
        const colRightPixel = colLeftPixel + colWidth * multiplier;
        const colMidPixel = colLeftPixel + (colWidth / 2) * multiplier;
        return { colLeft: colLeftPixel, colMiddle: colMidPixel, colRight: colRightPixel };
    }
    getViewportBounds() {
        const viewportWidth = this.centerRowsCtrl.getCenterWidth();
        const scrollPosition = this.centerRowsCtrl.getCenterViewportScrollLeft();
        const viewportStartPixel = scrollPosition;
        const viewportEndPixel = viewportWidth + scrollPosition;
        return { start: viewportStartPixel, end: viewportEndPixel, width: viewportWidth };
    }
}
exports.GridBodyScrollFeature = GridBodyScrollFeature;


/***/ }),

/***/ 8399:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._getNormalisedMousePosition = exports._getCellPositionForEvent = exports._isElementInThisGrid = exports._isEventFromThisGrid = exports._stampTopLevelGridCompWithGridInstance = void 0;
const gridOptionsUtils_1 = __webpack_require__(67274);
const cellCtrl_1 = __webpack_require__(60814);
const generic_1 = __webpack_require__(34422);
const GRID_DOM_KEY = '__ag_grid_instance';
// we put the instance id onto the main DOM element. this is used for events, when grids are inside grids,
// so the grid can work out if the even came from this grid or a grid inside this one. see the ctrl+v logic
// for where this is used.
function _stampTopLevelGridCompWithGridInstance(gos, eGridDiv) {
    eGridDiv[GRID_DOM_KEY] = gos.gridInstanceId;
}
exports._stampTopLevelGridCompWithGridInstance = _stampTopLevelGridCompWithGridInstance;
// walks the path of the event, and returns true if this grid is the first one that it finds. if doing
// master / detail grids, and a child grid is found, then it returns false. this stops things like copy/paste
// getting executed on many grids at the same time.
function _isEventFromThisGrid(gos, event) {
    const res = _isElementInThisGrid(gos, event.target);
    return res;
}
exports._isEventFromThisGrid = _isEventFromThisGrid;
function _isElementInThisGrid(gos, element) {
    let pointer = element;
    while (pointer) {
        const instanceId = pointer[GRID_DOM_KEY];
        if ((0, generic_1._exists)(instanceId)) {
            const eventFromThisGrid = instanceId === gos.gridInstanceId;
            return eventFromThisGrid;
        }
        pointer = pointer.parentElement;
    }
    return false;
}
exports._isElementInThisGrid = _isElementInThisGrid;
function _getCellPositionForEvent(gos, event) {
    return (0, cellCtrl_1._getCellCtrlForEventTarget)(gos, event.target)?.getFocusedCellPosition() ?? null;
}
exports._getCellPositionForEvent = _getCellPositionForEvent;
function _getNormalisedMousePosition(beans, event) {
    const gridPanelHasScrolls = (0, gridOptionsUtils_1._isDomLayout)(beans.gos, 'normal');
    const e = event;
    let x;
    let y;
    if (e.clientX != null || e.clientY != null) {
        x = e.clientX;
        y = e.clientY;
    }
    else {
        x = e.x;
        y = e.y;
    }
    const { pageFirstPixel } = beans.pageBounds.getCurrentPagePixelRange();
    y += pageFirstPixel;
    if (gridPanelHasScrolls) {
        const scrollFeature = beans.ctrlsSvc.getScrollFeature();
        const vRange = scrollFeature.getVScrollPosition();
        const hRange = scrollFeature.getHScrollPosition();
        x += hRange.left;
        y += vRange.top;
    }
    return { x, y };
}
exports._getNormalisedMousePosition = _getNormalisedMousePosition;


/***/ }),

/***/ 54633:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RowContainerSelector = exports.RowContainerComp = void 0;
const rowComp_1 = __webpack_require__(98430);
const dom_1 = __webpack_require__(33507);
const component_1 = __webpack_require__(78020);
const rowContainerCtrl_1 = __webpack_require__(8115);
function getElementParams(name, options, beans) {
    const isCellSpanning = !!beans.gos.get('enableCellSpan') && !!options.getSpannedRowCtrls;
    const eContainerElement = {
        tag: 'div',
        ref: 'eContainer',
        cls: (0, rowContainerCtrl_1._getRowContainerClass)(name),
        role: 'rowgroup',
    };
    if (options.type === 'center' || isCellSpanning) {
        const eSpannedContainerElement = {
            tag: 'div',
            ref: 'eSpannedContainer',
            cls: `ag-spanning-container ${(0, rowContainerCtrl_1._getRowSpanContainerClass)(name)}`,
            role: 'rowgroup',
        };
        return {
            tag: 'div',
            ref: 'eViewport',
            cls: `ag-viewport ${(0, rowContainerCtrl_1._getRowViewportClass)(name)}`,
            role: 'presentation',
            children: [eContainerElement, isCellSpanning ? eSpannedContainerElement : null],
        };
    }
    return eContainerElement;
}
class RowContainerComp extends component_1.Component {
    constructor(params) {
        super();
        this.eViewport = component_1.RefPlaceholder;
        this.eContainer = component_1.RefPlaceholder;
        this.eSpannedContainer = component_1.RefPlaceholder;
        this.rowCompsNoSpan = {};
        this.rowCompsWithSpan = {};
        this.name = params?.name;
        this.options = (0, rowContainerCtrl_1._getRowContainerOptions)(this.name);
    }
    postConstruct() {
        this.setTemplate(getElementParams(this.name, this.options, this.beans));
        const compProxy = {
            setHorizontalScroll: (offset) => (this.eViewport.scrollLeft = offset),
            setViewportHeight: (height) => (this.eViewport.style.height = height),
            setRowCtrls: ({ rowCtrls }) => this.setRowCtrls(rowCtrls),
            setSpannedRowCtrls: (rowCtrls) => this.setRowCtrls(rowCtrls, true),
            setDomOrder: (domOrder) => {
                this.domOrder = domOrder;
            },
            setContainerWidth: (width) => {
                this.eContainer.style.width = width;
                if (this.eSpannedContainer) {
                    this.eSpannedContainer.style.width = width;
                }
            },
            setOffsetTop: (offset) => {
                const top = `translateY(${offset})`;
                this.eContainer.style.transform = top;
                if (this.eSpannedContainer) {
                    this.eSpannedContainer.style.transform = top;
                }
            },
        };
        const ctrl = this.createManagedBean(new rowContainerCtrl_1.RowContainerCtrl(this.name));
        ctrl.setComp(compProxy, this.eContainer, this.eSpannedContainer, this.eViewport);
    }
    destroy() {
        // destroys all row comps
        this.setRowCtrls([]);
        this.setRowCtrls([], true);
        super.destroy();
        this.lastPlacedElement = null;
    }
    setRowCtrls(rowCtrls, spanContainer) {
        const { beans, options } = this;
        const container = spanContainer ? this.eSpannedContainer : this.eContainer;
        const oldRows = spanContainer ? { ...this.rowCompsWithSpan } : { ...this.rowCompsNoSpan };
        const newComps = {};
        if (spanContainer) {
            this.rowCompsWithSpan = newComps;
        }
        else {
            this.rowCompsNoSpan = newComps;
        }
        this.lastPlacedElement = null;
        const orderedRows = [];
        for (const rowCtrl of rowCtrls) {
            const instanceId = rowCtrl.instanceId;
            const existingRowComp = oldRows[instanceId];
            let rowComp;
            if (existingRowComp) {
                rowComp = existingRowComp;
                delete oldRows[instanceId];
            }
            else {
                if (!rowCtrl.rowNode.displayed) {
                    continue;
                }
                rowComp = new rowComp_1.RowComp(rowCtrl, beans, options.type);
            }
            newComps[instanceId] = rowComp;
            orderedRows.push([rowComp, !existingRowComp]);
        }
        this.removeOldRows(Object.values(oldRows), container);
        this.addRowNodes(orderedRows, container);
    }
    addRowNodes(rows, container) {
        const { domOrder } = this;
        for (const [rowComp, isNew] of rows) {
            const eGui = rowComp.getGui();
            if (!domOrder) {
                if (isNew) {
                    container.appendChild(eGui);
                }
            }
            else {
                this.ensureDomOrder(eGui, container);
            }
        }
    }
    removeOldRows(rowComps, container) {
        for (const oldRowComp of rowComps) {
            container.removeChild(oldRowComp.getGui());
            oldRowComp.destroy();
        }
    }
    ensureDomOrder(eRow, container) {
        (0, dom_1._ensureDomOrder)(container, eRow, this.lastPlacedElement);
        this.lastPlacedElement = eRow;
    }
}
exports.RowContainerComp = RowContainerComp;
exports.RowContainerSelector = {
    selector: 'AG-ROW-CONTAINER',
    component: RowContainerComp,
};


/***/ }),

/***/ 8115:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RowContainerCtrl = exports._getRowContainerOptions = exports._getRowSpanContainerClass = exports._getRowContainerClass = exports._getRowViewportClass = void 0;
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const dom_1 = __webpack_require__(33507);
const centerWidthFeature_1 = __webpack_require__(42218);
const viewportSizeFeature_1 = __webpack_require__(25858);
const rowContainerEventsFeature_1 = __webpack_require__(32625);
const setHeightFeature_1 = __webpack_require__(9622);
const getTopRowCtrls = (r) => r.topRowCtrls;
const getStickyTopRowCtrls = (r) => r.getStickyTopRowCtrls();
const getStickyBottomRowCtrls = (r) => r.getStickyBottomRowCtrls();
const getBottomRowCtrls = (r) => r.bottomRowCtrls;
const getCentreRowCtrls = (r) => r.allRowCtrls;
const getSpannedTopRowCtrls = (r) => r.getCtrls('top');
const getSpannedCenterRowCtrls = (r) => r.getCtrls('center');
const getSpannedBottomRowCtrls = (r) => r.getCtrls('bottom');
const ContainerCssClasses = {
    center: {
        type: 'center',
        name: 'center-cols',
        getRowCtrls: getCentreRowCtrls,
        getSpannedRowCtrls: getSpannedCenterRowCtrls,
    },
    left: {
        type: 'left',
        name: 'pinned-left-cols',
        pinnedType: 'left',
        getRowCtrls: getCentreRowCtrls,
        getSpannedRowCtrls: getSpannedCenterRowCtrls,
    },
    right: {
        type: 'right',
        name: 'pinned-right-cols',
        pinnedType: 'right',
        getRowCtrls: getCentreRowCtrls,
        getSpannedRowCtrls: getSpannedCenterRowCtrls,
    },
    fullWidth: {
        type: 'fullWidth',
        name: 'full-width',
        fullWidth: true,
        getRowCtrls: getCentreRowCtrls,
    },
    topCenter: {
        type: 'center',
        name: 'floating-top',
        getRowCtrls: getTopRowCtrls,
        getSpannedRowCtrls: getSpannedTopRowCtrls,
    },
    topLeft: {
        type: 'left',
        name: 'pinned-left-floating',
        container: 'ag-pinned-left-floating-top',
        pinnedType: 'left',
        getRowCtrls: getTopRowCtrls,
        getSpannedRowCtrls: getSpannedTopRowCtrls,
    },
    topRight: {
        type: 'right',
        name: 'pinned-right-floating',
        container: 'ag-pinned-right-floating-top',
        pinnedType: 'right',
        getRowCtrls: getTopRowCtrls,
        getSpannedRowCtrls: getSpannedTopRowCtrls,
    },
    topFullWidth: {
        type: 'fullWidth',
        name: 'floating-top-full-width',
        fullWidth: true,
        getRowCtrls: getTopRowCtrls,
    },
    stickyTopCenter: {
        type: 'center',
        name: 'sticky-top',
        getRowCtrls: getStickyTopRowCtrls,
    },
    stickyTopLeft: {
        type: 'left',
        name: 'pinned-left-sticky-top',
        container: 'ag-pinned-left-sticky-top',
        pinnedType: 'left',
        getRowCtrls: getStickyTopRowCtrls,
    },
    stickyTopRight: {
        type: 'right',
        name: 'pinned-right-sticky-top',
        container: 'ag-pinned-right-sticky-top',
        pinnedType: 'right',
        getRowCtrls: getStickyTopRowCtrls,
    },
    stickyTopFullWidth: {
        type: 'fullWidth',
        name: 'sticky-top-full-width',
        fullWidth: true,
        getRowCtrls: getStickyTopRowCtrls,
    },
    stickyBottomCenter: {
        type: 'center',
        name: 'sticky-bottom',
        getRowCtrls: getStickyBottomRowCtrls,
    },
    stickyBottomLeft: {
        type: 'left',
        name: 'pinned-left-sticky-bottom',
        container: 'ag-pinned-left-sticky-bottom',
        pinnedType: 'left',
        getRowCtrls: getStickyBottomRowCtrls,
    },
    stickyBottomRight: {
        type: 'right',
        name: 'pinned-right-sticky-bottom',
        container: 'ag-pinned-right-sticky-bottom',
        pinnedType: 'right',
        getRowCtrls: getStickyBottomRowCtrls,
    },
    stickyBottomFullWidth: {
        type: 'fullWidth',
        name: 'sticky-bottom-full-width',
        fullWidth: true,
        getRowCtrls: getStickyBottomRowCtrls,
    },
    bottomCenter: {
        type: 'center',
        name: 'floating-bottom',
        getRowCtrls: getBottomRowCtrls,
        getSpannedRowCtrls: getSpannedBottomRowCtrls,
    },
    bottomLeft: {
        type: 'left',
        name: 'pinned-left-floating-bottom',
        container: 'ag-pinned-left-floating-bottom',
        pinnedType: 'left',
        getRowCtrls: getBottomRowCtrls,
        getSpannedRowCtrls: getSpannedBottomRowCtrls,
    },
    bottomRight: {
        type: 'right',
        name: 'pinned-right-floating-bottom',
        container: 'ag-pinned-right-floating-bottom',
        pinnedType: 'right',
        getRowCtrls: getBottomRowCtrls,
        getSpannedRowCtrls: getSpannedBottomRowCtrls,
    },
    bottomFullWidth: {
        type: 'fullWidth',
        name: 'floating-bottom-full-width',
        fullWidth: true,
        getRowCtrls: getBottomRowCtrls,
    },
};
function _getRowViewportClass(name) {
    const options = _getRowContainerOptions(name);
    return `ag-${options.name}-viewport`;
}
exports._getRowViewportClass = _getRowViewportClass;
function _getRowContainerClass(name) {
    const options = _getRowContainerOptions(name);
    return options.container ?? `ag-${options.name}-container`;
}
exports._getRowContainerClass = _getRowContainerClass;
function _getRowSpanContainerClass(name) {
    const options = _getRowContainerOptions(name);
    return `ag-${options.name}-spanned-cells-container`;
}
exports._getRowSpanContainerClass = _getRowSpanContainerClass;
function _getRowContainerOptions(name) {
    return ContainerCssClasses[name];
}
exports._getRowContainerOptions = _getRowContainerOptions;
const allTopNoFW = ['topCenter', 'topLeft', 'topRight'];
const allBottomNoFW = ['bottomCenter', 'bottomLeft', 'bottomRight'];
const allMiddleNoFW = ['center', 'left', 'right'];
const allMiddle = ['center', 'left', 'right', 'fullWidth'];
const allCenter = ['stickyTopCenter', 'stickyBottomCenter', 'center', 'topCenter', 'bottomCenter'];
const allLeft = ['left', 'bottomLeft', 'topLeft', 'stickyTopLeft', 'stickyBottomLeft'];
const allRight = ['right', 'bottomRight', 'topRight', 'stickyTopRight', 'stickyBottomRight'];
// sticky section must show rows in set order
const allStickyTopNoFW = ['stickyTopCenter', 'stickyTopLeft', 'stickyTopRight'];
const allStickyBottomNoFW = ['stickyBottomCenter', 'stickyBottomLeft', 'stickyBottomRight'];
const allStickyContainers = [
    ...allStickyTopNoFW,
    'stickyTopFullWidth',
    ...allStickyBottomNoFW,
    'stickyBottomFullWidth',
];
const allNoFW = [
    ...allTopNoFW,
    ...allBottomNoFW,
    ...allMiddleNoFW,
    ...allStickyTopNoFW,
    ...allStickyBottomNoFW,
];
class RowContainerCtrl extends beanStub_1.BeanStub {
    constructor(name) {
        super();
        this.name = name;
        this.visible = true;
        // Maintaining a constant reference enables optimization in React.
        this.EMPTY_CTRLS = [];
        this.options = _getRowContainerOptions(name);
    }
    postConstruct() {
        this.enableRtl = this.gos.get('enableRtl');
        this.forContainers(['center'], () => {
            this.viewportSizeFeature = this.createManagedBean(new viewportSizeFeature_1.ViewportSizeFeature(this));
            this.addManagedEventListeners({
                stickyTopOffsetChanged: this.onStickyTopOffsetChanged.bind(this),
            });
        });
    }
    onStickyTopOffsetChanged(event) {
        this.comp.setOffsetTop(`${event.offset}px`);
    }
    registerWithCtrlsService() {
        // we don't register full width containers
        if (this.options.fullWidth)
            return;
        this.beans.ctrlsSvc.register(this.name, this);
    }
    forContainers(names, callback) {
        if (names.indexOf(this.name) >= 0) {
            callback();
        }
    }
    setComp(view, eContainer, eSpannedContainer, eViewport) {
        this.comp = view;
        this.eContainer = eContainer;
        this.eSpannedContainer = eSpannedContainer;
        this.eViewport = eViewport;
        this.createManagedBean(new rowContainerEventsFeature_1.RowContainerEventsFeature(this.eViewport ?? this.eContainer));
        this.addPreventScrollWhileDragging();
        this.listenOnDomOrder();
        const { pinnedCols, rangeSvc } = this.beans;
        const pinnedWidthChanged = () => this.onPinnedWidthChanged();
        this.forContainers(allLeft, () => {
            this.pinnedWidthFeature = this.createOptionalManagedBean(pinnedCols?.createPinnedWidthFeature(true, this.eContainer, this.eSpannedContainer));
            this.addManagedEventListeners({ leftPinnedWidthChanged: pinnedWidthChanged });
        });
        this.forContainers(allRight, () => {
            this.pinnedWidthFeature = this.createOptionalManagedBean(pinnedCols?.createPinnedWidthFeature(false, this.eContainer, this.eSpannedContainer));
            this.addManagedEventListeners({ rightPinnedWidthChanged: pinnedWidthChanged });
        });
        this.forContainers(allMiddle, () => this.createManagedBean(new setHeightFeature_1.SetHeightFeature(this.eContainer, this.name === 'center' ? eViewport : undefined)));
        if (rangeSvc) {
            this.forContainers(allNoFW, () => this.createManagedBean(rangeSvc.createDragListenerFeature(this.eContainer)));
        }
        this.forContainers(allCenter, () => this.createManagedBean(new centerWidthFeature_1.CenterWidthFeature((width) => this.comp.setContainerWidth(`${width}px`))));
        // Set the initial visibility of the container to avoid extra rendering
        this.visible = this.isContainerVisible();
        this.addListeners();
        this.registerWithCtrlsService();
    }
    onScrollCallback(fn) {
        this.addManagedElementListeners(this.eViewport, { scroll: fn });
    }
    addListeners() {
        const { spannedRowRenderer, gos } = this.beans;
        const onDisplayedColumnsChanged = this.onDisplayedColumnsChanged.bind(this);
        this.addManagedEventListeners({
            displayedColumnsChanged: onDisplayedColumnsChanged,
            displayedColumnsWidthChanged: onDisplayedColumnsChanged,
            displayedRowsChanged: (params) => this.onDisplayedRowsChanged(params.afterScroll),
        });
        onDisplayedColumnsChanged();
        this.onDisplayedRowsChanged();
        if (spannedRowRenderer && this.options.getSpannedRowCtrls && gos.get('enableCellSpan')) {
            this.addManagedListeners(spannedRowRenderer, {
                spannedRowsUpdated: () => {
                    const spannedCtrls = this.options.getSpannedRowCtrls(spannedRowRenderer);
                    if (!spannedCtrls) {
                        return;
                    }
                    this.comp.setSpannedRowCtrls(spannedCtrls, false);
                },
            });
        }
    }
    listenOnDomOrder() {
        const isStickContainer = allStickyContainers.indexOf(this.name) >= 0;
        if (isStickContainer) {
            this.comp.setDomOrder(true);
            return;
        }
        const listener = () => {
            const isEnsureDomOrder = this.gos.get('ensureDomOrder');
            const isPrintLayout = (0, gridOptionsUtils_1._isDomLayout)(this.gos, 'print');
            this.comp.setDomOrder(isEnsureDomOrder || isPrintLayout);
        };
        this.addManagedPropertyListener('domLayout', listener);
        listener();
    }
    onDisplayedColumnsChanged() {
        this.forContainers(['center'], () => this.onHorizontalViewportChanged());
    }
    // this methods prevents the grid views from being scrolled while the dragService is being used
    // eg. the view should not scroll up and down while dragging rows using the rowDragComp.
    addPreventScrollWhileDragging() {
        const { dragSvc } = this.beans;
        if (!dragSvc) {
            return;
        }
        const preventScroll = (e) => {
            if (dragSvc.dragging) {
                if (e.cancelable) {
                    e.preventDefault();
                }
            }
        };
        this.eContainer.addEventListener('touchmove', preventScroll, { passive: false });
        this.addDestroyFunc(() => this.eContainer.removeEventListener('touchmove', preventScroll));
    }
    // this gets called whenever a change in the viewport, so we can inform column controller it has to work
    // out the virtual columns again. gets called from following locations:
    // + ensureColVisible, scroll, init, layoutChanged, displayedColumnsChanged
    onHorizontalViewportChanged(afterScroll = false) {
        const scrollWidth = this.getCenterWidth();
        const scrollPosition = this.getCenterViewportScrollLeft();
        this.beans.colViewport.setScrollPosition(scrollWidth, scrollPosition, afterScroll);
    }
    hasHorizontalScrollGap() {
        return this.eContainer.clientWidth - this.eViewport.clientWidth < 0;
    }
    hasVerticalScrollGap() {
        return this.eContainer.clientHeight - this.eViewport.clientHeight < 0;
    }
    getCenterWidth() {
        return (0, dom_1._getInnerWidth)(this.eViewport);
    }
    getCenterViewportScrollLeft() {
        // we defer to a util, as how you calculated scrollLeft when doing RTL depends on the browser
        return (0, dom_1._getScrollLeft)(this.eViewport, this.enableRtl);
    }
    registerViewportResizeListener(listener) {
        const unsubscribeFromResize = (0, dom_1._observeResize)(this.beans, this.eViewport, listener);
        this.addDestroyFunc(() => unsubscribeFromResize());
    }
    isViewportInTheDOMTree() {
        return (0, dom_1._isInDOM)(this.eViewport);
    }
    getViewportScrollLeft() {
        return (0, dom_1._getScrollLeft)(this.eViewport, this.enableRtl);
    }
    isHorizontalScrollShowing() {
        const isAlwaysShowHorizontalScroll = this.gos.get('alwaysShowHorizontalScroll');
        return isAlwaysShowHorizontalScroll || (0, dom_1._isHorizontalScrollShowing)(this.eViewport);
    }
    setHorizontalScroll(offset) {
        this.comp.setHorizontalScroll(offset);
    }
    getHScrollPosition() {
        const res = {
            left: this.eViewport.scrollLeft,
            right: this.eViewport.scrollLeft + this.eViewport.offsetWidth,
        };
        return res;
    }
    setCenterViewportScrollLeft(value) {
        // we defer to a util, as how you calculated scrollLeft when doing RTL depends on the browser
        (0, dom_1._setScrollLeft)(this.eViewport, value, this.enableRtl);
    }
    isContainerVisible() {
        const pinned = this.options.pinnedType != null;
        return !pinned || (!!this.pinnedWidthFeature && this.pinnedWidthFeature.getWidth() > 0);
    }
    onPinnedWidthChanged() {
        const visible = this.isContainerVisible();
        if (this.visible != visible) {
            this.visible = visible;
            this.onDisplayedRowsChanged();
        }
    }
    onDisplayedRowsChanged(afterScroll = false) {
        const rows = this.options.getRowCtrls(this.beans.rowRenderer);
        if (!this.visible || rows.length === 0) {
            this.comp.setRowCtrls({ rowCtrls: this.EMPTY_CTRLS });
            return;
        }
        const printLayout = (0, gridOptionsUtils_1._isDomLayout)(this.gos, 'print');
        const embedFullWidthRows = this.gos.get('embedFullWidthRows');
        const embedFW = embedFullWidthRows || printLayout;
        // this list contains either all pinned top, center or pinned bottom rows
        // this filters out rows not for this container, eg if it's a full with row, but we are not full with container
        const rowsThisContainer = rows.filter((rowCtrl) => {
            // this just justifies if the ctrl is in the correct place, this will be fed with zombie rows by the
            // row renderer, so should not block them as they still need to animate -  the row renderer
            // will clean these up when they finish animating
            const fullWidthRow = rowCtrl.isFullWidth();
            const match = this.options.fullWidth ? !embedFW && fullWidthRow : embedFW || !fullWidthRow;
            return match;
        });
        this.comp.setRowCtrls({ rowCtrls: rowsThisContainer, useFlushSync: afterScroll });
    }
}
exports.RowContainerCtrl = RowContainerCtrl;


/***/ }),

/***/ 32625:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RowContainerEventsFeature = void 0;
const keyCode_1 = __webpack_require__(39853);
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const cellCtrl_1 = __webpack_require__(60814);
const rowCtrl_1 = __webpack_require__(7632);
const event_1 = __webpack_require__(92979);
const keyboard_1 = __webpack_require__(16466);
const selection_1 = __webpack_require__(24009);
const mouseEventUtils_1 = __webpack_require__(8399);
const A_KEYCODE = 65;
const C_KEYCODE = 67;
const V_KEYCODE = 86;
const D_KEYCODE = 68;
const Z_KEYCODE = 90;
const Y_KEYCODE = 89;
function _normaliseQwertyAzerty(keyboardEvent) {
    const { keyCode } = keyboardEvent;
    let code;
    switch (keyCode) {
        case A_KEYCODE:
            code = keyCode_1.KeyCode.A;
            break;
        case C_KEYCODE:
            code = keyCode_1.KeyCode.C;
            break;
        case V_KEYCODE:
            code = keyCode_1.KeyCode.V;
            break;
        case D_KEYCODE:
            code = keyCode_1.KeyCode.D;
            break;
        case Z_KEYCODE:
            code = keyCode_1.KeyCode.Z;
            break;
        case Y_KEYCODE:
            code = keyCode_1.KeyCode.Y;
            break;
        default:
            code = keyboardEvent.code;
    }
    return code;
}
class RowContainerEventsFeature extends beanStub_1.BeanStub {
    constructor(element) {
        super();
        this.element = element;
    }
    postConstruct() {
        this.addKeyboardListeners();
        this.addMouseListeners();
        this.beans.touchSvc?.mockRowContextMenu(this);
        this.editSvc = this.beans.editSvc;
    }
    addKeyboardListeners() {
        const eventName = 'keydown';
        const listener = this.processKeyboardEvent.bind(this, eventName);
        this.addManagedElementListeners(this.element, { [eventName]: listener });
    }
    addMouseListeners() {
        const mouseDownEvent = (0, event_1._isEventSupported)('touchstart') ? 'touchstart' : 'mousedown';
        const eventNames = ['dblclick', 'contextmenu', 'mouseover', 'mouseout', 'click', mouseDownEvent];
        eventNames.forEach((eventName) => {
            const listener = this.processMouseEvent.bind(this, eventName);
            this.addManagedElementListeners(this.element, { [eventName]: listener });
        });
    }
    processMouseEvent(eventName, mouseEvent) {
        if (!(0, mouseEventUtils_1._isEventFromThisGrid)(this.gos, mouseEvent) || (0, event_1._isStopPropagationForAgGrid)(mouseEvent)) {
            return;
        }
        const { cellCtrl, rowCtrl } = this.getControlsForEventTarget(mouseEvent.target);
        if (eventName === 'contextmenu') {
            if (cellCtrl?.column) {
                cellCtrl.dispatchCellContextMenuEvent(mouseEvent);
            }
            this.beans.contextMenuSvc?.handleContextMenuMouseEvent(mouseEvent, undefined, rowCtrl, cellCtrl);
        }
        else {
            if (cellCtrl) {
                cellCtrl.onMouseEvent(eventName, mouseEvent);
            }
            if (rowCtrl) {
                rowCtrl.onMouseEvent(eventName, mouseEvent);
            }
        }
    }
    getControlsForEventTarget(target) {
        const { gos } = this;
        return {
            cellCtrl: (0, cellCtrl_1._getCellCtrlForEventTarget)(gos, target),
            rowCtrl: (0, event_1._getCtrlForEventTarget)(gos, target, rowCtrl_1.DOM_DATA_KEY_ROW_CTRL),
        };
    }
    processKeyboardEvent(eventName, keyboardEvent) {
        const { cellCtrl, rowCtrl } = this.getControlsForEventTarget(keyboardEvent.target);
        if (keyboardEvent.defaultPrevented) {
            return;
        }
        if (cellCtrl) {
            this.processCellKeyboardEvent(cellCtrl, eventName, keyboardEvent);
        }
        else if (rowCtrl?.isFullWidth()) {
            this.processFullWidthRowKeyboardEvent(rowCtrl, eventName, keyboardEvent);
        }
    }
    processCellKeyboardEvent(cellCtrl, eventName, keyboardEvent) {
        const editing = this.editSvc?.isEditing(cellCtrl, { withOpenEditor: true }) ?? false;
        const gridProcessingAllowed = !(0, keyboard_1._isUserSuppressingKeyboardEvent)(this.gos, keyboardEvent, cellCtrl.rowNode, cellCtrl.column, editing);
        if (gridProcessingAllowed) {
            if (eventName === 'keydown') {
                // first see if it's a scroll key, page up / down, home / end etc
                const wasScrollKey = !editing && this.beans.navigation?.handlePageScrollingKey(keyboardEvent);
                // if not a scroll key, then we pass onto cell
                if (!wasScrollKey) {
                    cellCtrl.onKeyDown(keyboardEvent);
                }
                // perform clipboard and undo / redo operations
                this.doGridOperations(keyboardEvent, editing);
                if ((0, keyboard_1._isEventFromPrintableCharacter)(keyboardEvent)) {
                    cellCtrl.processCharacter(keyboardEvent);
                }
            }
        }
        if (eventName === 'keydown') {
            this.eventSvc.dispatchEvent(cellCtrl.createEvent(keyboardEvent, 'cellKeyDown'));
        }
    }
    processFullWidthRowKeyboardEvent(rowCtrl, eventName, keyboardEvent) {
        const { rowNode } = rowCtrl;
        const { focusSvc, navigation } = this.beans;
        const focusedCell = focusSvc.getFocusedCell();
        const column = focusedCell?.column;
        const gridProcessingAllowed = !(0, keyboard_1._isUserSuppressingKeyboardEvent)(this.gos, keyboardEvent, rowNode, column, false);
        if (gridProcessingAllowed) {
            const key = keyboardEvent.key;
            if (eventName === 'keydown') {
                switch (key) {
                    case keyCode_1.KeyCode.PAGE_HOME:
                    case keyCode_1.KeyCode.PAGE_END:
                    case keyCode_1.KeyCode.PAGE_UP:
                    case keyCode_1.KeyCode.PAGE_DOWN:
                        navigation?.handlePageScrollingKey(keyboardEvent, true);
                        break;
                    case keyCode_1.KeyCode.LEFT:
                    case keyCode_1.KeyCode.RIGHT:
                        if (!this.gos.get('embedFullWidthRows')) {
                            break;
                        }
                    /* eslint-ignore: no-fallthrough */
                    case keyCode_1.KeyCode.UP:
                    case keyCode_1.KeyCode.DOWN:
                        rowCtrl.onKeyboardNavigate(keyboardEvent);
                        break;
                    case keyCode_1.KeyCode.TAB:
                        rowCtrl.onTabKeyDown(keyboardEvent);
                        break;
                    default:
                }
            }
        }
        if (eventName === 'keydown') {
            this.eventSvc.dispatchEvent(rowCtrl.createRowEvent('cellKeyDown', keyboardEvent));
        }
    }
    doGridOperations(keyboardEvent, editing) {
        // check if ctrl or meta key pressed
        if (!keyboardEvent.ctrlKey && !keyboardEvent.metaKey) {
            return;
        }
        // if the cell the event came from is editing, then we do not
        // want to do the default shortcut keys, otherwise the editor
        // (eg a text field) would not be able to do the normal cut/copy/paste
        if (editing) {
            return;
        }
        // for copy / paste, we don't want to execute when the event
        // was from a child grid (happens in master detail)
        if (!(0, mouseEventUtils_1._isEventFromThisGrid)(this.gos, keyboardEvent)) {
            return;
        }
        const keyCode = _normaliseQwertyAzerty(keyboardEvent);
        const { clipboardSvc, undoRedo } = this.beans;
        if (keyCode === keyCode_1.KeyCode.A) {
            return this.onCtrlAndA(keyboardEvent);
        }
        if (keyCode === keyCode_1.KeyCode.C) {
            return this.onCtrlAndC(clipboardSvc, keyboardEvent);
        }
        if (keyCode === keyCode_1.KeyCode.D) {
            return this.onCtrlAndD(clipboardSvc, keyboardEvent);
        }
        if (keyCode === keyCode_1.KeyCode.V) {
            return this.onCtrlAndV(clipboardSvc, keyboardEvent);
        }
        if (keyCode === keyCode_1.KeyCode.X) {
            return this.onCtrlAndX(clipboardSvc, keyboardEvent);
        }
        if (keyCode === keyCode_1.KeyCode.Y) {
            return this.onCtrlAndY(undoRedo);
        }
        if (keyCode === keyCode_1.KeyCode.Z) {
            return this.onCtrlAndZ(undoRedo, keyboardEvent);
        }
    }
    onCtrlAndA(event) {
        const { beans: { rowModel, rangeSvc, selectionSvc }, gos, } = this;
        if (rangeSvc && (0, gridOptionsUtils_1._isCellSelectionEnabled)(gos) && rowModel.isRowsToRender()) {
            (0, selection_1._selectAllCells)(this.beans);
        }
        else if (selectionSvc) {
            selectionSvc?.selectAllRowNodes({ source: 'keyboardSelectAll', selectAll: (0, gridOptionsUtils_1._getSelectAll)(gos) });
        }
        event.preventDefault();
    }
    onCtrlAndC(clipboardSvc, event) {
        if (!clipboardSvc || this.gos.get('enableCellTextSelection')) {
            return;
        }
        const { cellCtrl } = this.getControlsForEventTarget(event.target);
        if (this.editSvc?.isEditing(cellCtrl, { withOpenEditor: true })) {
            return;
        }
        event.preventDefault();
        clipboardSvc.copyToClipboard();
    }
    onCtrlAndX(clipboardSvc, event) {
        if (!clipboardSvc || this.gos.get('enableCellTextSelection') || this.gos.get('suppressCutToClipboard')) {
            return;
        }
        const { cellCtrl } = this.getControlsForEventTarget(event.target);
        if (this.editSvc?.isEditing(cellCtrl, { withOpenEditor: true })) {
            return;
        }
        event.preventDefault();
        clipboardSvc.cutToClipboard(undefined, 'ui');
    }
    onCtrlAndV(clipboardSvc, event) {
        const { cellCtrl } = this.getControlsForEventTarget(event.target);
        if (this.editSvc?.isEditing(cellCtrl, { withOpenEditor: true })) {
            return;
        }
        if (clipboardSvc && !this.gos.get('suppressClipboardPaste')) {
            clipboardSvc.pasteFromClipboard();
        }
    }
    onCtrlAndD(clipboardSvc, event) {
        if (clipboardSvc && !this.gos.get('suppressClipboardPaste')) {
            clipboardSvc.copyRangeDown();
        }
        event.preventDefault();
    }
    onCtrlAndZ(undoRedo, event) {
        if (!this.gos.get('undoRedoCellEditing') || !undoRedo) {
            return;
        }
        event.preventDefault();
        if (event.shiftKey) {
            undoRedo.redo('ui');
        }
        else {
            undoRedo.undo('ui');
        }
    }
    onCtrlAndY(undoRedo) {
        undoRedo?.redo('ui');
    }
}
exports.RowContainerEventsFeature = RowContainerEventsFeature;


/***/ }),

/***/ 9622:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetHeightFeature = void 0;
const beanStub_1 = __webpack_require__(68731);
class SetHeightFeature extends beanStub_1.BeanStub {
    constructor(eContainer, eViewport) {
        super();
        this.eContainer = eContainer;
        this.eViewport = eViewport;
    }
    postConstruct() {
        this.addManagedEventListeners({
            rowContainerHeightChanged: this.onHeightChanged.bind(this, this.beans.rowContainerHeight),
        });
    }
    onHeightChanged(maxDivHeightScaler) {
        const height = maxDivHeightScaler.uiContainerHeight;
        const heightString = height != null ? `${height}px` : ``;
        this.eContainer.style.height = heightString;
        if (this.eViewport) {
            this.eViewport.style.height = heightString;
        }
    }
}
exports.SetHeightFeature = SetHeightFeature;


/***/ }),

/***/ 2865:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetPinnedWidthFeature = void 0;
const beanStub_1 = __webpack_require__(68731);
const dom_1 = __webpack_require__(33507);
class SetPinnedWidthFeature extends beanStub_1.BeanStub {
    constructor(isLeft, elements) {
        super();
        this.isLeft = isLeft;
        this.elements = elements;
        this.getWidth = isLeft ? () => this.beans.pinnedCols.leftWidth : () => this.beans.pinnedCols.rightWidth;
    }
    postConstruct() {
        this.addManagedEventListeners({
            [`${this.isLeft ? 'left' : 'right'}PinnedWidthChanged`]: this.onPinnedWidthChanged.bind(this),
        });
    }
    onPinnedWidthChanged() {
        const width = this.getWidth();
        const displayed = width > 0;
        for (const element of this.elements) {
            if (element) {
                (0, dom_1._setDisplayed)(element, displayed);
                (0, dom_1._setFixedWidth)(element, width);
            }
        }
    }
}
exports.SetPinnedWidthFeature = SetPinnedWidthFeature;


/***/ }),

/***/ 88913:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScrollVisibleService = void 0;
const beanStub_1 = __webpack_require__(68731);
const browser_1 = __webpack_require__(98667);
class ScrollVisibleService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'scrollVisibleSvc';
    }
    wireBeans(beans) {
        this.ctrlsSvc = beans.ctrlsSvc;
        this.colAnimation = beans.colAnimation;
    }
    postConstruct() {
        // sets an initial calculation for the scrollbar width
        this.getScrollbarWidth();
        this.addManagedEventListeners({
            displayedColumnsChanged: this.updateScrollVisible.bind(this),
            displayedColumnsWidthChanged: this.updateScrollVisible.bind(this),
        });
    }
    updateScrollVisible() {
        // Because of column animation, if user removes cols anywhere except at the RHS,
        // then the cols on the RHS will animate to the left to fill the gap. This animation
        // means just after the cols are removed, the remaining cols are still in the original
        // location at the start of the animation, so pre animation the H scrollbar is still
        // needed, but post animation it is not. So if animation is active, we only update
        // after the animation has ended.
        const { colAnimation } = this;
        if (colAnimation?.isActive()) {
            colAnimation.executeLaterVMTurn(() => {
                colAnimation.executeLaterVMTurn(() => this.updateScrollVisibleImpl());
            });
        }
        else {
            this.updateScrollVisibleImpl();
        }
    }
    updateScrollVisibleImpl() {
        const centerRowCtrl = this.ctrlsSvc.get('center');
        if (!centerRowCtrl || this.colAnimation?.isActive()) {
            return;
        }
        const params = {
            horizontalScrollShowing: centerRowCtrl.isHorizontalScrollShowing(),
            verticalScrollShowing: this.verticalScrollShowing,
        };
        this.setScrollsVisible(params);
        this.updateScrollGap();
    }
    updateScrollGap() {
        const centerRowCtrl = this.ctrlsSvc.get('center');
        const horizontalGap = centerRowCtrl.hasHorizontalScrollGap();
        const verticalGap = centerRowCtrl.hasVerticalScrollGap();
        const atLeastOneDifferent = this.horizontalScrollGap !== horizontalGap || this.verticalScrollGap !== verticalGap;
        if (atLeastOneDifferent) {
            this.horizontalScrollGap = horizontalGap;
            this.verticalScrollGap = verticalGap;
            this.eventSvc.dispatchEvent({
                type: 'scrollGapChanged',
            });
        }
    }
    setScrollsVisible(params) {
        const atLeastOneDifferent = this.horizontalScrollShowing !== params.horizontalScrollShowing ||
            this.verticalScrollShowing !== params.verticalScrollShowing;
        if (atLeastOneDifferent) {
            this.horizontalScrollShowing = params.horizontalScrollShowing;
            this.verticalScrollShowing = params.verticalScrollShowing;
            this.eventSvc.dispatchEvent({
                type: 'scrollVisibilityChanged',
            });
        }
    }
    // the user might be using some non-standard scrollbar, eg a scrollbar that has zero
    // width and overlays (like the Safari scrollbar, but presented in Chrome). so we
    // allow the user to provide the scroll width before we work it out.
    getScrollbarWidth() {
        if (this.scrollbarWidth == null) {
            const gridOptionsScrollbarWidth = this.gos.get('scrollbarWidth');
            const useGridOptions = typeof gridOptionsScrollbarWidth === 'number' && gridOptionsScrollbarWidth >= 0;
            const scrollbarWidth = useGridOptions ? gridOptionsScrollbarWidth : (0, browser_1._getScrollbarWidth)();
            if (scrollbarWidth != null) {
                this.scrollbarWidth = scrollbarWidth;
                this.eventSvc.dispatchEvent({
                    type: 'scrollbarWidthChanged',
                });
            }
        }
        return this.scrollbarWidth;
    }
}
exports.ScrollVisibleService = ScrollVisibleService;


/***/ }),

/***/ 25858:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ViewportSizeFeature = void 0;
const beanStub_1 = __webpack_require__(68731);
const dom_1 = __webpack_require__(33507);
// listens to changes in the center viewport size, for column and row virtualisation,
// and adjusts grid as necessary. there are two viewports, one for horizontal and one for
// vertical scrolling.
class ViewportSizeFeature extends beanStub_1.BeanStub {
    wireBeans(beans) {
        this.scrollVisibleSvc = beans.scrollVisibleSvc;
    }
    constructor(centerContainerCtrl) {
        super();
        this.centerContainerCtrl = centerContainerCtrl;
    }
    postConstruct() {
        this.beans.ctrlsSvc.whenReady(this, (p) => {
            this.gridBodyCtrl = p.gridBodyCtrl;
            this.listenForResize();
        });
        this.addManagedEventListeners({ scrollbarWidthChanged: this.onScrollbarWidthChanged.bind(this) });
        this.addManagedPropertyListeners(['alwaysShowHorizontalScroll', 'alwaysShowVerticalScroll'], () => {
            this.checkViewportAndScrolls();
        });
    }
    listenForResize() {
        const { beans, centerContainerCtrl, gridBodyCtrl } = this;
        const listener = () => {
            // onCenterViewportResize causes resize events to be fired (flex-columns).
            // when any resize event happens, style and layout are re-evaluated  which in turn may
            // trigger more resize events. Infinite loops from cyclic dependencies are addressed by
            // only processing elements deeper in the DOM during each iteration.
            // so the solution here is to use the animation frame service to avoid infinite loops.
            // For more info, see: https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver#observation_errors
            (0, dom_1._requestAnimationFrame)(beans, () => {
                this.onCenterViewportResized();
            });
        };
        // centerContainer gets horizontal resizes
        centerContainerCtrl.registerViewportResizeListener(listener);
        // eBodyViewport gets vertical resizes
        gridBodyCtrl.registerBodyViewportResizeListener(listener);
    }
    onScrollbarWidthChanged() {
        this.checkViewportAndScrolls();
    }
    onCenterViewportResized() {
        this.scrollVisibleSvc.updateScrollGap();
        if (this.centerContainerCtrl.isViewportInTheDOMTree()) {
            const { pinnedCols, colFlex } = this.beans;
            pinnedCols?.keepPinnedColumnsNarrowerThanViewport();
            this.checkViewportAndScrolls();
            const newWidth = this.centerContainerCtrl.getCenterWidth();
            if (newWidth !== this.centerWidth) {
                this.centerWidth = newWidth;
                colFlex?.refreshFlexedColumns({
                    viewportWidth: this.centerWidth,
                    updateBodyWidths: true,
                    fireResizedEvent: true,
                });
            }
        }
        else {
            this.bodyHeight = 0;
        }
    }
    // gets called every time the viewport size changes. we use this to check visibility of scrollbars
    // in the grid panel, and also to check size and position of viewport for row and column virtualisation.
    checkViewportAndScrolls() {
        // results in updating anything that depends on scroll showing
        this.updateScrollVisibleService();
        // fires event if height changes, used by PaginationService, HeightScalerService, RowRenderer
        this.checkBodyHeight();
        // check for virtual columns for ColumnController
        this.onHorizontalViewportChanged();
        this.gridBodyCtrl.scrollFeature.checkScrollLeft();
    }
    getBodyHeight() {
        return this.bodyHeight;
    }
    checkBodyHeight() {
        const eBodyViewport = this.gridBodyCtrl.eBodyViewport;
        const bodyHeight = (0, dom_1._getInnerHeight)(eBodyViewport);
        if (this.bodyHeight !== bodyHeight) {
            this.bodyHeight = bodyHeight;
            this.eventSvc.dispatchEvent({
                type: 'bodyHeightChanged',
            });
        }
    }
    updateScrollVisibleService() {
        // because of column animation (which takes 200ms), we have to do this twice.
        // eg if user removes cols anywhere except at the RHS, then the cols on the RHS
        // will animate to the left to fill the gap. this animation means just after
        // the cols are removed, the remaining cols are still in the original location
        // at the start of the animation, so pre animation the H scrollbar is still needed,
        // but post animation it is not.
        this.updateScrollVisibleServiceImpl();
        setTimeout(this.updateScrollVisibleServiceImpl.bind(this), 500);
    }
    updateScrollVisibleServiceImpl() {
        const params = {
            horizontalScrollShowing: this.centerContainerCtrl.isHorizontalScrollShowing(),
            verticalScrollShowing: this.gridBodyCtrl.isVerticalScrollShowing(),
        };
        this.scrollVisibleSvc.setScrollsVisible(params);
    }
    // this gets called whenever a change in the viewport, so we can inform column controller it has to work
    // out the virtual columns again. gets called from following locations:
    // + ensureColVisible, scroll, init, layoutChanged, displayedColumnsChanged
    onHorizontalViewportChanged() {
        const scrollWidth = this.centerContainerCtrl.getCenterWidth();
        const scrollPosition = this.centerContainerCtrl.getViewportScrollLeft();
        this.beans.colViewport.setScrollPosition(scrollWidth, scrollPosition);
    }
}
exports.ViewportSizeFeature = ViewportSizeFeature;


/***/ }),

/***/ 1678:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GridComp = void 0;
const gridBodyComp_1 = __webpack_require__(2006);
const layoutFeature_1 = __webpack_require__(59360);
const dom_1 = __webpack_require__(33507);
const function_1 = __webpack_require__(92043);
const component_1 = __webpack_require__(78020);
const tabGuardComp_1 = __webpack_require__(68332);
const gridCtrl_1 = __webpack_require__(37600);
class GridComp extends tabGuardComp_1.TabGuardComp {
    constructor(eGridDiv) {
        super();
        this.gridBody = component_1.RefPlaceholder;
        this.sideBar = component_1.RefPlaceholder;
        this.pagination = component_1.RefPlaceholder;
        this.rootWrapperBody = component_1.RefPlaceholder;
        this.eGridDiv = eGridDiv;
    }
    postConstruct() {
        const compProxy = {
            destroyGridUi: () => this.destroyBean(this),
            setRtlClass: (cssClass) => this.addCss(cssClass),
            forceFocusOutOfContainer: this.forceFocusOutOfContainer.bind(this),
            updateLayoutClasses: this.updateLayoutClasses.bind(this),
            getFocusableContainers: this.getFocusableContainers.bind(this),
            setUserSelect: (value) => {
                this.getGui().style.userSelect = value != null ? value : '';
                this.getGui().style.webkitUserSelect = value != null ? value : '';
            },
            setCursor: (value) => {
                this.getGui().style.cursor = value != null ? value : '';
            },
        };
        const ctrl = this.createManagedBean(new gridCtrl_1.GridCtrl());
        const comps = ctrl.getOptionalSelectors();
        const template = this.createTemplate(comps);
        const requiredComps = [gridBodyComp_1.GridBodySelector, ...Object.values(comps).filter((c) => !!c)];
        this.setTemplate(template, requiredComps);
        ctrl.setComp(compProxy, this.eGridDiv, this.getGui());
        this.insertGridIntoDom();
        this.initialiseTabGuard({
            // we want to override the default behaviour to do nothing for onTabKeyDown
            onTabKeyDown: () => undefined,
            focusInnerElement: (fromBottom) => ctrl.focusInnerElement(fromBottom),
            forceFocusOutWhenTabGuardsAreEmpty: true,
            isEmpty: () => !ctrl.isFocusable(),
        });
    }
    insertGridIntoDom() {
        const eGui = this.getGui();
        this.eGridDiv.appendChild(eGui);
        this.addDestroyFunc(() => {
            this.eGridDiv.removeChild(eGui);
            (0, function_1._logIfDebug)(this.gos, 'Grid removed from DOM');
        });
    }
    updateLayoutClasses(cssClass, params) {
        const eRootWrapperBodyClassList = this.rootWrapperBody.classList;
        const { AUTO_HEIGHT, NORMAL, PRINT } = layoutFeature_1.LayoutCssClasses;
        const { autoHeight, normal, print } = params;
        eRootWrapperBodyClassList.toggle(AUTO_HEIGHT, autoHeight);
        eRootWrapperBodyClassList.toggle(NORMAL, normal);
        eRootWrapperBodyClassList.toggle(PRINT, print);
        this.toggleCss(AUTO_HEIGHT, autoHeight);
        this.toggleCss(NORMAL, normal);
        this.toggleCss(PRINT, print);
    }
    createTemplate(params) {
        const dropZones = params.gridHeaderDropZonesSelector
            ? { tag: 'ag-grid-header-drop-zones' }
            : null;
        const sideBar = params.sideBarSelector
            ? {
                tag: 'ag-side-bar',
                ref: 'sideBar',
            }
            : null;
        const statusBar = params.statusBarSelector ? { tag: 'ag-status-bar' } : null;
        const watermark = params.watermarkSelector ? { tag: 'ag-watermark' } : null;
        const pagination = params.paginationSelector
            ? { tag: 'ag-pagination', ref: 'pagination' }
            : null;
        return {
            tag: 'div',
            cls: 'ag-root-wrapper',
            role: 'presentation',
            children: [
                dropZones,
                {
                    tag: 'div',
                    ref: 'rootWrapperBody',
                    cls: 'ag-root-wrapper-body',
                    role: 'presentation',
                    children: [{ tag: 'ag-grid-body', ref: 'gridBody' }, sideBar],
                },
                statusBar,
                pagination,
                watermark,
            ],
        };
    }
    getFocusableElement() {
        return this.rootWrapperBody;
    }
    forceFocusOutOfContainer(up = false) {
        if (!up && this.pagination?.isDisplayed()) {
            this.pagination.forceFocusOutOfContainer(up);
            return;
        }
        super.forceFocusOutOfContainer(up);
    }
    getFocusableContainers() {
        const focusableContainers = [this.gridBody];
        [this.sideBar, this.pagination].forEach((comp) => {
            if (comp) {
                focusableContainers.push(comp);
            }
        });
        return focusableContainers.filter((el) => (0, dom_1._isVisible)(el.getGui()));
    }
}
exports.GridComp = GridComp;


/***/ }),

/***/ 37600:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GridCtrl = void 0;
const beanStub_1 = __webpack_require__(68731);
const mouseEventUtils_1 = __webpack_require__(8399);
const gridOptionsUtils_1 = __webpack_require__(67274);
const layoutFeature_1 = __webpack_require__(59360);
const array_1 = __webpack_require__(31502);
const dom_1 = __webpack_require__(33507);
const focus_1 = __webpack_require__(82331);
class GridCtrl extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.additionalFocusableContainers = new Set();
    }
    setComp(view, eGridDiv, eGui) {
        this.view = view;
        this.eGridHostDiv = eGridDiv;
        this.eGui = eGui;
        this.eGui.setAttribute('grid-id', this.beans.context.getGridId());
        const { dragAndDrop, ctrlsSvc } = this.beans;
        dragAndDrop?.registerGridDropTarget(() => this.eGui, this);
        (0, mouseEventUtils_1._stampTopLevelGridCompWithGridInstance)(this.gos, eGridDiv);
        this.createManagedBean(new layoutFeature_1.LayoutFeature(this.view));
        this.view.setRtlClass(this.gos.get('enableRtl') ? 'ag-rtl' : 'ag-ltr');
        const unsubscribeFromResize = (0, dom_1._observeResize)(this.beans, this.eGridHostDiv, this.onGridSizeChanged.bind(this));
        this.addDestroyFunc(() => unsubscribeFromResize());
        ctrlsSvc.register('gridCtrl', this);
    }
    isDetailGrid() {
        const el = (0, focus_1._findTabbableParent)(this.getGui());
        return el?.getAttribute('row-id')?.startsWith('detail') || false;
    }
    getOptionalSelectors() {
        const beans = this.beans;
        return {
            paginationSelector: beans.pagination?.getPaginationSelector(),
            gridHeaderDropZonesSelector: beans.registry.getSelector('AG-GRID-HEADER-DROP-ZONES'),
            sideBarSelector: beans.sideBar?.getSelector(),
            statusBarSelector: beans.registry?.getSelector('AG-STATUS-BAR'),
            watermarkSelector: beans.licenseManager?.getWatermarkSelector(),
        };
    }
    onGridSizeChanged() {
        this.eventSvc.dispatchEvent({
            type: 'gridSizeChanged',
            clientWidth: this.eGridHostDiv.clientWidth,
            clientHeight: this.eGridHostDiv.clientHeight,
        });
    }
    destroyGridUi() {
        this.view.destroyGridUi();
    }
    getGui() {
        return this.eGui;
    }
    setResizeCursor(on) {
        this.view.setCursor(on ? 'ew-resize' : null);
    }
    disableUserSelect(on) {
        this.view.setUserSelect(on ? 'none' : null);
    }
    focusNextInnerContainer(backwards) {
        const focusableContainers = this.getFocusableContainers();
        const { indexWithFocus, nextIndex } = this.getNextFocusableIndex(focusableContainers, backwards);
        if (nextIndex < 0 || nextIndex >= focusableContainers.length) {
            return false;
        }
        if (nextIndex === 0) {
            if (indexWithFocus > 0) {
                const { visibleCols, focusSvc } = this.beans;
                const allColumns = visibleCols.allCols;
                const lastColumn = (0, array_1._last)(allColumns);
                if (focusSvc.focusGridView({ column: lastColumn, backwards: true })) {
                    return true;
                }
            }
            return false;
        }
        return this.focusContainer(focusableContainers[nextIndex], backwards);
    }
    focusInnerElement(fromBottom) {
        const userCallbackFunction = this.gos.getCallback('focusGridInnerElement');
        if (userCallbackFunction && userCallbackFunction({ fromBottom: !!fromBottom })) {
            return true;
        }
        const focusableContainers = this.getFocusableContainers();
        const { focusSvc, visibleCols } = this.beans;
        const allColumns = visibleCols.allCols;
        if (fromBottom) {
            if (focusableContainers.length > 1) {
                return this.focusContainer((0, array_1._last)(focusableContainers), fromBottom);
            }
            const lastColumn = (0, array_1._last)(allColumns);
            if (focusSvc.focusGridView({ column: lastColumn, backwards: fromBottom })) {
                return true;
            }
        }
        if (this.gos.get('headerHeight') === 0 || (0, focus_1._isHeaderFocusSuppressed)(this.beans)) {
            if (focusSvc.focusGridView({ column: allColumns[0], backwards: fromBottom })) {
                return true;
            }
            for (let i = 1; i < focusableContainers.length; i++) {
                if ((0, focus_1._focusInto)(focusableContainers[i].getGui(), fromBottom)) {
                    return true;
                }
            }
            return false;
        }
        return focusSvc.focusFirstHeader();
    }
    forceFocusOutOfContainer(up = false) {
        this.view.forceFocusOutOfContainer(up);
    }
    addFocusableContainer(container) {
        this.additionalFocusableContainers.add(container);
    }
    removeFocusableContainer(container) {
        this.additionalFocusableContainers.delete(container);
    }
    allowFocusForNextCoreContainer(up) {
        const coreContainers = this.view.getFocusableContainers();
        const { nextIndex, indexWithFocus } = this.getNextFocusableIndex(coreContainers, up);
        if (indexWithFocus === -1 || nextIndex < 0 || nextIndex >= coreContainers.length) {
            return;
        }
        const comp = coreContainers[nextIndex];
        comp.setAllowFocus?.(true);
        // we're letting the browser handle the focus here, so need to wait for focus to move into the container before disabling focus again.
        // can't do this via event, as the container may not have anything focusable. In which case, the focus will just go out of the grid.
        setTimeout(() => {
            comp.setAllowFocus?.(false);
        });
    }
    isFocusable() {
        const beans = this.beans;
        return (!(0, focus_1._isCellFocusSuppressed)(beans) || !(0, focus_1._isHeaderFocusSuppressed)(beans) || !!beans.sideBar?.comp?.isDisplayed());
    }
    getNextFocusableIndex(focusableContainers, backwards) {
        const activeEl = (0, gridOptionsUtils_1._getActiveDomElement)(this.beans);
        const indexWithFocus = focusableContainers.findIndex((container) => container.getGui().contains(activeEl));
        const nextIndex = indexWithFocus + (backwards ? -1 : 1);
        return {
            indexWithFocus,
            nextIndex,
        };
    }
    focusContainer(comp, up) {
        comp.setAllowFocus?.(true);
        const result = (0, focus_1._focusInto)(comp.getGui(), up, false, true);
        comp.setAllowFocus?.(false);
        return result;
    }
    getFocusableContainers() {
        return [...this.view.getFocusableContainers(), ...this.additionalFocusableContainers];
    }
    destroy() {
        this.additionalFocusableContainers.clear();
        super.destroy();
    }
}
exports.GridCtrl = GridCtrl;


/***/ }),

/***/ 91978:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommunityCoreModule = void 0;
const apiFunctionService_1 = __webpack_require__(33907);
const coreApi_1 = __webpack_require__(69875);
const columnMoveModule_1 = __webpack_require__(64074);
const columnResizeModule_1 = __webpack_require__(96924);
const columnGroupModule_1 = __webpack_require__(66041);
const columnModel_1 = __webpack_require__(72986);
const columnModule_1 = __webpack_require__(52027);
const columnNameService_1 = __webpack_require__(48997);
const columnViewportService_1 = __webpack_require__(5034);
const visibleColsService_1 = __webpack_require__(6869);
const cellRendererFunctionModule_1 = __webpack_require__(28414);
const registry_1 = __webpack_require__(34110);
const userComponentFactory_1 = __webpack_require__(31585);
const ctrlsService_1 = __webpack_require__(80020);
const environment_1 = __webpack_require__(89024);
const eventService_1 = __webpack_require__(8778);
const focusService_1 = __webpack_require__(45626);
const scrollVisibleService_1 = __webpack_require__(88913);
const gridDestroyService_1 = __webpack_require__(63888);
const gridOptionsService_1 = __webpack_require__(38484);
const headerModule_1 = __webpack_require__(88078);
const animationFrameModule_1 = __webpack_require__(14011);
const touchModule_1 = __webpack_require__(23705);
const navigationModule_1 = __webpack_require__(928);
const pageBoundsListener_1 = __webpack_require__(82550);
const pageBoundsService_1 = __webpack_require__(93003);
const pinnedColumnModule_1 = __webpack_require__(46219);
const ariaModule_1 = __webpack_require__(73433);
const cellRendererModule_1 = __webpack_require__(37358);
const overlayModule_1 = __webpack_require__(75366);
const rowContainerHeightService_1 = __webpack_require__(17109);
const rowRenderer_1 = __webpack_require__(90557);
const sortModule_1 = __webpack_require__(96620);
const syncService_1 = __webpack_require__(7711);
const valueModule_1 = __webpack_require__(76431);
const valueService_1 = __webpack_require__(35736);
const version_1 = __webpack_require__(97205);
/**
 * @internal
 */
exports.CommunityCoreModule = {
    moduleName: 'CommunityCore',
    version: version_1.VERSION,
    beans: [
        gridDestroyService_1.GridDestroyService,
        apiFunctionService_1.ApiFunctionService,
        registry_1.Registry,
        userComponentFactory_1.UserComponentFactory,
        rowContainerHeightService_1.RowContainerHeightService,
        visibleColsService_1.VisibleColsService,
        eventService_1.EventService,
        gridOptionsService_1.GridOptionsService,
        columnModel_1.ColumnModel,
        pageBoundsService_1.PageBoundsService,
        pageBoundsListener_1.PageBoundsListener,
        rowRenderer_1.RowRenderer,
        valueService_1.ValueService,
        focusService_1.FocusService,
        environment_1.Environment,
        scrollVisibleService_1.ScrollVisibleService,
        ctrlsService_1.CtrlsService,
        syncService_1.SyncService,
        columnNameService_1.ColumnNameService,
        columnViewportService_1.ColumnViewportService,
    ],
    icons: {
        // icon on select dropdowns (select cell editor, charts tool panels)
        selectOpen: 'small-down',
        /** @deprecated v33 */
        smallDown: 'small-down',
        /** @deprecated v33 */
        colorPicker: 'color-picker',
        /** @deprecated v33 */
        smallUp: 'small-up',
        /** @deprecated v33 */
        checkboxChecked: 'small-up',
        /** @deprecated v33 */
        checkboxIndeterminate: 'checkbox-indeterminate',
        /** @deprecated v33 */
        checkboxUnchecked: 'checkbox-unchecked',
        /** @deprecated v33 */
        radioButtonOn: 'radio-button-on',
        /** @deprecated v33 */
        radioButtonOff: 'radio-button-off',
        /** @deprecated v33 */
        smallLeft: 'small-left',
        /** @deprecated v33 */
        smallRight: 'small-right',
    },
    apiFunctions: {
        getGridId: coreApi_1.getGridId,
        destroy: coreApi_1.destroy,
        isDestroyed: coreApi_1.isDestroyed,
        getGridOption: coreApi_1.getGridOption,
        setGridOption: coreApi_1.setGridOption,
        updateGridOptions: coreApi_1.updateGridOptions,
        isModuleRegistered: coreApi_1.isModuleRegistered,
    },
    dependsOn: [
        columnModule_1.DataTypeModule,
        columnMoveModule_1.ColumnMoveModule,
        columnResizeModule_1.ColumnResizeModule,
        sortModule_1.SortModule,
        headerModule_1.ColumnHeaderCompModule,
        columnGroupModule_1.ColumnGroupModule,
        headerModule_1.ColumnGroupHeaderCompModule,
        overlayModule_1.OverlayModule,
        valueModule_1.ChangeDetectionModule,
        animationFrameModule_1.AnimationFrameModule,
        navigationModule_1.KeyboardNavigationModule,
        pinnedColumnModule_1.PinnedColumnModule,
        ariaModule_1.AriaModule,
        touchModule_1.TouchModule,
        cellRendererFunctionModule_1.CellRendererFunctionModule,
        columnModule_1.ColumnFlexModule,
        valueModule_1.ExpressionModule,
        cellRendererModule_1.SkeletonCellRendererModule,
    ],
};


/***/ }),

/***/ 63888:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GridDestroyService = void 0;
const beanStub_1 = __webpack_require__(68731);
class GridDestroyService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'gridDestroySvc';
        this.destroyCalled = false;
    }
    destroy() {
        // prevent infinite loop
        if (this.destroyCalled) {
            return;
        }
        const { stateSvc, ctrlsSvc, context } = this.beans;
        this.eventSvc.dispatchEvent({
            type: 'gridPreDestroyed',
            state: stateSvc?.getState() ?? {},
        });
        // Set after pre-destroy so user can still use the api in pre-destroy event and it is not marked as destroyed yet.
        this.destroyCalled = true;
        // destroy the UI first (as they use the services)
        ctrlsSvc.get('gridCtrl')?.destroyGridUi();
        // destroy the services
        context.destroy();
        super.destroy();
    }
}
exports.GridDestroyService = GridDestroyService;


/***/ }),

/***/ 5266:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GRID_OPTION_DEFAULTS = void 0;
// Leave untyped. so it can be inferred. Might be possible to type in the future with NoInfer<T>
// Ideally we would not set all the false default values as this can save bundle size. However,
// if we remove the false defaults then this will change the result of the api.getGridOption() method
// when the user has not provided a value making this a breaking change.
exports.GRID_OPTION_DEFAULTS = {
    suppressContextMenu: false,
    preventDefaultOnContextMenu: false,
    allowContextMenuWithControlKey: false,
    suppressMenuHide: true,
    enableBrowserTooltips: false,
    tooltipTrigger: 'hover',
    tooltipShowDelay: 2000,
    tooltipHideDelay: 10000,
    tooltipMouseTrack: false,
    tooltipShowMode: 'standard',
    tooltipInteraction: false,
    copyHeadersToClipboard: false,
    copyGroupHeadersToClipboard: false,
    clipboardDelimiter: '\t',
    suppressCopyRowsToClipboard: false,
    suppressCopySingleCellRanges: false,
    suppressLastEmptyLineOnPaste: false,
    suppressClipboardPaste: false,
    suppressClipboardApi: false,
    suppressCutToClipboard: false,
    maintainColumnOrder: false,
    enableStrictPivotColumnOrder: false,
    suppressFieldDotNotation: false,
    allowDragFromColumnsToolPanel: false,
    suppressMovableColumns: false,
    suppressColumnMoveAnimation: false,
    suppressMoveWhenColumnDragging: false,
    suppressDragLeaveHidesColumns: false,
    suppressRowGroupHidesColumns: false,
    suppressAutoSize: false,
    autoSizePadding: 20,
    skipHeaderOnAutoSize: false,
    singleClickEdit: false,
    suppressClickEdit: false,
    readOnlyEdit: false,
    stopEditingWhenCellsLoseFocus: false,
    enterNavigatesVertically: false,
    enterNavigatesVerticallyAfterEdit: false,
    enableCellEditingOnBackspace: false,
    undoRedoCellEditing: false,
    undoRedoCellEditingLimit: 10,
    suppressCsvExport: false,
    suppressExcelExport: false,
    cacheQuickFilter: false,
    includeHiddenColumnsInQuickFilter: false,
    excludeChildrenWhenTreeDataFiltering: false,
    enableAdvancedFilter: false,
    includeHiddenColumnsInAdvancedFilter: false,
    enableCharts: false,
    masterDetail: false,
    keepDetailRows: false,
    keepDetailRowsCount: 10,
    detailRowAutoHeight: false,
    tabIndex: 0,
    rowBuffer: 10,
    valueCache: false,
    valueCacheNeverExpires: false,
    enableCellExpressions: false,
    suppressTouch: false,
    suppressFocusAfterRefresh: false,
    suppressBrowserResizeObserver: false,
    suppressPropertyNamesCheck: false,
    suppressChangeDetection: false,
    debug: false,
    suppressLoadingOverlay: false,
    suppressNoRowsOverlay: false,
    pagination: false,
    paginationPageSize: 100,
    paginationPageSizeSelector: true,
    paginationAutoPageSize: false,
    paginateChildRows: false,
    suppressPaginationPanel: false,
    pivotMode: false,
    pivotPanelShow: 'never',
    pivotDefaultExpanded: 0,
    pivotSuppressAutoColumn: false,
    suppressExpandablePivotGroups: false,
    functionsReadOnly: false,
    suppressAggFuncInHeader: false,
    alwaysAggregateAtRootLevel: false,
    aggregateOnlyChangedColumns: false,
    suppressAggFilteredOnly: false,
    removePivotHeaderRowWhenSingleValueColumn: false,
    animateRows: true,
    cellFlashDuration: 500,
    cellFadeDuration: 1000,
    allowShowChangeAfterFilter: false,
    domLayout: 'normal',
    ensureDomOrder: false,
    enableRtl: false,
    suppressColumnVirtualisation: false,
    suppressMaxRenderedRowRestriction: false,
    suppressRowVirtualisation: false,
    rowDragManaged: false,
    rowDragInsertDelay: 500,
    suppressRowDrag: false,
    suppressMoveWhenRowDragging: false,
    rowDragEntireRow: false,
    rowDragMultiRow: false,
    embedFullWidthRows: false,
    groupDisplayType: 'singleColumn',
    groupDefaultExpanded: 0,
    groupMaintainOrder: false,
    groupSelectsChildren: false,
    groupSuppressBlankHeader: false,
    groupSelectsFiltered: false,
    showOpenedGroup: false,
    groupRemoveSingleChildren: false,
    groupRemoveLowestSingleChildren: false,
    groupHideOpenParents: false,
    groupAllowUnbalanced: false,
    rowGroupPanelShow: 'never',
    suppressMakeColumnVisibleAfterUnGroup: false,
    treeData: false,
    rowGroupPanelSuppressSort: false,
    suppressGroupRowsSticky: false,
    rowModelType: 'clientSide',
    asyncTransactionWaitMillis: 50,
    suppressModelUpdateAfterUpdateTransaction: false,
    cacheOverflowSize: 1,
    infiniteInitialRowCount: 1,
    serverSideInitialRowCount: 1,
    cacheBlockSize: 100,
    maxBlocksInCache: -1,
    maxConcurrentDatasourceRequests: 2,
    blockLoadDebounceMillis: 0,
    purgeClosedRowNodes: false,
    serverSideSortAllLevels: false,
    serverSideOnlyRefreshFilteredGroups: false,
    serverSidePivotResultFieldSeparator: '_',
    viewportRowModelPageSize: 5,
    viewportRowModelBufferSize: 5,
    alwaysShowHorizontalScroll: false,
    alwaysShowVerticalScroll: false,
    debounceVerticalScrollbar: false,
    suppressHorizontalScroll: false,
    suppressScrollOnNewData: false,
    suppressScrollWhenPopupsAreOpen: false,
    suppressAnimationFrame: false,
    suppressMiddleClickScrolls: false,
    suppressPreventDefaultOnMouseWheel: false,
    rowMultiSelectWithClick: false,
    suppressRowDeselection: false,
    suppressRowClickSelection: false,
    suppressCellFocus: false,
    suppressHeaderFocus: false,
    suppressMultiRangeSelection: false,
    enableCellTextSelection: false,
    enableRangeSelection: false,
    enableRangeHandle: false,
    enableFillHandle: false,
    fillHandleDirection: 'xy',
    suppressClearOnFillReduction: false,
    accentedSort: false,
    unSortIcon: false,
    suppressMultiSort: false,
    alwaysMultiSort: false,
    suppressMaintainUnsortedOrder: false,
    suppressRowHoverHighlight: false,
    suppressRowTransform: false,
    columnHoverHighlight: false,
    deltaSort: false,
    enableGroupEdit: false,
    groupLockGroupColumns: 0,
    serverSideEnableClientSideSort: false,
    suppressServerSideFullWidthLoadingRow: false,
    pivotMaxGeneratedColumns: -1,
    columnMenu: 'new',
    reactiveCustomComponents: true,
    suppressSetFilterByDefault: false,
    rowNumbers: false,
    enableFilterHandlers: false,
};
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const allValidKeys = true;
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const allValidValues = 'V';


/***/ }),

/***/ 2891:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.INITIAL_GRID_OPTION_KEYS = void 0;
exports.INITIAL_GRID_OPTION_KEYS = {
    enableBrowserTooltips: true,
    tooltipTrigger: true,
    tooltipMouseTrack: true,
    tooltipShowMode: true,
    tooltipInteraction: true,
    defaultColGroupDef: true,
    suppressAutoSize: true,
    skipHeaderOnAutoSize: true,
    autoSizeStrategy: true,
    components: true,
    stopEditingWhenCellsLoseFocus: true,
    undoRedoCellEditing: true,
    undoRedoCellEditingLimit: true,
    excelStyles: true,
    cacheQuickFilter: true,
    customChartThemes: true,
    chartThemeOverrides: true,
    chartToolPanelsDef: true,
    loadingCellRendererSelector: true,
    localeText: true,
    keepDetailRows: true,
    keepDetailRowsCount: true,
    detailRowHeight: true,
    detailRowAutoHeight: true,
    tabIndex: true,
    valueCache: true,
    valueCacheNeverExpires: true,
    enableCellExpressions: true,
    suppressTouch: true,
    suppressBrowserResizeObserver: true,
    suppressPropertyNamesCheck: true,
    debug: true,
    dragAndDropImageComponent: true,
    loadingOverlayComponent: true,
    suppressLoadingOverlay: true,
    noRowsOverlayComponent: true,
    paginationPageSizeSelector: true,
    paginateChildRows: true,
    pivotPanelShow: true,
    pivotSuppressAutoColumn: true,
    suppressExpandablePivotGroups: true,
    aggFuncs: true,
    allowShowChangeAfterFilter: true,
    ensureDomOrder: true,
    enableRtl: true,
    suppressColumnVirtualisation: true,
    suppressMaxRenderedRowRestriction: true,
    suppressRowVirtualisation: true,
    rowDragText: true,
    groupLockGroupColumns: true,
    suppressGroupRowsSticky: true,
    rowModelType: true,
    cacheOverflowSize: true,
    infiniteInitialRowCount: true,
    serverSideInitialRowCount: true,
    maxBlocksInCache: true,
    maxConcurrentDatasourceRequests: true,
    blockLoadDebounceMillis: true,
    serverSideOnlyRefreshFilteredGroups: true,
    serverSidePivotResultFieldSeparator: true,
    viewportRowModelPageSize: true,
    viewportRowModelBufferSize: true,
    debounceVerticalScrollbar: true,
    suppressAnimationFrame: true,
    suppressPreventDefaultOnMouseWheel: true,
    scrollbarWidth: true,
    icons: true,
    suppressRowTransform: true,
    gridId: true,
    enableGroupEdit: true,
    initialState: true,
    processUnpinnedColumns: true,
    createChartContainer: true,
    getLocaleText: true,
    getRowId: true,
    reactiveCustomComponents: true,
    renderingMode: true,
    columnMenu: true,
    suppressSetFilterByDefault: true,
    getDataPath: true,
    enableCellSpan: true,
    enableFilterHandlers: true,
    filterHandlers: true,
};
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const allValidKeys = true;


/***/ }),

/***/ 38484:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GridOptionsService = void 0;
const beanStub_1 = __webpack_require__(68731);
const events_1 = __webpack_require__(57968);
const gridOptionsDefault_1 = __webpack_require__(5266);
const localEventService_1 = __webpack_require__(85889);
const moduleRegistry_1 = __webpack_require__(2132);
const publicEventHandlersMap_1 = __webpack_require__(8829);
const function_1 = __webpack_require__(92043);
const generic_1 = __webpack_require__(34422);
const logging_1 = __webpack_require__(47764);
const colDefValidations_1 = __webpack_require__(34842);
const gridOptionsValidations_1 = __webpack_require__(50711);
let changeSetId = 0;
// this is added to the main DOM element
let gridInstanceSequence = 0;
class GridOptionsService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'gos';
        this.domDataKey = '__AG_' + Math.random().toString();
        /** This is only used for the main DOM element */
        this.gridInstanceId = gridInstanceSequence++;
        // Used to hold user events until the grid is ready
        // Required to support React 19 StrictMode. See IFrameworkOverrides.runWhenReadyAsync but also is likely a good idea that onGridReady is the first event fired.
        this.gridReadyFired = false;
        this.queueEvents = [];
        this.propEventSvc = new localEventService_1.LocalEventService();
        // responsible for calling the onXXX functions on gridOptions
        // It forces events defined in GridOptionsService.alwaysSyncGlobalEvents to be fired synchronously.
        // This is required for events such as GridPreDestroyed.
        // Other events can be fired asynchronously or synchronously depending on config.
        this.globalEventHandlerFactory = (restrictToSyncOnly) => {
            return (eventName, event) => {
                // prevent events from being fired _after_ the grid has been destroyed
                if (!this.isAlive()) {
                    return;
                }
                const alwaysSync = events_1.ALWAYS_SYNC_GLOBAL_EVENTS.has(eventName);
                if ((alwaysSync && !restrictToSyncOnly) || (!alwaysSync && restrictToSyncOnly)) {
                    return;
                }
                if (!isPublicEventHandler(eventName)) {
                    return;
                }
                const fireEvent = (name, e) => {
                    const eventHandlerName = publicEventHandlersMap_1._PUBLIC_EVENT_HANDLERS_MAP[name];
                    const eventHandler = this.gridOptions[eventHandlerName];
                    if (typeof eventHandler === 'function') {
                        this.beans.frameworkOverrides.wrapOutgoing(() => eventHandler(e));
                    }
                };
                if (this.gridReadyFired) {
                    fireEvent(eventName, event);
                }
                else {
                    if (eventName === 'gridReady') {
                        fireEvent(eventName, event);
                        this.gridReadyFired = true;
                        for (const q of this.queueEvents) {
                            fireEvent(q.eventName, q.event);
                        }
                        this.queueEvents = [];
                    }
                    else {
                        this.queueEvents.push({ eventName, event });
                    }
                }
            };
        };
    }
    wireBeans(beans) {
        this.gridOptions = beans.gridOptions;
        this.validation = beans.validation;
        this.api = beans.gridApi;
        this.gridId = beans.context.getGridId();
    }
    // This is quicker then having code call gridOptionsService.get('context')
    get gridOptionsContext() {
        return this.gridOptions['context'];
    }
    postConstruct() {
        this.validateGridOptions(this.gridOptions);
        this.eventSvc.addGlobalListener(this.globalEventHandlerFactory().bind(this), true);
        this.eventSvc.addGlobalListener(this.globalEventHandlerFactory(true).bind(this), false);
        // Ensure the propertyEventService has framework overrides set so that it can fire events outside of angular
        this.propEventSvc.setFrameworkOverrides(this.beans.frameworkOverrides);
        this.addManagedEventListeners({
            gridOptionsChanged: ({ options }) => {
                this.updateGridOptions({ options, force: true, source: 'gridOptionsUpdated' });
            },
        });
    }
    destroy() {
        super.destroy();
        this.queueEvents = [];
    }
    /**
     * Get the raw value of the GridOptions property provided.
     * @param property
     */
    get(property) {
        return (this.gridOptions[property] ??
            gridOptionsDefault_1.GRID_OPTION_DEFAULTS[property]);
    }
    /**
     * Get the GridOption callback but wrapped so that the common params of api and context are automatically applied to the params.
     * @param property GridOption callback properties based on the fact that this property has a callback with params extending AgGridCommon
     */
    getCallback(property) {
        return this.mergeGridCommonParams(this.gridOptions[property]);
    }
    /**
     * Returns `true` if a value has been specified for this GridOption.
     * @param property GridOption property
     */
    exists(property) {
        return (0, generic_1._exists)(this.gridOptions[property]);
    }
    /**
     * Wrap the user callback and attach the api and context to the params object on the way through.
     * @param callback User provided callback
     * @returns Wrapped callback where the params object not require api and context
     */
    mergeGridCommonParams(callback) {
        if (callback) {
            const wrapped = (callbackParams) => {
                return callback(this.addGridCommonParams(callbackParams));
            };
            return wrapped;
        }
        return callback;
    }
    updateGridOptions({ options, force, source = 'api', }) {
        const changeSet = { id: changeSetId++, properties: [] };
        // all events are fired after grid options has finished updating.
        const events = [];
        const { gridOptions, validation } = this;
        for (const key of Object.keys(options)) {
            const value = options[key];
            validation?.warnOnInitialPropertyUpdate(source, key);
            const shouldForce = force || (typeof value === 'object' && source === 'api'); // force objects as they could have been mutated.
            const previousValue = gridOptions[key];
            if (shouldForce || previousValue !== value) {
                gridOptions[key] = value;
                const event = {
                    type: key,
                    currentValue: value,
                    previousValue,
                    changeSet,
                    source,
                };
                events.push(event);
            }
        }
        this.validateGridOptions(this.gridOptions);
        // changeSet should just include the properties that have changed.
        changeSet.properties = events.map((event) => event.type);
        events.forEach((event) => {
            (0, function_1._logIfDebug)(this, `Updated property ${event.type} from`, event.previousValue, ` to `, event.currentValue);
            this.propEventSvc.dispatchEvent(event);
        });
    }
    addPropertyEventListener(key, listener) {
        this.propEventSvc.addEventListener(key, listener);
    }
    removePropertyEventListener(key, listener) {
        this.propEventSvc.removeEventListener(key, listener);
    }
    getDomDataKey() {
        return this.domDataKey;
    }
    /** Prefer _addGridCommonParams from gridOptionsUtils for bundle size savings */
    addGridCommonParams(params) {
        params.api = this.api;
        params.context = this.gridOptionsContext;
        return params;
    }
    validateOptions(options, modValidations) {
        for (const key of Object.keys(options)) {
            const value = options[key];
            if (value == null || value === false) {
                // false implies feature is disabled, don't validate.
                continue;
            }
            let moduleToCheck = modValidations[key];
            if (typeof moduleToCheck === 'function') {
                moduleToCheck = moduleToCheck(options, this.gridOptions, this.beans);
            }
            if (moduleToCheck) {
                this.assertModuleRegistered(moduleToCheck, key);
            }
        }
    }
    validateGridOptions(gridOptions) {
        this.validateOptions(gridOptions, gridOptionsValidations_1.GRID_OPTIONS_MODULES);
        this.validation?.processGridOptions(gridOptions);
    }
    validateColDef(colDef, colId, skipInferenceCheck) {
        if (skipInferenceCheck || !this.beans.dataTypeSvc?.isColPendingInference(colId)) {
            this.validateOptions(colDef, colDefValidations_1.COLUMN_DEFINITION_MOD_VALIDATIONS);
            this.validation?.validateColDef(colDef);
        }
    }
    assertModuleRegistered(moduleName, reasonOrId) {
        const registered = Array.isArray(moduleName)
            ? moduleName.some((modName) => this.isModuleRegistered(modName))
            : this.isModuleRegistered(moduleName);
        if (!registered) {
            (0, logging_1._error)(200, {
                ...this.getModuleErrorParams(),
                moduleName,
                reasonOrId,
            });
        }
        return registered;
    }
    getModuleErrorParams() {
        return {
            gridId: this.gridId,
            gridScoped: (0, moduleRegistry_1._areModulesGridScoped)(),
            rowModelType: this.get('rowModelType'),
            isUmd: (0, moduleRegistry_1._isUmd)(),
        };
    }
    isModuleRegistered(moduleName) {
        return (0, moduleRegistry_1._isModuleRegistered)(moduleName, this.gridId, this.get('rowModelType'));
    }
}
exports.GridOptionsService = GridOptionsService;
function isPublicEventHandler(eventName) {
    return !!publicEventHandlersMap_1._PUBLIC_EVENT_HANDLERS_MAP[eventName];
}


/***/ }),

/***/ 67274:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._isSetFilterByDefault = exports._getMasterSelects = exports._getGroupSelectsDescendants = exports._getSelectAll = exports._getGroupSelection = exports._getEnableSelectionWithoutKeys = exports._isMultiRowSelection = exports._getRowSelectionMode = exports._getIsRowSelectable = exports._getEnableDeselection = exports._getEnableSelection = exports._getFillHandle = exports._isCellSelectionEnabled = exports._getSuppressMultiRanges = exports._isUsingNewCellSelectionAPI = exports._isUsingNewRowSelectionAPI = exports._getHideDisabledCheckboxes = exports._getCheckboxLocation = exports._getHeaderCheckbox = exports._getCheckboxes = exports._shouldUpdateColVisibilityAfterGroup = exports._getMaxConcurrentDatasourceRequests = exports._canSkipShowingRowGroup = exports._getRowIdCallback = exports._isFullWidthGroupRow = exports._isGroupUseEntireRow = exports._isGroupMultiAutoColumn = exports._getGroupTotalRowCallback = exports._getGrandTotalRow = exports._getGroupAggFiltering = exports._isColumnsSortingCoupledToGroup = exports._isGroupRowsSticky = exports._isAnimateRows = exports._isNothingFocused = exports._anchorElementToMouseMoveEvent = exports._getPageBody = exports._getActiveDomElement = exports._getRootNode = exports._getWindow = exports._getDocument = exports._setDomData = exports._getDomData = exports._getRowHeightAsNumber = exports._getRowHeightForNode = exports._shouldMaintainColumnOrder = exports._isGetRowHeightFunction = exports._isRowSelection = exports._isDomLayout = exports._isServerSideRowModel = exports._isClientSideRowModel = void 0;
exports._getGridOption = exports._getGroupingApproach = exports._addGridCommonParams = exports._processOnChange = exports._combineAttributesAndGridOptions = exports._getCallbackForEvent = exports._areAdditionalColumnMenuItemsEnabled = exports._isColumnMenuAnchoringEnabled = exports._isLegacyMenuEnabled = void 0;
const globalGridOptions_1 = __webpack_require__(75518);
const gridOptionsDefault_1 = __webpack_require__(5266);
const dom_1 = __webpack_require__(33507);
const function_1 = __webpack_require__(92043);
const generic_1 = __webpack_require__(34422);
const logging_1 = __webpack_require__(47764);
function isRowModelType(gos, rowModelType) {
    return gos.get('rowModelType') === rowModelType;
}
function _isClientSideRowModel(gos, rowModel) {
    return isRowModelType(gos, 'clientSide');
}
exports._isClientSideRowModel = _isClientSideRowModel;
function _isServerSideRowModel(gos, rowModel) {
    return isRowModelType(gos, 'serverSide');
}
exports._isServerSideRowModel = _isServerSideRowModel;
function _isDomLayout(gos, domLayout) {
    return gos.get('domLayout') === domLayout;
}
exports._isDomLayout = _isDomLayout;
function _isRowSelection(gos) {
    return _getRowSelectionMode(gos) !== undefined;
}
exports._isRowSelection = _isRowSelection;
function _isGetRowHeightFunction(gos) {
    return typeof gos.get('getRowHeight') === 'function';
}
exports._isGetRowHeightFunction = _isGetRowHeightFunction;
function _shouldMaintainColumnOrder(gos, isPivotColumns) {
    if (isPivotColumns) {
        return !gos.get('enableStrictPivotColumnOrder');
    }
    return gos.get('maintainColumnOrder');
}
exports._shouldMaintainColumnOrder = _shouldMaintainColumnOrder;
function _getRowHeightForNode(beans, rowNode, allowEstimate = false, defaultRowHeight) {
    const { gos, environment } = beans;
    if (defaultRowHeight == null) {
        defaultRowHeight = environment.getDefaultRowHeight();
    }
    // check the function first, in case use set both function and
    // number, when using virtual pagination then function can be
    // used for pinned rows and the number for the body rows.
    if (_isGetRowHeightFunction(gos)) {
        if (allowEstimate) {
            return { height: defaultRowHeight, estimated: true };
        }
        const params = {
            node: rowNode,
            data: rowNode.data,
        };
        const height = gos.getCallback('getRowHeight')(params);
        if (isNumeric(height)) {
            if (height === 0) {
                (0, logging_1._warn)(23);
            }
            return { height: Math.max(1, height), estimated: false };
        }
    }
    if (rowNode.detail && gos.get('masterDetail')) {
        return getMasterDetailRowHeight(gos);
    }
    const gridOptionsRowHeight = gos.get('rowHeight');
    const rowHeight = gridOptionsRowHeight && isNumeric(gridOptionsRowHeight) ? gridOptionsRowHeight : defaultRowHeight;
    return { height: rowHeight, estimated: false };
}
exports._getRowHeightForNode = _getRowHeightForNode;
function getMasterDetailRowHeight(gos) {
    // if autoHeight, we want the height to grow to the new height starting at 1, as otherwise a flicker would happen,
    // as the detail goes to the default (eg 200px) and then immediately shrink up/down to the new measured height
    // (due to auto height) which looks bad, especially if doing row animation.
    if (gos.get('detailRowAutoHeight')) {
        return { height: 1, estimated: false };
    }
    const defaultRowHeight = gos.get('detailRowHeight');
    if (isNumeric(defaultRowHeight)) {
        return { height: defaultRowHeight, estimated: false };
    }
    return { height: 300, estimated: false };
}
// we don't allow dynamic row height for virtual paging
function _getRowHeightAsNumber(beans) {
    const { environment, gos } = beans;
    const gridOptionsRowHeight = gos.get('rowHeight');
    if (!gridOptionsRowHeight || (0, generic_1._missing)(gridOptionsRowHeight)) {
        return environment.getDefaultRowHeight();
    }
    const rowHeight = environment.refreshRowHeightVariable();
    if (rowHeight !== -1) {
        return rowHeight;
    }
    (0, logging_1._warn)(24);
    return environment.getDefaultRowHeight();
}
exports._getRowHeightAsNumber = _getRowHeightAsNumber;
function isNumeric(value) {
    return !isNaN(value) && typeof value === 'number' && isFinite(value);
}
// returns the dom data, or undefined if not found
function _getDomData(gos, element, key) {
    const domData = element[gos.getDomDataKey()];
    return domData ? domData[key] : undefined;
}
exports._getDomData = _getDomData;
function _setDomData(gos, element, key, value) {
    const domDataKey = gos.getDomDataKey();
    let domData = element[domDataKey];
    if ((0, generic_1._missing)(domData)) {
        domData = {};
        element[domDataKey] = domData;
    }
    domData[key] = value;
}
exports._setDomData = _setDomData;
function _getDocument(beans) {
    // if user is providing document, we use the users one,
    // otherwise we use the document on the global namespace.
    const { gos, eGridDiv } = beans;
    let result = null;
    const gridOptionsGetDocument = gos.get('getDocument');
    if (gridOptionsGetDocument && (0, generic_1._exists)(gridOptionsGetDocument)) {
        result = gridOptionsGetDocument();
    }
    else if (eGridDiv) {
        result = eGridDiv.ownerDocument;
    }
    if (result && (0, generic_1._exists)(result)) {
        return result;
    }
    return document;
}
exports._getDocument = _getDocument;
function _getWindow(beans) {
    const eDocument = _getDocument(beans);
    return eDocument.defaultView || window;
}
exports._getWindow = _getWindow;
function _getRootNode(beans) {
    return beans.eGridDiv.getRootNode();
}
exports._getRootNode = _getRootNode;
function _getActiveDomElement(beans) {
    return _getRootNode(beans).activeElement;
}
exports._getActiveDomElement = _getActiveDomElement;
function _getPageBody(beans) {
    let rootNode = null;
    let targetEl = null;
    try {
        rootNode = _getDocument(beans).fullscreenElement;
    }
    catch (e) {
        // some environments like SalesForce will throw errors
        // simply by trying to read the fullscreenElement property
    }
    finally {
        if (!rootNode) {
            rootNode = _getRootNode(beans);
        }
        const body = rootNode.querySelector('body');
        if (body) {
            targetEl = body;
        }
        else if (rootNode instanceof ShadowRoot) {
            targetEl = rootNode;
        }
        else if (rootNode instanceof Document) {
            targetEl = rootNode?.documentElement;
        }
        else {
            targetEl = rootNode;
        }
    }
    return targetEl;
}
exports._getPageBody = _getPageBody;
function _getBodyWidth(beans) {
    const body = _getPageBody(beans);
    return body?.clientWidth ?? (window.innerHeight || -1);
}
function _getBodyHeight(beans) {
    const body = _getPageBody(beans);
    return body?.clientHeight ?? (window.innerHeight || -1);
}
function _anchorElementToMouseMoveEvent(element, mouseMoveEvent, beans) {
    const eRect = element.getBoundingClientRect();
    const height = eRect.height;
    const browserWidth = _getBodyWidth(beans) - 2; // 2px for 1px borderLeft and 1px borderRight
    const browserHeight = _getBodyHeight(beans) - 2; // 2px for 1px borderTop and 1px borderBottom
    const offsetParent = element.offsetParent;
    if (!offsetParent) {
        return;
    }
    const offsetParentSize = (0, dom_1._getElementRectWithOffset)(element.offsetParent);
    const { clientY, clientX } = mouseMoveEvent;
    let top = clientY - offsetParentSize.top - height / 2;
    let left = clientX - offsetParentSize.left - 10;
    const eDocument = _getDocument(beans);
    const win = eDocument.defaultView || window;
    const windowScrollY = win.pageYOffset || eDocument.documentElement.scrollTop;
    const windowScrollX = win.pageXOffset || eDocument.documentElement.scrollLeft;
    // check if the drag and drop image component is not positioned outside of the browser
    if (browserWidth > 0 && left + element.clientWidth > browserWidth + windowScrollX) {
        left = browserWidth + windowScrollX - element.clientWidth;
    }
    if (left < 0) {
        left = 0;
    }
    if (browserHeight > 0 && top + element.clientHeight > browserHeight + windowScrollY) {
        top = browserHeight + windowScrollY - element.clientHeight;
    }
    if (top < 0) {
        top = 0;
    }
    element.style.left = `${left}px`;
    element.style.top = `${top}px`;
}
exports._anchorElementToMouseMoveEvent = _anchorElementToMouseMoveEvent;
function _isNothingFocused(beans) {
    const activeEl = _getActiveDomElement(beans);
    return activeEl === null || activeEl === _getDocument(beans).body;
}
exports._isNothingFocused = _isNothingFocused;
function _isAnimateRows(gos) {
    // never allow animating if enforcing the row order
    if (gos.get('ensureDomOrder')) {
        return false;
    }
    return gos.get('animateRows');
}
exports._isAnimateRows = _isAnimateRows;
function _isGroupRowsSticky(gos) {
    if (gos.get('paginateChildRows') || gos.get('groupHideOpenParents') || _isDomLayout(gos, 'print')) {
        return false;
    }
    return true;
}
exports._isGroupRowsSticky = _isGroupRowsSticky;
function _isColumnsSortingCoupledToGroup(gos) {
    const autoGroupColumnDef = gos.get('autoGroupColumnDef');
    return !autoGroupColumnDef?.comparator && !gos.get('treeData');
}
exports._isColumnsSortingCoupledToGroup = _isColumnsSortingCoupledToGroup;
function _getGroupAggFiltering(gos) {
    const userValue = gos.get('groupAggFiltering');
    if (typeof userValue === 'function') {
        return gos.getCallback('groupAggFiltering');
    }
    if (userValue === true) {
        return () => true;
    }
    return undefined;
}
exports._getGroupAggFiltering = _getGroupAggFiltering;
function _getGrandTotalRow(gos) {
    return gos.get('grandTotalRow');
}
exports._getGrandTotalRow = _getGrandTotalRow;
function _getGroupTotalRowCallback(gos) {
    const userValue = gos.get('groupTotalRow');
    if (typeof userValue === 'function') {
        return gos.getCallback('groupTotalRow');
    }
    return () => userValue ?? undefined;
}
exports._getGroupTotalRowCallback = _getGroupTotalRowCallback;
function _isGroupMultiAutoColumn(gos) {
    const isHideOpenParents = !!gos.get('groupHideOpenParents');
    if (isHideOpenParents) {
        return true;
    }
    return gos.get('groupDisplayType') === 'multipleColumns';
}
exports._isGroupMultiAutoColumn = _isGroupMultiAutoColumn;
function _isGroupUseEntireRow(gos, pivotMode) {
    // we never allow groupDisplayType = 'groupRows' if in pivot mode, otherwise we won't see the pivot values.
    if (pivotMode) {
        return false;
    }
    return gos.get('groupDisplayType') === 'groupRows';
}
exports._isGroupUseEntireRow = _isGroupUseEntireRow;
function _isFullWidthGroupRow(gos, node, pivotMode) {
    return !!node.group && !node.footer && _isGroupUseEntireRow(gos, pivotMode);
}
exports._isFullWidthGroupRow = _isFullWidthGroupRow;
// AG-9259 Can't use `WrappedCallback<'getRowId', ...>` here because of a strange typescript bug
function _getRowIdCallback(gos) {
    const getRowId = gos.getCallback('getRowId');
    if (getRowId === undefined) {
        return getRowId;
    }
    return (params) => {
        let id = getRowId(params);
        if (typeof id !== 'string') {
            // Avoid logging for every row if the user is returning a non-string value, could be thousands of rows
            (0, function_1._doOnce)(() => (0, logging_1._warn)(25, { id }), 'getRowIdString');
            id = String(id);
        }
        return id;
    };
}
exports._getRowIdCallback = _getRowIdCallback;
function _canSkipShowingRowGroup(gos, node) {
    const isSkippingGroups = gos.get('groupHideParentOfSingleChild');
    if (isSkippingGroups === true) {
        return true;
    }
    if (isSkippingGroups === 'leafGroupsOnly' && node.leafGroup) {
        return true;
    }
    // deprecated
    if (gos.get('groupRemoveSingleChildren')) {
        return true;
    }
    if (gos.get('groupRemoveLowestSingleChildren') && node.leafGroup) {
        return true;
    }
    return false;
}
exports._canSkipShowingRowGroup = _canSkipShowingRowGroup;
function _getMaxConcurrentDatasourceRequests(gos) {
    const res = gos.get('maxConcurrentDatasourceRequests');
    // negative number, eg -1, means no max restriction
    return res > 0 ? res : undefined;
}
exports._getMaxConcurrentDatasourceRequests = _getMaxConcurrentDatasourceRequests;
/** Get the selection checkbox configuration. Defaults to enabled. */
function _shouldUpdateColVisibilityAfterGroup(gos, isGrouped) {
    const preventVisibilityChanges = gos.get('suppressGroupChangesColumnVisibility');
    if (preventVisibilityChanges === true) {
        return false;
    }
    if (isGrouped && preventVisibilityChanges === 'suppressHideOnGroup') {
        return false;
    }
    if (!isGrouped && preventVisibilityChanges === 'suppressShowOnUngroup') {
        return false;
    }
    const legacySuppressOnGroup = gos.get('suppressRowGroupHidesColumns');
    if (isGrouped && legacySuppressOnGroup === true) {
        return false;
    }
    const legacySuppressOnUngroup = gos.get('suppressMakeColumnVisibleAfterUnGroup');
    if (!isGrouped && legacySuppressOnUngroup === true) {
        return false;
    }
    return true;
}
exports._shouldUpdateColVisibilityAfterGroup = _shouldUpdateColVisibilityAfterGroup;
/** Get the selection checkbox configuration. Defaults to enabled. */
function _getCheckboxes(selection) {
    return selection?.checkboxes ?? true;
}
exports._getCheckboxes = _getCheckboxes;
/** Get the header checkbox configuration. Defaults to enabled in `multiRow`, otherwise disabled. */
function _getHeaderCheckbox(selection) {
    return selection?.mode === 'multiRow' && (selection.headerCheckbox ?? true);
}
exports._getHeaderCheckbox = _getHeaderCheckbox;
function _getCheckboxLocation(rowSelection) {
    if (typeof rowSelection !== 'object') {
        return undefined;
    }
    return rowSelection.checkboxLocation ?? 'selectionColumn';
}
exports._getCheckboxLocation = _getCheckboxLocation;
/** Get the display configuration for disabled checkboxes. Defaults to displaying disabled checkboxes. */
function _getHideDisabledCheckboxes(selection) {
    return selection?.hideDisabledCheckboxes ?? false;
}
exports._getHideDisabledCheckboxes = _getHideDisabledCheckboxes;
function _isUsingNewRowSelectionAPI(gos) {
    const rowSelection = gos.get('rowSelection');
    return typeof rowSelection !== 'string';
}
exports._isUsingNewRowSelectionAPI = _isUsingNewRowSelectionAPI;
function _isUsingNewCellSelectionAPI(gos) {
    return gos.get('cellSelection') !== undefined;
}
exports._isUsingNewCellSelectionAPI = _isUsingNewCellSelectionAPI;
function _getSuppressMultiRanges(gos) {
    const selection = gos.get('cellSelection');
    const useNewAPI = selection !== undefined;
    if (!useNewAPI) {
        return gos.get('suppressMultiRangeSelection');
    }
    return typeof selection !== 'boolean' ? selection?.suppressMultiRanges ?? false : false;
}
exports._getSuppressMultiRanges = _getSuppressMultiRanges;
function _isCellSelectionEnabled(gos) {
    const selection = gos.get('cellSelection');
    const useNewAPI = selection !== undefined;
    return useNewAPI ? !!selection : gos.get('enableRangeSelection');
}
exports._isCellSelectionEnabled = _isCellSelectionEnabled;
function _getFillHandle(gos) {
    const selection = gos.get('cellSelection');
    const useNewAPI = selection !== undefined;
    if (!useNewAPI) {
        return {
            mode: 'fill',
            setFillValue: gos.get('fillOperation'),
            direction: gos.get('fillHandleDirection'),
            suppressClearOnFillReduction: gos.get('suppressClearOnFillReduction'),
        };
    }
    return typeof selection !== 'boolean' && selection.handle?.mode === 'fill' ? selection.handle : undefined;
}
exports._getFillHandle = _getFillHandle;
function _getEnableClickSelection(gos) {
    const selection = gos.get('rowSelection') ?? 'single';
    if (typeof selection === 'string') {
        const suppressRowClickSelection = gos.get('suppressRowClickSelection');
        const suppressRowDeselection = gos.get('suppressRowDeselection');
        if (suppressRowClickSelection && suppressRowDeselection) {
            return false;
        }
        else if (suppressRowClickSelection) {
            return 'enableDeselection';
        }
        else if (suppressRowDeselection) {
            return 'enableSelection';
        }
        else {
            return true;
        }
    }
    return selection.mode === 'singleRow' || selection.mode === 'multiRow'
        ? selection.enableClickSelection ?? false
        : false;
}
function _getEnableSelection(gos) {
    const enableClickSelection = _getEnableClickSelection(gos);
    return enableClickSelection === true || enableClickSelection === 'enableSelection';
}
exports._getEnableSelection = _getEnableSelection;
function _getEnableDeselection(gos) {
    const enableClickSelection = _getEnableClickSelection(gos);
    return enableClickSelection === true || enableClickSelection === 'enableDeselection';
}
exports._getEnableDeselection = _getEnableDeselection;
function _getIsRowSelectable(gos) {
    const selection = gos.get('rowSelection');
    if (typeof selection === 'string') {
        return gos.get('isRowSelectable');
    }
    return selection?.isRowSelectable;
}
exports._getIsRowSelectable = _getIsRowSelectable;
function _getRowSelectionMode(arg) {
    const selection = 'beanName' in arg && arg.beanName === 'gos'
        ? arg.get('rowSelection')
        : arg.rowSelection;
    if (typeof selection === 'string') {
        switch (selection) {
            case 'multiple':
                return 'multiRow';
            case 'single':
                return 'singleRow';
            default:
                return;
        }
    }
    // only permit expected values for selection mode
    switch (selection?.mode) {
        case 'multiRow':
        case 'singleRow':
            return selection.mode;
        default:
            return;
    }
}
exports._getRowSelectionMode = _getRowSelectionMode;
function _isMultiRowSelection(arg) {
    const mode = _getRowSelectionMode(arg);
    return mode === 'multiRow';
}
exports._isMultiRowSelection = _isMultiRowSelection;
function _getEnableSelectionWithoutKeys(gos) {
    const selection = gos.get('rowSelection');
    if (typeof selection === 'string') {
        return gos.get('rowMultiSelectWithClick');
    }
    return selection?.enableSelectionWithoutKeys ?? false;
}
exports._getEnableSelectionWithoutKeys = _getEnableSelectionWithoutKeys;
function _getGroupSelection(gos) {
    const selection = gos.get('rowSelection');
    if (typeof selection === 'string') {
        const groupSelectsChildren = gos.get('groupSelectsChildren');
        const groupSelectsFiltered = gos.get('groupSelectsFiltered');
        if (groupSelectsChildren && groupSelectsFiltered) {
            return 'filteredDescendants';
        }
        else if (groupSelectsChildren) {
            return 'descendants';
        }
        else {
            return 'self';
        }
    }
    return selection?.mode === 'multiRow' ? selection.groupSelects : undefined;
}
exports._getGroupSelection = _getGroupSelection;
function _getSelectAll(gos, defaultValue = true) {
    const rowSelection = gos.get('rowSelection');
    if (typeof rowSelection !== 'object') {
        return defaultValue ? 'all' : undefined;
    }
    return rowSelection.mode === 'multiRow' ? rowSelection.selectAll : 'all';
}
exports._getSelectAll = _getSelectAll;
function _getGroupSelectsDescendants(gos) {
    const groupSelection = _getGroupSelection(gos);
    return groupSelection === 'descendants' || groupSelection === 'filteredDescendants';
}
exports._getGroupSelectsDescendants = _getGroupSelectsDescendants;
function _getMasterSelects(gos) {
    const rowSelection = gos.get('rowSelection');
    return (typeof rowSelection === 'object' && rowSelection.masterSelects) || 'self';
}
exports._getMasterSelects = _getMasterSelects;
function _isSetFilterByDefault(gos) {
    return gos.isModuleRegistered('SetFilter') && !gos.get('suppressSetFilterByDefault');
}
exports._isSetFilterByDefault = _isSetFilterByDefault;
function _isLegacyMenuEnabled(gos) {
    return gos.get('columnMenu') === 'legacy';
}
exports._isLegacyMenuEnabled = _isLegacyMenuEnabled;
function _isColumnMenuAnchoringEnabled(gos) {
    return !_isLegacyMenuEnabled(gos);
}
exports._isColumnMenuAnchoringEnabled = _isColumnMenuAnchoringEnabled;
function _areAdditionalColumnMenuItemsEnabled(gos) {
    return gos.get('columnMenu') === 'new';
}
exports._areAdditionalColumnMenuItemsEnabled = _areAdditionalColumnMenuItemsEnabled;
function _getCallbackForEvent(eventName) {
    if (!eventName || eventName.length < 2) {
        return eventName;
    }
    return 'on' + eventName[0].toUpperCase() + eventName.substring(1);
}
exports._getCallbackForEvent = _getCallbackForEvent;
/** Combines component props / attributes with the provided gridOptions returning a new combined gridOptions object */
function _combineAttributesAndGridOptions(gridOptions, component, gridOptionsKeys) {
    // create empty grid options if none were passed
    if (typeof gridOptions !== 'object') {
        gridOptions = {};
    }
    // shallow copy (so we don't change the provided object)
    const mergedOptions = { ...gridOptions };
    // Loop through component props, if they are not undefined and a valid gridOption copy to gridOptions
    gridOptionsKeys.forEach((key) => {
        const value = component[key];
        if (typeof value !== 'undefined') {
            mergedOptions[key] = value;
        }
    });
    return mergedOptions;
}
exports._combineAttributesAndGridOptions = _combineAttributesAndGridOptions;
function _processOnChange(changes, api) {
    if (!changes) {
        return;
    }
    const gridChanges = {};
    let hasChanges = false;
    Object.keys(changes).forEach((key) => {
        gridChanges[key] = changes[key];
        hasChanges = true;
    });
    if (!hasChanges) {
        return;
    }
    const internalUpdateEvent = {
        type: 'gridOptionsChanged',
        options: gridChanges,
    };
    api.dispatchEvent(internalUpdateEvent);
    // copy gridChanges into an event for dispatch
    const event = {
        type: 'componentStateChanged',
        ...gridChanges,
    };
    api.dispatchEvent(event);
}
exports._processOnChange = _processOnChange;
function _addGridCommonParams(gos, params) {
    return gos.addGridCommonParams(params);
}
exports._addGridCommonParams = _addGridCommonParams;
function _getGroupingApproach(gos) {
    if (gos.get('treeData')) {
        if (gos.get('treeDataParentIdField')) {
            return 'treeSelfRef';
        }
        if (gos.get('treeDataChildrenField')) {
            return 'treeNested';
        }
        return 'treePath';
    }
    return 'group';
}
exports._getGroupingApproach = _getGroupingApproach;
/** Used for before GridOptionsService is initialised */
function _getGridOption(providedGridOptions, gridOption) {
    return (providedGridOptions[gridOption] ??
        providedGridOptions[`gridOptions`]?.[gridOption] ??
        (0, globalGridOptions_1._getGlobalGridOption)(gridOption) ??
        gridOptionsDefault_1.GRID_OPTION_DEFAULTS[gridOption]);
}
exports._getGridOption = _getGridOption;


/***/ }),

/***/ 59860:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractHeaderCellComp = void 0;
const component_1 = __webpack_require__(78020);
class AbstractHeaderCellComp extends component_1.Component {
    constructor(template, ctrl) {
        super(template);
        this.ctrl = ctrl;
    }
    getCtrl() {
        return this.ctrl;
    }
}
exports.AbstractHeaderCellComp = AbstractHeaderCellComp;


/***/ }),

/***/ 83534:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractHeaderCellCtrl = exports.DOM_DATA_KEY_HEADER_CTRL = void 0;
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const aria_1 = __webpack_require__(95230);
const dom_1 = __webpack_require__(33507);
const focus_1 = __webpack_require__(82331);
const function_1 = __webpack_require__(92043);
const generic_1 = __webpack_require__(34422);
const keyCode_1 = __webpack_require__(39853);
const cssClassApplier_1 = __webpack_require__(91295);
let instanceIdSequence = 0;
exports.DOM_DATA_KEY_HEADER_CTRL = 'headerCtrl';
class AbstractHeaderCellCtrl extends beanStub_1.BeanStub {
    constructor(column, rowCtrl) {
        super();
        this.column = column;
        this.rowCtrl = rowCtrl;
        this.resizeToggleTimeout = 0;
        this.resizeMultiplier = 1;
        this.resizeFeature = null;
        this.lastFocusEvent = null;
        this.dragSource = null;
        // unique id to this instance, including the column ID to help with debugging in React as it's used in 'key'
        this.instanceId = (column.getUniqueId() + '-' + instanceIdSequence++);
    }
    postConstruct() {
        const refreshTabIndex = this.refreshTabIndex.bind(this);
        this.addManagedPropertyListeners(['suppressHeaderFocus'], refreshTabIndex);
        this.addManagedEventListeners({
            overlayExclusiveChanged: refreshTabIndex,
        });
    }
    shouldStopEventPropagation(event) {
        const { headerRowIndex, column } = this.beans.focusSvc.focusedHeader;
        const colDef = column.getDefinition();
        const colDefFunc = colDef && colDef.suppressHeaderKeyboardEvent;
        if (!(0, generic_1._exists)(colDefFunc)) {
            return false;
        }
        const params = (0, gridOptionsUtils_1._addGridCommonParams)(this.gos, {
            colDef: colDef,
            column,
            headerRowIndex,
            event,
        });
        return !!colDefFunc(params);
    }
    getWrapperHasFocus() {
        const activeEl = (0, gridOptionsUtils_1._getActiveDomElement)(this.beans);
        return activeEl === this.eGui;
    }
    setGui(eGui, compBean) {
        this.eGui = eGui;
        this.addDomData(compBean);
        compBean.addManagedListeners(this.beans.eventSvc, {
            displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
        });
        compBean.addManagedElementListeners(this.eGui, {
            focus: this.onGuiFocus.bind(this),
        });
        this.onDisplayedColumnsChanged();
        this.refreshTabIndex();
    }
    refreshHeaderStyles() {
        const colDef = this.column.getDefinition();
        if (!colDef) {
            return;
        }
        const { headerStyle } = colDef;
        let styles;
        if (typeof headerStyle === 'function') {
            const cellStyleParams = this.getHeaderClassParams();
            styles = headerStyle(cellStyleParams);
        }
        else {
            styles = headerStyle;
        }
        if (styles) {
            this.comp.setUserStyles(styles);
        }
    }
    onGuiFocus() {
        this.eventSvc.dispatchEvent({
            type: 'headerFocused',
            column: this.column,
        });
    }
    setupAutoHeight(params) {
        const { wrapperElement, checkMeasuringCallback, compBean } = params;
        const { beans } = this;
        const measureHeight = (timesCalled) => {
            if (!this.isAlive() || !compBean.isAlive()) {
                return;
            }
            const { paddingTop, paddingBottom, borderBottomWidth, borderTopWidth } = (0, dom_1._getElementSize)(this.eGui);
            const extraHeight = paddingTop + paddingBottom + borderBottomWidth + borderTopWidth;
            const wrapperHeight = wrapperElement.offsetHeight;
            const autoHeight = wrapperHeight + extraHeight;
            if (timesCalled < 5) {
                // if not in doc yet, means framework not yet inserted, so wait for next VM turn,
                // maybe it will be ready next VM turn
                const doc = (0, gridOptionsUtils_1._getDocument)(beans);
                const notYetInDom = !doc || !doc.contains(wrapperElement);
                // this happens in React, where React hasn't put any content in. we say 'possibly'
                // as a) may not be React and b) the cell could be empty anyway
                const possiblyNoContentYet = autoHeight == 0;
                if (notYetInDom || possiblyNoContentYet) {
                    (0, function_1._batchCall)(() => measureHeight(timesCalled + 1), 'raf', beans);
                    return;
                }
            }
            this.setColHeaderHeight(this.column, autoHeight);
        };
        let isMeasuring = false;
        let stopResizeObserver;
        const checkMeasuring = () => {
            const newValue = this.column.isAutoHeaderHeight();
            if (newValue && !isMeasuring) {
                startMeasuring();
            }
            if (!newValue && isMeasuring) {
                stopMeasuring();
            }
        };
        const startMeasuring = () => {
            isMeasuring = true;
            measureHeight(0);
            this.comp.toggleCss('ag-header-cell-auto-height', true);
            stopResizeObserver = (0, dom_1._observeResize)(this.beans, wrapperElement, () => measureHeight(0));
        };
        const stopMeasuring = () => {
            isMeasuring = false;
            if (stopResizeObserver) {
                stopResizeObserver();
            }
            this.comp.toggleCss('ag-header-cell-auto-height', false);
            stopResizeObserver = undefined;
        };
        checkMeasuring();
        compBean.addDestroyFunc(() => stopMeasuring());
        // In theory we could rely on the resize observer for everything - but since it's debounced
        // it can be a little janky for smooth movement. in this case its better to react to our own events
        // And unfortunately we cant _just_ rely on our own events, since custom components can change whenever
        compBean.addManagedListeners(this.column, { widthChanged: () => isMeasuring && measureHeight(0) });
        // Displaying the sort icon changes the available area for text, so sort changes can affect height
        compBean.addManagedEventListeners({
            sortChanged: () => {
                // Rendering changes for sort, happen after the event... not ideal
                if (isMeasuring) {
                    window.setTimeout(() => measureHeight(0));
                }
            },
        });
        if (checkMeasuringCallback) {
            checkMeasuringCallback(checkMeasuring);
        }
    }
    onDisplayedColumnsChanged() {
        const { comp, column, beans, eGui } = this;
        if (!comp || !column || !eGui) {
            return;
        }
        (0, cssClassApplier_1.refreshFirstAndLastStyles)(comp, column, beans.visibleCols);
        (0, aria_1._setAriaColIndex)(eGui, beans.visibleCols.getAriaColIndex(column)); // for react, we don't use JSX, as it slowed down column moving
    }
    addResizeAndMoveKeyboardListeners(compBean) {
        compBean.addManagedListeners(this.eGui, {
            keydown: this.onGuiKeyDown.bind(this),
            keyup: this.onGuiKeyUp.bind(this),
        });
    }
    refreshTabIndex() {
        const suppressHeaderFocus = (0, focus_1._isHeaderFocusSuppressed)(this.beans);
        if (this.eGui) {
            (0, dom_1._addOrRemoveAttribute)(this.eGui, 'tabindex', suppressHeaderFocus ? null : '-1');
        }
    }
    onGuiKeyDown(e) {
        const activeEl = (0, gridOptionsUtils_1._getActiveDomElement)(this.beans);
        const isLeftOrRight = e.key === keyCode_1.KeyCode.LEFT || e.key === keyCode_1.KeyCode.RIGHT;
        if (this.isResizing) {
            e.preventDefault();
            e.stopImmediatePropagation();
        }
        if (
        // if elements within the header are focused, we don't process the event
        activeEl !== this.eGui ||
            // if shiftKey and altKey are not pressed, it's cell navigation so we don't process the event
            (!e.shiftKey && !e.altKey)) {
            return;
        }
        if (this.isResizing || isLeftOrRight) {
            e.preventDefault();
            e.stopImmediatePropagation();
        }
        if (!isLeftOrRight) {
            return;
        }
        const isLeft = (e.key === keyCode_1.KeyCode.LEFT) !== this.gos.get('enableRtl');
        const direction = isLeft ? 'left' : 'right';
        if (e.altKey) {
            this.isResizing = true;
            this.resizeMultiplier += 1;
            const diff = this.getViewportAdjustedResizeDiff(e);
            this.resizeHeader(diff, e.shiftKey);
            this.resizeFeature?.toggleColumnResizing(true);
        }
        else {
            this.moveHeader(direction);
        }
    }
    moveHeader(hDirection) {
        this.beans.colMoves?.moveHeader(hDirection, this.eGui, this.column, this.rowCtrl.pinned, this);
    }
    getViewportAdjustedResizeDiff(e) {
        const diff = this.getResizeDiff(e);
        const { pinnedCols } = this.beans;
        return pinnedCols ? pinnedCols.getHeaderResizeDiff(diff, this.column) : diff;
    }
    getResizeDiff(e) {
        const { gos, column } = this;
        let isLeft = (e.key === keyCode_1.KeyCode.LEFT) !== gos.get('enableRtl');
        const pinned = column.getPinned();
        const isRtl = gos.get('enableRtl');
        if (pinned) {
            if (isRtl !== (pinned === 'right')) {
                isLeft = !isLeft;
            }
        }
        return (isLeft ? -1 : 1) * this.resizeMultiplier;
    }
    onGuiKeyUp() {
        if (!this.isResizing) {
            return;
        }
        if (this.resizeToggleTimeout) {
            window.clearTimeout(this.resizeToggleTimeout);
            this.resizeToggleTimeout = 0;
        }
        this.isResizing = false;
        this.resizeMultiplier = 1;
        this.resizeToggleTimeout = window.setTimeout(() => {
            this.resizeFeature?.toggleColumnResizing(false);
        }, 150);
    }
    handleKeyDown(e) {
        const wrapperHasFocus = this.getWrapperHasFocus();
        switch (e.key) {
            case keyCode_1.KeyCode.PAGE_DOWN:
            case keyCode_1.KeyCode.PAGE_UP:
            case keyCode_1.KeyCode.PAGE_HOME:
            case keyCode_1.KeyCode.PAGE_END:
                if (wrapperHasFocus) {
                    e.preventDefault();
                }
        }
    }
    addDomData(compBean) {
        const key = exports.DOM_DATA_KEY_HEADER_CTRL;
        const { eGui, gos } = this;
        (0, gridOptionsUtils_1._setDomData)(gos, eGui, key, this);
        compBean.addDestroyFunc(() => (0, gridOptionsUtils_1._setDomData)(gos, eGui, key, null));
    }
    focus(event) {
        const { eGui } = this;
        if (!eGui) {
            return false;
        }
        this.lastFocusEvent = event || null;
        eGui.focus();
        return true;
    }
    focusThis() {
        this.beans.focusSvc.focusedHeader = { headerRowIndex: this.rowCtrl.rowIndex, column: this.column };
    }
    removeDragSource() {
        if (this.dragSource) {
            this.beans.dragAndDrop?.removeDragSource(this.dragSource);
            this.dragSource = null;
        }
    }
    handleContextMenuMouseEvent(mouseEvent, touchEvent, column) {
        const event = mouseEvent ?? touchEvent;
        const { menuSvc, gos } = this.beans;
        if (gos.get('preventDefaultOnContextMenu')) {
            event.preventDefault();
        }
        if (menuSvc?.isHeaderContextMenuEnabled(column)) {
            menuSvc.showHeaderContextMenu(column, mouseEvent, touchEvent);
        }
        this.dispatchColumnMouseEvent('columnHeaderContextMenu', column);
    }
    dispatchColumnMouseEvent(eventType, column) {
        this.eventSvc.dispatchEvent({
            type: eventType,
            column,
        });
    }
    setColHeaderHeight(col, height) {
        if (!col.setAutoHeaderHeight(height)) {
            return;
        }
        const { eventSvc } = this;
        if (col.isColumn) {
            eventSvc.dispatchEvent({
                type: 'columnHeaderHeightChanged',
                column: col,
                columns: [col],
                source: 'autosizeColumnHeaderHeight',
            });
        }
        else {
            eventSvc.dispatchEvent({
                type: 'columnGroupHeaderHeightChanged',
                columnGroup: col,
                source: 'autosizeColumnGroupHeaderHeight',
            });
        }
    }
    clearComponent() {
        this.removeDragSource();
        this.resizeFeature = null;
        this.comp = null;
        this.eGui = null;
    }
    destroy() {
        super.destroy();
        this.column = null;
        this.lastFocusEvent = null;
        this.rowCtrl = null;
    }
}
exports.AbstractHeaderCellCtrl = AbstractHeaderCellCtrl;


/***/ }),

/***/ 21906:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HeaderCellComp = void 0;
const aria_1 = __webpack_require__(95230);
const dom_1 = __webpack_require__(33507);
const component_1 = __webpack_require__(78020);
const abstractHeaderCellComp_1 = __webpack_require__(59860);
const HeaderCellElement = {
    tag: 'div',
    cls: 'ag-header-cell',
    role: 'columnheader',
    children: [
        { tag: 'div', ref: 'eResize', cls: 'ag-header-cell-resize', role: 'presentation' },
        { tag: 'div', ref: 'eHeaderCompWrapper', cls: 'ag-header-cell-comp-wrapper', role: 'presentation' },
    ],
};
class HeaderCellComp extends abstractHeaderCellComp_1.AbstractHeaderCellComp {
    constructor(ctrl) {
        super(HeaderCellElement, ctrl);
        this.eResize = component_1.RefPlaceholder;
        this.eHeaderCompWrapper = component_1.RefPlaceholder;
        this.headerCompVersion = 0;
    }
    postConstruct() {
        const eGui = this.getGui();
        const setAttribute = (name, value) => {
            if (value != null && value != '') {
                eGui.setAttribute(name, value);
            }
            else {
                eGui.removeAttribute(name);
            }
        };
        const refreshSelectAllGui = () => {
            const selectAllGui = this.ctrl.getSelectAllGui();
            if (selectAllGui) {
                this.eResize.insertAdjacentElement('afterend', selectAllGui);
                this.addDestroyFunc(() => selectAllGui.remove());
            }
        };
        setAttribute('col-id', this.ctrl.column.getColId());
        const compProxy = {
            setWidth: (width) => (eGui.style.width = width),
            toggleCss: (cssClassName, on) => this.toggleCss(cssClassName, on),
            setUserStyles: (styles) => (0, dom_1._addStylesToElement)(eGui, styles),
            setAriaSort: (sort) => (sort ? (0, aria_1._setAriaSort)(eGui, sort) : (0, aria_1._removeAriaSort)(eGui)),
            setUserCompDetails: (compDetails) => this.setUserCompDetails(compDetails),
            getUserCompInstance: () => this.headerComp,
            refreshSelectAllGui,
            removeSelectAllGui: () => this.ctrl.getSelectAllGui()?.remove(),
        };
        this.ctrl.setComp(compProxy, this.getGui(), this.eResize, this.eHeaderCompWrapper, undefined);
        refreshSelectAllGui();
    }
    destroy() {
        this.destroyHeaderComp();
        super.destroy();
    }
    destroyHeaderComp() {
        if (this.headerComp) {
            this.eHeaderCompWrapper.removeChild(this.headerCompGui);
            this.headerComp = this.destroyBean(this.headerComp);
            this.headerCompGui = undefined;
        }
    }
    setUserCompDetails(compDetails) {
        this.headerCompVersion++;
        const versionCopy = this.headerCompVersion;
        compDetails.newAgStackInstance().then((comp) => this.afterCompCreated(versionCopy, comp));
    }
    afterCompCreated(version, headerComp) {
        if (version != this.headerCompVersion || !this.isAlive()) {
            this.destroyBean(headerComp);
            return;
        }
        this.destroyHeaderComp();
        this.headerComp = headerComp;
        this.headerCompGui = headerComp.getGui();
        this.eHeaderCompWrapper.appendChild(this.headerCompGui);
        this.ctrl.setDragSource(this.getGui());
    }
}
exports.HeaderCellComp = HeaderCellComp;


/***/ }),

/***/ 20260:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HeaderCellCtrl = void 0;
const emptyBean_1 = __webpack_require__(33789);
const userCompUtils_1 = __webpack_require__(12036);
const keyCode_1 = __webpack_require__(39853);
const gridOptionsUtils_1 = __webpack_require__(67274);
const iColumn_1 = __webpack_require__(62783);
const setLeftFeature_1 = __webpack_require__(68703);
const aria_1 = __webpack_require__(95230);
const dom_1 = __webpack_require__(33507);
const focus_1 = __webpack_require__(82331);
const managedFocusFeature_1 = __webpack_require__(31772);
const headerUtils_1 = __webpack_require__(1323);
const abstractHeaderCellCtrl_1 = __webpack_require__(83534);
const cssClassApplier_1 = __webpack_require__(91295);
class HeaderCellCtrl extends abstractHeaderCellCtrl_1.AbstractHeaderCellCtrl {
    constructor() {
        super(...arguments);
        this.refreshFunctions = {};
        this.userHeaderClasses = new Set();
        this.ariaDescriptionProperties = new Map();
    }
    setComp(comp, eGui, eResize, eHeaderCompWrapper, compBeanInput) {
        this.comp = comp;
        const { rowCtrl, column, beans } = this;
        const { colResize, context, colHover, rangeSvc } = beans;
        const compBean = (0, emptyBean_1.setupCompBean)(this, context, compBeanInput);
        this.setGui(eGui, compBean);
        this.updateState();
        this.setupWidth(compBean);
        this.setupMovingCss(compBean);
        this.setupMenuClass(compBean);
        this.setupSortableClass(compBean);
        this.setupWrapTextClass();
        this.refreshSpanHeaderHeight();
        this.setupAutoHeight({
            wrapperElement: eHeaderCompWrapper,
            checkMeasuringCallback: (checkMeasuring) => this.setRefreshFunction('measuring', checkMeasuring),
            compBean,
        });
        this.addColumnHoverListener(compBean);
        this.setupFilterClass(compBean);
        this.setupStylesFromColDef();
        this.setupClassesFromColDef();
        this.setupTooltip();
        this.addActiveHeaderMouseListeners(compBean);
        this.setupSelectAll(compBean);
        this.setupUserComp();
        this.refreshAria();
        if (colResize) {
            this.resizeFeature = compBean.createManagedBean(colResize.createResizeFeature(rowCtrl.pinned, column, eResize, comp, this));
        }
        else {
            (0, dom_1._setDisplayed)(eResize, false);
        }
        colHover?.createHoverFeature(compBean, [column], eGui);
        rangeSvc?.createRangeHighlightFeature(compBean, column, comp);
        compBean.createManagedBean(new setLeftFeature_1.SetLeftFeature(column, eGui, beans));
        compBean.createManagedBean(new managedFocusFeature_1.ManagedFocusFeature(eGui, {
            shouldStopEventPropagation: (e) => this.shouldStopEventPropagation(e),
            onTabKeyDown: () => null,
            handleKeyDown: this.handleKeyDown.bind(this),
            onFocusIn: this.onFocusIn.bind(this),
            onFocusOut: this.onFocusOut.bind(this),
        }));
        this.addResizeAndMoveKeyboardListeners(compBean);
        compBean.addManagedPropertyListeners(['suppressMovableColumns', 'suppressMenuHide', 'suppressAggFuncInHeader', 'enableAdvancedFilter'], () => this.refresh());
        compBean.addManagedListeners(column, { colDefChanged: () => this.refresh() });
        compBean.addManagedListeners(column, { headerHighlightChanged: this.onHeaderHighlightChanged.bind(this) });
        const listener = () => this.checkDisplayName();
        compBean.addManagedEventListeners({
            columnValueChanged: listener,
            columnRowGroupChanged: listener,
            columnPivotChanged: listener,
            headerHeightChanged: this.onHeaderHeightChanged.bind(this),
        });
        compBean.addDestroyFunc(() => {
            this.refreshFunctions = {};
            this.selectAllFeature = null;
            this.dragSourceElement = undefined;
            this.userCompDetails = null;
            this.userHeaderClasses.clear();
            this.ariaDescriptionProperties.clear();
            // Make sure this is the last destroy func as it clears the gui and comp
            this.clearComponent();
        });
    }
    resizeHeader(delta, shiftKey) {
        this.beans.colResize?.resizeHeader(this.column, delta, shiftKey);
    }
    getHeaderClassParams() {
        const { column, beans } = this;
        const colDef = column.colDef;
        return (0, gridOptionsUtils_1._addGridCommonParams)(beans.gos, {
            colDef,
            column,
            floatingFilter: false,
        });
    }
    setupUserComp() {
        const compDetails = this.lookupUserCompDetails();
        if (compDetails) {
            this.setCompDetails(compDetails);
        }
    }
    setCompDetails(compDetails) {
        this.userCompDetails = compDetails;
        this.comp.setUserCompDetails(compDetails);
    }
    lookupUserCompDetails() {
        const params = this.createParams();
        const colDef = this.column.getColDef();
        return (0, userCompUtils_1._getHeaderCompDetails)(this.beans.userCompFactory, colDef, params);
    }
    createParams() {
        const { menuSvc, sortSvc, colFilter, gos } = this.beans;
        const params = (0, gridOptionsUtils_1._addGridCommonParams)(gos, {
            column: this.column,
            displayName: this.displayName,
            enableSorting: this.column.isSortable(),
            enableMenu: this.menuEnabled,
            enableFilterButton: this.openFilterEnabled && !!menuSvc?.isHeaderFilterButtonEnabled(this.column),
            enableFilterIcon: !!colFilter && (!this.openFilterEnabled || (0, gridOptionsUtils_1._isLegacyMenuEnabled)(this.gos)),
            showColumnMenu: (buttonElement, onClosedCallback) => {
                menuSvc?.showColumnMenu({
                    column: this.column,
                    buttonElement,
                    positionBy: 'button',
                    onClosedCallback,
                });
            },
            showColumnMenuAfterMouseClick: (mouseEvent, onClosedCallback) => {
                menuSvc?.showColumnMenu({
                    column: this.column,
                    mouseEvent,
                    positionBy: 'mouse',
                    onClosedCallback,
                });
            },
            showFilter: (buttonElement) => {
                menuSvc?.showFilterMenu({
                    column: this.column,
                    buttonElement: buttonElement,
                    containerType: 'columnFilter',
                    positionBy: 'button',
                });
            },
            progressSort: (multiSort) => {
                sortSvc?.progressSort(this.column, !!multiSort, 'uiColumnSorted');
            },
            setSort: (sort, multiSort) => {
                sortSvc?.setSortForColumn(this.column, sort, !!multiSort, 'uiColumnSorted');
            },
            eGridHeader: this.eGui,
            setTooltip: (value, shouldDisplayTooltip) => {
                gos.assertModuleRegistered('Tooltip', 3);
                this.setupTooltip(value, shouldDisplayTooltip);
            },
        });
        return params;
    }
    setupSelectAll(compBean) {
        const { selectionSvc } = this.beans;
        if (!selectionSvc) {
            return;
        }
        this.selectAllFeature = compBean.createOptionalManagedBean(selectionSvc.createSelectAllFeature(this.column));
        this.selectAllFeature?.setComp(this);
        compBean.addManagedPropertyListener('rowSelection', () => {
            const selectAllFeature = selectionSvc.createSelectAllFeature(this.column);
            if (selectAllFeature && !this.selectAllFeature) {
                this.selectAllFeature = compBean.createManagedBean(selectAllFeature);
                this.selectAllFeature?.setComp(this);
                this.comp.refreshSelectAllGui();
            }
            else if (this.selectAllFeature && !selectAllFeature) {
                this.comp.removeSelectAllGui();
                this.selectAllFeature = this.destroyBean(this.selectAllFeature);
            }
        });
    }
    getSelectAllGui() {
        return this.selectAllFeature?.getCheckboxGui();
    }
    handleKeyDown(e) {
        super.handleKeyDown(e);
        if (e.key === keyCode_1.KeyCode.SPACE) {
            this.selectAllFeature?.onSpaceKeyDown(e);
        }
        if (e.key === keyCode_1.KeyCode.ENTER) {
            this.onEnterKeyDown(e);
        }
        if (e.key === keyCode_1.KeyCode.DOWN && e.altKey) {
            this.showMenuOnKeyPress(e, false);
        }
    }
    onEnterKeyDown(e) {
        if (e.ctrlKey || e.metaKey) {
            this.showMenuOnKeyPress(e, true);
        }
        else if (this.sortable) {
            this.beans.sortSvc?.progressSort(this.column, e.shiftKey, 'uiColumnSorted');
        }
    }
    showMenuOnKeyPress(e, isFilterShortcut) {
        const headerComp = this.comp.getUserCompInstance();
        if (!isHeaderComp(headerComp)) {
            return;
        }
        // the header comp knows what features are enabled, so let it handle the shortcut
        if (headerComp.onMenuKeyboardShortcut(isFilterShortcut)) {
            e.preventDefault();
        }
    }
    onFocusIn(e) {
        if (!this.eGui.contains(e.relatedTarget)) {
            this.focusThis();
            this.announceAriaDescription();
        }
        if ((0, focus_1._isKeyboardMode)()) {
            this.setActiveHeader(true);
        }
    }
    onFocusOut(e) {
        if (this.eGui.contains(e.relatedTarget)) {
            return;
        }
        this.setActiveHeader(false);
    }
    setupTooltip(value, shouldDisplayTooltip) {
        this.tooltipFeature = this.beans.tooltipSvc?.setupHeaderTooltip(this.tooltipFeature, this, value, shouldDisplayTooltip);
    }
    setupStylesFromColDef() {
        this.setRefreshFunction('headerStyles', this.refreshHeaderStyles.bind(this));
        this.refreshHeaderStyles();
    }
    setupClassesFromColDef() {
        const refreshHeaderClasses = () => {
            const colDef = this.column.getColDef();
            const classes = (0, cssClassApplier_1._getHeaderClassesFromColDef)(colDef, this.gos, this.column, null);
            const oldClasses = this.userHeaderClasses;
            this.userHeaderClasses = new Set(classes);
            classes.forEach((c) => {
                if (oldClasses.has(c)) {
                    // class already added, no need to apply it, but remove from old set
                    oldClasses.delete(c);
                }
                else {
                    // class new since last time, so apply it
                    this.comp.toggleCss(c, true);
                }
            });
            // now old set only has classes that were applied last time, but not this time, so remove them
            oldClasses.forEach((c) => this.comp.toggleCss(c, false));
        };
        this.setRefreshFunction('headerClasses', refreshHeaderClasses);
        refreshHeaderClasses();
    }
    setDragSource(eSource) {
        this.dragSourceElement = eSource;
        this.removeDragSource();
        if (!eSource || !this.draggable) {
            return;
        }
        this.dragSource = this.beans.colMoves?.setDragSourceForHeader(eSource, this.column, this.displayName) ?? null;
    }
    updateState() {
        const { menuSvc } = this.beans;
        this.menuEnabled = !!menuSvc?.isColumnMenuInHeaderEnabled(this.column);
        this.openFilterEnabled = !!menuSvc?.isFilterMenuInHeaderEnabled(this.column);
        this.sortable = this.column.isSortable();
        this.displayName = this.calculateDisplayName();
        this.draggable = this.workOutDraggable();
    }
    setRefreshFunction(name, func) {
        this.refreshFunctions[name] = func;
    }
    refresh() {
        this.updateState();
        this.refreshHeaderComp();
        this.refreshAria();
        Object.values(this.refreshFunctions).forEach((f) => f());
    }
    refreshHeaderComp() {
        const newCompDetails = this.lookupUserCompDetails();
        if (!newCompDetails) {
            return;
        }
        const compInstance = this.comp.getUserCompInstance();
        // only try refresh if old comp exists adn it is the correct type
        const attemptRefresh = compInstance != null && this.userCompDetails.componentClass == newCompDetails.componentClass;
        const headerCompRefreshed = attemptRefresh ? this.attemptHeaderCompRefresh(newCompDetails.params) : false;
        if (headerCompRefreshed) {
            // we do this as a refresh happens after colDefs change, and it's possible the column has had it's
            // draggable property toggled. no need to call this if not refreshing, as setDragSource is done
            // as part of appendHeaderComp
            this.setDragSource(this.dragSourceElement);
        }
        else {
            this.setCompDetails(newCompDetails);
        }
    }
    attemptHeaderCompRefresh(params) {
        const headerComp = this.comp.getUserCompInstance();
        if (!headerComp) {
            return false;
        }
        // if no refresh method, then we want to replace the headerComp
        if (!headerComp.refresh) {
            return false;
        }
        const res = headerComp.refresh(params);
        return res;
    }
    calculateDisplayName() {
        return this.beans.colNames.getDisplayNameForColumn(this.column, 'header', true);
    }
    checkDisplayName() {
        // display name can change if aggFunc different, eg sum(Gold) is now max(Gold)
        if (this.displayName !== this.calculateDisplayName()) {
            this.refresh();
        }
    }
    workOutDraggable() {
        const colDef = this.column.getColDef();
        const isSuppressMovableColumns = this.gos.get('suppressMovableColumns');
        const colCanMove = !isSuppressMovableColumns && !colDef.suppressMovable && !colDef.lockPosition;
        // we should still be allowed drag the column, even if it can't be moved, if the column
        // can be dragged to a rowGroup or pivot drop zone
        return !!colCanMove || !!colDef.enableRowGroup || !!colDef.enablePivot;
    }
    setupWidth(compBean) {
        const listener = () => {
            const columnWidth = this.column.getActualWidth();
            this.comp.setWidth(`${columnWidth}px`);
        };
        compBean.addManagedListeners(this.column, { widthChanged: listener });
        listener();
    }
    setupMovingCss(compBean) {
        const listener = () => {
            // this is what makes the header go dark when it is been moved (gives impression to
            // user that the column was picked up).
            this.comp.toggleCss('ag-header-cell-moving', this.column.isMoving());
        };
        compBean.addManagedListeners(this.column, { movingChanged: listener });
        listener();
    }
    setupMenuClass(compBean) {
        const listener = () => {
            this.comp?.toggleCss('ag-column-menu-visible', this.column.isMenuVisible());
        };
        compBean.addManagedListeners(this.column, { menuVisibleChanged: listener });
        listener();
    }
    setupSortableClass(compBean) {
        const updateSortableCssClass = () => {
            this.comp.toggleCss('ag-header-cell-sortable', !!this.sortable);
        };
        updateSortableCssClass();
        this.setRefreshFunction('updateSortable', updateSortableCssClass);
        compBean.addManagedEventListeners({ sortChanged: this.refreshAriaSort.bind(this) });
    }
    setupFilterClass(compBean) {
        const listener = () => {
            const isFilterActive = this.column.isFilterActive();
            this.comp.toggleCss('ag-header-cell-filtered', isFilterActive);
            this.refreshAria();
        };
        compBean.addManagedListeners(this.column, { filterActiveChanged: listener });
        listener();
    }
    setupWrapTextClass() {
        const listener = () => {
            const wrapText = !!this.column.getColDef().wrapHeaderText;
            this.comp.toggleCss('ag-header-cell-wrap-text', wrapText);
        };
        listener();
        this.setRefreshFunction('wrapText', listener);
    }
    onHeaderHighlightChanged() {
        const highlighted = this.column.getHighlighted();
        const beforeOn = highlighted === iColumn_1.ColumnHighlightPosition.Before;
        const afterOn = highlighted === iColumn_1.ColumnHighlightPosition.After;
        this.comp.toggleCss('ag-header-highlight-before', beforeOn);
        this.comp.toggleCss('ag-header-highlight-after', afterOn);
    }
    onDisplayedColumnsChanged() {
        super.onDisplayedColumnsChanged();
        if (!this.isAlive()) {
            return;
        }
        this.onHeaderHeightChanged();
    }
    onHeaderHeightChanged() {
        this.refreshSpanHeaderHeight();
    }
    refreshSpanHeaderHeight() {
        const { eGui, column, comp, beans } = this;
        const groupHeaderHeight = (0, headerUtils_1.getGroupRowsHeight)(this.beans);
        const isZeroGroupHeight = groupHeaderHeight.reduce((total, next) => (total += next), 0) === 0;
        comp.toggleCss('ag-header-parent-hidden', isZeroGroupHeight);
        if (!column.isSpanHeaderHeight()) {
            eGui.style.removeProperty('top');
            eGui.style.removeProperty('height');
            comp.toggleCss('ag-header-span-height', false);
            comp.toggleCss('ag-header-span-total', false);
            return;
        }
        const { numberOfParents, isSpanningTotal } = this.column.getColumnGroupPaddingInfo();
        comp.toggleCss('ag-header-span-height', numberOfParents > 0);
        const headerHeight = (0, headerUtils_1.getColumnHeaderRowHeight)(beans);
        if (numberOfParents === 0) {
            // if spanning has stopped then need to reset these values.
            comp.toggleCss('ag-header-span-total', false);
            eGui.style.setProperty('top', `0px`);
            eGui.style.setProperty('height', `${headerHeight}px`);
            return;
        }
        comp.toggleCss('ag-header-span-total', isSpanningTotal);
        let extraHeight = 0;
        for (let i = 0; i < numberOfParents; i++) {
            extraHeight += groupHeaderHeight[groupHeaderHeight.length - 1 - i];
        }
        eGui.style.setProperty('top', `${-extraHeight}px`);
        eGui.style.setProperty('height', `${headerHeight + extraHeight}px`);
    }
    refreshAriaSort() {
        if (this.sortable) {
            const translate = this.getLocaleTextFunc();
            const sort = this.beans.sortSvc?.getDisplaySortForColumn(this.column) || null;
            this.comp.setAriaSort((0, aria_1._getAriaSortState)(sort));
            this.setAriaDescriptionProperty('sort', translate('ariaSortableColumn', 'Press ENTER to sort'));
        }
        else {
            this.comp.setAriaSort();
            this.setAriaDescriptionProperty('sort', null);
        }
    }
    refreshAriaMenu() {
        if (this.menuEnabled) {
            const translate = this.getLocaleTextFunc();
            this.setAriaDescriptionProperty('menu', translate('ariaMenuColumn', 'Press ALT DOWN to open column menu'));
        }
        else {
            this.setAriaDescriptionProperty('menu', null);
        }
    }
    refreshAriaFilterButton() {
        if (this.openFilterEnabled && !(0, gridOptionsUtils_1._isLegacyMenuEnabled)(this.gos)) {
            const translate = this.getLocaleTextFunc();
            this.setAriaDescriptionProperty('filterButton', translate('ariaFilterColumn', 'Press CTRL ENTER to open filter'));
        }
        else {
            this.setAriaDescriptionProperty('filterButton', null);
        }
    }
    refreshAriaFiltered() {
        const translate = this.getLocaleTextFunc();
        const isFilterActive = this.column.isFilterActive();
        if (isFilterActive) {
            this.setAriaDescriptionProperty('filter', translate('ariaColumnFiltered', 'Column Filtered'));
        }
        else {
            this.setAriaDescriptionProperty('filter', null);
        }
    }
    setAriaDescriptionProperty(property, value) {
        if (value != null) {
            this.ariaDescriptionProperties.set(property, value);
        }
        else {
            this.ariaDescriptionProperties.delete(property);
        }
    }
    announceAriaDescription() {
        if (!this.eGui.contains((0, gridOptionsUtils_1._getActiveDomElement)(this.beans))) {
            return;
        }
        const ariaDescription = Array.from(this.ariaDescriptionProperties.keys())
            // always announce the filter description first
            .sort((a, b) => (a === 'filter' ? -1 : b.charCodeAt(0) - a.charCodeAt(0)))
            .map((key) => this.ariaDescriptionProperties.get(key))
            .join('. ');
        this.beans.ariaAnnounce?.announceValue(ariaDescription, 'columnHeader');
    }
    refreshAria() {
        this.refreshAriaSort();
        this.refreshAriaMenu();
        this.refreshAriaFilterButton();
        this.refreshAriaFiltered();
    }
    addColumnHoverListener(compBean) {
        this.beans.colHover?.addHeaderColumnHoverListener(compBean, this.comp, this.column);
    }
    addActiveHeaderMouseListeners(compBean) {
        const listener = (e) => this.handleMouseOverChange(e.type === 'mouseenter');
        const clickListener = () => {
            this.setActiveHeader(true);
            this.dispatchColumnMouseEvent('columnHeaderClicked', this.column);
        };
        const contextMenuListener = (event) => this.handleContextMenuMouseEvent(event, undefined, this.column);
        compBean.addManagedListeners(this.eGui, {
            mouseenter: listener,
            mouseleave: listener,
            click: clickListener,
            contextmenu: contextMenuListener,
        });
    }
    handleMouseOverChange(isMouseOver) {
        this.setActiveHeader(isMouseOver);
        this.eventSvc.dispatchEvent({
            type: isMouseOver ? 'columnHeaderMouseOver' : 'columnHeaderMouseLeave',
            column: this.column,
        });
    }
    setActiveHeader(active) {
        this.comp.toggleCss('ag-header-active', active);
    }
    getAnchorElementForMenu(isFilter) {
        const headerComp = this.comp.getUserCompInstance();
        if (isHeaderComp(headerComp)) {
            return headerComp.getAnchorElementForMenu(isFilter);
        }
        return this.eGui;
    }
    destroy() {
        this.tooltipFeature = this.destroyBean(this.tooltipFeature);
        super.destroy();
    }
}
exports.HeaderCellCtrl = HeaderCellCtrl;
function isHeaderComp(headerComp) {
    // can't use `instanceof` here as it prevents tree shaking of `HeaderComp`
    return (typeof headerComp?.getAnchorElementForMenu === 'function' &&
        typeof headerComp.onMenuKeyboardShortcut === 'function');
}


/***/ }),

/***/ 49270:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HeaderComp = void 0;
const userCompUtils_1 = __webpack_require__(12036);
const gridOptionsUtils_1 = __webpack_require__(67274);
const dom_1 = __webpack_require__(33507);
const icon_1 = __webpack_require__(59970);
const object_1 = __webpack_require__(6996);
const string_1 = __webpack_require__(37766);
const component_1 = __webpack_require__(78020);
function getHeaderCompElementParams(includeSortIndicator) {
    const hiddenAttrs = { 'aria-hidden': 'true' };
    return {
        tag: 'div',
        cls: 'ag-cell-label-container',
        role: 'presentation',
        children: [
            {
                tag: 'span',
                ref: 'eMenu',
                cls: 'ag-header-icon ag-header-cell-menu-button',
                attrs: hiddenAttrs,
            },
            {
                tag: 'span',
                ref: 'eFilterButton',
                cls: 'ag-header-icon ag-header-cell-filter-button',
                attrs: hiddenAttrs,
            },
            {
                tag: 'div',
                ref: 'eLabel',
                cls: 'ag-header-cell-label',
                role: 'presentation',
                children: [
                    { tag: 'span', ref: 'eText', cls: 'ag-header-cell-text' },
                    {
                        tag: 'span',
                        ref: 'eFilter',
                        cls: 'ag-header-icon ag-header-label-icon ag-filter-icon',
                        attrs: hiddenAttrs,
                    },
                    includeSortIndicator ? { tag: 'ag-sort-indicator', ref: 'eSortIndicator' } : null,
                ],
            },
        ],
    };
}
const HeaderCompElement = getHeaderCompElementParams(true);
const HeaderCompElementNoSort = getHeaderCompElementParams(false);
class HeaderComp extends component_1.Component {
    constructor() {
        super(...arguments);
        // All the elements are optional, as they are not guaranteed to be present if the user provides a custom template
        this.eFilter = component_1.RefPlaceholder;
        this.eFilterButton = component_1.RefPlaceholder;
        this.eSortIndicator = component_1.RefPlaceholder;
        this.eMenu = component_1.RefPlaceholder;
        this.eLabel = component_1.RefPlaceholder;
        this.eText = component_1.RefPlaceholder;
        /**
         * Selectors for custom headers templates, i.e when the ag-sort-indicator is not present.
         */
        this.eSortOrder = component_1.RefPlaceholder;
        this.eSortAsc = component_1.RefPlaceholder;
        this.eSortDesc = component_1.RefPlaceholder;
        this.eSortMixed = component_1.RefPlaceholder;
        this.eSortNone = component_1.RefPlaceholder;
        this.isLoadingInnerComponent = false;
    }
    refresh(params) {
        const oldParams = this.params;
        this.params = params;
        // if template changed, then recreate the whole comp, the code required to manage
        // a changing template is to difficult for what it's worth.
        if (this.workOutTemplate(params, !!this.beans?.sortSvc) != this.currentTemplate ||
            this.workOutShowMenu() != this.currentShowMenu ||
            params.enableSorting != this.currentSort ||
            (this.currentSuppressMenuHide != null && this.shouldSuppressMenuHide() != this.currentSuppressMenuHide) ||
            oldParams.enableFilterButton != params.enableFilterButton ||
            oldParams.enableFilterIcon != params.enableFilterIcon) {
            return false;
        }
        if (this.innerHeaderComponent) {
            // Mimic the merging of params that happens during init of _getInnerHeaderCompDetails(userCompFactory, params, params);
            const mergedParams = { ...params };
            (0, object_1._mergeDeep)(mergedParams, params.innerHeaderComponentParams);
            this.innerHeaderComponent.refresh?.(mergedParams);
        }
        else {
            this.setDisplayName(params);
        }
        return true;
    }
    workOutTemplate(params, isSorting) {
        const paramsTemplate = params.template;
        if (paramsTemplate) {
            // take account of any newlines & whitespace before/after the actual template
            return paramsTemplate?.trim ? paramsTemplate.trim() : paramsTemplate;
        }
        else {
            return isSorting ? HeaderCompElement : HeaderCompElementNoSort;
        }
    }
    init(params) {
        this.params = params;
        const { sortSvc, touchSvc, rowNumbersSvc, userCompFactory } = this.beans;
        const sortComp = sortSvc?.getSortIndicatorSelector();
        this.currentTemplate = this.workOutTemplate(params, !!sortComp);
        this.setTemplate(this.currentTemplate, sortComp ? [sortComp] : undefined);
        touchSvc?.setupForHeader(this);
        this.setMenu();
        this.setupSort();
        rowNumbersSvc?.setupForHeader(this);
        this.setupFilterIcon();
        this.setupFilterButton();
        this.workOutInnerHeaderComponent(userCompFactory, params);
        this.setDisplayName(params);
    }
    workOutInnerHeaderComponent(userCompFactory, params) {
        const userCompDetails = (0, userCompUtils_1._getInnerHeaderCompDetails)(userCompFactory, params, params);
        if (!userCompDetails) {
            return;
        }
        this.isLoadingInnerComponent = true;
        userCompDetails.newAgStackInstance().then((comp) => {
            this.isLoadingInnerComponent = false;
            if (!comp) {
                return;
            }
            if (this.isAlive()) {
                this.innerHeaderComponent = comp;
                if (this.eText) {
                    this.eText.appendChild(comp.getGui());
                }
            }
            else {
                this.destroyBean(comp);
            }
        });
    }
    setDisplayName(params) {
        const { displayName } = params;
        const oldDisplayName = this.currentDisplayName;
        this.currentDisplayName = displayName;
        if (!this.eText ||
            oldDisplayName === displayName ||
            this.innerHeaderComponent ||
            this.isLoadingInnerComponent) {
            return;
        }
        this.eText.textContent = (0, string_1._toString)(displayName);
    }
    addInIcon(iconName, eParent, column) {
        const eIcon = (0, icon_1._createIconNoSpan)(iconName, this.beans, column);
        if (eIcon) {
            eParent.appendChild(eIcon);
        }
    }
    workOutShowMenu() {
        return this.params.enableMenu && !!this.beans.menuSvc?.isHeaderMenuButtonEnabled();
    }
    shouldSuppressMenuHide() {
        return !!this.beans.menuSvc?.isHeaderMenuButtonAlwaysShowEnabled();
    }
    setMenu() {
        // if no menu provided in template, do nothing
        if (!this.eMenu) {
            return;
        }
        this.currentShowMenu = this.workOutShowMenu();
        if (!this.currentShowMenu) {
            (0, dom_1._removeFromParent)(this.eMenu);
            this.eMenu = undefined;
            return;
        }
        const { gos, eMenu, params } = this;
        const isLegacyMenu = (0, gridOptionsUtils_1._isLegacyMenuEnabled)(gos);
        this.addInIcon(isLegacyMenu ? 'menu' : 'menuAlt', eMenu, params.column);
        eMenu.classList.toggle('ag-header-menu-icon', !isLegacyMenu);
        const currentSuppressMenuHide = this.shouldSuppressMenuHide();
        this.currentSuppressMenuHide = currentSuppressMenuHide;
        this.addManagedElementListeners(eMenu, { click: () => this.showColumnMenu(this.eMenu) });
        this.toggleMenuAlwaysShow(currentSuppressMenuHide);
    }
    toggleMenuAlwaysShow(alwaysShow) {
        this.eMenu?.classList.toggle('ag-header-menu-always-show', alwaysShow);
    }
    showColumnMenu(element) {
        const { currentSuppressMenuHide, params } = this;
        if (!currentSuppressMenuHide) {
            this.toggleMenuAlwaysShow(true);
        }
        params.showColumnMenu(element, () => {
            if (!currentSuppressMenuHide) {
                this.toggleMenuAlwaysShow(false);
            }
        });
    }
    onMenuKeyboardShortcut(isFilterShortcut) {
        const { params, gos, beans, eMenu, eFilterButton } = this;
        const column = params.column;
        const isLegacyMenuEnabled = (0, gridOptionsUtils_1._isLegacyMenuEnabled)(gos);
        if (isFilterShortcut && !isLegacyMenuEnabled) {
            if (beans.menuSvc?.isFilterMenuInHeaderEnabled(column)) {
                params.showFilter(eFilterButton ?? eMenu ?? this.getGui());
                return true;
            }
        }
        else if (params.enableMenu) {
            this.showColumnMenu(eMenu ?? eFilterButton ?? this.getGui());
            return true;
        }
        return false;
    }
    setupSort() {
        const { sortSvc } = this.beans;
        if (!sortSvc) {
            return;
        }
        const { enableSorting, column } = this.params;
        this.currentSort = enableSorting;
        // eSortIndicator will not be present when customers provided custom header
        // templates, in that case, we need to look for provided sort elements and
        // manually create eSortIndicator.
        if (!this.eSortIndicator) {
            this.eSortIndicator = this.createBean(sortSvc.createSortIndicator(true));
            const { eSortIndicator, eSortOrder, eSortAsc, eSortDesc, eSortMixed, eSortNone } = this;
            eSortIndicator.attachCustomElements(eSortOrder, eSortAsc, eSortDesc, eSortMixed, eSortNone);
        }
        this.eSortIndicator.setupSort(column);
        // we set up the indicator prior to the check for whether this column is sortable, as it allows the indicator to
        // set up the multi sort indicator which can appear irrelevant of whether this column can itself be sorted.
        // this can occur in the case of a non-sortable group display column.
        if (!this.currentSort) {
            return;
        }
        sortSvc.setupHeader(this, column, this.eLabel);
    }
    setupFilterIcon() {
        const { eFilter, params } = this;
        if (!eFilter) {
            return;
        }
        const onFilterChangedIcon = () => {
            const filterPresent = params.column.isFilterActive();
            (0, dom_1._setDisplayed)(eFilter, filterPresent, { skipAriaHidden: true });
        };
        this.configureFilter(params.enableFilterIcon, eFilter, onFilterChangedIcon, 'filterActive');
    }
    setupFilterButton() {
        const { eFilterButton, params } = this;
        if (!eFilterButton) {
            return;
        }
        const configured = this.configureFilter(params.enableFilterButton, eFilterButton, this.onFilterChangedButton.bind(this), 'filter');
        if (configured) {
            this.addManagedElementListeners(eFilterButton, {
                click: () => params.showFilter(eFilterButton),
            });
        }
        else {
            this.eFilterButton = undefined;
        }
    }
    configureFilter(enabled, element, filterChangedCallback, icon) {
        if (!enabled) {
            (0, dom_1._removeFromParent)(element);
            return false;
        }
        const column = this.params.column;
        this.addInIcon(icon, element, column);
        this.addManagedListeners(column, { filterChanged: filterChangedCallback });
        filterChangedCallback();
        return true;
    }
    onFilterChangedButton() {
        const filterPresent = this.params.column.isFilterActive();
        this.eFilterButton.classList.toggle('ag-filter-active', filterPresent);
    }
    getAnchorElementForMenu(isFilter) {
        const { eFilterButton, eMenu } = this;
        if (isFilter) {
            return eFilterButton ?? eMenu ?? this.getGui();
        }
        return eMenu ?? eFilterButton ?? this.getGui();
    }
    destroy() {
        super.destroy();
        if (this.innerHeaderComponent) {
            this.destroyBean(this.innerHeaderComponent);
            this.innerHeaderComponent = undefined;
        }
    }
}
exports.HeaderComp = HeaderComp;


/***/ }),

/***/ 44312:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GroupWidthFeature = void 0;
const beanStub_1 = __webpack_require__(68731);
class GroupWidthFeature extends beanStub_1.BeanStub {
    constructor(comp, columnGroup) {
        super();
        // the children can change, we keep destroy functions related to listening to the children here
        this.removeChildListenersFuncs = [];
        this.columnGroup = columnGroup;
        this.comp = comp;
    }
    postConstruct() {
        // we need to listen to changes in child columns, as they impact our width
        this.addListenersToChildrenColumns();
        // the children belonging to this group can change, so we need to add and remove listeners as they change
        this.addManagedListeners(this.columnGroup, {
            displayedChildrenChanged: this.onDisplayedChildrenChanged.bind(this),
        });
        this.onWidthChanged();
        // the child listeners are not tied to this components life-cycle, as children can get added and removed
        // to the group - hence they are on a different life-cycle. so we must make sure the existing children
        // listeners are removed when we finally get destroyed
        this.addDestroyFunc(this.removeListenersOnChildrenColumns.bind(this));
    }
    addListenersToChildrenColumns() {
        // first destroy any old listeners
        this.removeListenersOnChildrenColumns();
        // now add new listeners to the new set of children
        const widthChangedListener = this.onWidthChanged.bind(this);
        this.columnGroup.getLeafColumns().forEach((column) => {
            column.__addEventListener('widthChanged', widthChangedListener);
            column.__addEventListener('visibleChanged', widthChangedListener);
            this.removeChildListenersFuncs.push(() => {
                column.__removeEventListener('widthChanged', widthChangedListener);
                column.__removeEventListener('visibleChanged', widthChangedListener);
            });
        });
    }
    removeListenersOnChildrenColumns() {
        this.removeChildListenersFuncs.forEach((func) => func());
        this.removeChildListenersFuncs = [];
    }
    onDisplayedChildrenChanged() {
        this.addListenersToChildrenColumns();
        this.onWidthChanged();
    }
    onWidthChanged() {
        const columnWidth = this.columnGroup.getActualWidth();
        this.comp.setWidth(`${columnWidth}px`);
        this.comp.toggleCss('ag-hidden', columnWidth === 0);
    }
}
exports.GroupWidthFeature = GroupWidthFeature;


/***/ }),

/***/ 87746:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HeaderGroupCellComp = void 0;
const dom_1 = __webpack_require__(33507);
const component_1 = __webpack_require__(78020);
const abstractHeaderCellComp_1 = __webpack_require__(59860);
const HeaderGroupCellCompElement = {
    tag: 'div',
    cls: 'ag-header-group-cell',
    role: 'columnheader',
    children: [
        { tag: 'div', ref: 'eHeaderCompWrapper', cls: 'ag-header-cell-comp-wrapper', role: 'presentation' },
        { tag: 'div', ref: 'eResize', cls: 'ag-header-cell-resize', role: 'presentation' },
    ],
};
class HeaderGroupCellComp extends abstractHeaderCellComp_1.AbstractHeaderCellComp {
    constructor(ctrl) {
        super(HeaderGroupCellCompElement, ctrl);
        this.eResize = component_1.RefPlaceholder;
        this.eHeaderCompWrapper = component_1.RefPlaceholder;
    }
    postConstruct() {
        const eGui = this.getGui();
        const setAttribute = (key, value) => value != undefined ? eGui.setAttribute(key, value) : eGui.removeAttribute(key);
        eGui.setAttribute('col-id', this.ctrl.column.getUniqueId());
        const compProxy = {
            toggleCss: (cssClassName, on) => this.toggleCss(cssClassName, on),
            setUserStyles: (styles) => (0, dom_1._addStylesToElement)(eGui, styles),
            setHeaderWrapperHidden: (hidden) => {
                if (hidden) {
                    this.eHeaderCompWrapper.style.setProperty('display', 'none');
                }
                else {
                    this.eHeaderCompWrapper.style.removeProperty('display');
                }
            },
            setHeaderWrapperMaxHeight: (value) => {
                if (value != null) {
                    this.eHeaderCompWrapper.style.setProperty('max-height', `${value}px`);
                }
                else {
                    this.eHeaderCompWrapper.style.removeProperty('max-height');
                }
                this.eHeaderCompWrapper.classList.toggle('ag-header-cell-comp-wrapper-limited-height', value != null);
            },
            setResizableDisplayed: (displayed) => (0, dom_1._setDisplayed)(this.eResize, displayed),
            setWidth: (width) => (eGui.style.width = width),
            setAriaExpanded: (expanded) => setAttribute('aria-expanded', expanded),
            setUserCompDetails: (details) => this.setUserCompDetails(details),
            getUserCompInstance: () => this.headerGroupComp,
        };
        this.ctrl.setComp(compProxy, eGui, this.eResize, this.eHeaderCompWrapper, undefined);
    }
    setUserCompDetails(details) {
        details.newAgStackInstance().then((comp) => this.afterHeaderCompCreated(comp));
    }
    afterHeaderCompCreated(headerGroupComp) {
        const destroyFunc = () => this.destroyBean(headerGroupComp);
        if (!this.isAlive()) {
            destroyFunc();
            return;
        }
        const eGui = this.getGui();
        const eHeaderGroupGui = headerGroupComp.getGui();
        this.eHeaderCompWrapper.appendChild(eHeaderGroupGui);
        this.addDestroyFunc(destroyFunc);
        this.headerGroupComp = headerGroupComp;
        this.ctrl.setDragSource(eGui);
    }
    addOrRemoveHeaderWrapperStyle(style, value) {
        const { eHeaderCompWrapper } = this;
        if (value) {
            eHeaderCompWrapper.style.setProperty(style, value);
        }
        else {
            eHeaderCompWrapper.style.removeProperty(style);
        }
    }
}
exports.HeaderGroupCellComp = HeaderGroupCellComp;


/***/ }),

/***/ 60084:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HeaderGroupCellCtrl = void 0;
const emptyBean_1 = __webpack_require__(33789);
const userCompUtils_1 = __webpack_require__(12036);
const keyCode_1 = __webpack_require__(39853);
const gridOptionsUtils_1 = __webpack_require__(67274);
const iColumn_1 = __webpack_require__(62783);
const setLeftFeature_1 = __webpack_require__(68703);
const array_1 = __webpack_require__(31502);
const managedFocusFeature_1 = __webpack_require__(31772);
const abstractHeaderCellCtrl_1 = __webpack_require__(83534);
const cssClassApplier_1 = __webpack_require__(91295);
const groupWidthFeature_1 = __webpack_require__(44312);
class HeaderGroupCellCtrl extends abstractHeaderCellCtrl_1.AbstractHeaderCellCtrl {
    constructor() {
        super(...arguments);
        this.onSuppressColMoveChange = () => {
            if (!this.isAlive() || this.isSuppressMoving()) {
                this.removeDragSource();
            }
            else {
                if (!this.dragSource) {
                    this.setDragSource(this.eGui);
                }
            }
        };
    }
    setComp(comp, eGui, eResize, eHeaderCompWrapper, compBean) {
        const { column, beans } = this;
        const { context, colNames, colHover, rangeSvc, colResize } = beans;
        this.comp = comp;
        compBean = (0, emptyBean_1.setupCompBean)(this, context, compBean);
        this.setGui(eGui, compBean);
        this.displayName = colNames.getDisplayNameForColumnGroup(column, 'header');
        this.refreshHeaderStyles();
        this.addClasses();
        this.setupMovingCss(compBean);
        this.setupExpandable(compBean);
        this.setupTooltip();
        this.setupAutoHeight({
            wrapperElement: eHeaderCompWrapper,
            compBean,
        });
        this.setupUserComp();
        this.addHeaderMouseListeners(compBean);
        this.addManagedPropertyListener('groupHeaderHeight', this.refreshMaxHeaderHeight.bind(this));
        this.refreshMaxHeaderHeight();
        const pinned = this.rowCtrl.pinned;
        const leafCols = column.getProvidedColumnGroup().getLeafColumns();
        colHover?.createHoverFeature(compBean, leafCols, eGui);
        rangeSvc?.createRangeHighlightFeature(compBean, column, comp);
        compBean.createManagedBean(new setLeftFeature_1.SetLeftFeature(column, eGui, beans));
        compBean.createManagedBean(new groupWidthFeature_1.GroupWidthFeature(comp, column));
        if (colResize) {
            this.resizeFeature = compBean.createManagedBean(colResize.createGroupResizeFeature(comp, eResize, pinned, column));
        }
        else {
            comp.setResizableDisplayed(false);
        }
        compBean.createManagedBean(new managedFocusFeature_1.ManagedFocusFeature(eGui, {
            shouldStopEventPropagation: this.shouldStopEventPropagation.bind(this),
            onTabKeyDown: () => undefined,
            handleKeyDown: this.handleKeyDown.bind(this),
            onFocusIn: this.onFocusIn.bind(this),
        }));
        this.addHighlightListeners(compBean, leafCols);
        compBean.addManagedPropertyListener('suppressMovableColumns', this.onSuppressColMoveChange);
        this.addResizeAndMoveKeyboardListeners(compBean);
        // Make sure this is the last destroy func as it clears the gui and comp
        compBean.addDestroyFunc(() => this.clearComponent());
    }
    getHeaderClassParams() {
        const { column, beans } = this;
        const colDef = column.getDefinition();
        return (0, gridOptionsUtils_1._addGridCommonParams)(beans.gos, {
            colDef,
            columnGroup: column,
            floatingFilter: false,
        });
    }
    refreshMaxHeaderHeight() {
        const { gos, comp } = this;
        const groupHeaderHeight = gos.get('groupHeaderHeight');
        if (groupHeaderHeight != null) {
            if (groupHeaderHeight === 0) {
                comp.setHeaderWrapperHidden(true);
            }
            else {
                comp.setHeaderWrapperMaxHeight(groupHeaderHeight);
            }
        }
        else {
            comp.setHeaderWrapperHidden(false);
            comp.setHeaderWrapperMaxHeight(null);
        }
    }
    addHighlightListeners(compBean, columns) {
        if (!this.beans.gos.get('suppressMoveWhenColumnDragging')) {
            return;
        }
        for (const column of columns) {
            compBean.addManagedListeners(column, {
                headerHighlightChanged: this.onLeafColumnHighlightChanged.bind(this, column),
            });
        }
    }
    onLeafColumnHighlightChanged(column) {
        const displayedColumns = this.column.getDisplayedLeafColumns();
        const isFirst = displayedColumns[0] === column;
        const isLast = (0, array_1._last)(displayedColumns) === column;
        if (!isFirst && !isLast) {
            return;
        }
        const highlighted = column.getHighlighted();
        const isColumnMoveAtThisLevel = !!this.rowCtrl.getHeaderCellCtrls().find((ctrl) => {
            return ctrl.column.isMoving();
        });
        let beforeOn = false;
        let afterOn = false;
        if (isColumnMoveAtThisLevel) {
            const isRtl = this.beans.gos.get('enableRtl');
            const isHighlightAfter = highlighted === iColumn_1.ColumnHighlightPosition.After;
            const isHighlightBefore = highlighted === iColumn_1.ColumnHighlightPosition.Before;
            if (isFirst) {
                if (isRtl) {
                    afterOn = isHighlightAfter;
                }
                else {
                    beforeOn = isHighlightBefore;
                }
            }
            if (isLast) {
                if (isRtl) {
                    beforeOn = isHighlightBefore;
                }
                else {
                    afterOn = isHighlightAfter;
                }
            }
        }
        this.comp.toggleCss('ag-header-highlight-before', beforeOn);
        this.comp.toggleCss('ag-header-highlight-after', afterOn);
    }
    resizeHeader(delta, shiftKey) {
        const { resizeFeature } = this;
        // check to avoid throwing when a component has not been setup yet (React 18)
        if (!resizeFeature) {
            return;
        }
        const initialValues = resizeFeature.getInitialValues(shiftKey);
        resizeFeature.resizeColumns(initialValues, initialValues.resizeStartWidth + delta, 'uiColumnResized', true);
    }
    resizeLeafColumnsToFit(source) {
        // check to avoid throwing when a component has not been setup yet (React 18)
        this.resizeFeature?.resizeLeafColumnsToFit(source);
    }
    setupUserComp() {
        const { colGroupSvc, userCompFactory, gos, enterpriseMenuFactory } = this.beans;
        const columnGroup = this.column;
        const providedColumnGroup = columnGroup.getProvidedColumnGroup();
        const params = (0, gridOptionsUtils_1._addGridCommonParams)(gos, {
            displayName: this.displayName,
            columnGroup,
            setExpanded: (expanded) => {
                colGroupSvc.setColumnGroupOpened(providedColumnGroup, expanded, 'gridInitializing');
            },
            setTooltip: (value, shouldDisplayTooltip) => {
                gos.assertModuleRegistered('Tooltip', 3);
                this.setupTooltip(value, shouldDisplayTooltip);
            },
            showColumnMenu: (buttonElement, onClosedCallback) => enterpriseMenuFactory?.showMenuAfterButtonClick(providedColumnGroup, buttonElement, 'columnMenu', onClosedCallback),
            showColumnMenuAfterMouseClick: (mouseEvent, onClosedCallback) => enterpriseMenuFactory?.showMenuAfterMouseEvent(providedColumnGroup, mouseEvent, 'columnMenu', onClosedCallback),
            eGridHeader: this.eGui,
        });
        const compDetails = (0, userCompUtils_1._getHeaderGroupCompDetails)(userCompFactory, params);
        if (compDetails) {
            this.comp.setUserCompDetails(compDetails);
        }
    }
    addHeaderMouseListeners(compBean) {
        const listener = (e) => this.handleMouseOverChange(e.type === 'mouseenter');
        const clickListener = () => this.dispatchColumnMouseEvent('columnHeaderClicked', this.column.getProvidedColumnGroup());
        const contextMenuListener = (event) => this.handleContextMenuMouseEvent(event, undefined, this.column.getProvidedColumnGroup());
        compBean.addManagedListeners(this.eGui, {
            mouseenter: listener,
            mouseleave: listener,
            click: clickListener,
            contextmenu: contextMenuListener,
        });
    }
    handleMouseOverChange(isMouseOver) {
        this.eventSvc.dispatchEvent({
            type: isMouseOver ? 'columnHeaderMouseOver' : 'columnHeaderMouseLeave',
            column: this.column.getProvidedColumnGroup(),
        });
    }
    setupTooltip(value, shouldDisplayTooltip) {
        this.tooltipFeature = this.beans.tooltipSvc?.setupHeaderGroupTooltip(this.tooltipFeature, this, value, shouldDisplayTooltip);
    }
    setupExpandable(compBean) {
        const providedColGroup = this.column.getProvidedColumnGroup();
        this.refreshExpanded();
        const listener = this.refreshExpanded.bind(this);
        compBean.addManagedListeners(providedColGroup, {
            expandedChanged: listener,
            expandableChanged: listener,
        });
    }
    refreshExpanded() {
        const { column } = this;
        this.expandable = column.isExpandable();
        const expanded = column.isExpanded();
        if (this.expandable) {
            this.comp.setAriaExpanded(expanded ? 'true' : 'false');
        }
        else {
            this.comp.setAriaExpanded(undefined);
        }
        this.refreshHeaderStyles();
    }
    addClasses() {
        const { column } = this;
        const colGroupDef = column.getColGroupDef();
        const classes = (0, cssClassApplier_1._getHeaderClassesFromColDef)(colGroupDef, this.gos, null, column);
        // having different classes below allows the style to not have a bottom border
        // on the group header, if no group is specified
        if (column.isPadding()) {
            classes.push('ag-header-group-cell-no-group');
            const leafCols = column.getLeafColumns();
            if (leafCols.every((col) => col.isSpanHeaderHeight())) {
                classes.push('ag-header-span-height');
            }
        }
        else {
            classes.push('ag-header-group-cell-with-group');
            if (colGroupDef?.wrapHeaderText) {
                classes.push('ag-header-cell-wrap-text');
            }
        }
        classes.forEach((c) => this.comp.toggleCss(c, true));
    }
    setupMovingCss(compBean) {
        const { column } = this;
        const providedColumnGroup = column.getProvidedColumnGroup();
        const leafColumns = providedColumnGroup.getLeafColumns();
        // function adds or removes the moving css, based on if the col is moving.
        // this is what makes the header go dark when it is been moved (gives impression to
        // user that the column was picked up).
        const listener = () => this.comp.toggleCss('ag-header-cell-moving', column.isMoving());
        leafColumns.forEach((col) => {
            compBean.addManagedListeners(col, { movingChanged: listener });
        });
        listener();
    }
    onFocusIn(e) {
        if (!this.eGui.contains(e.relatedTarget)) {
            this.focusThis();
        }
    }
    handleKeyDown(e) {
        super.handleKeyDown(e);
        const wrapperHasFocus = this.getWrapperHasFocus();
        if (!this.expandable || !wrapperHasFocus) {
            return;
        }
        if (e.key === keyCode_1.KeyCode.ENTER) {
            const column = this.column;
            const newExpandedValue = !column.isExpanded();
            this.beans.colGroupSvc.setColumnGroupOpened(column.getProvidedColumnGroup(), newExpandedValue, 'uiColumnExpanded');
        }
    }
    // unlike columns, this will only get called once, as we don't react on props on column groups
    // (we will always destroy and recreate this comp if something changes)
    setDragSource(eHeaderGroup) {
        if (!this.isAlive() || this.isSuppressMoving()) {
            return;
        }
        this.removeDragSource();
        if (!eHeaderGroup) {
            return;
        }
        this.dragSource =
            this.beans.colMoves?.setDragSourceForHeader(eHeaderGroup, this.column, this.displayName) ?? null;
    }
    isSuppressMoving() {
        // if any child is fixed, then don't allow moving
        return (this.gos.get('suppressMovableColumns') ||
            this.column
                .getLeafColumns()
                .some((column) => column.getColDef().suppressMovable || column.getColDef().lockPosition));
    }
    destroy() {
        this.tooltipFeature = this.destroyBean(this.tooltipFeature);
        super.destroy();
    }
}
exports.HeaderGroupCellCtrl = HeaderGroupCellCtrl;


/***/ }),

/***/ 4998:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HeaderGroupComp = void 0;
const userCompUtils_1 = __webpack_require__(12036);
const dom_1 = __webpack_require__(33507);
const event_1 = __webpack_require__(92979);
const generic_1 = __webpack_require__(34422);
const icon_1 = __webpack_require__(59970);
const string_1 = __webpack_require__(37766);
const logging_1 = __webpack_require__(47764);
const component_1 = __webpack_require__(78020);
const HeaderGroupCompElement = {
    tag: 'div',
    cls: 'ag-header-group-cell-label',
    role: 'presentation',
    children: [
        { tag: 'span', ref: 'agLabel', cls: 'ag-header-group-text', role: 'presentation' },
        { tag: 'span', ref: 'agOpened', cls: `ag-header-icon ag-header-expand-icon ag-header-expand-icon-expanded` },
        { tag: 'span', ref: 'agClosed', cls: `ag-header-icon ag-header-expand-icon ag-header-expand-icon-collapsed` },
    ],
};
class HeaderGroupComp extends component_1.Component {
    constructor() {
        super(HeaderGroupCompElement);
        this.agOpened = component_1.RefPlaceholder;
        this.agClosed = component_1.RefPlaceholder;
        this.agLabel = component_1.RefPlaceholder;
        this.isLoadingInnerComponent = false;
    }
    init(params) {
        const { userCompFactory, touchSvc } = this.beans;
        this.params = params;
        this.checkWarnings();
        this.workOutInnerHeaderGroupComponent(userCompFactory, params);
        this.setupLabel(params);
        this.addGroupExpandIcon(params);
        this.setupExpandIcons();
        touchSvc?.setupForHeaderGroup(this);
    }
    checkWarnings() {
        const paramsAny = this.params;
        if (paramsAny.template) {
            (0, logging_1._warn)(89);
        }
    }
    workOutInnerHeaderGroupComponent(userCompFactory, params) {
        const userCompDetails = (0, userCompUtils_1._getInnerHeaderGroupCompDetails)(userCompFactory, params, params);
        if (!userCompDetails) {
            return;
        }
        this.isLoadingInnerComponent = true;
        userCompDetails.newAgStackInstance().then((comp) => {
            this.isLoadingInnerComponent = false;
            if (!comp) {
                return;
            }
            if (this.isAlive()) {
                this.innerHeaderGroupComponent = comp;
                this.agLabel.appendChild(comp.getGui());
            }
            else {
                this.destroyBean(comp);
            }
        });
    }
    setupExpandIcons() {
        const { agOpened, agClosed, params: { columnGroup }, beans, } = this;
        this.addInIcon('columnGroupOpened', agOpened);
        this.addInIcon('columnGroupClosed', agClosed);
        const expandAction = (event) => {
            if ((0, event_1._isStopPropagationForAgGrid)(event)) {
                return;
            }
            const newExpandedValue = !columnGroup.isExpanded();
            beans.colGroupSvc.setColumnGroupOpened(columnGroup.getProvidedColumnGroup(), newExpandedValue, 'uiColumnExpanded');
        };
        this.addTouchAndClickListeners(beans, agClosed, expandAction);
        this.addTouchAndClickListeners(beans, agOpened, expandAction);
        const stopPropagationAction = (event) => {
            (0, event_1._stopPropagationForAgGrid)(event);
        };
        // adding stopPropagation to the double click for the icons prevents double click action happening
        // when the icons are clicked. if the icons are double clicked, then the groups should open and
        // then close again straight away. if we also listened to double click, then the group would open,
        // close, then open, which is not what we want. double click should only action if the user double
        // clicks outside of the icons.
        this.addManagedElementListeners(agClosed, { dblclick: stopPropagationAction });
        this.addManagedElementListeners(agOpened, { dblclick: stopPropagationAction });
        this.addManagedElementListeners(this.getGui(), { dblclick: expandAction });
        this.updateIconVisibility();
        const providedColumnGroup = columnGroup.getProvidedColumnGroup();
        const updateIcon = this.updateIconVisibility.bind(this);
        this.addManagedListeners(providedColumnGroup, {
            expandedChanged: updateIcon,
            expandableChanged: updateIcon,
        });
    }
    addTouchAndClickListeners(beans, eElement, action) {
        beans.touchSvc?.setupForHeaderGroupElement(this, eElement, action);
        this.addManagedElementListeners(eElement, { click: action });
    }
    updateIconVisibility() {
        const { agOpened, agClosed, params: { columnGroup }, } = this;
        if (columnGroup.isExpandable()) {
            const expanded = columnGroup.isExpanded();
            (0, dom_1._setDisplayed)(agOpened, expanded);
            (0, dom_1._setDisplayed)(agClosed, !expanded);
        }
        else {
            (0, dom_1._setDisplayed)(agOpened, false);
            (0, dom_1._setDisplayed)(agClosed, false);
        }
    }
    addInIcon(iconName, element) {
        const eIcon = (0, icon_1._createIconNoSpan)(iconName, this.beans, null);
        if (eIcon) {
            element.appendChild(eIcon);
        }
    }
    addGroupExpandIcon(params) {
        if (!params.columnGroup.isExpandable()) {
            const { agOpened, agClosed } = this;
            (0, dom_1._setDisplayed)(agOpened, false);
            (0, dom_1._setDisplayed)(agClosed, false);
            return;
        }
    }
    setupLabel(params) {
        // no renderer, default text render
        const { displayName, columnGroup } = params;
        const hasInnerComponent = this.innerHeaderGroupComponent || this.isLoadingInnerComponent;
        if ((0, generic_1._exists)(displayName) && !hasInnerComponent) {
            this.agLabel.textContent = (0, string_1._toString)(displayName);
        }
        this.toggleCss('ag-sticky-label', !columnGroup.getColGroupDef()?.suppressStickyLabel);
    }
    destroy() {
        super.destroy();
        if (this.innerHeaderGroupComponent) {
            this.destroyBean(this.innerHeaderGroupComponent);
            this.innerHeaderGroupComponent = undefined;
        }
    }
}
exports.HeaderGroupComp = HeaderGroupComp;


/***/ }),

/***/ 91295:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.refreshFirstAndLastStyles = exports._getToolPanelClassesFromColDef = exports._getHeaderClassesFromColDef = void 0;
const gridOptionsUtils_1 = __webpack_require__(67274);
const generic_1 = __webpack_require__(34422);
const CSS_FIRST_COLUMN = 'ag-column-first';
const CSS_LAST_COLUMN = 'ag-column-last';
function _getHeaderClassesFromColDef(abstractColDef, gos, column, columnGroup) {
    if ((0, generic_1._missing)(abstractColDef)) {
        return [];
    }
    return getColumnClassesFromCollDef(abstractColDef.headerClass, abstractColDef, gos, column, columnGroup);
}
exports._getHeaderClassesFromColDef = _getHeaderClassesFromColDef;
function _getToolPanelClassesFromColDef(abstractColDef, gos, column, columnGroup) {
    if ((0, generic_1._missing)(abstractColDef)) {
        return [];
    }
    return getColumnClassesFromCollDef(abstractColDef.toolPanelClass, abstractColDef, gos, column, columnGroup);
}
exports._getToolPanelClassesFromColDef = _getToolPanelClassesFromColDef;
function refreshFirstAndLastStyles(comp, column, presentedColsService) {
    comp.toggleCss(CSS_FIRST_COLUMN, presentedColsService.isColAtEdge(column, 'first'));
    comp.toggleCss(CSS_LAST_COLUMN, presentedColsService.isColAtEdge(column, 'last'));
}
exports.refreshFirstAndLastStyles = refreshFirstAndLastStyles;
function getClassParams(abstractColDef, gos, column, columnGroup) {
    return (0, gridOptionsUtils_1._addGridCommonParams)(gos, {
        // bad naming, as colDef here can be a group or a column,
        // however most people won't appreciate the difference,
        // so keeping it as colDef to avoid confusion.
        colDef: abstractColDef,
        column: column,
        columnGroup: columnGroup,
    });
}
function getColumnClassesFromCollDef(classesOrFunc, abstractColDef, gos, column, columnGroup) {
    if ((0, generic_1._missing)(classesOrFunc)) {
        return [];
    }
    let classToUse;
    if (typeof classesOrFunc === 'function') {
        const params = getClassParams(abstractColDef, gos, column, columnGroup);
        classToUse = classesOrFunc(params);
    }
    else {
        classToUse = classesOrFunc;
    }
    if (typeof classToUse === 'string') {
        return [classToUse];
    }
    if (Array.isArray(classToUse)) {
        return [...classToUse];
    }
    return [];
}


/***/ }),

/***/ 93290:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HeaderFilterCellComp = void 0;
const dom_1 = __webpack_require__(33507);
const component_1 = __webpack_require__(78020);
const abstractHeaderCellComp_1 = __webpack_require__(59860);
const HeaderFilterCellCompElement = {
    tag: 'div',
    cls: 'ag-header-cell ag-floating-filter',
    role: 'gridcell',
    children: [
        { tag: 'div', ref: 'eFloatingFilterBody', role: 'presentation' },
        {
            tag: 'div',
            ref: 'eButtonWrapper',
            cls: 'ag-floating-filter-button ag-hidden',
            role: 'presentation',
            children: [
                {
                    tag: 'button',
                    ref: 'eButtonShowMainFilter',
                    cls: 'ag-button ag-floating-filter-button-button',
                    attrs: { type: 'button', tabindex: '-1' },
                },
            ],
        },
    ],
};
class HeaderFilterCellComp extends abstractHeaderCellComp_1.AbstractHeaderCellComp {
    constructor(ctrl) {
        super(HeaderFilterCellCompElement, ctrl);
        this.eFloatingFilterBody = component_1.RefPlaceholder;
        this.eButtonWrapper = component_1.RefPlaceholder;
        this.eButtonShowMainFilter = component_1.RefPlaceholder;
    }
    postConstruct() {
        const eGui = this.getGui();
        const compProxy = {
            toggleCss: (cssClassName, on) => this.toggleCss(cssClassName, on),
            setUserStyles: (styles) => (0, dom_1._addStylesToElement)(eGui, styles),
            addOrRemoveBodyCssClass: (cssClassName, on) => this.eFloatingFilterBody.classList.toggle(cssClassName, on),
            setButtonWrapperDisplayed: (displayed) => (0, dom_1._setDisplayed)(this.eButtonWrapper, displayed),
            setCompDetails: (compDetails) => this.setCompDetails(compDetails),
            getFloatingFilterComp: () => this.compPromise,
            setWidth: (width) => (eGui.style.width = width),
            setMenuIcon: (eIcon) => this.eButtonShowMainFilter.appendChild(eIcon),
        };
        this.ctrl.setComp(compProxy, eGui, this.eButtonShowMainFilter, this.eFloatingFilterBody, undefined);
    }
    setCompDetails(compDetails) {
        if (!compDetails) {
            this.destroyFloatingFilterComp();
            this.compPromise = null;
            return;
        }
        // because we are providing defaultFloatingFilterType, we know it will never be undefined;
        this.compPromise = compDetails.newAgStackInstance();
        this.compPromise.then((comp) => this.afterCompCreated(comp));
    }
    destroy() {
        this.destroyFloatingFilterComp();
        super.destroy();
    }
    destroyFloatingFilterComp() {
        if (this.floatingFilterComp) {
            this.eFloatingFilterBody.removeChild(this.floatingFilterComp.getGui());
            this.floatingFilterComp = this.destroyBean(this.floatingFilterComp);
        }
    }
    afterCompCreated(comp) {
        if (!comp) {
            return;
        }
        if (!this.isAlive()) {
            this.destroyBean(comp);
            return;
        }
        this.destroyFloatingFilterComp();
        this.floatingFilterComp = comp;
        this.eFloatingFilterBody.appendChild(comp.getGui());
        if (comp.afterGuiAttached) {
            comp.afterGuiAttached();
        }
    }
}
exports.HeaderFilterCellComp = HeaderFilterCellComp;


/***/ }),

/***/ 33868:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HeaderFilterCellCtrl = void 0;
const emptyBean_1 = __webpack_require__(33789);
const keyCode_1 = __webpack_require__(39853);
const columnFilterUtils_1 = __webpack_require__(4985);
const gridOptionsUtils_1 = __webpack_require__(67274);
const setLeftFeature_1 = __webpack_require__(68703);
const aria_1 = __webpack_require__(95230);
const dom_1 = __webpack_require__(33507);
const event_1 = __webpack_require__(92979);
const focus_1 = __webpack_require__(82331);
const icon_1 = __webpack_require__(59970);
const managedFocusFeature_1 = __webpack_require__(31772);
const abstractHeaderCellCtrl_1 = __webpack_require__(83534);
class HeaderFilterCellCtrl extends abstractHeaderCellCtrl_1.AbstractHeaderCellCtrl {
    constructor() {
        super(...arguments);
        this.iconCreated = false;
    }
    setComp(comp, eGui, eButtonShowMainFilter, eFloatingFilterBody, compBeanInput) {
        this.comp = comp;
        const compBean = (0, emptyBean_1.setupCompBean)(this, this.beans.context, compBeanInput);
        this.eButtonShowMainFilter = eButtonShowMainFilter;
        this.eFloatingFilterBody = eFloatingFilterBody;
        this.setGui(eGui, compBean);
        this.setupActive();
        this.refreshHeaderStyles();
        this.setupWidth(compBean);
        this.setupLeft(compBean);
        this.setupHover(compBean);
        this.setupFocus(compBean);
        this.setupAria();
        this.setupFilterButton();
        this.setupUserComp();
        this.setupSyncWithFilter(compBean);
        this.setupUi();
        compBean.addManagedElementListeners(this.eButtonShowMainFilter, { click: this.showParentFilter.bind(this) });
        this.setupFilterChangedListener(compBean);
        const colDefChanged = () => this.onColDefChanged(compBean);
        compBean.addManagedListeners(this.column, { colDefChanged });
        compBean.addManagedEventListeners({
            filterSwitched: ({ column }) => {
                if (column === this.column) {
                    colDefChanged();
                }
            },
        });
        // Make sure this is the last destroy func as it clears the gui and comp
        compBean.addDestroyFunc(() => {
            this.eButtonShowMainFilter = null;
            this.eFloatingFilterBody = null;
            this.userCompDetails = null;
            this.clearComponent();
        });
    }
    // empty abstract method
    resizeHeader() { }
    moveHeader() {
        // doesn't support move
    }
    getHeaderClassParams() {
        const { column, beans } = this;
        const colDef = column.colDef;
        return (0, gridOptionsUtils_1._addGridCommonParams)(beans.gos, {
            colDef,
            column,
            floatingFilter: true,
        });
    }
    setupActive() {
        const colDef = this.column.getColDef();
        const filterExists = !!colDef.filter;
        const floatingFilterExists = !!colDef.floatingFilter;
        this.active = filterExists && floatingFilterExists;
    }
    setupUi() {
        this.comp.setButtonWrapperDisplayed(!this.suppressFilterButton && this.active);
        this.comp.addOrRemoveBodyCssClass('ag-floating-filter-full-body', this.suppressFilterButton);
        this.comp.addOrRemoveBodyCssClass('ag-floating-filter-body', !this.suppressFilterButton);
        if (!this.active || this.iconCreated) {
            return;
        }
        const eMenuIcon = (0, icon_1._createIconNoSpan)('filter', this.beans, this.column);
        if (eMenuIcon) {
            this.iconCreated = true;
            this.eButtonShowMainFilter.appendChild(eMenuIcon);
        }
    }
    setupFocus(compBean) {
        compBean.createManagedBean(new managedFocusFeature_1.ManagedFocusFeature(this.eGui, {
            shouldStopEventPropagation: this.shouldStopEventPropagation.bind(this),
            onTabKeyDown: this.onTabKeyDown.bind(this),
            handleKeyDown: this.handleKeyDown.bind(this),
            onFocusIn: this.onFocusIn.bind(this),
        }));
    }
    setupAria() {
        const localeTextFunc = this.getLocaleTextFunc();
        (0, aria_1._setAriaLabel)(this.eButtonShowMainFilter, localeTextFunc('ariaFilterMenuOpen', 'Open Filter Menu'));
    }
    onTabKeyDown(e) {
        const { beans } = this;
        const activeEl = (0, gridOptionsUtils_1._getActiveDomElement)(beans);
        const wrapperHasFocus = activeEl === this.eGui;
        if (wrapperHasFocus) {
            return;
        }
        const nextFocusableEl = (0, focus_1._findNextFocusableElement)(beans, this.eGui, null, e.shiftKey);
        if (nextFocusableEl) {
            beans.headerNavigation?.scrollToColumn(this.column);
            e.preventDefault();
            nextFocusableEl.focus();
            return;
        }
        const nextFocusableColumn = this.findNextColumnWithFloatingFilter(e.shiftKey);
        if (!nextFocusableColumn) {
            return;
        }
        if (beans.focusSvc.focusHeaderPosition({
            headerPosition: {
                headerRowIndex: this.rowCtrl.rowIndex,
                column: nextFocusableColumn,
            },
            event: e,
        })) {
            e.preventDefault();
        }
    }
    findNextColumnWithFloatingFilter(backwards) {
        const presentedColsService = this.beans.visibleCols;
        let nextCol = this.column;
        do {
            nextCol = backwards
                ? presentedColsService.getColBefore(nextCol)
                : presentedColsService.getColAfter(nextCol);
            if (!nextCol) {
                break;
            }
        } while (!nextCol.getColDef().filter || !nextCol.getColDef().floatingFilter);
        return nextCol;
    }
    handleKeyDown(e) {
        super.handleKeyDown(e);
        const wrapperHasFocus = this.getWrapperHasFocus();
        switch (e.key) {
            case keyCode_1.KeyCode.UP:
            case keyCode_1.KeyCode.DOWN:
            case keyCode_1.KeyCode.LEFT:
            case keyCode_1.KeyCode.RIGHT:
                if (wrapperHasFocus) {
                    return;
                }
                (0, event_1._stopPropagationForAgGrid)(e);
            // eslint-disable-next-line no-fallthrough
            case keyCode_1.KeyCode.ENTER:
                if (wrapperHasFocus) {
                    if ((0, focus_1._focusInto)(this.eGui)) {
                        e.preventDefault();
                    }
                }
                break;
            case keyCode_1.KeyCode.ESCAPE:
                if (!wrapperHasFocus) {
                    this.eGui.focus();
                }
        }
    }
    onFocusIn(e) {
        const isRelatedWithin = this.eGui.contains(e.relatedTarget);
        // when the focus is already within the component,
        // we default to the browser's behavior
        if (isRelatedWithin) {
            return;
        }
        const notFromHeaderWrapper = !!e.relatedTarget && !e.relatedTarget.classList.contains('ag-floating-filter');
        const fromWithinHeader = !!e.relatedTarget && (0, dom_1._isElementChildOfClass)(e.relatedTarget, 'ag-floating-filter');
        if (notFromHeaderWrapper && fromWithinHeader && e.target === this.eGui) {
            const lastFocusEvent = this.lastFocusEvent;
            const fromTab = !!(lastFocusEvent && lastFocusEvent.key === keyCode_1.KeyCode.TAB);
            if (lastFocusEvent && fromTab) {
                const shouldFocusLast = lastFocusEvent.shiftKey;
                (0, focus_1._focusInto)(this.eGui, shouldFocusLast);
            }
        }
        this.focusThis();
    }
    setupHover(compBean) {
        this.beans.colHover?.addHeaderFilterColumnHoverListener(compBean, this.comp, this.column, this.eGui);
    }
    setupLeft(compBean) {
        const setLeftFeature = new setLeftFeature_1.SetLeftFeature(this.column, this.eGui, this.beans);
        compBean.createManagedBean(setLeftFeature);
    }
    setupFilterButton() {
        this.suppressFilterButton = !this.beans.menuSvc?.isFloatingFilterButtonEnabled(this.column);
        this.highlightFilterButtonWhenActive = !(0, gridOptionsUtils_1._isLegacyMenuEnabled)(this.gos);
    }
    setupUserComp() {
        if (!this.active) {
            return;
        }
        const compDetails = this.beans.colFilter?.getFloatingFilterCompDetails(this.column, () => this.showParentFilter());
        if (compDetails) {
            this.setCompDetails(compDetails);
        }
    }
    setCompDetails(compDetails) {
        this.userCompDetails = compDetails;
        this.comp.setCompDetails(compDetails);
    }
    showParentFilter() {
        const eventSource = this.suppressFilterButton ? this.eFloatingFilterBody : this.eButtonShowMainFilter;
        this.beans.menuSvc?.showFilterMenu({
            column: this.column,
            buttonElement: eventSource,
            containerType: 'floatingFilter',
            positionBy: 'button',
        });
    }
    setupSyncWithFilter(compBean) {
        if (!this.active) {
            return;
        }
        const { beans: { colFilter }, column, gos, } = this;
        const syncWithFilter = (event) => {
            if (event?.source === 'filterDestroyed' && (!this.isAlive() || !colFilter?.isAlive())) {
                return;
            }
            const compPromise = this.comp.getFloatingFilterComp();
            if (!compPromise) {
                return;
            }
            compPromise.then((comp) => {
                if (comp) {
                    if (gos.get('enableFilterHandlers')) {
                        const eventWithParams = event;
                        let source = 'filter';
                        if (eventWithParams?.afterFloatingFilter) {
                            source = 'ui';
                        }
                        else if (eventWithParams?.afterDataChange) {
                            source = 'dataChanged';
                        }
                        else if (event?.source === 'api') {
                            source = 'api';
                        }
                        this.updateFloatingFilterParams(this.userCompDetails, source);
                        return;
                    }
                    const parentModel = colFilter?.getCurrentFloatingFilterParentModel(column);
                    const filterChangedEvent = event
                        ? {
                            // event can have additional params like `afterDataChange` which need to be passed through
                            ...event,
                            columns: event.columns ?? [],
                            source: event.source === 'api' ? 'api' : 'columnFilter',
                        }
                        : null;
                    comp.onParentModelChanged(parentModel, filterChangedEvent);
                }
            });
        };
        [this.destroySyncListener] = compBean.addManagedListeners(column, { filterChanged: syncWithFilter });
        if (colFilter?.isFilterActive(column)) {
            syncWithFilter(null);
        }
    }
    setupWidth(compBean) {
        const listener = () => {
            const width = `${this.column.getActualWidth()}px`;
            this.comp.setWidth(width);
        };
        compBean.addManagedListeners(this.column, { widthChanged: listener });
        listener();
    }
    setupFilterChangedListener(compBean) {
        if (this.active) {
            [this.destroyFilterChangedListener] = compBean.addManagedListeners(this.column, {
                filterChanged: this.updateFilterButton.bind(this),
            });
            this.updateFilterButton();
        }
    }
    updateFilterButton() {
        if (!this.suppressFilterButton && this.comp) {
            const isFilterAllowed = !!this.beans.filterManager?.isFilterAllowed(this.column);
            this.comp.setButtonWrapperDisplayed(isFilterAllowed);
            if (this.highlightFilterButtonWhenActive && isFilterAllowed) {
                this.eButtonShowMainFilter.classList.toggle('ag-filter-active', this.column.isFilterActive());
            }
        }
    }
    onColDefChanged(compBean) {
        const wasActive = this.active;
        this.setupActive();
        const becomeActive = !wasActive && this.active;
        if (wasActive && !this.active) {
            this.destroySyncListener();
            this.destroyFilterChangedListener();
        }
        const colFilter = this.beans.colFilter;
        const newCompDetails = this.active
            ? colFilter?.getFloatingFilterCompDetails(this.column, () => this.showParentFilter())
            : null;
        const compPromise = this.comp.getFloatingFilterComp();
        if (!compPromise || !newCompDetails) {
            this.updateCompDetails(compBean, newCompDetails, becomeActive);
        }
        else {
            compPromise.then((compInstance) => {
                if (!compInstance || colFilter?.areFilterCompsDifferent(this.userCompDetails ?? null, newCompDetails)) {
                    this.updateCompDetails(compBean, newCompDetails, becomeActive);
                }
                else {
                    this.updateFloatingFilterParams(newCompDetails, 'colDef');
                }
            });
        }
    }
    updateCompDetails(compBean, compDetails, becomeActive) {
        if (!this.isAlive()) {
            return;
        }
        this.setCompDetails(compDetails);
        // filter button and UI can change based on params, so always want to update
        this.setupFilterButton();
        this.setupUi();
        if (becomeActive) {
            this.setupSyncWithFilter(compBean);
            this.setupFilterChangedListener(compBean);
        }
    }
    updateFloatingFilterParams(userCompDetails, source) {
        if (!userCompDetails) {
            return;
        }
        let params = userCompDetails.params;
        this.comp.getFloatingFilterComp()?.then((floatingFilter) => {
            if (typeof floatingFilter?.refresh === 'function') {
                if (this.gos.get('enableFilterHandlers')) {
                    params = {
                        ...params,
                        model: (0, columnFilterUtils_1._getFilterModel)(this.beans.colFilter?.model ?? {}, this.column.getColId()),
                        source,
                    };
                }
                floatingFilter.refresh(params);
            }
        });
    }
    addResizeAndMoveKeyboardListeners() {
        // do nothing
    }
    destroy() {
        super.destroy();
        this.destroySyncListener = null;
        this.destroyFilterChangedListener = null;
    }
}
exports.HeaderFilterCellCtrl = HeaderFilterCellCtrl;


/***/ }),

/***/ 88078:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColumnGroupHeaderCompModule = exports.ColumnHeaderCompModule = void 0;
const version_1 = __webpack_require__(97205);
const headerComp_1 = __webpack_require__(49270);
const headerGroupComp_1 = __webpack_require__(4998);
/**
 * @feature Columns -> Column Header
 * @colDef headerComponent
 */
exports.ColumnHeaderCompModule = {
    moduleName: 'ColumnHeaderComp',
    version: version_1.VERSION,
    userComponents: {
        agColumnHeader: headerComp_1.HeaderComp,
    },
    icons: {
        // button to launch legacy column menu
        menu: 'menu',
        // button to launch new enterprise column menu
        menuAlt: 'menu-alt',
    },
};
/**
 * @feature Columns -> Column Groups
 * @colGroupDef headerGroupComponent
 */
exports.ColumnGroupHeaderCompModule = {
    moduleName: 'ColumnGroupHeaderComp',
    version: version_1.VERSION,
    userComponents: {
        agColumnGroupHeader: headerGroupComp_1.HeaderGroupComp,
    },
    icons: {
        // header column group shown when expanded (click to contract)
        columnGroupOpened: 'expanded',
        // header column group shown when contracted (click to expand)
        columnGroupClosed: 'contracted',
    },
};


/***/ }),

/***/ 38791:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GridHeaderSelector = exports.GridHeaderComp = void 0;
const component_1 = __webpack_require__(78020);
const gridHeaderCtrl_1 = __webpack_require__(70009);
const headerRowContainerComp_1 = __webpack_require__(77260);
const GridHeaderElement = { tag: 'div', cls: 'ag-header', role: 'presentation' };
class GridHeaderComp extends component_1.Component {
    constructor() {
        super(GridHeaderElement);
    }
    postConstruct() {
        const compProxy = {
            toggleCss: (cssClassName, on) => this.toggleCss(cssClassName, on),
            setHeightAndMinHeight: (height) => {
                this.getGui().style.height = height;
                this.getGui().style.minHeight = height;
            },
        };
        const ctrl = this.createManagedBean(new gridHeaderCtrl_1.GridHeaderCtrl());
        ctrl.setComp(compProxy, this.getGui(), this.getFocusableElement());
        const addContainer = (container) => {
            this.createManagedBean(container);
            this.appendChild(container);
        };
        addContainer(new headerRowContainerComp_1.HeaderRowContainerComp('left'));
        addContainer(new headerRowContainerComp_1.HeaderRowContainerComp(null));
        addContainer(new headerRowContainerComp_1.HeaderRowContainerComp('right'));
    }
}
exports.GridHeaderComp = GridHeaderComp;
exports.GridHeaderSelector = {
    selector: 'AG-HEADER-ROOT',
    component: GridHeaderComp,
};


/***/ }),

/***/ 70009:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GridHeaderCtrl = void 0;
const keyCode_1 = __webpack_require__(39853);
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const dom_1 = __webpack_require__(33507);
const focus_1 = __webpack_require__(82331);
const generic_1 = __webpack_require__(34422);
const managedFocusFeature_1 = __webpack_require__(31772);
const headerUtils_1 = __webpack_require__(1323);
class GridHeaderCtrl extends beanStub_1.BeanStub {
    setComp(comp, eGui, eFocusableElement) {
        this.comp = comp;
        this.eGui = eGui;
        const { beans } = this;
        const { headerNavigation, touchSvc, ctrlsSvc } = beans;
        if (headerNavigation) {
            this.createManagedBean(new managedFocusFeature_1.ManagedFocusFeature(eFocusableElement, {
                onTabKeyDown: this.onTabKeyDown.bind(this),
                handleKeyDown: this.handleKeyDown.bind(this),
                onFocusOut: this.onFocusOut.bind(this),
            }));
        }
        // for setting ag-pivot-on / ag-pivot-off CSS classes
        this.addManagedEventListeners({
            columnPivotModeChanged: this.onPivotModeChanged.bind(this, beans),
            displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this, beans),
        });
        this.onPivotModeChanged(beans);
        this.setupHeaderHeight();
        const listener = this.onHeaderContextMenu.bind(this);
        this.addManagedElementListeners(this.eGui, { contextmenu: listener });
        touchSvc?.mockHeaderContextMenu(this, listener);
        ctrlsSvc.register('gridHeaderCtrl', this);
    }
    setupHeaderHeight() {
        const listener = this.setHeaderHeight.bind(this);
        listener();
        this.addManagedPropertyListeners([
            'headerHeight',
            'pivotHeaderHeight',
            'groupHeaderHeight',
            'pivotGroupHeaderHeight',
            'floatingFiltersHeight',
        ], listener);
        this.addManagedEventListeners({
            displayedColumnsChanged: listener,
            columnHeaderHeightChanged: listener,
            // add this to the animation frame to avoid a feedback loop
            columnGroupHeaderHeightChanged: () => (0, dom_1._requestAnimationFrame)(this.beans, () => listener()),
            gridStylesChanged: listener,
            advancedFilterEnabledChanged: listener,
        });
    }
    setHeaderHeight() {
        const { beans } = this;
        let totalHeaderHeight = 0;
        const groupHeight = (0, headerUtils_1.getGroupRowsHeight)(beans).reduce((prev, curr) => prev + curr, 0);
        const headerHeight = (0, headerUtils_1.getColumnHeaderRowHeight)(beans);
        if (beans.filterManager?.hasFloatingFilters()) {
            totalHeaderHeight += (0, headerUtils_1.getFloatingFiltersHeight)(beans);
        }
        totalHeaderHeight += groupHeight;
        totalHeaderHeight += headerHeight;
        if (this.headerHeight === totalHeaderHeight) {
            return;
        }
        this.headerHeight = totalHeaderHeight;
        // one extra pixel is needed here to account for the
        // height of the border
        const px = `${totalHeaderHeight + 1}px`;
        this.comp.setHeightAndMinHeight(px);
        this.eventSvc.dispatchEvent({
            type: 'headerHeightChanged',
        });
    }
    onPivotModeChanged(beans) {
        const pivotMode = beans.colModel.isPivotMode();
        this.comp.toggleCss('ag-pivot-on', pivotMode);
        this.comp.toggleCss('ag-pivot-off', !pivotMode);
    }
    onDisplayedColumnsChanged(beans) {
        const columns = beans.visibleCols.allCols;
        const shouldAllowOverflow = columns.some((col) => col.isSpanHeaderHeight());
        this.comp.toggleCss('ag-header-allow-overflow', shouldAllowOverflow);
    }
    onTabKeyDown(e) {
        const isRtl = this.gos.get('enableRtl');
        const backwards = e.shiftKey;
        const direction = backwards !== isRtl ? 'LEFT' : 'RIGHT';
        const { beans } = this;
        const { headerNavigation, focusSvc } = beans;
        if (headerNavigation.navigateHorizontally(direction, true, e) ||
            (!backwards && focusSvc.focusOverlay(false)) ||
            (0, focus_1._focusNextGridCoreContainer)(beans, backwards, true)) {
            // preventDefault so that the tab key doesn't cause focus to get lost
            e.preventDefault();
        }
    }
    handleKeyDown(e) {
        let direction = null;
        const { headerNavigation } = this.beans;
        switch (e.key) {
            case keyCode_1.KeyCode.LEFT:
                direction = 'LEFT';
            // eslint-disable-next-line no-fallthrough
            case keyCode_1.KeyCode.RIGHT: {
                if (!(0, generic_1._exists)(direction)) {
                    direction = 'RIGHT';
                }
                if (headerNavigation.navigateHorizontally(direction, false, e)) {
                    // preventDefault so that the arrow keys don't cause an extra scroll
                    e.preventDefault();
                }
                break;
            }
            case keyCode_1.KeyCode.UP:
                direction = 'UP';
            // eslint-disable-next-line no-fallthrough
            case keyCode_1.KeyCode.DOWN: {
                if (!(0, generic_1._exists)(direction)) {
                    direction = 'DOWN';
                }
                if (headerNavigation.navigateVertically(direction, e)) {
                    // preventDefault so that the arrow keys don't cause an extra scroll
                    e.preventDefault();
                }
                break;
            }
            default:
                return;
        }
    }
    onFocusOut(e) {
        const { relatedTarget } = e;
        const { eGui, beans } = this;
        if (!relatedTarget && eGui.contains((0, gridOptionsUtils_1._getActiveDomElement)(beans))) {
            return;
        }
        if (!eGui.contains(relatedTarget)) {
            beans.focusSvc.focusedHeader = null;
        }
    }
    onHeaderContextMenu(mouseEvent, touch, touchEvent) {
        const { menuSvc, ctrlsSvc } = this.beans;
        if ((!mouseEvent && !touchEvent) || !menuSvc?.isHeaderContextMenuEnabled()) {
            return;
        }
        const { target } = (mouseEvent ?? touch);
        if (target === this.eGui || target === ctrlsSvc.getHeaderRowContainerCtrl()?.eViewport) {
            menuSvc.showHeaderContextMenu(undefined, mouseEvent, touchEvent);
        }
    }
}
exports.GridHeaderCtrl = GridHeaderCtrl;


/***/ }),

/***/ 1323:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getFloatingFiltersHeight = exports.getHeaderHeight = exports.getColumnHeaderRowHeight = exports.getGroupRowsHeight = exports.getFocusHeaderRowCount = exports.getHeaderRowCount = void 0;
// + gridPanel -> for resizing the body and setting top margin
function getHeaderRowCount(colModel) {
    return colModel.cols ? colModel.cols.treeDepth + 1 : -1;
}
exports.getHeaderRowCount = getHeaderRowCount;
function getFocusHeaderRowCount(beans) {
    return beans.ctrlsSvc.getHeaderRowContainerCtrl()?.getRowCount() ?? 0;
}
exports.getFocusHeaderRowCount = getFocusHeaderRowCount;
function getGroupRowsHeight(beans) {
    const heights = [];
    const headerRowContainerCtrls = beans.ctrlsSvc.getHeaderRowContainerCtrls();
    for (const headerRowContainerCtrl of headerRowContainerCtrls) {
        if (!headerRowContainerCtrl) {
            continue;
        }
        const groupRowCount = headerRowContainerCtrl.getGroupRowCount() || 0;
        for (let i = 0; i < groupRowCount; i++) {
            const headerRowCtrl = headerRowContainerCtrl.getGroupRowCtrlAtIndex(i);
            const currentHeightAtPos = heights[i];
            if (headerRowCtrl) {
                const newHeight = getColumnGroupHeaderRowHeight(beans, headerRowCtrl);
                if (currentHeightAtPos == null || newHeight > currentHeightAtPos) {
                    heights[i] = newHeight;
                }
            }
        }
    }
    return heights;
}
exports.getGroupRowsHeight = getGroupRowsHeight;
function getColumnGroupHeaderRowHeight(beans, headerRowCtrl) {
    const defaultHeight = beans.colModel.isPivotMode() ? getPivotGroupHeaderHeight(beans) : getGroupHeaderHeight(beans);
    let maxDisplayedHeight = defaultHeight;
    const headerRowCellCtrls = headerRowCtrl.getHeaderCellCtrls();
    for (const headerCellCtrl of headerRowCellCtrls) {
        const { column } = headerCellCtrl;
        const height = column.getAutoHeaderHeight();
        if (height != null && height > maxDisplayedHeight && column.isAutoHeaderHeight()) {
            maxDisplayedHeight = height;
        }
    }
    return maxDisplayedHeight;
}
function getColumnHeaderRowHeight(beans) {
    const defaultHeight = beans.colModel.isPivotMode() ? getPivotHeaderHeight(beans) : getHeaderHeight(beans);
    let maxDisplayedHeight = defaultHeight;
    beans.colModel.forAllCols((col) => {
        const height = col.getAutoHeaderHeight();
        if (height != null && height > maxDisplayedHeight && col.isAutoHeaderHeight()) {
            maxDisplayedHeight = height;
        }
    });
    return maxDisplayedHeight;
}
exports.getColumnHeaderRowHeight = getColumnHeaderRowHeight;
function getHeaderHeight(beans) {
    return beans.gos.get('headerHeight') ?? beans.environment.getDefaultHeaderHeight();
}
exports.getHeaderHeight = getHeaderHeight;
function getFloatingFiltersHeight(beans) {
    return beans.gos.get('floatingFiltersHeight') ?? getHeaderHeight(beans);
}
exports.getFloatingFiltersHeight = getFloatingFiltersHeight;
function getGroupHeaderHeight(beans) {
    return beans.gos.get('groupHeaderHeight') ?? getHeaderHeight(beans);
}
function getPivotHeaderHeight(beans) {
    return beans.gos.get('pivotHeaderHeight') ?? getHeaderHeight(beans);
}
function getPivotGroupHeaderHeight(beans) {
    return beans.gos.get('pivotGroupHeaderHeight') ?? getGroupHeaderHeight(beans);
}


/***/ }),

/***/ 28866:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HeaderRowComp = void 0;
const aria_1 = __webpack_require__(95230);
const dom_1 = __webpack_require__(33507);
const component_1 = __webpack_require__(78020);
const headerCellComp_1 = __webpack_require__(21906);
const headerGroupCellComp_1 = __webpack_require__(87746);
const headerFilterCellComp_1 = __webpack_require__(93290);
class HeaderRowComp extends component_1.Component {
    constructor(ctrl) {
        super({ tag: 'div', cls: ctrl.headerRowClass, role: 'row' });
        this.ctrl = ctrl;
        this.headerComps = {};
    }
    postConstruct() {
        (0, aria_1._setAriaRowIndex)(this.getGui(), this.ctrl.getAriaRowIndex());
        const compProxy = {
            setHeight: (height) => (this.getGui().style.height = height),
            setTop: (top) => (this.getGui().style.top = top),
            setHeaderCtrls: (ctrls, forceOrder) => this.setHeaderCtrls(ctrls, forceOrder),
            setWidth: (width) => (this.getGui().style.width = width),
        };
        this.ctrl.setComp(compProxy, undefined);
    }
    destroy() {
        this.setHeaderCtrls([], false);
        super.destroy();
    }
    setHeaderCtrls(ctrls, forceOrder) {
        if (!this.isAlive()) {
            return;
        }
        const oldComps = this.headerComps;
        this.headerComps = {};
        ctrls.forEach((ctrl) => {
            const id = ctrl.instanceId;
            let comp = oldComps[id];
            delete oldComps[id];
            if (comp == null) {
                comp = this.createHeaderComp(ctrl);
                this.getGui().appendChild(comp.getGui());
            }
            this.headerComps[id] = comp;
        });
        Object.values(oldComps).forEach((comp) => {
            this.getGui().removeChild(comp.getGui());
            this.destroyBean(comp);
        });
        if (forceOrder) {
            const comps = Object.values(this.headerComps);
            // ordering the columns by left position orders them in the order they appear on the screen
            comps.sort((a, b) => {
                const leftA = a.getCtrl().column.getLeft();
                const leftB = b.getCtrl().column.getLeft();
                return leftA - leftB;
            });
            const elementsInOrder = comps.map((c) => c.getGui());
            (0, dom_1._setDomChildOrder)(this.getGui(), elementsInOrder);
        }
    }
    createHeaderComp(headerCtrl) {
        let result;
        switch (this.ctrl.type) {
            case 'group':
                result = new headerGroupCellComp_1.HeaderGroupCellComp(headerCtrl);
                break;
            case 'filter':
                result = new headerFilterCellComp_1.HeaderFilterCellComp(headerCtrl);
                break;
            default:
                result = new headerCellComp_1.HeaderCellComp(headerCtrl);
                break;
        }
        this.createBean(result);
        result.setParentComponent(this);
        return result;
    }
}
exports.HeaderRowComp = HeaderRowComp;


/***/ }),

/***/ 82868:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HeaderRowCtrl = void 0;
const emptyBean_1 = __webpack_require__(33789);
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const headerCellCtrl_1 = __webpack_require__(20260);
const headerUtils_1 = __webpack_require__(1323);
let instanceIdSequence = 0;
class HeaderRowCtrl extends beanStub_1.BeanStub {
    constructor(rowIndex, pinned, type) {
        super();
        this.rowIndex = rowIndex;
        this.pinned = pinned;
        this.type = type;
        this.instanceId = instanceIdSequence++;
        this.allCtrls = [];
        const typeClass = type == 'group'
            ? `ag-header-row-column-group`
            : type == 'filter'
                ? `ag-header-row-column-filter`
                : `ag-header-row-column`;
        this.headerRowClass = `ag-header-row ${typeClass}`;
    }
    postConstruct() {
        this.isPrintLayout = (0, gridOptionsUtils_1._isDomLayout)(this.gos, 'print');
        this.isEnsureDomOrder = this.gos.get('ensureDomOrder');
    }
    /** Checks that every header cell that is currently visible has been rendered.
     * Can only be false under some circumstances when using React
     */
    areCellsRendered() {
        if (!this.comp) {
            return false;
        }
        return this.allCtrls.every((ctrl) => ctrl.eGui != null);
    }
    /**
     *
     * @param comp Proxy to the actual component
     * @param initCompState Should the component be initialised with the current state of the controller. Default: true
     */
    setComp(comp, compBean, initCompState = true) {
        this.comp = comp;
        compBean = (0, emptyBean_1.setupCompBean)(this, this.beans.context, compBean);
        if (initCompState) {
            this.onRowHeightChanged();
            this.onVirtualColumnsChanged();
        }
        // width is managed directly regardless of framework and so is not included in initCompState
        this.setWidth();
        this.addEventListeners(compBean);
    }
    getAriaRowIndex() {
        return this.rowIndex + 1;
    }
    addEventListeners(compBean) {
        const onHeightChanged = this.onRowHeightChanged.bind(this);
        const onDisplayedColumnsChanged = this.onDisplayedColumnsChanged.bind(this);
        compBean.addManagedEventListeners({
            columnResized: this.setWidth.bind(this),
            displayedColumnsChanged: onDisplayedColumnsChanged,
            virtualColumnsChanged: (params) => this.onVirtualColumnsChanged(params.afterScroll),
            columnGroupHeaderHeightChanged: onHeightChanged,
            columnHeaderHeightChanged: onHeightChanged,
            gridStylesChanged: onHeightChanged,
            advancedFilterEnabledChanged: onHeightChanged,
        });
        // when print layout changes, it changes what columns are in what section
        compBean.addManagedPropertyListener('domLayout', onDisplayedColumnsChanged);
        compBean.addManagedPropertyListener('ensureDomOrder', (e) => (this.isEnsureDomOrder = e.currentValue));
        compBean.addManagedPropertyListeners([
            'headerHeight',
            'pivotHeaderHeight',
            'groupHeaderHeight',
            'pivotGroupHeaderHeight',
            'floatingFiltersHeight',
        ], onHeightChanged);
    }
    onDisplayedColumnsChanged() {
        this.isPrintLayout = (0, gridOptionsUtils_1._isDomLayout)(this.gos, 'print');
        this.onVirtualColumnsChanged();
        this.setWidth();
        this.onRowHeightChanged();
    }
    setWidth() {
        const width = this.getWidthForRow();
        this.comp.setWidth(`${width}px`);
    }
    getWidthForRow() {
        const { visibleCols } = this.beans;
        if (this.isPrintLayout) {
            const pinned = this.pinned != null;
            if (pinned) {
                return 0;
            }
            return (visibleCols.getContainerWidth('right') +
                visibleCols.getContainerWidth('left') +
                visibleCols.getContainerWidth(null));
        }
        // if not printing, just return the width as normal
        return visibleCols.getContainerWidth(this.pinned);
    }
    onRowHeightChanged() {
        const { topOffset, rowHeight } = this.getTopAndHeight();
        this.comp.setTop(topOffset + 'px');
        this.comp.setHeight(rowHeight + 'px');
    }
    getTopAndHeight() {
        const { filterManager } = this.beans;
        const sizes = [];
        const groupHeadersHeight = (0, headerUtils_1.getGroupRowsHeight)(this.beans);
        const headerHeight = (0, headerUtils_1.getColumnHeaderRowHeight)(this.beans);
        sizes.push(...groupHeadersHeight);
        sizes.push(headerHeight);
        if (filterManager?.hasFloatingFilters()) {
            sizes.push((0, headerUtils_1.getFloatingFiltersHeight)(this.beans));
        }
        let topOffset = 0;
        for (let i = 0; i < this.rowIndex; i++) {
            topOffset += sizes[i];
        }
        const rowHeight = sizes[this.rowIndex];
        return { topOffset, rowHeight };
    }
    onVirtualColumnsChanged(afterScroll = false) {
        const ctrlsToDisplay = this.getUpdatedHeaderCtrls();
        const forceOrder = this.isEnsureDomOrder || this.isPrintLayout;
        this.comp.setHeaderCtrls(ctrlsToDisplay, forceOrder, afterScroll);
    }
    /**
     * Recycles the header cell ctrls and creates new ones for the columns in the viewport
     * @returns The updated header cell ctrls
     */
    getUpdatedHeaderCtrls() {
        const oldCtrls = this.ctrlsById;
        this.ctrlsById = new Map();
        const columns = this.getColumnsInViewport();
        for (const child of columns) {
            this.recycleAndCreateHeaderCtrls(child, this.ctrlsById, oldCtrls);
        }
        // we want to keep columns that are focused, otherwise keyboard navigation breaks
        const isFocusedAndDisplayed = (ctrl) => {
            const { focusSvc, visibleCols } = this.beans;
            const isFocused = focusSvc.isHeaderWrapperFocused(ctrl);
            if (!isFocused) {
                return false;
            }
            const isDisplayed = visibleCols.isVisible(ctrl.column);
            return isDisplayed;
        };
        if (oldCtrls) {
            for (const [id, oldCtrl] of oldCtrls) {
                const keepCtrl = isFocusedAndDisplayed(oldCtrl);
                if (keepCtrl) {
                    this.ctrlsById.set(id, oldCtrl);
                }
                else {
                    this.destroyBean(oldCtrl);
                }
            }
        }
        this.allCtrls = Array.from(this.ctrlsById.values());
        return this.allCtrls;
    }
    /** Get the current header cell ctrls */
    getHeaderCellCtrls() {
        return this.allCtrls;
    }
    recycleAndCreateHeaderCtrls(headerColumn, currCtrls, oldCtrls) {
        // skip groups that have no displayed children. this can happen when the group is broken,
        // and this section happens to have nothing to display for the open / closed state.
        // (a broken group is one that is split, ie columns in the group have a non-group column
        // in between them)
        if (headerColumn.isEmptyGroup()) {
            return;
        }
        const idOfChild = headerColumn.getUniqueId();
        // if we already have this cell rendered, do nothing
        let headerCtrl;
        if (oldCtrls) {
            headerCtrl = oldCtrls.get(idOfChild);
            oldCtrls.delete(idOfChild);
        }
        // it's possible there is a new Column with the same ID, but it's for a different Column.
        // this is common with pivoting, where the pivot cols change, but the id's are still pivot_0,
        // pivot_1 etc. so if new col but same ID, need to remove the old col here first as we are
        // about to replace it in the this.headerComps map.
        const forOldColumn = headerCtrl && headerCtrl.column != headerColumn;
        if (forOldColumn) {
            this.destroyBean(headerCtrl);
            headerCtrl = undefined;
        }
        if (headerCtrl == null) {
            switch (this.type) {
                case 'filter': {
                    headerCtrl = this.createBean(this.beans.registry.createDynamicBean('headerFilterCellCtrl', true, headerColumn, this));
                    break;
                }
                case 'group':
                    headerCtrl = this.createBean(this.beans.registry.createDynamicBean('headerGroupCellCtrl', true, headerColumn, this));
                    break;
                default:
                    headerCtrl = this.createBean(new headerCellCtrl_1.HeaderCellCtrl(headerColumn, this));
                    break;
            }
        }
        currCtrls.set(idOfChild, headerCtrl);
    }
    getColumnsInViewport() {
        return this.isPrintLayout ? this.getColumnsInViewportPrintLayout() : this.getColumnsInViewportNormalLayout();
    }
    getColumnsInViewportPrintLayout() {
        // for print layout, we add all columns into the center
        if (this.pinned != null) {
            return [];
        }
        let viewportColumns = [];
        const actualDepth = this.getActualDepth();
        const { colViewport } = this.beans;
        ['left', null, 'right'].forEach((pinned) => {
            const items = colViewport.getHeadersToRender(pinned, actualDepth);
            viewportColumns = viewportColumns.concat(items);
        });
        return viewportColumns;
    }
    getActualDepth() {
        return this.type == 'filter' ? this.rowIndex - 1 : this.rowIndex;
    }
    getColumnsInViewportNormalLayout() {
        // when in normal layout, we add the columns for that container only
        return this.beans.colViewport.getHeadersToRender(this.pinned, this.getActualDepth());
    }
    focusHeader(column, event) {
        const ctrl = this.allCtrls.find((ctrl) => ctrl.column == column);
        if (!ctrl) {
            return false;
        }
        const focused = ctrl.focus(event);
        return focused;
    }
    destroy() {
        this.allCtrls = this.destroyBeans(this.allCtrls);
        this.ctrlsById = undefined;
        super.destroy();
    }
}
exports.HeaderRowCtrl = HeaderRowCtrl;


/***/ }),

/***/ 77260:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HeaderRowContainerComp = void 0;
const dom_1 = __webpack_require__(33507);
const component_1 = __webpack_require__(78020);
const headerRowComp_1 = __webpack_require__(28866);
const headerRowContainerCtrl_1 = __webpack_require__(98934);
const PinnedLeftElement = { tag: 'div', cls: 'ag-pinned-left-header', role: 'rowgroup' };
const PinnedRightElement = { tag: 'div', cls: 'ag-pinned-right-header', role: 'rowgroup' };
const CenterElement = {
    tag: 'div',
    cls: 'ag-header-viewport',
    role: 'presentation',
    attrs: { tabindex: '-1' },
    children: [{ tag: 'div', ref: 'eCenterContainer', cls: 'ag-header-container', role: 'rowgroup' }],
};
class HeaderRowContainerComp extends component_1.Component {
    constructor(pinned) {
        super();
        this.eCenterContainer = component_1.RefPlaceholder;
        this.headerRowComps = {};
        this.rowCompsList = [];
        this.pinned = pinned;
    }
    postConstruct() {
        this.selectAndSetTemplate();
        const compProxy = {
            setDisplayed: (displayed) => this.setDisplayed(displayed),
            setCtrls: (ctrls) => this.setCtrls(ctrls),
            // only gets called for center section
            setCenterWidth: (width) => (this.eCenterContainer.style.width = width),
            setViewportScrollLeft: (left) => (this.getGui().scrollLeft = left),
            // only gets called for pinned sections
            setPinnedContainerWidth: (width) => {
                const eGui = this.getGui();
                eGui.style.width = width;
                eGui.style.maxWidth = width;
                eGui.style.minWidth = width;
            },
        };
        const ctrl = this.createManagedBean(new headerRowContainerCtrl_1.HeaderRowContainerCtrl(this.pinned));
        ctrl.setComp(compProxy, this.getGui());
    }
    selectAndSetTemplate() {
        const pinnedLeft = this.pinned == 'left';
        const pinnedRight = this.pinned == 'right';
        const template = pinnedLeft ? PinnedLeftElement : pinnedRight ? PinnedRightElement : CenterElement;
        this.setTemplate(template);
        // for left and right, we add rows directly to the root element,
        // but for center container we add elements to the child container.
        this.eRowContainer = this.eCenterContainer !== component_1.RefPlaceholder ? this.eCenterContainer : this.getGui();
    }
    destroy() {
        this.setCtrls([]);
        super.destroy();
    }
    destroyRowComp(rowComp) {
        this.destroyBean(rowComp);
        this.eRowContainer.removeChild(rowComp.getGui());
    }
    setCtrls(ctrls) {
        const oldRowComps = this.headerRowComps;
        this.headerRowComps = {};
        this.rowCompsList = [];
        let prevGui;
        const appendEnsuringDomOrder = (rowComp) => {
            const eGui = rowComp.getGui();
            const notAlreadyIn = eGui.parentElement != this.eRowContainer;
            if (notAlreadyIn) {
                this.eRowContainer.appendChild(eGui);
            }
            if (prevGui) {
                (0, dom_1._ensureDomOrder)(this.eRowContainer, eGui, prevGui);
            }
            prevGui = eGui;
        };
        ctrls.forEach((ctrl) => {
            const ctrlId = ctrl.instanceId;
            const existingComp = oldRowComps[ctrlId];
            delete oldRowComps[ctrlId];
            const rowComp = existingComp ? existingComp : this.createBean(new headerRowComp_1.HeaderRowComp(ctrl));
            this.headerRowComps[ctrlId] = rowComp;
            this.rowCompsList.push(rowComp);
            appendEnsuringDomOrder(rowComp);
        });
        Object.values(oldRowComps).forEach((c) => this.destroyRowComp(c));
    }
}
exports.HeaderRowContainerComp = HeaderRowContainerComp;


/***/ }),

/***/ 98934:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HeaderRowContainerCtrl = void 0;
const beanStub_1 = __webpack_require__(68731);
const agColumn_1 = __webpack_require__(13355);
const centerWidthFeature_1 = __webpack_require__(42218);
const headerUtils_1 = __webpack_require__(1323);
const headerRowCtrl_1 = __webpack_require__(82868);
class HeaderRowContainerCtrl extends beanStub_1.BeanStub {
    constructor(pinned) {
        super();
        this.pinned = pinned;
        this.hidden = false;
        this.includeFloatingFilter = false;
        this.groupsRowCtrls = [];
    }
    setComp(comp, eGui) {
        this.comp = comp;
        this.eViewport = eGui;
        const { pinnedCols, ctrlsSvc, colModel, colMoves, filterManager } = this.beans;
        this.setupCenterWidth();
        pinnedCols?.setupHeaderPinnedWidth(this);
        this.setupDragAndDrop(colMoves, this.eViewport);
        const onDisplayedColsChanged = this.onDisplayedColumnsChanged.bind(this, filterManager);
        this.addManagedEventListeners({
            gridColumnsChanged: this.onGridColumnsChanged.bind(this),
            displayedColumnsChanged: onDisplayedColsChanged,
            advancedFilterEnabledChanged: onDisplayedColsChanged,
        });
        const headerType = `${typeof this.pinned === 'string' ? this.pinned : 'center'}Header`;
        ctrlsSvc.register(headerType, this);
        if (colModel.ready) {
            this.refresh();
        }
    }
    getAllCtrls() {
        const res = [...this.groupsRowCtrls];
        if (this.columnsRowCtrl) {
            res.push(this.columnsRowCtrl);
        }
        if (this.filtersRowCtrl) {
            res.push(this.filtersRowCtrl);
        }
        return res;
    }
    refresh(keepColumns = false) {
        const { focusSvc, colModel, filterManager } = this.beans;
        let sequence = 0;
        const focusedHeaderPosition = focusSvc.getFocusHeaderToUseAfterRefresh();
        const refreshColumnGroups = () => {
            const groupRowCount = (0, headerUtils_1.getHeaderRowCount)(colModel) - 1;
            this.groupsRowCtrls = this.destroyBeans(this.groupsRowCtrls);
            for (let i = 0; i < groupRowCount; i++) {
                const ctrl = this.createBean(new headerRowCtrl_1.HeaderRowCtrl(sequence++, this.pinned, 'group'));
                this.groupsRowCtrls.push(ctrl);
            }
        };
        const refreshColumns = () => {
            const rowIndex = sequence++;
            const needNewInstance = !this.hidden &&
                (this.columnsRowCtrl == null || !keepColumns || this.columnsRowCtrl.rowIndex !== rowIndex);
            const shouldDestroyInstance = needNewInstance || this.hidden;
            if (shouldDestroyInstance) {
                this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl);
            }
            if (needNewInstance) {
                this.columnsRowCtrl = this.createBean(new headerRowCtrl_1.HeaderRowCtrl(rowIndex, this.pinned, 'column'));
            }
        };
        const refreshFilters = () => {
            this.includeFloatingFilter = !!filterManager?.hasFloatingFilters() && !this.hidden;
            const destroyPreviousComp = () => {
                this.filtersRowCtrl = this.destroyBean(this.filtersRowCtrl);
            };
            if (!this.includeFloatingFilter) {
                destroyPreviousComp();
                return;
            }
            const rowIndex = sequence++;
            if (this.filtersRowCtrl) {
                const rowIndexMismatch = this.filtersRowCtrl.rowIndex !== rowIndex;
                if (!keepColumns || rowIndexMismatch) {
                    destroyPreviousComp();
                }
            }
            if (!this.filtersRowCtrl) {
                this.filtersRowCtrl = this.createBean(new headerRowCtrl_1.HeaderRowCtrl(rowIndex, this.pinned, 'filter'));
            }
        };
        refreshColumnGroups();
        refreshColumns();
        refreshFilters();
        const allCtrls = this.getAllCtrls();
        this.comp.setCtrls(allCtrls);
        this.restoreFocusOnHeader(focusSvc, focusedHeaderPosition);
    }
    getHeaderCtrlForColumn(column) {
        const findCtrl = (ctrl) => ctrl?.getHeaderCellCtrls().find((ctrl) => ctrl.column === column);
        if ((0, agColumn_1.isColumn)(column)) {
            return findCtrl(this.columnsRowCtrl);
        }
        if (this.groupsRowCtrls.length === 0) {
            return;
        }
        for (let i = 0; i < this.groupsRowCtrls.length; i++) {
            const ctrl = findCtrl(this.groupsRowCtrls[i]);
            if (ctrl) {
                return ctrl;
            }
        }
    }
    getHtmlElementForColumnHeader(column) {
        return this.getHeaderCtrlForColumn(column)?.eGui ?? null;
    }
    getRowType(rowIndex) {
        return this.getAllCtrls()[rowIndex]?.type;
    }
    focusHeader(rowIndex, column, event) {
        const allCtrls = this.getAllCtrls();
        const ctrl = allCtrls[rowIndex];
        if (!ctrl) {
            return false;
        }
        return ctrl.focusHeader(column, event);
    }
    getGroupRowCount() {
        return this.groupsRowCtrls.length;
    }
    getGroupRowCtrlAtIndex(index) {
        return this.groupsRowCtrls[index];
    }
    getRowCount() {
        return this.groupsRowCtrls.length + (this.columnsRowCtrl ? 1 : 0) + (this.filtersRowCtrl ? 1 : 0);
    }
    setHorizontalScroll(offset) {
        this.comp.setViewportScrollLeft(offset);
    }
    onScrollCallback(fn) {
        this.addManagedElementListeners(this.eViewport, { scroll: fn });
    }
    destroy() {
        this.filtersRowCtrl = this.destroyBean(this.filtersRowCtrl);
        this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl);
        this.groupsRowCtrls = this.destroyBeans(this.groupsRowCtrls);
        super.destroy();
    }
    setupDragAndDrop(colMoves, dropContainer) {
        const bodyDropTarget = colMoves?.createBodyDropTarget(this.pinned, dropContainer);
        if (bodyDropTarget) {
            this.createManagedBean(bodyDropTarget);
        }
    }
    restoreFocusOnHeader(focusSvc, position) {
        if (!position) {
            return;
        }
        const { column } = position;
        if (column.getPinned() != this.pinned) {
            return;
        }
        focusSvc.focusHeaderPosition({ headerPosition: position });
    }
    // grid cols have changed - this also means the number of rows in the header can have
    // changed. so we remove all the old rows and insert new ones for a complete refresh
    onGridColumnsChanged() {
        this.refresh(true);
    }
    onDisplayedColumnsChanged(filterManager) {
        const includeFloatingFilter = !!filterManager?.hasFloatingFilters() && !this.hidden;
        if (this.includeFloatingFilter !== includeFloatingFilter) {
            this.refresh(true);
        }
    }
    setupCenterWidth() {
        if (this.pinned != null) {
            return;
        }
        this.createManagedBean(new centerWidthFeature_1.CenterWidthFeature((width) => this.comp.setCenterWidth(`${width}px`), true));
    }
}
exports.HeaderRowContainerCtrl = HeaderRowContainerCtrl;


/***/ }),

/***/ 76642:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InfiniteBlock = void 0;
const beanStub_1 = __webpack_require__(68731);
const rowNode_1 = __webpack_require__(3373);
const gridOptionsUtils_1 = __webpack_require__(67274);
const generic_1 = __webpack_require__(34422);
const logging_1 = __webpack_require__(47764);
class InfiniteBlock extends beanStub_1.BeanStub {
    constructor(id, parentCache, params) {
        super();
        this.id = id;
        this.parentCache = parentCache;
        this.params = params;
        this.state = 'needsLoading';
        this.version = 0;
        // we don't need to calculate these now, as the inputs don't change,
        // however it makes the code easier to read if we work them out up front
        this.startRow = id * params.blockSize;
        this.endRow = this.startRow + params.blockSize;
    }
    load() {
        this.state = 'loading';
        this.loadFromDatasource();
    }
    setStateWaitingToLoad() {
        // in case any current loads in progress, this will have their results ignored
        this.version++;
        this.state = 'needsLoading';
    }
    pageLoadFailed(version) {
        const requestMostRecentAndLive = this.isRequestMostRecentAndLive(version);
        if (requestMostRecentAndLive) {
            this.state = 'failed';
        }
        this.dispatchLocalEvent({ type: 'loadComplete' });
    }
    pageLoaded(version, rows, lastRow) {
        this.successCommon(version, { rowData: rows, rowCount: lastRow });
    }
    isRequestMostRecentAndLive(version) {
        // thisIsMostRecentRequest - if block was refreshed, then another request
        // could of been sent after this one.
        const thisIsMostRecentRequest = version === this.version;
        // weAreNotDestroyed - if InfiniteStore is purged, then blocks are destroyed
        // and new blocks created. so data loads of old blocks are discarded.
        const weAreNotDestroyed = this.isAlive();
        return thisIsMostRecentRequest && weAreNotDestroyed;
    }
    successCommon(version, params) {
        // need to dispatch load complete before processing the data, as PaginationComp checks
        // RowNodeBlockLoader to see if it is still loading, so the RowNodeBlockLoader needs to
        // be updated first (via LoadComplete event) before PaginationComp updates (via processServerResult method)
        this.dispatchLocalEvent({ type: 'loadComplete' });
        const requestMostRecentAndLive = this.isRequestMostRecentAndLive(version);
        if (requestMostRecentAndLive) {
            this.state = 'loaded';
            this.processServerResult(params);
        }
    }
    postConstruct() {
        // creates empty row nodes, data is missing as not loaded yet
        this.rowNodes = [];
        const { params: { blockSize, rowHeight }, startRow, beans, rowNodes, } = this;
        for (let i = 0; i < blockSize; i++) {
            const rowIndex = startRow + i;
            const rowNode = new rowNode_1.RowNode(beans);
            rowNode.setRowHeight(rowHeight);
            rowNode.uiLevel = 0;
            rowNode.setRowIndex(rowIndex);
            rowNode.setRowTop(rowHeight * rowIndex);
            rowNodes.push(rowNode);
        }
    }
    getBlockStateJson() {
        const { id, startRow, endRow, state: pageStatus } = this;
        return {
            id: '' + id,
            state: {
                blockNumber: id,
                startRow,
                endRow,
                pageStatus,
            },
        };
    }
    setDataAndId(rowNode, data, index) {
        if ((0, generic_1._exists)(data)) {
            // this means if the user is not providing id's we just use the
            // index for the row. this will allow selection to work (that is based
            // on index) as long user is not inserting or deleting rows,
            // or wanting to keep selection between server side sorting or filtering
            rowNode.setDataAndId(data, index.toString());
        }
        else {
            rowNode.setDataAndId(undefined, undefined);
        }
    }
    loadFromDatasource() {
        const params = this.createLoadParams();
        if ((0, generic_1._missing)(this.params.datasource.getRows)) {
            (0, logging_1._warn)(90);
            return;
        }
        // put in timeout, to force result to be async
        window.setTimeout(() => {
            this.params.datasource.getRows(params);
        }, 0);
    }
    createLoadParams() {
        const { startRow, endRow, version, params: { sortModel, filterModel }, gos, } = this;
        // PROBLEM . . . . when the user sets sort via colDef.sort, then this code
        // is executing before the sort is set up, so server is not getting the sort
        // model. need to change with regards order - so the server side request is
        // AFTER thus it gets the right sort model.
        const params = {
            startRow,
            endRow,
            successCallback: this.pageLoaded.bind(this, version),
            failCallback: this.pageLoadFailed.bind(this, version),
            sortModel,
            filterModel,
            context: (0, gridOptionsUtils_1._addGridCommonParams)(gos, {}).context,
        };
        return params;
    }
    forEachNode(callback, sequence, rowCount) {
        this.rowNodes.forEach((rowNode, index) => {
            const rowIndex = this.startRow + index;
            if (rowIndex < rowCount) {
                callback(rowNode, sequence.value++);
            }
        });
    }
    getRow(rowIndex, dontTouchLastAccessed = false) {
        if (!dontTouchLastAccessed) {
            this.lastAccessed = this.params.lastAccessedSequence.value++;
        }
        const localIndex = rowIndex - this.startRow;
        return this.rowNodes[localIndex];
    }
    processServerResult(params) {
        const { rowNodes, beans } = this;
        rowNodes.forEach((rowNode, index) => {
            const data = params.rowData ? params.rowData[index] : undefined;
            if (!rowNode.id && rowNode.alreadyRendered && data) {
                // if the node had no id and was rendered, but we have data for it now, then
                // destroy the old row and copy its position into new row. This prevents an additional
                // set of events being fired as the row renderer tries to understand the changing id
                rowNodes[index] = new rowNode_1.RowNode(beans);
                rowNodes[index].setRowIndex(rowNode.rowIndex);
                rowNodes[index].setRowTop(rowNode.rowTop);
                rowNodes[index].setRowHeight(rowNode.rowHeight);
                // clean up the old row
                rowNode.clearRowTopAndRowIndex();
            }
            this.setDataAndId(rowNodes[index], data, this.startRow + index);
        });
        const finalRowCount = params.rowCount != null && params.rowCount >= 0 ? params.rowCount : undefined;
        this.parentCache.pageLoaded(this, finalRowCount);
    }
    destroy() {
        this.rowNodes.forEach((rowNode) => {
            // this is needed, so row render knows to fade out the row, otherwise it
            // sees row top is present, and thinks the row should be shown.
            rowNode.clearRowTopAndRowIndex();
        });
        super.destroy();
    }
}
exports.InfiniteBlock = InfiniteBlock;


/***/ }),

/***/ 88861:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InfiniteCache = void 0;
const beanStub_1 = __webpack_require__(68731);
const function_1 = __webpack_require__(92043);
const generic_1 = __webpack_require__(34422);
const infiniteBlock_1 = __webpack_require__(76642);
// this property says how many empty blocks should be in a cache, eg if scrolls down fast and creates 10
// blocks all for loading, the grid will only load the last 2 - it will assume the blocks the user quickly
// scrolled over are not needed to be loaded.
const MAX_EMPTY_BLOCKS_TO_KEEP = 2;
class InfiniteCache extends beanStub_1.BeanStub {
    constructor(params) {
        super();
        this.params = params;
        this.lastRowIndexKnown = false;
        this.blocks = {};
        this.blockCount = 0;
        this.rowCount = params.initialRowCount;
    }
    // the rowRenderer will not pass dontCreatePage, meaning when rendering the grid,
    // it will want new pages in the cache as it asks for rows. only when we are inserting /
    // removing rows via the api is dontCreatePage set, where we move rows between the pages.
    getRow(rowIndex, dontCreatePage = false) {
        const blockId = Math.floor(rowIndex / this.params.blockSize);
        let block = this.blocks[blockId];
        if (!block) {
            if (dontCreatePage) {
                return undefined;
            }
            block = this.createBlock(blockId);
        }
        return block.getRow(rowIndex);
    }
    createBlock(blockNumber) {
        const params = this.params;
        const newBlock = this.createBean(new infiniteBlock_1.InfiniteBlock(blockNumber, this, params));
        this.blocks[newBlock.id] = newBlock;
        this.blockCount++;
        this.purgeBlocksIfNeeded(newBlock);
        params.rowNodeBlockLoader.addBlock(newBlock);
        return newBlock;
    }
    // we have this on infinite row model only, not server side row model,
    // because for server side, it would leave the children in inconsistent
    // state - eg if a node had children, but after the refresh it had data
    // for a different row, then the children would be with the wrong row node.
    refreshCache() {
        const nothingToRefresh = this.blockCount == 0;
        if (nothingToRefresh) {
            this.purgeCache();
            return;
        }
        this.getBlocksInOrder().forEach((block) => block.setStateWaitingToLoad());
        this.params.rowNodeBlockLoader.checkBlockToLoad();
    }
    destroy() {
        this.getBlocksInOrder().forEach((block) => this.destroyBlock(block));
        super.destroy();
    }
    getRowCount() {
        return this.rowCount;
    }
    isLastRowIndexKnown() {
        return this.lastRowIndexKnown;
    }
    // block calls this, when page loaded
    pageLoaded(block, lastRow) {
        // if we are not active, then we ignore all events, otherwise we could end up getting the
        // grid to refresh even though we are no longer the active cache
        if (!this.isAlive()) {
            return;
        }
        (0, function_1._logIfDebug)(this.gos, `InfiniteCache - onPageLoaded: page = ${block.id}, lastRow = ${lastRow}`);
        this.checkRowCount(block, lastRow);
        // we fire cacheUpdated even if the row count has not changed, as some items need updating even
        // if no new rows to render. for example the pagination panel has '?' as the total rows when loading
        // is underway, which would need to get updated when loading finishes.
        this.onCacheUpdated();
    }
    purgeBlocksIfNeeded(blockToExclude) {
        // we exclude checking for the page just created, as this has yet to be accessed and hence
        // the lastAccessed stamp will not be updated for the first time yet
        const blocksForPurging = this.getBlocksInOrder().filter((b) => b != blockToExclude);
        const lastAccessedComparator = (a, b) => b.lastAccessed - a.lastAccessed;
        blocksForPurging.sort(lastAccessedComparator);
        // we remove (maxBlocksInCache - 1) as we already excluded the 'just created' page.
        // in other words, after the splice operation below, we have taken out the blocks
        // we want to keep, which means we are left with blocks that we can potentially purge
        const maxBlocksProvided = this.params.maxBlocksInCache > 0;
        const blocksToKeep = maxBlocksProvided ? this.params.maxBlocksInCache - 1 : null;
        const emptyBlocksToKeep = MAX_EMPTY_BLOCKS_TO_KEEP - 1;
        blocksForPurging.forEach((block, index) => {
            const purgeBecauseBlockEmpty = block.state === 'needsLoading' && index >= emptyBlocksToKeep;
            const purgeBecauseCacheFull = maxBlocksProvided ? index >= blocksToKeep : false;
            if (purgeBecauseBlockEmpty || purgeBecauseCacheFull) {
                // if the block currently has rows been displayed, then don't remove it either.
                // this can happen if user has maxBlocks=2, and blockSize=5 (thus 10 max rows in cache)
                // but the screen is showing 20 rows, so at least 4 blocks are needed.
                if (this.isBlockCurrentlyDisplayed(block)) {
                    return;
                }
                // don't want to loose keyboard focus, so keyboard navigation can continue. so keep focused blocks.
                if (this.isBlockFocused(block)) {
                    return;
                }
                // at this point, block is not needed, so burn baby burn
                this.removeBlockFromCache(block);
            }
        });
    }
    isBlockFocused(block) {
        const focusedCell = this.beans.focusSvc.getFocusCellToUseAfterRefresh();
        if (!focusedCell) {
            return false;
        }
        if (focusedCell.rowPinned != null) {
            return false;
        }
        const { startRow, endRow } = block;
        const hasFocus = focusedCell.rowIndex >= startRow && focusedCell.rowIndex < endRow;
        return hasFocus;
    }
    isBlockCurrentlyDisplayed(block) {
        const { startRow, endRow } = block;
        return this.beans.rowRenderer.isRangeInRenderedViewport(startRow, endRow - 1);
    }
    removeBlockFromCache(blockToRemove) {
        if (!blockToRemove) {
            return;
        }
        this.destroyBlock(blockToRemove);
        // we do not want to remove the 'loaded' event listener, as the
        // concurrent loads count needs to be updated when the load is complete
        // if the purged page is in loading state
    }
    checkRowCount(block, lastRow) {
        // if client provided a last row, we always use it, as it could change between server calls
        // if user deleted data and then called refresh on the grid.
        if (typeof lastRow === 'number' && lastRow >= 0) {
            this.rowCount = lastRow;
            this.lastRowIndexKnown = true;
        }
        else if (!this.lastRowIndexKnown) {
            const { blockSize, overflowSize } = this.params;
            // otherwise, see if we need to add some virtual rows
            const lastRowIndex = (block.id + 1) * blockSize;
            const lastRowIndexPlusOverflow = lastRowIndex + overflowSize;
            if (this.rowCount < lastRowIndexPlusOverflow) {
                this.rowCount = lastRowIndexPlusOverflow;
            }
        }
    }
    setRowCount(rowCount, lastRowIndexKnown) {
        this.rowCount = rowCount;
        // if undefined is passed, we do not set this value, if one of {true,false}
        // is passed, we do set the value.
        if ((0, generic_1._exists)(lastRowIndexKnown)) {
            this.lastRowIndexKnown = lastRowIndexKnown;
        }
        // if we are still searching, then the row count must not end at the end
        // of a particular page, otherwise the searching will not pop into the
        // next page
        if (!this.lastRowIndexKnown) {
            if (this.rowCount % this.params.blockSize === 0) {
                this.rowCount++;
            }
        }
        this.onCacheUpdated();
    }
    forEachNodeDeep(callback) {
        const sequence = { value: 0 };
        this.getBlocksInOrder().forEach((block) => block.forEachNode(callback, sequence, this.rowCount));
    }
    getBlocksInOrder() {
        // get all page id's as NUMBERS (not strings, as we need to sort as numbers) and in descending order
        const blockComparator = (a, b) => a.id - b.id;
        const blocks = Object.values(this.blocks).sort(blockComparator);
        return blocks;
    }
    destroyBlock(block) {
        delete this.blocks[block.id];
        this.destroyBean(block);
        this.blockCount--;
        this.params.rowNodeBlockLoader.removeBlock(block);
    }
    // gets called 1) row count changed 2) cache purged 3) items inserted
    onCacheUpdated() {
        if (this.isAlive()) {
            // if the virtualRowCount is shortened, then it's possible blocks exist that are no longer
            // in the valid range. so we must remove these. this can happen if user explicitly sets
            // the virtual row count, or the datasource returns a result and sets lastRow to something
            // less than virtualRowCount (can happen if user scrolls down, server reduces dataset size).
            this.destroyAllBlocksPastVirtualRowCount();
            // this results in both row models (infinite and server side) firing ModelUpdated,
            // however server side row model also updates the row indexes first
            this.eventSvc.dispatchEvent({
                type: 'storeUpdated',
            });
        }
    }
    destroyAllBlocksPastVirtualRowCount() {
        const blocksToDestroy = [];
        this.getBlocksInOrder().forEach((block) => {
            const startRow = block.id * this.params.blockSize;
            if (startRow >= this.rowCount) {
                blocksToDestroy.push(block);
            }
        });
        if (blocksToDestroy.length > 0) {
            blocksToDestroy.forEach((block) => this.destroyBlock(block));
        }
    }
    purgeCache() {
        this.getBlocksInOrder().forEach((block) => this.removeBlockFromCache(block));
        this.lastRowIndexKnown = false;
        // if zero rows in the cache, we need to get the SSRM to start asking for rows again.
        // otherwise if set to zero rows last time, and we don't update the row count, then after
        // the purge there will still be zero rows, meaning the SSRM won't request any rows.
        // to kick things off, at least one row needs to be asked for.
        if (this.rowCount === 0) {
            this.rowCount = this.params.initialRowCount;
        }
        this.onCacheUpdated();
    }
    getRowNodesInRange(firstInRange, lastInRange) {
        const result = [];
        let lastBlockId = -1;
        let inActiveRange = false;
        const numberSequence = { value: 0 };
        let foundGapInSelection = false;
        this.getBlocksInOrder().forEach((block) => {
            if (foundGapInSelection) {
                return;
            }
            if (inActiveRange && lastBlockId + 1 !== block.id) {
                foundGapInSelection = true;
                return;
            }
            lastBlockId = block.id;
            block.forEachNode((rowNode) => {
                const hitFirstOrLast = rowNode === firstInRange || rowNode === lastInRange;
                if (inActiveRange || hitFirstOrLast) {
                    result.push(rowNode);
                }
                if (hitFirstOrLast) {
                    inActiveRange = !inActiveRange;
                }
            }, numberSequence, this.rowCount);
        });
        // inActiveRange will be still true if we never hit the second rowNode
        const invalidRange = foundGapInSelection || inActiveRange;
        return invalidRange ? [] : result;
    }
}
exports.InfiniteCache = InfiniteCache;


/***/ }),

/***/ 52550:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InfiniteRowModel = void 0;
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const generic_1 = __webpack_require__(34422);
const infiniteCache_1 = __webpack_require__(88861);
class InfiniteRowModel extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'rowModel';
    }
    getRowBounds(index) {
        return {
            rowHeight: this.rowHeight,
            rowTop: this.rowHeight * index,
        };
    }
    // we don't implement as lazy row heights is not supported in this row model
    ensureRowHeightsValid() {
        return false;
    }
    postConstruct() {
        if (this.gos.get('rowModelType') !== 'infinite') {
            return;
        }
        this.rowHeight = (0, gridOptionsUtils_1._getRowHeightAsNumber)(this.beans);
        this.addEventListeners();
        this.addDestroyFunc(() => this.destroyCache());
    }
    start() {
        this.setDatasource(this.gos.get('datasource'));
    }
    destroy() {
        this.destroyDatasource();
        super.destroy();
    }
    destroyDatasource() {
        if (this.datasource) {
            this.destroyBean(this.datasource);
            this.beans.rowRenderer.datasourceChanged();
            this.datasource = null;
        }
    }
    addEventListeners() {
        this.addManagedEventListeners({
            filterChanged: this.reset.bind(this),
            sortChanged: this.reset.bind(this),
            newColumnsLoaded: this.onColumnEverything.bind(this),
            storeUpdated: this.dispatchModelUpdatedEvent.bind(this),
        });
        this.addManagedPropertyListener('datasource', () => this.setDatasource(this.gos.get('datasource')));
        this.addManagedPropertyListener('cacheBlockSize', () => this.resetCache());
        this.addManagedPropertyListener('rowHeight', () => {
            this.rowHeight = (0, gridOptionsUtils_1._getRowHeightAsNumber)(this.beans);
            this.cacheParams.rowHeight = this.rowHeight;
            this.updateRowHeights();
        });
    }
    onColumnEverything() {
        let resetRequired;
        // if cache params, we require reset only if sort model has changed. we don't need to check
        // for filter model, as the filter manager will fire an event when columns change that result
        // in the filter changing.
        if (this.cacheParams) {
            resetRequired = !(0, generic_1._jsonEquals)(this.cacheParams.sortModel, this.beans.sortSvc?.getSortModel() ?? []);
        }
        else {
            // if no cacheParams, means first time creating the cache, so always create one
            resetRequired = true;
        }
        if (resetRequired) {
            this.reset();
        }
    }
    getType() {
        return 'infinite';
    }
    setDatasource(datasource) {
        this.destroyDatasource();
        this.datasource = datasource;
        // only reset if we have a valid datasource to working with
        if (datasource) {
            this.reset();
        }
    }
    isEmpty() {
        return !this.infiniteCache;
    }
    isRowsToRender() {
        return !!this.infiniteCache;
    }
    getNodesInRangeForSelection(firstInRange, lastInRange) {
        return this.infiniteCache?.getRowNodesInRange(firstInRange, lastInRange) ?? [];
    }
    reset() {
        // important to return here, as the user could be setting filter or sort before
        // data-source is set
        if (!this.datasource) {
            return;
        }
        // if user is providing id's, then this means we can keep the selection between datasource hits,
        // as the rows will keep their unique id's even if, for example, server side sorting or filtering
        // is done.
        const getRowIdFunc = (0, gridOptionsUtils_1._getRowIdCallback)(this.gos);
        const userGeneratingIds = getRowIdFunc != null;
        if (!userGeneratingIds) {
            this.beans.selectionSvc?.reset('rowDataChanged');
        }
        this.resetCache();
    }
    dispatchModelUpdatedEvent() {
        this.eventSvc.dispatchEvent({
            type: 'modelUpdated',
            // not sure if these should all be false - noticed if after implementing,
            // maybe they should be true?
            newPage: false,
            newPageSize: false,
            newData: false,
            keepRenderedRows: true,
            animate: false,
        });
    }
    resetCache() {
        // if not first time creating a cache, need to destroy the old one
        this.destroyCache();
        const beans = this.beans;
        const { filterManager, sortSvc, rowNodeBlockLoader, eventSvc, gos } = beans;
        this.cacheParams = {
            // the user provided datasource
            datasource: this.datasource,
            // sort and filter model
            filterModel: filterManager?.getFilterModel() ?? {},
            sortModel: sortSvc?.getSortModel() ?? [],
            rowNodeBlockLoader: rowNodeBlockLoader,
            // properties - this way we take a snapshot of them, so if user changes any, they will be
            // used next time we create a new cache, which is generally after a filter or sort change,
            // or a new datasource is set
            initialRowCount: gos.get('infiniteInitialRowCount'),
            maxBlocksInCache: gos.get('maxBlocksInCache'),
            rowHeight: (0, gridOptionsUtils_1._getRowHeightAsNumber)(beans),
            // if user doesn't provide overflow, we use default overflow of 1, so user can scroll past
            // the current page and request first row of next page
            overflowSize: gos.get('cacheOverflowSize'),
            // page size needs to be 1 or greater. having it at 1 would be silly, as you would be hitting the
            // server for one page at a time. so the default if not specified is 100.
            blockSize: gos.get('cacheBlockSize'),
            // the cache could create this, however it is also used by the pages, so handy to create it
            // here as the settings are also passed to the pages
            lastAccessedSequence: { value: 0 },
        };
        this.infiniteCache = this.createBean(new infiniteCache_1.InfiniteCache(this.cacheParams));
        eventSvc.dispatchEventOnce({
            type: 'rowCountReady',
        });
        this.dispatchModelUpdatedEvent();
    }
    updateRowHeights() {
        this.forEachNode((node) => {
            node.setRowHeight(this.rowHeight);
            node.setRowTop(this.rowHeight * node.rowIndex);
        });
        this.dispatchModelUpdatedEvent();
    }
    destroyCache() {
        this.infiniteCache = this.destroyBean(this.infiniteCache);
    }
    getRow(rowIndex) {
        const infiniteCache = this.infiniteCache;
        if (!infiniteCache) {
            return undefined;
        }
        if (rowIndex >= infiniteCache.getRowCount()) {
            return undefined;
        }
        return infiniteCache.getRow(rowIndex);
    }
    getRowNode(id) {
        let result;
        this.forEachNode((rowNode) => {
            if (rowNode.id === id) {
                result = rowNode;
            }
        });
        return result;
    }
    forEachNode(callback) {
        this.infiniteCache?.forEachNodeDeep(callback);
    }
    getTopLevelRowCount() {
        return this.getRowCount();
    }
    getTopLevelRowDisplayedIndex(topLevelIndex) {
        return topLevelIndex;
    }
    getRowIndexAtPixel(pixel) {
        if (this.rowHeight !== 0) {
            // avoid divide by zero error
            const rowIndexForPixel = Math.floor(pixel / this.rowHeight);
            const lastRowIndex = this.getRowCount() - 1;
            if (rowIndexForPixel > lastRowIndex) {
                return lastRowIndex;
            }
            return rowIndexForPixel;
        }
        return 0;
    }
    getRowCount() {
        return this.infiniteCache ? this.infiniteCache.getRowCount() : 0;
    }
    isRowPresent(rowNode) {
        return !!this.getRowNode(rowNode.id);
    }
    refreshCache() {
        this.infiniteCache?.refreshCache();
    }
    purgeCache() {
        this.infiniteCache?.purgeCache();
    }
    // for iRowModel
    isLastRowIndexKnown() {
        return this.infiniteCache?.isLastRowIndexKnown() ?? false;
    }
    setRowCount(rowCount, lastRowIndexKnown) {
        this.infiniteCache?.setRowCount(rowCount, lastRowIndexKnown);
    }
}
exports.InfiniteRowModel = InfiniteRowModel;


/***/ }),

/***/ 49836:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getInfiniteRowCount = exports.purgeInfiniteCache = exports.refreshInfiniteCache = void 0;
const rowModelApiUtils_1 = __webpack_require__(66876);
function refreshInfiniteCache(beans) {
    (0, rowModelApiUtils_1._getInfiniteRowModel)(beans)?.refreshCache();
}
exports.refreshInfiniteCache = refreshInfiniteCache;
function purgeInfiniteCache(beans) {
    (0, rowModelApiUtils_1._getInfiniteRowModel)(beans)?.purgeCache();
}
exports.purgeInfiniteCache = purgeInfiniteCache;
function getInfiniteRowCount(beans) {
    return (0, rowModelApiUtils_1._getInfiniteRowModel)(beans)?.getRowCount();
}
exports.getInfiniteRowCount = getInfiniteRowCount;


/***/ }),

/***/ 44002:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InfiniteRowModelModule = void 0;
const sharedApiModule_1 = __webpack_require__(36437);
const version_1 = __webpack_require__(97205);
const infiniteRowModel_1 = __webpack_require__(52550);
const infiniteRowModelApi_1 = __webpack_require__(49836);
const rowNodeBlockLoader_1 = __webpack_require__(39789);
/**
 * @internal
 */
const InfiniteRowModelCoreModule = {
    moduleName: 'InfiniteRowModelCore',
    version: version_1.VERSION,
    rowModels: ['infinite'],
    beans: [infiniteRowModel_1.InfiniteRowModel, rowNodeBlockLoader_1.RowNodeBlockLoader],
};
/**
 * @feature Infinite Row Model
 */
exports.InfiniteRowModelModule = {
    moduleName: 'InfiniteRowModel',
    version: version_1.VERSION,
    apiFunctions: {
        refreshInfiniteCache: infiniteRowModelApi_1.refreshInfiniteCache,
        purgeInfiniteCache: infiniteRowModelApi_1.purgeInfiniteCache,
        getInfiniteRowCount: infiniteRowModelApi_1.getInfiniteRowCount,
    },
    dependsOn: [InfiniteRowModelCoreModule, sharedApiModule_1.SsrmInfiniteSharedApiModule],
};


/***/ }),

/***/ 39789:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RowNodeBlockLoader = void 0;
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const array_1 = __webpack_require__(31502);
const function_1 = __webpack_require__(92043);
class RowNodeBlockLoader extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'rowNodeBlockLoader';
        this.activeBlockLoadsCount = 0;
        this.blocks = [];
        this.active = true;
    }
    postConstruct() {
        this.maxConcurrentRequests = (0, gridOptionsUtils_1._getMaxConcurrentDatasourceRequests)(this.gos);
        const blockLoadDebounceMillis = this.gos.get('blockLoadDebounceMillis');
        if (blockLoadDebounceMillis && blockLoadDebounceMillis > 0) {
            this.checkBlockToLoadDebounce = (0, function_1._debounce)(this, this.performCheckBlocksToLoad.bind(this), blockLoadDebounceMillis);
        }
    }
    addBlock(block) {
        this.blocks.push(block);
        // note that we do not remove this listener when removing the block. this is because the
        // cache can get destroyed (and containing blocks) when a block is loading. however the loading block
        // is still counted as an active loading block and we must decrement activeBlockLoadsCount when it finishes.
        block.addEventListener('loadComplete', this.loadComplete.bind(this));
        this.checkBlockToLoad();
    }
    removeBlock(block) {
        (0, array_1._removeFromArray)(this.blocks, block);
    }
    destroy() {
        super.destroy();
        this.active = false;
    }
    loadComplete() {
        this.activeBlockLoadsCount--;
        this.checkBlockToLoad();
    }
    checkBlockToLoad() {
        if (this.checkBlockToLoadDebounce) {
            this.checkBlockToLoadDebounce();
        }
        else {
            this.performCheckBlocksToLoad();
        }
    }
    performCheckBlocksToLoad() {
        if (!this.active) {
            return;
        }
        this.printCacheStatus();
        if (this.maxConcurrentRequests != null && this.activeBlockLoadsCount >= this.maxConcurrentRequests) {
            (0, function_1._logIfDebug)(this.gos, `RowNodeBlockLoader - checkBlockToLoad: max loads exceeded`);
            return;
        }
        const loadAvailability = this.maxConcurrentRequests != null ? this.maxConcurrentRequests - this.activeBlockLoadsCount : 1;
        const blocksToLoad = this.blocks
            .filter((block) => block.state === 'needsLoading')
            .slice(0, loadAvailability);
        this.activeBlockLoadsCount += blocksToLoad.length;
        blocksToLoad.forEach((block) => block.load());
        this.printCacheStatus();
    }
    getBlockState() {
        const result = {};
        this.blocks.forEach((block) => {
            const { id, state } = block.getBlockStateJson();
            result[id] = state;
        });
        return result;
    }
    printCacheStatus() {
        (0, function_1._logIfDebug)(this.gos, `RowNodeBlockLoader - printCacheStatus: activePageLoadsCount = ${this.activeBlockLoadsCount},` +
            ` blocks = ${JSON.stringify(this.getBlockState())}`);
    }
}
exports.RowNodeBlockLoader = RowNodeBlockLoader;


/***/ }),

/***/ 55961:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CellRangeType = void 0;
var CellRangeType;
(function (CellRangeType) {
    CellRangeType[CellRangeType["VALUE"] = 0] = "VALUE";
    CellRangeType[CellRangeType["DIMENSION"] = 1] = "DIMENSION";
})(CellRangeType || (exports.CellRangeType = CellRangeType = {}));


/***/ }),

/***/ 17419:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 62783:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColumnHighlightPosition = void 0;
var ColumnHighlightPosition;
(function (ColumnHighlightPosition) {
    ColumnHighlightPosition[ColumnHighlightPosition["Before"] = 0] = "Before";
    ColumnHighlightPosition[ColumnHighlightPosition["After"] = 1] = "After";
})(ColumnHighlightPosition || (exports.ColumnHighlightPosition = ColumnHighlightPosition = {}));


/***/ }),

/***/ 25679:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isColumnFilterComp = void 0;
function isColumnFilterComp(filter) {
    return typeof filter === 'object' && !!filter.component;
}
exports.isColumnFilterComp = isColumnFilterComp;


/***/ }),

/***/ 7919:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 73590:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServerSideTransactionResultStatus = void 0;
var ServerSideTransactionResultStatus;
(function (ServerSideTransactionResultStatus) {
    /** Transaction was successfully applied */
    ServerSideTransactionResultStatus["Applied"] = "Applied";
    /**
     * Store was not found, transaction not applied.
     * Either invalid route, or the parent row has not yet been expanded.
     */
    ServerSideTransactionResultStatus["StoreNotFound"] = "StoreNotFound";
    /**
     * Store is loading, transaction not applied.
     */
    ServerSideTransactionResultStatus["StoreLoading"] = "StoreLoading";
    /**
     * Store is loading (as max loads exceeded), transaction not applied.
     */
    ServerSideTransactionResultStatus["StoreWaitingToLoad"] = "StoreWaitingToLoad";
    /**
     * Store load attempt failed, transaction not applied.
     */
    ServerSideTransactionResultStatus["StoreLoadingFailed"] = "StoreLoadingFailed";
    /**
     * Store is type Partial, which doesn't accept transactions
     */
    ServerSideTransactionResultStatus["StoreWrongType"] = "StoreWrongType";
    /**
     * Transaction was cancelled, due to grid.
     * Callback isApplyServerSideTransaction() returning false
     */
    ServerSideTransactionResultStatus["Cancelled"] = "Cancelled";
    /**
     * Store has not started yet, transaction not applied
     */
    ServerSideTransactionResultStatus["StoreNotStarted"] = "StoreNotStarted";
})(ServerSideTransactionResultStatus || (exports.ServerSideTransactionResultStatus = ServerSideTransactionResultStatus = {}));


/***/ }),

/***/ 85889:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LocalEventService = void 0;
class LocalEventService {
    constructor() {
        this.allSyncListeners = new Map();
        this.allAsyncListeners = new Map();
        this.globalSyncListeners = new Set();
        this.globalAsyncListeners = new Set();
        this.asyncFunctionsQueue = [];
        this.scheduled = false;
        // using an object performs better than a Set for the number of different events we have
        this.firedEvents = {};
    }
    setFrameworkOverrides(frameworkOverrides) {
        this.frameworkOverrides = frameworkOverrides;
    }
    getListeners(eventType, async, autoCreateListenerCollection) {
        const listenerMap = async ? this.allAsyncListeners : this.allSyncListeners;
        let listeners = listenerMap.get(eventType);
        // Note: 'autoCreateListenerCollection' should only be 'true' if a listener is about to be added. For instance
        // getListeners() is also called during event dispatch even though no listeners are added. This measure protects
        // against 'memory bloat' as empty collections will prevent the RowNode's event service from being removed after
        // the RowComp is destroyed, see noRegisteredListenersExist() below.
        if (!listeners && autoCreateListenerCollection) {
            listeners = new Set();
            listenerMap.set(eventType, listeners);
        }
        return listeners;
    }
    noRegisteredListenersExist() {
        return (this.allSyncListeners.size === 0 &&
            this.allAsyncListeners.size === 0 &&
            this.globalSyncListeners.size === 0 &&
            this.globalAsyncListeners.size === 0);
    }
    addEventListener(eventType, listener, async = false) {
        this.getListeners(eventType, async, true).add(listener);
    }
    removeEventListener(eventType, listener, async = false) {
        const listeners = this.getListeners(eventType, async, false);
        if (!listeners) {
            return;
        }
        listeners.delete(listener);
        if (listeners.size === 0) {
            (async ? this.allAsyncListeners : this.allSyncListeners).delete(eventType);
        }
    }
    addGlobalListener(listener, async = false) {
        this.getGlobalListeners(async).add(listener);
    }
    removeGlobalListener(listener, async = false) {
        this.getGlobalListeners(async).delete(listener);
    }
    dispatchEvent(event) {
        this.dispatchToListeners(event, true);
        this.dispatchToListeners(event, false);
        this.firedEvents[event.type] = true;
    }
    dispatchEventOnce(event) {
        if (!this.firedEvents[event.type]) {
            this.dispatchEvent(event);
        }
    }
    dispatchToListeners(event, async) {
        const eventType = event.type;
        if (async && 'event' in event) {
            const browserEvent = event.event;
            if (browserEvent instanceof Event) {
                // AG-7893 - Persist composedPath() so that its result can still be accessed by the user asynchronously.
                // Within an async event handler if they call composedPath() on the event it will always return an empty [].
                event.eventPath = browserEvent.composedPath();
            }
        }
        const { frameworkOverrides } = this;
        const runCallback = (func) => {
            const callback = frameworkOverrides ? () => frameworkOverrides.wrapIncoming(func) : func;
            if (async) {
                this.dispatchAsync(callback);
            }
            else {
                callback();
            }
        };
        const originalListeners = this.getListeners(eventType, async, false);
        if ((originalListeners?.size ?? 0) > 0) {
            // create a shallow copy to prevent listeners cyclically adding more listeners to capture this event
            const listeners = new Set(originalListeners);
            for (const listener of listeners) {
                if (!originalListeners?.has(listener)) {
                    // A listener could have been removed by a previously processed listener. In this case we don't want to call
                    continue;
                }
                runCallback(() => listener(event));
            }
        }
        const globalListenersSrc = this.getGlobalListeners(async);
        if (globalListenersSrc.size > 0) {
            const globalListeners = new Set(globalListenersSrc);
            for (const listener of globalListeners) {
                runCallback(() => listener(eventType, event));
            }
        }
    }
    getGlobalListeners(async) {
        return async ? this.globalAsyncListeners : this.globalSyncListeners;
    }
    // this gets called inside the grid's thread, for each event that it
    // wants to set async. the grid then batches the events into one setTimeout()
    // because setTimeout() is an expensive operation. ideally we would have
    // each event in it's own setTimeout(), but we batch for performance.
    dispatchAsync(func) {
        // add to the queue for executing later in the next VM turn
        this.asyncFunctionsQueue.push(func);
        // check if timeout is already scheduled. the first time the grid calls
        // this within it's thread turn, this should be false, so it will schedule
        // the 'flush queue' method the first time it comes here. then the flag is
        // set to 'true' so it will know it's already scheduled for subsequent calls.
        if (!this.scheduled) {
            // if not scheduled, schedule one
            const flush = () => {
                window.setTimeout(this.flushAsyncQueue.bind(this), 0);
            };
            this.frameworkOverrides ? this.frameworkOverrides.wrapIncoming(flush) : flush();
            // mark that it is scheduled
            this.scheduled = true;
        }
    }
    // this happens in the next VM turn only, and empties the queue of events
    flushAsyncQueue() {
        this.scheduled = false;
        // we take a copy, because the event listener could be using
        // the grid, which would cause more events, which would be potentially
        // added to the queue, so safe to take a copy, the new events will
        // get executed in a later VM turn rather than risk updating the
        // queue as we are flushing it.
        const queueCopy = this.asyncFunctionsQueue.slice();
        this.asyncFunctionsQueue = [];
        // execute the queue
        queueCopy.forEach((func) => func());
    }
}
exports.LocalEventService = LocalEventService;


/***/ }),

/***/ 89058:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(85608);
/*
 * Used for umd bundles with styles
 */
__webpack_require__(18510);
__webpack_require__(22685);
__webpack_require__(95151);
__webpack_require__(99681);
__webpack_require__(72883);
__webpack_require__(63543);
__webpack_require__(71109);
__webpack_require__(81601);
__webpack_require__(48755);
__webpack_require__(23713);
__webpack_require__(89029);
__webpack_require__(87628);
__webpack_require__(2559);
__webpack_require__(89893);
const main_1 = __webpack_require__(10012);
(0, main_1._setUmd)();
main_1.ModuleRegistry.registerModules([main_1.AllCommunityModule]);
tslib_1.__exportStar(__webpack_require__(10012), exports);


/***/ }),

/***/ 10012:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FilterWrapperComp = exports.FilterComp = exports._getFilterModel = exports._refreshFilterUi = exports._updateFilterModel = exports._refreshHandlerAndUi = exports._createRowNodeSibling = exports._createGlobalRowEvent = exports._ROW_ID_PREFIX_BOTTOM_PINNED = exports._ROW_ID_PREFIX_TOP_PINNED = exports._ROW_ID_PREFIX_ROW_GROUP = exports.RowNode = exports.isProvidedColumnGroup = exports.AgProvidedColumnGroup = exports.isColumnGroup = exports.AgColumnGroup = exports.isColumn = exports.AgColumn = exports.DragSourceType = exports.BeanStub = exports._unwrapUserComp = exports._getInnerCellRendererDetails = exports._getEditorRendererDetails = exports._getCellRendererDetails = exports._getFloatingFilterCompDetails = exports._getFilterDetails = exports.RefPlaceholder = exports._EmptyBean = exports._columnsMatch = exports._convertColumnEventSourceType = exports._updateColsMap = exports._areColIdsEqual = exports._getColumnsFromTree = exports._destroyColumnTree = exports.isColumnGroupAutoCol = exports.isColumnSelectionCol = exports.isRowNumberCol = exports.ROW_NUMBERS_COLUMN_ID = exports.SELECTION_COLUMN_ID = exports.GROUP_AUTO_COLUMN_ID = exports.GroupInstanceIdCreator = exports.ColumnKeyCreator = exports._getColumnState = exports._applyColumnState = exports._resetColumnState = exports.BaseColsService = exports._createColumnTreeWithIds = exports._createColumnTree = exports._addColumnDefaultAndTypes = exports._updateColumnState = void 0;
exports.TabGuardComp = exports._FOCUS_MANAGED_CLASS = exports.ManagedFocusFeature = exports.Component = exports.AgSelectSelector = exports.AgSelect = exports.AgInputDateField = exports.AgInputNumberFieldSelector = exports.AgInputNumberField = exports.AgInputTextArea = exports.AgInputTextFieldSelector = exports.AgInputTextField = exports.AgToggleButtonSelector = exports.AgToggleButton = exports.AgRadioButton = exports.AgCheckboxSelector = exports.AgCheckbox = exports.AgAbstractInputField = exports.BaseSelectionService = exports.ServerSideTransactionResultStatus = exports.AbstractClientSideNodeManager = exports.PinnedRowModel = exports.CssClassManager = exports._getCellCtrlForEventTarget = exports.PositionableFeature = exports.AgAbstractCellEditor = exports._setColMenuVisible = exports._getHeaderRowCount = exports._getFloatingFiltersHeight = exports.HeaderRowContainerCtrl = exports.GridHeaderCtrl = exports._getToolPanelClassesFromColDef = exports._getHeaderClassesFromColDef = exports._getRowViewportClass = exports._getRowContainerClass = exports._getRowSpanContainerClass = exports._getRowContainerOptions = exports.RowContainerCtrl = exports.FakeVScrollComp = exports.FakeHScrollComp = exports._getNormalisedMousePosition = exports._getCellPositionForEvent = exports.GridBodyCtrl = exports._getDefaultFloatingFilterType = exports.isCombinedFilterModel = exports._isUseApplyButton = exports.ProvidedFilter = exports._getDefaultSimpleFilter = exports._getFilterParamsForDataType = exports.FilterButtonComp = void 0;
exports._getGroupSelection = exports._isGetRowHeightFunction = exports._isRowSelection = exports._getGroupAggFiltering = exports._getRootNode = exports._anchorElementToMouseMoveEvent = exports._getPageBody = exports._getDocument = exports._isNothingFocused = exports._getActiveDomElement = exports._shouldUpdateColVisibilityAfterGroup = exports._getRowHeightAsNumber = exports._canSkipShowingRowGroup = exports._isFullWidthGroupRow = exports._isGroupUseEntireRow = exports._isServerSideRowModel = exports._isClientSideRowModel = exports._isColumnsSortingCoupledToGroup = exports._isGroupMultiAutoColumn = exports._getGroupTotalRowCallback = exports._getGrandTotalRow = exports._isAnimateRows = exports._isDomLayout = exports._getRowHeightForNode = exports._getRowIdCallback = exports._getMaxConcurrentDatasourceRequests = exports._processOnChange = exports._combineAttributesAndGridOptions = exports._getCallbackForEvent = exports._addGridCommonParams = exports._PUBLIC_EVENT_HANDLERS_MAP = exports._PUBLIC_EVENTS = exports._GET_ALL_EVENTS = exports._getServerSideRowModel = exports._getClientSideRowModel = exports._getGlobalGridOption = exports.provideGlobalGridOptions = exports.createGrid = exports.GridCoreCreator = exports.KeyCode = exports.VanillaFrameworkOverrides = exports.AutoScrollService = exports.CellRangeType = exports.AgPickerField = exports.AgAbstractLabel = exports.TouchListener = exports.PopupComponent = exports.TabGuardFeature = exports.TabGuardClassNames = exports.TabGuardCtrl = void 0;
exports._setAriaColIndex = exports._setAriaRole = exports._setAriaControlsAndLabel = exports._setAriaControls = exports._setAriaChecked = exports._setAriaLabelledBy = exports._setAriaExpanded = exports._setAriaDescribedBy = exports._setAriaLabel = exports._setAriaLevel = exports._isShowTooltipWhenTruncated = exports._getShouldDisplayTooltip = exports.TooltipFeature = exports.BaseComponentWrapper = exports._HeaderComp = exports._BOOLEAN_MIXED_GRID_OPTIONS = exports._GET_ALL_GRID_OPTIONS = exports._getRowBelow = exports._getRowAbove = exports._getCellByPosition = exports._getRowNode = exports._isSameRow = exports._isRowBefore = exports._createCellId = exports._areCellsEqual = exports.convertColumnState = exports.convertColumnGroupState = exports._translate = exports._getLocaleTextFunc = exports.LocaleService = exports.GridCtrl = exports.LocalEventService = exports._isSetFilterByDefault = exports._getGridOption = exports._getGroupingApproach = exports._isGroupRowsSticky = exports._isUsingNewCellSelectionAPI = exports._isUsingNewRowSelectionAPI = exports._isColumnMenuAnchoringEnabled = exports._isLegacyMenuEnabled = exports._getRowSelectionMode = exports._getSuppressMultiRanges = exports._isCellSelectionEnabled = exports._getFillHandle = exports._isMultiRowSelection = exports._getHeaderCheckbox = exports._getCheckboxLocation = exports._getCheckboxes = exports._getIsRowSelectable = exports._getGroupSelectsDescendants = void 0;
exports._warnOnce = exports._isElementInEventPath = exports._isStopPropagationForAgGrid = exports._stopPropagationForAgGrid = exports._selectAllCells = exports._isElementOverflowingCallback = exports._requestAnimationFrame = exports._preserveRangesWhile = exports._observeResize = exports._isNodeOrElement = exports._getInnerWidth = exports._getInnerHeight = exports._setVisible = exports._setDisabled = exports._setFixedWidth = exports._isVisible = exports._createElement = exports._loadTemplate = exports._radioCssClass = exports._removeFromParent = exports._clearElement = exports._setDisplayed = exports._getAbsoluteWidth = exports._getAbsoluteHeight = exports._parseDateTimeFromString = exports._getDateParts = exports._serialiseDate = exports.ChangedPath = exports._isIOSUserAgent = exports._flatten = exports._areEqual = exports._last = exports._removeFromArray = exports._EmptyArray = exports._setAriaInvalid = exports._getAriaPosInSet = exports._setAriaHidden = exports._setAriaSetSize = exports._setAriaPosInSet = exports._setAriaSelected = exports._setAriaActiveDescendant = exports._setAriaRowCount = exports._setAriaColCount = exports._setAriaSort = exports._removeAriaSort = exports._removeAriaExpanded = exports._setAriaHasPopup = exports._setAriaDisabled = exports._setAriaRowIndex = exports._setAriaColSpan = void 0;
exports._FilterValueModule = exports._FilterCoreModule = exports._ColumnFilterModule = exports.RowDragModule = exports.DragAndDropModule = exports._SharedDragAndDropModule = exports._HorizontalResizeModule = exports._DragModule = exports._ColumnMoveModule = exports.ValidationModule = exports._setUmd = exports._getGridRegisteredModules = exports._registerModule = exports.ModuleRegistry = exports._downloadFile = exports.BaseGridSerializingSession = exports.BaseCreator = exports._focusNextGridCoreContainer = exports._isKeyboardMode = exports._focusGridInnerElement = exports._findTabbableParent = exports._findNextFocusableElement = exports._focusInto = exports._findFocusableElements = exports._addFocusableContainerListener = exports._isPromise = exports.AgPromise = exports._toString = exports._escapeString = exports._mergeDeep = exports._formatNumberCommas = exports._isEventFromPrintableCharacter = exports._defaultComparator = exports._makeNull = exports._toStringOrNull = exports._jsonEquals = exports._missing = exports._exists = exports._fuzzySuggestions = exports._createIconNoSpan = exports._createIcon = exports._interpretAsRightClick = exports._preInitErrMsg = exports._errMsg = exports._error = exports._warn = exports._batchCall = exports._waitUntil = exports._doOnce = exports._debounce = void 0;
exports.AllCommunityModule = exports._SharedExportModule = exports.RowAutoHeightModule = exports.LocaleModule = exports.TooltipModule = exports.EventApiModule = exports.ColumnHoverModule = exports.RowStyleModule = exports.CellStyleModule = exports.CellApiModule = exports.ValueCacheModule = exports.CellSpanModule = exports.PinnedRowModule = exports.ColumnAutoSizeModule = exports.RenderApiModule = exports.ScrollApiModule = exports.RowApiModule = exports.PaginationModule = exports.ColumnApiModule = exports.GridStateModule = exports._ColumnGroupModule = exports.HighlightChangesModule = exports._KeyboardNavigationModule = exports._PopupModule = exports.InfiniteRowModelModule = exports.CsvExportModule = exports.ClientSideRowModelApiModule = exports.ClientSideRowModelModule = exports.AlignedGridsModule = exports._SortModule = exports._SharedMenuModule = exports._SsrmInfiniteSharedApiModule = exports._CsrmSsrmSharedApiModule = exports._SharedRowSelectionModule = exports.RowSelectionModule = exports.CustomEditorModule = exports.UndoRedoEditModule = exports.SelectEditorModule = exports.LargeTextEditorModule = exports.TextEditorModule = exports.CheckboxEditorModule = exports.DateEditorModule = exports.NumberEditorModule = exports._EditCoreModule = exports.ExternalFilterModule = exports.DateFilterModule = exports.NumberFilterModule = exports.TextFilterModule = exports.QuickFilterModule = exports.CustomFilterModule = void 0;
exports.themeQuartz = exports.themeMaterial = exports.themeBalham = exports.themeAlpine = exports.styleMaterial = exports.columnDropStylePlain = exports.columnDropStyleBordered = exports.tabStyleRolodex = exports.tabStyleQuartz = exports.tabStyleMaterial = exports.tabStyleBase = exports.tabStyleAlpine = exports.buttonStyleQuartz = exports.buttonStyleBase = exports.buttonStyleBalham = exports.buttonStyleAlpine = exports.inputStyleUnderlined = exports.inputStyleBordered = exports.inputStyleBase = exports.iconSetQuartzRegular = exports.iconSetQuartzLight = exports.iconSetQuartzBold = exports.iconSetQuartz = exports.iconSetMaterial = exports.iconSetAlpine = exports.iconOverrides = exports.colorSchemeVariable = exports.colorSchemeLightWarm = exports.colorSchemeLightCold = exports.colorSchemeLight = exports.colorSchemeDarkWarm = exports.colorSchemeDarkBlue = exports.colorSchemeDark = exports.checkboxStyleDefault = exports._asThemeImpl = exports.createTheme = exports.createPart = void 0;
const tslib_1 = __webpack_require__(85608);
// columns
var columnFactoryUtils_1 = __webpack_require__(82716);
Object.defineProperty(exports, "_updateColumnState", ({ enumerable: true, get: function () { return columnFactoryUtils_1._updateColumnState; } }));
Object.defineProperty(exports, "_addColumnDefaultAndTypes", ({ enumerable: true, get: function () { return columnFactoryUtils_1._addColumnDefaultAndTypes; } }));
Object.defineProperty(exports, "_createColumnTree", ({ enumerable: true, get: function () { return columnFactoryUtils_1._createColumnTree; } }));
Object.defineProperty(exports, "_createColumnTreeWithIds", ({ enumerable: true, get: function () { return columnFactoryUtils_1._createColumnTreeWithIds; } }));
var baseColsService_1 = __webpack_require__(73600);
Object.defineProperty(exports, "BaseColsService", ({ enumerable: true, get: function () { return baseColsService_1.BaseColsService; } }));
var columnStateUtils_1 = __webpack_require__(2885);
Object.defineProperty(exports, "_resetColumnState", ({ enumerable: true, get: function () { return columnStateUtils_1._resetColumnState; } }));
Object.defineProperty(exports, "_applyColumnState", ({ enumerable: true, get: function () { return columnStateUtils_1._applyColumnState; } }));
Object.defineProperty(exports, "_getColumnState", ({ enumerable: true, get: function () { return columnStateUtils_1._getColumnState; } }));
var columnKeyCreator_1 = __webpack_require__(2294);
Object.defineProperty(exports, "ColumnKeyCreator", ({ enumerable: true, get: function () { return columnKeyCreator_1.ColumnKeyCreator; } }));
var groupInstanceIdCreator_1 = __webpack_require__(96034);
Object.defineProperty(exports, "GroupInstanceIdCreator", ({ enumerable: true, get: function () { return groupInstanceIdCreator_1.GroupInstanceIdCreator; } }));
var columnUtils_1 = __webpack_require__(73146);
Object.defineProperty(exports, "GROUP_AUTO_COLUMN_ID", ({ enumerable: true, get: function () { return columnUtils_1.GROUP_AUTO_COLUMN_ID; } }));
Object.defineProperty(exports, "SELECTION_COLUMN_ID", ({ enumerable: true, get: function () { return columnUtils_1.SELECTION_COLUMN_ID; } }));
Object.defineProperty(exports, "ROW_NUMBERS_COLUMN_ID", ({ enumerable: true, get: function () { return columnUtils_1.ROW_NUMBERS_COLUMN_ID; } }));
Object.defineProperty(exports, "isRowNumberCol", ({ enumerable: true, get: function () { return columnUtils_1.isRowNumberCol; } }));
Object.defineProperty(exports, "isColumnSelectionCol", ({ enumerable: true, get: function () { return columnUtils_1.isColumnSelectionCol; } }));
Object.defineProperty(exports, "isColumnGroupAutoCol", ({ enumerable: true, get: function () { return columnUtils_1.isColumnGroupAutoCol; } }));
Object.defineProperty(exports, "_destroyColumnTree", ({ enumerable: true, get: function () { return columnUtils_1._destroyColumnTree; } }));
Object.defineProperty(exports, "_getColumnsFromTree", ({ enumerable: true, get: function () { return columnUtils_1._getColumnsFromTree; } }));
Object.defineProperty(exports, "_areColIdsEqual", ({ enumerable: true, get: function () { return columnUtils_1._areColIdsEqual; } }));
Object.defineProperty(exports, "_updateColsMap", ({ enumerable: true, get: function () { return columnUtils_1._updateColsMap; } }));
Object.defineProperty(exports, "_convertColumnEventSourceType", ({ enumerable: true, get: function () { return columnUtils_1._convertColumnEventSourceType; } }));
Object.defineProperty(exports, "_columnsMatch", ({ enumerable: true, get: function () { return columnUtils_1._columnsMatch; } }));
// components
var emptyBean_1 = __webpack_require__(33789);
Object.defineProperty(exports, "_EmptyBean", ({ enumerable: true, get: function () { return emptyBean_1.EmptyBean; } }));
var component_1 = __webpack_require__(78020);
Object.defineProperty(exports, "RefPlaceholder", ({ enumerable: true, get: function () { return component_1.RefPlaceholder; } }));
var userCompUtils_1 = __webpack_require__(12036);
Object.defineProperty(exports, "_getFilterDetails", ({ enumerable: true, get: function () { return userCompUtils_1._getFilterDetails; } }));
Object.defineProperty(exports, "_getFloatingFilterCompDetails", ({ enumerable: true, get: function () { return userCompUtils_1._getFloatingFilterCompDetails; } }));
Object.defineProperty(exports, "_getCellRendererDetails", ({ enumerable: true, get: function () { return userCompUtils_1._getCellRendererDetails; } }));
Object.defineProperty(exports, "_getEditorRendererDetails", ({ enumerable: true, get: function () { return userCompUtils_1._getEditorRendererDetails; } }));
Object.defineProperty(exports, "_getInnerCellRendererDetails", ({ enumerable: true, get: function () { return userCompUtils_1._getInnerCellRendererDetails; } }));
var unwrapUserComp_1 = __webpack_require__(54126);
Object.defineProperty(exports, "_unwrapUserComp", ({ enumerable: true, get: function () { return unwrapUserComp_1._unwrapUserComp; } }));
// context
var beanStub_1 = __webpack_require__(68731);
Object.defineProperty(exports, "BeanStub", ({ enumerable: true, get: function () { return beanStub_1.BeanStub; } }));
var dragAndDropService_1 = __webpack_require__(12903);
Object.defineProperty(exports, "DragSourceType", ({ enumerable: true, get: function () { return dragAndDropService_1.DragSourceType; } }));
var agColumn_1 = __webpack_require__(13355);
Object.defineProperty(exports, "AgColumn", ({ enumerable: true, get: function () { return agColumn_1.AgColumn; } }));
Object.defineProperty(exports, "isColumn", ({ enumerable: true, get: function () { return agColumn_1.isColumn; } }));
var agColumnGroup_1 = __webpack_require__(56908);
Object.defineProperty(exports, "AgColumnGroup", ({ enumerable: true, get: function () { return agColumnGroup_1.AgColumnGroup; } }));
Object.defineProperty(exports, "isColumnGroup", ({ enumerable: true, get: function () { return agColumnGroup_1.isColumnGroup; } }));
var agProvidedColumnGroup_1 = __webpack_require__(79409);
Object.defineProperty(exports, "AgProvidedColumnGroup", ({ enumerable: true, get: function () { return agProvidedColumnGroup_1.AgProvidedColumnGroup; } }));
Object.defineProperty(exports, "isProvidedColumnGroup", ({ enumerable: true, get: function () { return agProvidedColumnGroup_1.isProvidedColumnGroup; } }));
var rowNode_1 = __webpack_require__(3373);
Object.defineProperty(exports, "RowNode", ({ enumerable: true, get: function () { return rowNode_1.RowNode; } }));
Object.defineProperty(exports, "_ROW_ID_PREFIX_ROW_GROUP", ({ enumerable: true, get: function () { return rowNode_1.ROW_ID_PREFIX_ROW_GROUP; } }));
Object.defineProperty(exports, "_ROW_ID_PREFIX_TOP_PINNED", ({ enumerable: true, get: function () { return rowNode_1.ROW_ID_PREFIX_TOP_PINNED; } }));
Object.defineProperty(exports, "_ROW_ID_PREFIX_BOTTOM_PINNED", ({ enumerable: true, get: function () { return rowNode_1.ROW_ID_PREFIX_BOTTOM_PINNED; } }));
var rowNodeUtils_1 = __webpack_require__(9888);
Object.defineProperty(exports, "_createGlobalRowEvent", ({ enumerable: true, get: function () { return rowNodeUtils_1._createGlobalRowEvent; } }));
Object.defineProperty(exports, "_createRowNodeSibling", ({ enumerable: true, get: function () { return rowNodeUtils_1._createRowNodeSibling; } }));
var columnFilterUtils_1 = __webpack_require__(4985);
Object.defineProperty(exports, "_refreshHandlerAndUi", ({ enumerable: true, get: function () { return columnFilterUtils_1._refreshHandlerAndUi; } }));
Object.defineProperty(exports, "_updateFilterModel", ({ enumerable: true, get: function () { return columnFilterUtils_1._updateFilterModel; } }));
Object.defineProperty(exports, "_refreshFilterUi", ({ enumerable: true, get: function () { return columnFilterUtils_1._refreshFilterUi; } }));
Object.defineProperty(exports, "_getFilterModel", ({ enumerable: true, get: function () { return columnFilterUtils_1._getFilterModel; } }));
var filterComp_1 = __webpack_require__(62231);
Object.defineProperty(exports, "FilterComp", ({ enumerable: true, get: function () { return filterComp_1.FilterComp; } }));
var filterWrapperComp_1 = __webpack_require__(21854);
Object.defineProperty(exports, "FilterWrapperComp", ({ enumerable: true, get: function () { return filterWrapperComp_1.FilterWrapperComp; } }));
var filterButtonComp_1 = __webpack_require__(71371);
Object.defineProperty(exports, "FilterButtonComp", ({ enumerable: true, get: function () { return filterButtonComp_1.FilterButtonComp; } }));
var filterDataTypeUtils_1 = __webpack_require__(26771);
Object.defineProperty(exports, "_getFilterParamsForDataType", ({ enumerable: true, get: function () { return filterDataTypeUtils_1._getFilterParamsForDataType; } }));
Object.defineProperty(exports, "_getDefaultSimpleFilter", ({ enumerable: true, get: function () { return filterDataTypeUtils_1._getDefaultSimpleFilter; } }));
var providedFilter_1 = __webpack_require__(2245);
Object.defineProperty(exports, "ProvidedFilter", ({ enumerable: true, get: function () { return providedFilter_1.ProvidedFilter; } }));
var providedFilterUtils_1 = __webpack_require__(96808);
Object.defineProperty(exports, "_isUseApplyButton", ({ enumerable: true, get: function () { return providedFilterUtils_1._isUseApplyButton; } }));
var iSimpleFilter_1 = __webpack_require__(78845);
Object.defineProperty(exports, "isCombinedFilterModel", ({ enumerable: true, get: function () { return iSimpleFilter_1.isCombinedFilterModel; } }));
var floatingFilterMapper_1 = __webpack_require__(59990);
Object.defineProperty(exports, "_getDefaultFloatingFilterType", ({ enumerable: true, get: function () { return floatingFilterMapper_1._getDefaultFloatingFilterType; } }));
// gridPanel
var gridBodyCtrl_1 = __webpack_require__(70520);
Object.defineProperty(exports, "GridBodyCtrl", ({ enumerable: true, get: function () { return gridBodyCtrl_1.GridBodyCtrl; } }));
var mouseEventUtils_1 = __webpack_require__(8399);
Object.defineProperty(exports, "_getCellPositionForEvent", ({ enumerable: true, get: function () { return mouseEventUtils_1._getCellPositionForEvent; } }));
Object.defineProperty(exports, "_getNormalisedMousePosition", ({ enumerable: true, get: function () { return mouseEventUtils_1._getNormalisedMousePosition; } }));
var fakeHScrollComp_1 = __webpack_require__(62716);
Object.defineProperty(exports, "FakeHScrollComp", ({ enumerable: true, get: function () { return fakeHScrollComp_1.FakeHScrollComp; } }));
var fakeVScrollComp_1 = __webpack_require__(46070);
Object.defineProperty(exports, "FakeVScrollComp", ({ enumerable: true, get: function () { return fakeVScrollComp_1.FakeVScrollComp; } }));
// rowContainer
var rowContainerCtrl_1 = __webpack_require__(8115);
Object.defineProperty(exports, "RowContainerCtrl", ({ enumerable: true, get: function () { return rowContainerCtrl_1.RowContainerCtrl; } }));
Object.defineProperty(exports, "_getRowContainerOptions", ({ enumerable: true, get: function () { return rowContainerCtrl_1._getRowContainerOptions; } }));
Object.defineProperty(exports, "_getRowSpanContainerClass", ({ enumerable: true, get: function () { return rowContainerCtrl_1._getRowSpanContainerClass; } }));
Object.defineProperty(exports, "_getRowContainerClass", ({ enumerable: true, get: function () { return rowContainerCtrl_1._getRowContainerClass; } }));
Object.defineProperty(exports, "_getRowViewportClass", ({ enumerable: true, get: function () { return rowContainerCtrl_1._getRowViewportClass; } }));
// headerRendering
var cssClassApplier_1 = __webpack_require__(91295);
Object.defineProperty(exports, "_getHeaderClassesFromColDef", ({ enumerable: true, get: function () { return cssClassApplier_1._getHeaderClassesFromColDef; } }));
Object.defineProperty(exports, "_getToolPanelClassesFromColDef", ({ enumerable: true, get: function () { return cssClassApplier_1._getToolPanelClassesFromColDef; } }));
var gridHeaderCtrl_1 = __webpack_require__(70009);
Object.defineProperty(exports, "GridHeaderCtrl", ({ enumerable: true, get: function () { return gridHeaderCtrl_1.GridHeaderCtrl; } }));
var headerRowContainerCtrl_1 = __webpack_require__(98934);
Object.defineProperty(exports, "HeaderRowContainerCtrl", ({ enumerable: true, get: function () { return headerRowContainerCtrl_1.HeaderRowContainerCtrl; } }));
var headerUtils_1 = __webpack_require__(1323);
Object.defineProperty(exports, "_getFloatingFiltersHeight", ({ enumerable: true, get: function () { return headerUtils_1.getFloatingFiltersHeight; } }));
Object.defineProperty(exports, "_getHeaderRowCount", ({ enumerable: true, get: function () { return headerUtils_1.getHeaderRowCount; } }));
var menuService_1 = __webpack_require__(8994);
Object.defineProperty(exports, "_setColMenuVisible", ({ enumerable: true, get: function () { return menuService_1._setColMenuVisible; } }));
var agAbstractCellEditor_1 = __webpack_require__(94872);
Object.defineProperty(exports, "AgAbstractCellEditor", ({ enumerable: true, get: function () { return agAbstractCellEditor_1.AgAbstractCellEditor; } }));
// features
var positionableFeature_1 = __webpack_require__(2147);
Object.defineProperty(exports, "PositionableFeature", ({ enumerable: true, get: function () { return positionableFeature_1.PositionableFeature; } }));
// rendering
var cellCtrl_1 = __webpack_require__(60814);
Object.defineProperty(exports, "_getCellCtrlForEventTarget", ({ enumerable: true, get: function () { return cellCtrl_1._getCellCtrlForEventTarget; } }));
var cssClassManager_1 = __webpack_require__(21734);
Object.defineProperty(exports, "CssClassManager", ({ enumerable: true, get: function () { return cssClassManager_1.CssClassManager; } }));
// row models
var pinnedRowModel_1 = __webpack_require__(9294);
Object.defineProperty(exports, "PinnedRowModel", ({ enumerable: true, get: function () { return pinnedRowModel_1.PinnedRowModel; } }));
var abstractClientSideNodeManager_1 = __webpack_require__(31954);
Object.defineProperty(exports, "AbstractClientSideNodeManager", ({ enumerable: true, get: function () { return abstractClientSideNodeManager_1.AbstractClientSideNodeManager; } }));
var serverSideTransaction_1 = __webpack_require__(73590);
Object.defineProperty(exports, "ServerSideTransactionResultStatus", ({ enumerable: true, get: function () { return serverSideTransaction_1.ServerSideTransactionResultStatus; } }));
// selection
var baseSelectionService_1 = __webpack_require__(23306);
Object.defineProperty(exports, "BaseSelectionService", ({ enumerable: true, get: function () { return baseSelectionService_1.BaseSelectionService; } }));
var agAbstractInputField_1 = __webpack_require__(98085);
Object.defineProperty(exports, "AgAbstractInputField", ({ enumerable: true, get: function () { return agAbstractInputField_1.AgAbstractInputField; } }));
var agCheckbox_1 = __webpack_require__(90066);
Object.defineProperty(exports, "AgCheckbox", ({ enumerable: true, get: function () { return agCheckbox_1.AgCheckbox; } }));
Object.defineProperty(exports, "AgCheckboxSelector", ({ enumerable: true, get: function () { return agCheckbox_1.AgCheckboxSelector; } }));
var agRadioButton_1 = __webpack_require__(77336);
Object.defineProperty(exports, "AgRadioButton", ({ enumerable: true, get: function () { return agRadioButton_1.AgRadioButton; } }));
var agToggleButton_1 = __webpack_require__(54927);
Object.defineProperty(exports, "AgToggleButton", ({ enumerable: true, get: function () { return agToggleButton_1.AgToggleButton; } }));
Object.defineProperty(exports, "AgToggleButtonSelector", ({ enumerable: true, get: function () { return agToggleButton_1.AgToggleButtonSelector; } }));
var agInputTextField_1 = __webpack_require__(45946);
Object.defineProperty(exports, "AgInputTextField", ({ enumerable: true, get: function () { return agInputTextField_1.AgInputTextField; } }));
Object.defineProperty(exports, "AgInputTextFieldSelector", ({ enumerable: true, get: function () { return agInputTextField_1.AgInputTextFieldSelector; } }));
var agInputTextArea_1 = __webpack_require__(56209);
Object.defineProperty(exports, "AgInputTextArea", ({ enumerable: true, get: function () { return agInputTextArea_1.AgInputTextArea; } }));
var agInputNumberField_1 = __webpack_require__(18792);
Object.defineProperty(exports, "AgInputNumberField", ({ enumerable: true, get: function () { return agInputNumberField_1.AgInputNumberField; } }));
Object.defineProperty(exports, "AgInputNumberFieldSelector", ({ enumerable: true, get: function () { return agInputNumberField_1.AgInputNumberFieldSelector; } }));
var agInputDateField_1 = __webpack_require__(23611);
Object.defineProperty(exports, "AgInputDateField", ({ enumerable: true, get: function () { return agInputDateField_1.AgInputDateField; } }));
var agSelect_1 = __webpack_require__(70159);
Object.defineProperty(exports, "AgSelect", ({ enumerable: true, get: function () { return agSelect_1.AgSelect; } }));
Object.defineProperty(exports, "AgSelectSelector", ({ enumerable: true, get: function () { return agSelect_1.AgSelectSelector; } }));
var component_2 = __webpack_require__(78020);
Object.defineProperty(exports, "Component", ({ enumerable: true, get: function () { return component_2.Component; } }));
var managedFocusFeature_1 = __webpack_require__(31772);
Object.defineProperty(exports, "ManagedFocusFeature", ({ enumerable: true, get: function () { return managedFocusFeature_1.ManagedFocusFeature; } }));
Object.defineProperty(exports, "_FOCUS_MANAGED_CLASS", ({ enumerable: true, get: function () { return managedFocusFeature_1.FOCUS_MANAGED_CLASS; } }));
var tabGuardComp_1 = __webpack_require__(68332);
Object.defineProperty(exports, "TabGuardComp", ({ enumerable: true, get: function () { return tabGuardComp_1.TabGuardComp; } }));
var tabGuardCtrl_1 = __webpack_require__(90006);
Object.defineProperty(exports, "TabGuardCtrl", ({ enumerable: true, get: function () { return tabGuardCtrl_1.TabGuardCtrl; } }));
Object.defineProperty(exports, "TabGuardClassNames", ({ enumerable: true, get: function () { return tabGuardCtrl_1.TabGuardClassNames; } }));
var tabGuardFeature_1 = __webpack_require__(71017);
Object.defineProperty(exports, "TabGuardFeature", ({ enumerable: true, get: function () { return tabGuardFeature_1.TabGuardFeature; } }));
var popupComponent_1 = __webpack_require__(63598);
Object.defineProperty(exports, "PopupComponent", ({ enumerable: true, get: function () { return popupComponent_1.PopupComponent; } }));
var touchListener_1 = __webpack_require__(99644);
Object.defineProperty(exports, "TouchListener", ({ enumerable: true, get: function () { return touchListener_1.TouchListener; } }));
var agAbstractLabel_1 = __webpack_require__(72747);
Object.defineProperty(exports, "AgAbstractLabel", ({ enumerable: true, get: function () { return agAbstractLabel_1.AgAbstractLabel; } }));
var agPickerField_1 = __webpack_require__(79497);
Object.defineProperty(exports, "AgPickerField", ({ enumerable: true, get: function () { return agPickerField_1.AgPickerField; } }));
// range
var IRangeService_1 = __webpack_require__(55961);
Object.defineProperty(exports, "CellRangeType", ({ enumerable: true, get: function () { return IRangeService_1.CellRangeType; } }));
// root
var autoScrollService_1 = __webpack_require__(35628);
Object.defineProperty(exports, "AutoScrollService", ({ enumerable: true, get: function () { return autoScrollService_1.AutoScrollService; } }));
var vanillaFrameworkOverrides_1 = __webpack_require__(56511);
Object.defineProperty(exports, "VanillaFrameworkOverrides", ({ enumerable: true, get: function () { return vanillaFrameworkOverrides_1.VanillaFrameworkOverrides; } }));
var keyCode_1 = __webpack_require__(39853);
Object.defineProperty(exports, "KeyCode", ({ enumerable: true, get: function () { return keyCode_1.KeyCode; } }));
var grid_1 = __webpack_require__(21657);
Object.defineProperty(exports, "GridCoreCreator", ({ enumerable: true, get: function () { return grid_1.GridCoreCreator; } }));
Object.defineProperty(exports, "createGrid", ({ enumerable: true, get: function () { return grid_1.createGrid; } }));
var globalGridOptions_1 = __webpack_require__(75518);
Object.defineProperty(exports, "provideGlobalGridOptions", ({ enumerable: true, get: function () { return globalGridOptions_1.provideGlobalGridOptions; } }));
Object.defineProperty(exports, "_getGlobalGridOption", ({ enumerable: true, get: function () { return globalGridOptions_1._getGlobalGridOption; } }));
var rowModelApiUtils_1 = __webpack_require__(66876);
Object.defineProperty(exports, "_getClientSideRowModel", ({ enumerable: true, get: function () { return rowModelApiUtils_1._getClientSideRowModel; } }));
Object.defineProperty(exports, "_getServerSideRowModel", ({ enumerable: true, get: function () { return rowModelApiUtils_1._getServerSideRowModel; } }));
var eventTypes_1 = __webpack_require__(73080);
Object.defineProperty(exports, "_GET_ALL_EVENTS", ({ enumerable: true, get: function () { return eventTypes_1._GET_ALL_EVENTS; } }));
Object.defineProperty(exports, "_PUBLIC_EVENTS", ({ enumerable: true, get: function () { return eventTypes_1._PUBLIC_EVENTS; } }));
var publicEventHandlersMap_1 = __webpack_require__(8829);
Object.defineProperty(exports, "_PUBLIC_EVENT_HANDLERS_MAP", ({ enumerable: true, get: function () { return publicEventHandlersMap_1._PUBLIC_EVENT_HANDLERS_MAP; } }));
var gridOptionsUtils_1 = __webpack_require__(67274);
Object.defineProperty(exports, "_addGridCommonParams", ({ enumerable: true, get: function () { return gridOptionsUtils_1._addGridCommonParams; } }));
Object.defineProperty(exports, "_getCallbackForEvent", ({ enumerable: true, get: function () { return gridOptionsUtils_1._getCallbackForEvent; } }));
Object.defineProperty(exports, "_combineAttributesAndGridOptions", ({ enumerable: true, get: function () { return gridOptionsUtils_1._combineAttributesAndGridOptions; } }));
Object.defineProperty(exports, "_processOnChange", ({ enumerable: true, get: function () { return gridOptionsUtils_1._processOnChange; } }));
Object.defineProperty(exports, "_getMaxConcurrentDatasourceRequests", ({ enumerable: true, get: function () { return gridOptionsUtils_1._getMaxConcurrentDatasourceRequests; } }));
Object.defineProperty(exports, "_getRowIdCallback", ({ enumerable: true, get: function () { return gridOptionsUtils_1._getRowIdCallback; } }));
Object.defineProperty(exports, "_getRowHeightForNode", ({ enumerable: true, get: function () { return gridOptionsUtils_1._getRowHeightForNode; } }));
Object.defineProperty(exports, "_isDomLayout", ({ enumerable: true, get: function () { return gridOptionsUtils_1._isDomLayout; } }));
Object.defineProperty(exports, "_isAnimateRows", ({ enumerable: true, get: function () { return gridOptionsUtils_1._isAnimateRows; } }));
Object.defineProperty(exports, "_getGrandTotalRow", ({ enumerable: true, get: function () { return gridOptionsUtils_1._getGrandTotalRow; } }));
Object.defineProperty(exports, "_getGroupTotalRowCallback", ({ enumerable: true, get: function () { return gridOptionsUtils_1._getGroupTotalRowCallback; } }));
Object.defineProperty(exports, "_isGroupMultiAutoColumn", ({ enumerable: true, get: function () { return gridOptionsUtils_1._isGroupMultiAutoColumn; } }));
Object.defineProperty(exports, "_isColumnsSortingCoupledToGroup", ({ enumerable: true, get: function () { return gridOptionsUtils_1._isColumnsSortingCoupledToGroup; } }));
Object.defineProperty(exports, "_isClientSideRowModel", ({ enumerable: true, get: function () { return gridOptionsUtils_1._isClientSideRowModel; } }));
Object.defineProperty(exports, "_isServerSideRowModel", ({ enumerable: true, get: function () { return gridOptionsUtils_1._isServerSideRowModel; } }));
Object.defineProperty(exports, "_isGroupUseEntireRow", ({ enumerable: true, get: function () { return gridOptionsUtils_1._isGroupUseEntireRow; } }));
Object.defineProperty(exports, "_isFullWidthGroupRow", ({ enumerable: true, get: function () { return gridOptionsUtils_1._isFullWidthGroupRow; } }));
Object.defineProperty(exports, "_canSkipShowingRowGroup", ({ enumerable: true, get: function () { return gridOptionsUtils_1._canSkipShowingRowGroup; } }));
Object.defineProperty(exports, "_getRowHeightAsNumber", ({ enumerable: true, get: function () { return gridOptionsUtils_1._getRowHeightAsNumber; } }));
Object.defineProperty(exports, "_shouldUpdateColVisibilityAfterGroup", ({ enumerable: true, get: function () { return gridOptionsUtils_1._shouldUpdateColVisibilityAfterGroup; } }));
Object.defineProperty(exports, "_getActiveDomElement", ({ enumerable: true, get: function () { return gridOptionsUtils_1._getActiveDomElement; } }));
Object.defineProperty(exports, "_isNothingFocused", ({ enumerable: true, get: function () { return gridOptionsUtils_1._isNothingFocused; } }));
Object.defineProperty(exports, "_getDocument", ({ enumerable: true, get: function () { return gridOptionsUtils_1._getDocument; } }));
Object.defineProperty(exports, "_getPageBody", ({ enumerable: true, get: function () { return gridOptionsUtils_1._getPageBody; } }));
Object.defineProperty(exports, "_anchorElementToMouseMoveEvent", ({ enumerable: true, get: function () { return gridOptionsUtils_1._anchorElementToMouseMoveEvent; } }));
Object.defineProperty(exports, "_getRootNode", ({ enumerable: true, get: function () { return gridOptionsUtils_1._getRootNode; } }));
Object.defineProperty(exports, "_getGroupAggFiltering", ({ enumerable: true, get: function () { return gridOptionsUtils_1._getGroupAggFiltering; } }));
Object.defineProperty(exports, "_isRowSelection", ({ enumerable: true, get: function () { return gridOptionsUtils_1._isRowSelection; } }));
Object.defineProperty(exports, "_isGetRowHeightFunction", ({ enumerable: true, get: function () { return gridOptionsUtils_1._isGetRowHeightFunction; } }));
Object.defineProperty(exports, "_getGroupSelection", ({ enumerable: true, get: function () { return gridOptionsUtils_1._getGroupSelection; } }));
Object.defineProperty(exports, "_getGroupSelectsDescendants", ({ enumerable: true, get: function () { return gridOptionsUtils_1._getGroupSelectsDescendants; } }));
Object.defineProperty(exports, "_getIsRowSelectable", ({ enumerable: true, get: function () { return gridOptionsUtils_1._getIsRowSelectable; } }));
Object.defineProperty(exports, "_getCheckboxes", ({ enumerable: true, get: function () { return gridOptionsUtils_1._getCheckboxes; } }));
Object.defineProperty(exports, "_getCheckboxLocation", ({ enumerable: true, get: function () { return gridOptionsUtils_1._getCheckboxLocation; } }));
Object.defineProperty(exports, "_getHeaderCheckbox", ({ enumerable: true, get: function () { return gridOptionsUtils_1._getHeaderCheckbox; } }));
Object.defineProperty(exports, "_isMultiRowSelection", ({ enumerable: true, get: function () { return gridOptionsUtils_1._isMultiRowSelection; } }));
Object.defineProperty(exports, "_getFillHandle", ({ enumerable: true, get: function () { return gridOptionsUtils_1._getFillHandle; } }));
Object.defineProperty(exports, "_isCellSelectionEnabled", ({ enumerable: true, get: function () { return gridOptionsUtils_1._isCellSelectionEnabled; } }));
Object.defineProperty(exports, "_getSuppressMultiRanges", ({ enumerable: true, get: function () { return gridOptionsUtils_1._getSuppressMultiRanges; } }));
Object.defineProperty(exports, "_getRowSelectionMode", ({ enumerable: true, get: function () { return gridOptionsUtils_1._getRowSelectionMode; } }));
Object.defineProperty(exports, "_isLegacyMenuEnabled", ({ enumerable: true, get: function () { return gridOptionsUtils_1._isLegacyMenuEnabled; } }));
Object.defineProperty(exports, "_isColumnMenuAnchoringEnabled", ({ enumerable: true, get: function () { return gridOptionsUtils_1._isColumnMenuAnchoringEnabled; } }));
Object.defineProperty(exports, "_isUsingNewRowSelectionAPI", ({ enumerable: true, get: function () { return gridOptionsUtils_1._isUsingNewRowSelectionAPI; } }));
Object.defineProperty(exports, "_isUsingNewCellSelectionAPI", ({ enumerable: true, get: function () { return gridOptionsUtils_1._isUsingNewCellSelectionAPI; } }));
Object.defineProperty(exports, "_isGroupRowsSticky", ({ enumerable: true, get: function () { return gridOptionsUtils_1._isGroupRowsSticky; } }));
Object.defineProperty(exports, "_getGroupingApproach", ({ enumerable: true, get: function () { return gridOptionsUtils_1._getGroupingApproach; } }));
Object.defineProperty(exports, "_getGridOption", ({ enumerable: true, get: function () { return gridOptionsUtils_1._getGridOption; } }));
Object.defineProperty(exports, "_isSetFilterByDefault", ({ enumerable: true, get: function () { return gridOptionsUtils_1._isSetFilterByDefault; } }));
var localEventService_1 = __webpack_require__(85889);
Object.defineProperty(exports, "LocalEventService", ({ enumerable: true, get: function () { return localEventService_1.LocalEventService; } }));
var gridCtrl_1 = __webpack_require__(37600);
Object.defineProperty(exports, "GridCtrl", ({ enumerable: true, get: function () { return gridCtrl_1.GridCtrl; } }));
var localeService_1 = __webpack_require__(9944);
Object.defineProperty(exports, "LocaleService", ({ enumerable: true, get: function () { return localeService_1.LocaleService; } }));
var localeUtils_1 = __webpack_require__(87230);
Object.defineProperty(exports, "_getLocaleTextFunc", ({ enumerable: true, get: function () { return localeUtils_1._getLocaleTextFunc; } }));
Object.defineProperty(exports, "_translate", ({ enumerable: true, get: function () { return localeUtils_1._translate; } }));
var stateUtils_1 = __webpack_require__(73240);
Object.defineProperty(exports, "convertColumnGroupState", ({ enumerable: true, get: function () { return stateUtils_1.convertColumnGroupState; } }));
Object.defineProperty(exports, "convertColumnState", ({ enumerable: true, get: function () { return stateUtils_1.convertColumnState; } }));
var positionUtils_1 = __webpack_require__(6257);
Object.defineProperty(exports, "_areCellsEqual", ({ enumerable: true, get: function () { return positionUtils_1._areCellsEqual; } }));
Object.defineProperty(exports, "_createCellId", ({ enumerable: true, get: function () { return positionUtils_1._createCellId; } }));
Object.defineProperty(exports, "_isRowBefore", ({ enumerable: true, get: function () { return positionUtils_1._isRowBefore; } }));
Object.defineProperty(exports, "_isSameRow", ({ enumerable: true, get: function () { return positionUtils_1._isSameRow; } }));
Object.defineProperty(exports, "_getRowNode", ({ enumerable: true, get: function () { return positionUtils_1._getRowNode; } }));
Object.defineProperty(exports, "_getCellByPosition", ({ enumerable: true, get: function () { return positionUtils_1._getCellByPosition; } }));
Object.defineProperty(exports, "_getRowAbove", ({ enumerable: true, get: function () { return positionUtils_1._getRowAbove; } }));
Object.defineProperty(exports, "_getRowBelow", ({ enumerable: true, get: function () { return positionUtils_1._getRowBelow; } }));
var propertyKeys_1 = __webpack_require__(40920);
Object.defineProperty(exports, "_GET_ALL_GRID_OPTIONS", ({ enumerable: true, get: function () { return propertyKeys_1._GET_ALL_GRID_OPTIONS; } }));
Object.defineProperty(exports, "_BOOLEAN_MIXED_GRID_OPTIONS", ({ enumerable: true, get: function () { return propertyKeys_1._BOOLEAN_MIXED_GRID_OPTIONS; } }));
var headerComp_1 = __webpack_require__(49270);
Object.defineProperty(exports, "_HeaderComp", ({ enumerable: true, get: function () { return headerComp_1.HeaderComp; } }));
var frameworkComponentWrapper_1 = __webpack_require__(8759);
Object.defineProperty(exports, "BaseComponentWrapper", ({ enumerable: true, get: function () { return frameworkComponentWrapper_1.BaseComponentWrapper; } }));
var tooltipFeature_1 = __webpack_require__(93386);
Object.defineProperty(exports, "TooltipFeature", ({ enumerable: true, get: function () { return tooltipFeature_1.TooltipFeature; } }));
Object.defineProperty(exports, "_getShouldDisplayTooltip", ({ enumerable: true, get: function () { return tooltipFeature_1._getShouldDisplayTooltip; } }));
Object.defineProperty(exports, "_isShowTooltipWhenTruncated", ({ enumerable: true, get: function () { return tooltipFeature_1._isShowTooltipWhenTruncated; } }));
// utils
var aria_1 = __webpack_require__(95230);
Object.defineProperty(exports, "_setAriaLevel", ({ enumerable: true, get: function () { return aria_1._setAriaLevel; } }));
Object.defineProperty(exports, "_setAriaLabel", ({ enumerable: true, get: function () { return aria_1._setAriaLabel; } }));
Object.defineProperty(exports, "_setAriaDescribedBy", ({ enumerable: true, get: function () { return aria_1._setAriaDescribedBy; } }));
Object.defineProperty(exports, "_setAriaExpanded", ({ enumerable: true, get: function () { return aria_1._setAriaExpanded; } }));
Object.defineProperty(exports, "_setAriaLabelledBy", ({ enumerable: true, get: function () { return aria_1._setAriaLabelledBy; } }));
Object.defineProperty(exports, "_setAriaChecked", ({ enumerable: true, get: function () { return aria_1._setAriaChecked; } }));
Object.defineProperty(exports, "_setAriaControls", ({ enumerable: true, get: function () { return aria_1._setAriaControls; } }));
Object.defineProperty(exports, "_setAriaControlsAndLabel", ({ enumerable: true, get: function () { return aria_1._setAriaControlsAndLabel; } }));
Object.defineProperty(exports, "_setAriaRole", ({ enumerable: true, get: function () { return aria_1._setAriaRole; } }));
Object.defineProperty(exports, "_setAriaColIndex", ({ enumerable: true, get: function () { return aria_1._setAriaColIndex; } }));
Object.defineProperty(exports, "_setAriaColSpan", ({ enumerable: true, get: function () { return aria_1._setAriaColSpan; } }));
Object.defineProperty(exports, "_setAriaRowIndex", ({ enumerable: true, get: function () { return aria_1._setAriaRowIndex; } }));
Object.defineProperty(exports, "_setAriaDisabled", ({ enumerable: true, get: function () { return aria_1._setAriaDisabled; } }));
Object.defineProperty(exports, "_setAriaHasPopup", ({ enumerable: true, get: function () { return aria_1._setAriaHasPopup; } }));
Object.defineProperty(exports, "_removeAriaExpanded", ({ enumerable: true, get: function () { return aria_1._removeAriaExpanded; } }));
Object.defineProperty(exports, "_removeAriaSort", ({ enumerable: true, get: function () { return aria_1._removeAriaSort; } }));
Object.defineProperty(exports, "_setAriaSort", ({ enumerable: true, get: function () { return aria_1._setAriaSort; } }));
Object.defineProperty(exports, "_setAriaColCount", ({ enumerable: true, get: function () { return aria_1._setAriaColCount; } }));
Object.defineProperty(exports, "_setAriaRowCount", ({ enumerable: true, get: function () { return aria_1._setAriaRowCount; } }));
Object.defineProperty(exports, "_setAriaActiveDescendant", ({ enumerable: true, get: function () { return aria_1._setAriaActiveDescendant; } }));
Object.defineProperty(exports, "_setAriaSelected", ({ enumerable: true, get: function () { return aria_1._setAriaSelected; } }));
Object.defineProperty(exports, "_setAriaPosInSet", ({ enumerable: true, get: function () { return aria_1._setAriaPosInSet; } }));
Object.defineProperty(exports, "_setAriaSetSize", ({ enumerable: true, get: function () { return aria_1._setAriaSetSize; } }));
Object.defineProperty(exports, "_setAriaHidden", ({ enumerable: true, get: function () { return aria_1._setAriaHidden; } }));
Object.defineProperty(exports, "_getAriaPosInSet", ({ enumerable: true, get: function () { return aria_1._getAriaPosInSet; } }));
Object.defineProperty(exports, "_setAriaInvalid", ({ enumerable: true, get: function () { return aria_1._setAriaInvalid; } }));
var array_1 = __webpack_require__(31502);
Object.defineProperty(exports, "_EmptyArray", ({ enumerable: true, get: function () { return array_1._EmptyArray; } }));
Object.defineProperty(exports, "_removeFromArray", ({ enumerable: true, get: function () { return array_1._removeFromArray; } }));
Object.defineProperty(exports, "_last", ({ enumerable: true, get: function () { return array_1._last; } }));
Object.defineProperty(exports, "_areEqual", ({ enumerable: true, get: function () { return array_1._areEqual; } }));
Object.defineProperty(exports, "_flatten", ({ enumerable: true, get: function () { return array_1._flatten; } }));
var browser_1 = __webpack_require__(98667);
Object.defineProperty(exports, "_isIOSUserAgent", ({ enumerable: true, get: function () { return browser_1._isIOSUserAgent; } }));
var changedPath_1 = __webpack_require__(76800);
Object.defineProperty(exports, "ChangedPath", ({ enumerable: true, get: function () { return changedPath_1.ChangedPath; } }));
var date_1 = __webpack_require__(39827);
Object.defineProperty(exports, "_serialiseDate", ({ enumerable: true, get: function () { return date_1._serialiseDate; } }));
Object.defineProperty(exports, "_getDateParts", ({ enumerable: true, get: function () { return date_1._getDateParts; } }));
Object.defineProperty(exports, "_parseDateTimeFromString", ({ enumerable: true, get: function () { return date_1._parseDateTimeFromString; } }));
var dom_1 = __webpack_require__(33507);
Object.defineProperty(exports, "_getAbsoluteHeight", ({ enumerable: true, get: function () { return dom_1._getAbsoluteHeight; } }));
Object.defineProperty(exports, "_getAbsoluteWidth", ({ enumerable: true, get: function () { return dom_1._getAbsoluteWidth; } }));
Object.defineProperty(exports, "_setDisplayed", ({ enumerable: true, get: function () { return dom_1._setDisplayed; } }));
Object.defineProperty(exports, "_clearElement", ({ enumerable: true, get: function () { return dom_1._clearElement; } }));
Object.defineProperty(exports, "_removeFromParent", ({ enumerable: true, get: function () { return dom_1._removeFromParent; } }));
Object.defineProperty(exports, "_radioCssClass", ({ enumerable: true, get: function () { return dom_1._radioCssClass; } }));
Object.defineProperty(exports, "_loadTemplate", ({ enumerable: true, get: function () { return dom_1._loadTemplate; } }));
Object.defineProperty(exports, "_createElement", ({ enumerable: true, get: function () { return dom_1._createElement; } }));
Object.defineProperty(exports, "_isVisible", ({ enumerable: true, get: function () { return dom_1._isVisible; } }));
Object.defineProperty(exports, "_setFixedWidth", ({ enumerable: true, get: function () { return dom_1._setFixedWidth; } }));
Object.defineProperty(exports, "_setDisabled", ({ enumerable: true, get: function () { return dom_1._setDisabled; } }));
Object.defineProperty(exports, "_setVisible", ({ enumerable: true, get: function () { return dom_1._setVisible; } }));
Object.defineProperty(exports, "_getInnerHeight", ({ enumerable: true, get: function () { return dom_1._getInnerHeight; } }));
Object.defineProperty(exports, "_getInnerWidth", ({ enumerable: true, get: function () { return dom_1._getInnerWidth; } }));
Object.defineProperty(exports, "_isNodeOrElement", ({ enumerable: true, get: function () { return dom_1._isNodeOrElement; } }));
Object.defineProperty(exports, "_observeResize", ({ enumerable: true, get: function () { return dom_1._observeResize; } }));
Object.defineProperty(exports, "_preserveRangesWhile", ({ enumerable: true, get: function () { return dom_1._preserveRangesWhile; } }));
Object.defineProperty(exports, "_requestAnimationFrame", ({ enumerable: true, get: function () { return dom_1._requestAnimationFrame; } }));
Object.defineProperty(exports, "_isElementOverflowingCallback", ({ enumerable: true, get: function () { return dom_1._isElementOverflowingCallback; } }));
var selection_1 = __webpack_require__(24009);
Object.defineProperty(exports, "_selectAllCells", ({ enumerable: true, get: function () { return selection_1._selectAllCells; } }));
var event_1 = __webpack_require__(92979);
Object.defineProperty(exports, "_stopPropagationForAgGrid", ({ enumerable: true, get: function () { return event_1._stopPropagationForAgGrid; } }));
Object.defineProperty(exports, "_isStopPropagationForAgGrid", ({ enumerable: true, get: function () { return event_1._isStopPropagationForAgGrid; } }));
Object.defineProperty(exports, "_isElementInEventPath", ({ enumerable: true, get: function () { return event_1._isElementInEventPath; } }));
var function_1 = __webpack_require__(92043);
Object.defineProperty(exports, "_warnOnce", ({ enumerable: true, get: function () { return function_1._warnOnce; } }));
Object.defineProperty(exports, "_debounce", ({ enumerable: true, get: function () { return function_1._debounce; } }));
Object.defineProperty(exports, "_doOnce", ({ enumerable: true, get: function () { return function_1._doOnce; } }));
Object.defineProperty(exports, "_waitUntil", ({ enumerable: true, get: function () { return function_1._waitUntil; } }));
Object.defineProperty(exports, "_batchCall", ({ enumerable: true, get: function () { return function_1._batchCall; } }));
var logging_1 = __webpack_require__(47764);
Object.defineProperty(exports, "_warn", ({ enumerable: true, get: function () { return logging_1._warn; } }));
Object.defineProperty(exports, "_error", ({ enumerable: true, get: function () { return logging_1._error; } }));
Object.defineProperty(exports, "_errMsg", ({ enumerable: true, get: function () { return logging_1._errMsg; } }));
Object.defineProperty(exports, "_preInitErrMsg", ({ enumerable: true, get: function () { return logging_1._preInitErrMsg; } }));
var mouse_1 = __webpack_require__(3276);
Object.defineProperty(exports, "_interpretAsRightClick", ({ enumerable: true, get: function () { return mouse_1._interpretAsRightClick; } }));
var icon_1 = __webpack_require__(59970);
Object.defineProperty(exports, "_createIcon", ({ enumerable: true, get: function () { return icon_1._createIcon; } }));
Object.defineProperty(exports, "_createIconNoSpan", ({ enumerable: true, get: function () { return icon_1._createIconNoSpan; } }));
var fuzzyMatch_1 = __webpack_require__(21298);
Object.defineProperty(exports, "_fuzzySuggestions", ({ enumerable: true, get: function () { return fuzzyMatch_1._fuzzySuggestions; } }));
var generic_1 = __webpack_require__(34422);
Object.defineProperty(exports, "_exists", ({ enumerable: true, get: function () { return generic_1._exists; } }));
Object.defineProperty(exports, "_missing", ({ enumerable: true, get: function () { return generic_1._missing; } }));
Object.defineProperty(exports, "_jsonEquals", ({ enumerable: true, get: function () { return generic_1._jsonEquals; } }));
Object.defineProperty(exports, "_toStringOrNull", ({ enumerable: true, get: function () { return generic_1._toStringOrNull; } }));
Object.defineProperty(exports, "_makeNull", ({ enumerable: true, get: function () { return generic_1._makeNull; } }));
Object.defineProperty(exports, "_defaultComparator", ({ enumerable: true, get: function () { return generic_1._defaultComparator; } }));
var keyboard_1 = __webpack_require__(16466);
Object.defineProperty(exports, "_isEventFromPrintableCharacter", ({ enumerable: true, get: function () { return keyboard_1._isEventFromPrintableCharacter; } }));
var number_1 = __webpack_require__(27698);
Object.defineProperty(exports, "_formatNumberCommas", ({ enumerable: true, get: function () { return number_1._formatNumberCommas; } }));
var object_1 = __webpack_require__(6996);
Object.defineProperty(exports, "_mergeDeep", ({ enumerable: true, get: function () { return object_1._mergeDeep; } }));
var string_1 = __webpack_require__(37766);
Object.defineProperty(exports, "_escapeString", ({ enumerable: true, get: function () { return string_1._escapeString; } }));
Object.defineProperty(exports, "_toString", ({ enumerable: true, get: function () { return string_1._toString; } }));
var promise_1 = __webpack_require__(57990);
Object.defineProperty(exports, "AgPromise", ({ enumerable: true, get: function () { return promise_1.AgPromise; } }));
Object.defineProperty(exports, "_isPromise", ({ enumerable: true, get: function () { return promise_1._isPromise; } }));
var focus_1 = __webpack_require__(82331);
Object.defineProperty(exports, "_addFocusableContainerListener", ({ enumerable: true, get: function () { return focus_1._addFocusableContainerListener; } }));
Object.defineProperty(exports, "_findFocusableElements", ({ enumerable: true, get: function () { return focus_1._findFocusableElements; } }));
Object.defineProperty(exports, "_focusInto", ({ enumerable: true, get: function () { return focus_1._focusInto; } }));
Object.defineProperty(exports, "_findNextFocusableElement", ({ enumerable: true, get: function () { return focus_1._findNextFocusableElement; } }));
Object.defineProperty(exports, "_findTabbableParent", ({ enumerable: true, get: function () { return focus_1._findTabbableParent; } }));
Object.defineProperty(exports, "_focusGridInnerElement", ({ enumerable: true, get: function () { return focus_1._focusGridInnerElement; } }));
Object.defineProperty(exports, "_isKeyboardMode", ({ enumerable: true, get: function () { return focus_1._isKeyboardMode; } }));
Object.defineProperty(exports, "_focusNextGridCoreContainer", ({ enumerable: true, get: function () { return focus_1._focusNextGridCoreContainer; } }));
// charts
tslib_1.__exportStar(__webpack_require__(17419), exports);
// sparklines
tslib_1.__exportStar(__webpack_require__(7919), exports);
// export
var baseCreator_1 = __webpack_require__(47331);
Object.defineProperty(exports, "BaseCreator", ({ enumerable: true, get: function () { return baseCreator_1.BaseCreator; } }));
var baseGridSerializingSession_1 = __webpack_require__(68376);
Object.defineProperty(exports, "BaseGridSerializingSession", ({ enumerable: true, get: function () { return baseGridSerializingSession_1.BaseGridSerializingSession; } }));
var downloader_1 = __webpack_require__(3885);
Object.defineProperty(exports, "_downloadFile", ({ enumerable: true, get: function () { return downloader_1._downloadFile; } }));
var moduleRegistry_1 = __webpack_require__(2132);
Object.defineProperty(exports, "ModuleRegistry", ({ enumerable: true, get: function () { return moduleRegistry_1.ModuleRegistry; } }));
Object.defineProperty(exports, "_registerModule", ({ enumerable: true, get: function () { return moduleRegistry_1._registerModule; } }));
Object.defineProperty(exports, "_getGridRegisteredModules", ({ enumerable: true, get: function () { return moduleRegistry_1._getGridRegisteredModules; } }));
Object.defineProperty(exports, "_setUmd", ({ enumerable: true, get: function () { return moduleRegistry_1._setUmd; } }));
var validationModule_1 = __webpack_require__(15010);
Object.defineProperty(exports, "ValidationModule", ({ enumerable: true, get: function () { return validationModule_1.ValidationModule; } }));
var columnMoveModule_1 = __webpack_require__(64074);
Object.defineProperty(exports, "_ColumnMoveModule", ({ enumerable: true, get: function () { return columnMoveModule_1.ColumnMoveModule; } }));
var dragModule_1 = __webpack_require__(24388);
Object.defineProperty(exports, "_DragModule", ({ enumerable: true, get: function () { return dragModule_1.DragModule; } }));
Object.defineProperty(exports, "_HorizontalResizeModule", ({ enumerable: true, get: function () { return dragModule_1.HorizontalResizeModule; } }));
Object.defineProperty(exports, "_SharedDragAndDropModule", ({ enumerable: true, get: function () { return dragModule_1.SharedDragAndDropModule; } }));
Object.defineProperty(exports, "DragAndDropModule", ({ enumerable: true, get: function () { return dragModule_1.DragAndDropModule; } }));
Object.defineProperty(exports, "RowDragModule", ({ enumerable: true, get: function () { return dragModule_1.RowDragModule; } }));
var filterModule_1 = __webpack_require__(45432);
Object.defineProperty(exports, "_ColumnFilterModule", ({ enumerable: true, get: function () { return filterModule_1.ColumnFilterModule; } }));
Object.defineProperty(exports, "_FilterCoreModule", ({ enumerable: true, get: function () { return filterModule_1.FilterCoreModule; } }));
Object.defineProperty(exports, "_FilterValueModule", ({ enumerable: true, get: function () { return filterModule_1.FilterValueModule; } }));
Object.defineProperty(exports, "CustomFilterModule", ({ enumerable: true, get: function () { return filterModule_1.CustomFilterModule; } }));
Object.defineProperty(exports, "QuickFilterModule", ({ enumerable: true, get: function () { return filterModule_1.QuickFilterModule; } }));
Object.defineProperty(exports, "TextFilterModule", ({ enumerable: true, get: function () { return filterModule_1.TextFilterModule; } }));
Object.defineProperty(exports, "NumberFilterModule", ({ enumerable: true, get: function () { return filterModule_1.NumberFilterModule; } }));
Object.defineProperty(exports, "DateFilterModule", ({ enumerable: true, get: function () { return filterModule_1.DateFilterModule; } }));
Object.defineProperty(exports, "ExternalFilterModule", ({ enumerable: true, get: function () { return filterModule_1.ExternalFilterModule; } }));
var editModule_1 = __webpack_require__(84652);
Object.defineProperty(exports, "_EditCoreModule", ({ enumerable: true, get: function () { return editModule_1.EditCoreModule; } }));
Object.defineProperty(exports, "NumberEditorModule", ({ enumerable: true, get: function () { return editModule_1.NumberEditorModule; } }));
Object.defineProperty(exports, "DateEditorModule", ({ enumerable: true, get: function () { return editModule_1.DateEditorModule; } }));
Object.defineProperty(exports, "CheckboxEditorModule", ({ enumerable: true, get: function () { return editModule_1.CheckboxEditorModule; } }));
Object.defineProperty(exports, "TextEditorModule", ({ enumerable: true, get: function () { return editModule_1.TextEditorModule; } }));
Object.defineProperty(exports, "LargeTextEditorModule", ({ enumerable: true, get: function () { return editModule_1.LargeTextEditorModule; } }));
Object.defineProperty(exports, "SelectEditorModule", ({ enumerable: true, get: function () { return editModule_1.SelectEditorModule; } }));
Object.defineProperty(exports, "UndoRedoEditModule", ({ enumerable: true, get: function () { return editModule_1.UndoRedoEditModule; } }));
Object.defineProperty(exports, "CustomEditorModule", ({ enumerable: true, get: function () { return editModule_1.CustomEditorModule; } }));
var rowSelectionModule_1 = __webpack_require__(43352);
Object.defineProperty(exports, "RowSelectionModule", ({ enumerable: true, get: function () { return rowSelectionModule_1.RowSelectionModule; } }));
Object.defineProperty(exports, "_SharedRowSelectionModule", ({ enumerable: true, get: function () { return rowSelectionModule_1.SharedRowSelectionModule; } }));
var sharedApiModule_1 = __webpack_require__(36437);
Object.defineProperty(exports, "_CsrmSsrmSharedApiModule", ({ enumerable: true, get: function () { return sharedApiModule_1.CsrmSsrmSharedApiModule; } }));
Object.defineProperty(exports, "_SsrmInfiniteSharedApiModule", ({ enumerable: true, get: function () { return sharedApiModule_1.SsrmInfiniteSharedApiModule; } }));
var sharedMenuModule_1 = __webpack_require__(23472);
Object.defineProperty(exports, "_SharedMenuModule", ({ enumerable: true, get: function () { return sharedMenuModule_1.SharedMenuModule; } }));
var sortModule_1 = __webpack_require__(96620);
Object.defineProperty(exports, "_SortModule", ({ enumerable: true, get: function () { return sortModule_1.SortModule; } }));
var alignedGridsModule_1 = __webpack_require__(22074);
Object.defineProperty(exports, "AlignedGridsModule", ({ enumerable: true, get: function () { return alignedGridsModule_1.AlignedGridsModule; } }));
var clientSideRowModelModule_1 = __webpack_require__(89722);
Object.defineProperty(exports, "ClientSideRowModelModule", ({ enumerable: true, get: function () { return clientSideRowModelModule_1.ClientSideRowModelModule; } }));
Object.defineProperty(exports, "ClientSideRowModelApiModule", ({ enumerable: true, get: function () { return clientSideRowModelModule_1.ClientSideRowModelApiModule; } }));
var csvExportModule_1 = __webpack_require__(59734);
Object.defineProperty(exports, "CsvExportModule", ({ enumerable: true, get: function () { return csvExportModule_1.CsvExportModule; } }));
var infiniteRowModelModule_1 = __webpack_require__(44002);
Object.defineProperty(exports, "InfiniteRowModelModule", ({ enumerable: true, get: function () { return infiniteRowModelModule_1.InfiniteRowModelModule; } }));
var popupModule_1 = __webpack_require__(3137);
Object.defineProperty(exports, "_PopupModule", ({ enumerable: true, get: function () { return popupModule_1.PopupModule; } }));
var navigationModule_1 = __webpack_require__(928);
Object.defineProperty(exports, "_KeyboardNavigationModule", ({ enumerable: true, get: function () { return navigationModule_1.KeyboardNavigationModule; } }));
var highlightChangesModule_1 = __webpack_require__(83498);
Object.defineProperty(exports, "HighlightChangesModule", ({ enumerable: true, get: function () { return highlightChangesModule_1.HighlightChangesModule; } }));
var columnGroupModule_1 = __webpack_require__(66041);
Object.defineProperty(exports, "_ColumnGroupModule", ({ enumerable: true, get: function () { return columnGroupModule_1.ColumnGroupModule; } }));
var stateModule_1 = __webpack_require__(6989);
Object.defineProperty(exports, "GridStateModule", ({ enumerable: true, get: function () { return stateModule_1.GridStateModule; } }));
var columnModule_1 = __webpack_require__(52027);
Object.defineProperty(exports, "ColumnApiModule", ({ enumerable: true, get: function () { return columnModule_1.ColumnApiModule; } }));
var paginationModule_1 = __webpack_require__(71824);
Object.defineProperty(exports, "PaginationModule", ({ enumerable: true, get: function () { return paginationModule_1.PaginationModule; } }));
var apiModule_1 = __webpack_require__(59642);
Object.defineProperty(exports, "RowApiModule", ({ enumerable: true, get: function () { return apiModule_1.RowApiModule; } }));
Object.defineProperty(exports, "ScrollApiModule", ({ enumerable: true, get: function () { return apiModule_1.ScrollApiModule; } }));
var renderModule_1 = __webpack_require__(66964);
Object.defineProperty(exports, "RenderApiModule", ({ enumerable: true, get: function () { return renderModule_1.RenderApiModule; } }));
var columnAutosizeModule_1 = __webpack_require__(63856);
Object.defineProperty(exports, "ColumnAutoSizeModule", ({ enumerable: true, get: function () { return columnAutosizeModule_1.ColumnAutoSizeModule; } }));
var pinnedRowModule_1 = __webpack_require__(15423);
Object.defineProperty(exports, "PinnedRowModule", ({ enumerable: true, get: function () { return pinnedRowModule_1.PinnedRowModule; } }));
var cellSpanModule_1 = __webpack_require__(4265);
Object.defineProperty(exports, "CellSpanModule", ({ enumerable: true, get: function () { return cellSpanModule_1.CellSpanModule; } }));
var valueModule_1 = __webpack_require__(76431);
Object.defineProperty(exports, "ValueCacheModule", ({ enumerable: true, get: function () { return valueModule_1.ValueCacheModule; } }));
Object.defineProperty(exports, "CellApiModule", ({ enumerable: true, get: function () { return valueModule_1.CellApiModule; } }));
var stylingModule_1 = __webpack_require__(68594);
Object.defineProperty(exports, "CellStyleModule", ({ enumerable: true, get: function () { return stylingModule_1.CellStyleModule; } }));
Object.defineProperty(exports, "RowStyleModule", ({ enumerable: true, get: function () { return stylingModule_1.RowStyleModule; } }));
var columnHoverModule_1 = __webpack_require__(41690);
Object.defineProperty(exports, "ColumnHoverModule", ({ enumerable: true, get: function () { return columnHoverModule_1.ColumnHoverModule; } }));
var apiEventModule_1 = __webpack_require__(99410);
Object.defineProperty(exports, "EventApiModule", ({ enumerable: true, get: function () { return apiEventModule_1.EventApiModule; } }));
var tooltipModule_1 = __webpack_require__(34658);
Object.defineProperty(exports, "TooltipModule", ({ enumerable: true, get: function () { return tooltipModule_1.TooltipModule; } }));
var localeModule_1 = __webpack_require__(89519);
Object.defineProperty(exports, "LocaleModule", ({ enumerable: true, get: function () { return localeModule_1.LocaleModule; } }));
var rowAutoHeightModule_1 = __webpack_require__(4577);
Object.defineProperty(exports, "RowAutoHeightModule", ({ enumerable: true, get: function () { return rowAutoHeightModule_1.RowAutoHeightModule; } }));
var exportModule_1 = __webpack_require__(92728);
Object.defineProperty(exports, "_SharedExportModule", ({ enumerable: true, get: function () { return exportModule_1.SharedExportModule; } }));
var allCommunityModule_1 = __webpack_require__(51621);
Object.defineProperty(exports, "AllCommunityModule", ({ enumerable: true, get: function () { return allCommunityModule_1.AllCommunityModule; } }));
//  events
tslib_1.__exportStar(__webpack_require__(57968), exports);
// theming
var Part_1 = __webpack_require__(86607);
Object.defineProperty(exports, "createPart", ({ enumerable: true, get: function () { return Part_1.createPart; } }));
var Theme_1 = __webpack_require__(39621);
Object.defineProperty(exports, "createTheme", ({ enumerable: true, get: function () { return Theme_1.createTheme; } }));
Object.defineProperty(exports, "_asThemeImpl", ({ enumerable: true, get: function () { return Theme_1._asThemeImpl; } }));
var checkbox_styles_1 = __webpack_require__(98265);
Object.defineProperty(exports, "checkboxStyleDefault", ({ enumerable: true, get: function () { return checkbox_styles_1.checkboxStyleDefault; } }));
var color_schemes_1 = __webpack_require__(38689);
Object.defineProperty(exports, "colorSchemeDark", ({ enumerable: true, get: function () { return color_schemes_1.colorSchemeDark; } }));
Object.defineProperty(exports, "colorSchemeDarkBlue", ({ enumerable: true, get: function () { return color_schemes_1.colorSchemeDarkBlue; } }));
Object.defineProperty(exports, "colorSchemeDarkWarm", ({ enumerable: true, get: function () { return color_schemes_1.colorSchemeDarkWarm; } }));
Object.defineProperty(exports, "colorSchemeLight", ({ enumerable: true, get: function () { return color_schemes_1.colorSchemeLight; } }));
Object.defineProperty(exports, "colorSchemeLightCold", ({ enumerable: true, get: function () { return color_schemes_1.colorSchemeLightCold; } }));
Object.defineProperty(exports, "colorSchemeLightWarm", ({ enumerable: true, get: function () { return color_schemes_1.colorSchemeLightWarm; } }));
Object.defineProperty(exports, "colorSchemeVariable", ({ enumerable: true, get: function () { return color_schemes_1.colorSchemeVariable; } }));
var icon_sets_1 = __webpack_require__(26407);
Object.defineProperty(exports, "iconOverrides", ({ enumerable: true, get: function () { return icon_sets_1.iconOverrides; } }));
Object.defineProperty(exports, "iconSetAlpine", ({ enumerable: true, get: function () { return icon_sets_1.iconSetAlpine; } }));
Object.defineProperty(exports, "iconSetMaterial", ({ enumerable: true, get: function () { return icon_sets_1.iconSetMaterial; } }));
Object.defineProperty(exports, "iconSetQuartz", ({ enumerable: true, get: function () { return icon_sets_1.iconSetQuartz; } }));
Object.defineProperty(exports, "iconSetQuartzBold", ({ enumerable: true, get: function () { return icon_sets_1.iconSetQuartzBold; } }));
Object.defineProperty(exports, "iconSetQuartzLight", ({ enumerable: true, get: function () { return icon_sets_1.iconSetQuartzLight; } }));
Object.defineProperty(exports, "iconSetQuartzRegular", ({ enumerable: true, get: function () { return icon_sets_1.iconSetQuartzRegular; } }));
var input_styles_1 = __webpack_require__(87161);
Object.defineProperty(exports, "inputStyleBase", ({ enumerable: true, get: function () { return input_styles_1.inputStyleBase; } }));
Object.defineProperty(exports, "inputStyleBordered", ({ enumerable: true, get: function () { return input_styles_1.inputStyleBordered; } }));
Object.defineProperty(exports, "inputStyleUnderlined", ({ enumerable: true, get: function () { return input_styles_1.inputStyleUnderlined; } }));
var button_styles_1 = __webpack_require__(82475);
Object.defineProperty(exports, "buttonStyleAlpine", ({ enumerable: true, get: function () { return button_styles_1.buttonStyleAlpine; } }));
Object.defineProperty(exports, "buttonStyleBalham", ({ enumerable: true, get: function () { return button_styles_1.buttonStyleBalham; } }));
Object.defineProperty(exports, "buttonStyleBase", ({ enumerable: true, get: function () { return button_styles_1.buttonStyleBase; } }));
Object.defineProperty(exports, "buttonStyleQuartz", ({ enumerable: true, get: function () { return button_styles_1.buttonStyleQuartz; } }));
var tab_styles_1 = __webpack_require__(5117);
Object.defineProperty(exports, "tabStyleAlpine", ({ enumerable: true, get: function () { return tab_styles_1.tabStyleAlpine; } }));
Object.defineProperty(exports, "tabStyleBase", ({ enumerable: true, get: function () { return tab_styles_1.tabStyleBase; } }));
Object.defineProperty(exports, "tabStyleMaterial", ({ enumerable: true, get: function () { return tab_styles_1.tabStyleMaterial; } }));
Object.defineProperty(exports, "tabStyleQuartz", ({ enumerable: true, get: function () { return tab_styles_1.tabStyleQuartz; } }));
Object.defineProperty(exports, "tabStyleRolodex", ({ enumerable: true, get: function () { return tab_styles_1.tabStyleRolodex; } }));
var column_drop_styles_1 = __webpack_require__(21697);
Object.defineProperty(exports, "columnDropStyleBordered", ({ enumerable: true, get: function () { return column_drop_styles_1.columnDropStyleBordered; } }));
Object.defineProperty(exports, "columnDropStylePlain", ({ enumerable: true, get: function () { return column_drop_styles_1.columnDropStylePlain; } }));
var themes_1 = __webpack_require__(2525);
Object.defineProperty(exports, "styleMaterial", ({ enumerable: true, get: function () { return themes_1.styleMaterial; } }));
Object.defineProperty(exports, "themeAlpine", ({ enumerable: true, get: function () { return themes_1.themeAlpine; } }));
Object.defineProperty(exports, "themeBalham", ({ enumerable: true, get: function () { return themes_1.themeBalham; } }));
Object.defineProperty(exports, "themeMaterial", ({ enumerable: true, get: function () { return themes_1.themeMaterial; } }));
Object.defineProperty(exports, "themeQuartz", ({ enumerable: true, get: function () { return themes_1.themeQuartz; } }));


/***/ }),

/***/ 14011:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnimationFrameModule = void 0;
const version_1 = __webpack_require__(97205);
const animationFrameService_1 = __webpack_require__(52612);
/**
 * @feature Rendering
 * @gridOption suppressAnimationFrame
 */
exports.AnimationFrameModule = {
    moduleName: 'AnimationFrame',
    version: version_1.VERSION,
    beans: [animationFrameService_1.AnimationFrameService],
};


/***/ }),

/***/ 52612:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnimationFrameService = void 0;
const beanStub_1 = __webpack_require__(68731);
const dom_1 = __webpack_require__(33507);
const logging_1 = __webpack_require__(47764);
class AnimationFrameService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'animationFrameSvc';
        // p1 and p2 are create tasks are to do with row and cell creation.
        // for them we want to execute according to row order, so we use
        // TaskItem so we know what index the item is for.
        this.p1 = { list: [], sorted: false }; // eg drawing back-ground of rows
        this.p2 = { list: [], sorted: false }; // eg cell renderers, adding hover functionality
        this.f1 = { list: [], sorted: false }; // eg framework cell renderers
        // destroy tasks are to do with row removal. they are done after row creation as the user will need to see new
        // rows first (as blank is scrolled into view), when we remove the old rows (no longer in view) is not as
        // important.
        this.destroyTasks = [];
        this.ticking = false;
        // we need to know direction of scroll, to build up rows in the direction of
        // the scroll. eg if user scrolls down, we extend the rows by building down.
        this.scrollGoingDown = true;
        this.lastScrollTop = 0;
        this.taskCount = 0;
    }
    setScrollTop(scrollTop) {
        this.scrollGoingDown = scrollTop >= this.lastScrollTop;
        if (scrollTop === 0) {
            // If we are at the top then we always want to be going down next.
            // This handles new pages for pagination and also row data being cleared.
            this.scrollGoingDown = true;
        }
        this.lastScrollTop = scrollTop;
    }
    postConstruct() {
        this.active = !this.gos.get('suppressAnimationFrame');
        this.batchFrameworkComps = this.beans.frameworkOverrides.batchFrameworkComps;
    }
    // this method is for our AG Grid sanity only - if animation frames are turned off,
    // then no place in the code should be looking to add any work to be done in animation
    // frames. this stops bugs - where some code is asking for a frame to be executed
    // when it should not.
    verify() {
        if (this.active === false) {
            (0, logging_1._warn)(92);
        }
    }
    createTask(task, index, list, isFramework, isDeferred = false) {
        this.verify();
        let taskList = list;
        if (isFramework && this.batchFrameworkComps) {
            taskList = 'f1';
        }
        const taskItem = { task, index, createOrder: ++this.taskCount, deferred: isDeferred };
        this.addTaskToList(this[taskList], taskItem);
        this.schedule();
    }
    addTaskToList(taskList, task) {
        taskList.list.push(task);
        taskList.sorted = false;
    }
    sortTaskList(taskList) {
        if (taskList.sorted) {
            return;
        }
        const sortDirection = this.scrollGoingDown ? 1 : -1;
        // Sort by:
        // 1. deferred last,
        // 2. then by row index (taking into account scroll direction),
        // 3. then by order of task creation (always ascending, so cells will render left-to-right)
        taskList.list.sort((a, b) => {
            if (a.deferred !== b.deferred) {
                return a.deferred ? -1 : 1; // deferred tasks always last
            }
            if (a.index !== b.index) {
                return sortDirection * (b.index - a.index);
            }
            return b.createOrder - a.createOrder;
        });
        taskList.sorted = true;
    }
    addDestroyTask(task) {
        this.verify();
        this.destroyTasks.push(task);
        this.schedule();
    }
    executeFrame(millis) {
        const { p1, p2, f1, destroyTasks, beans } = this;
        const { ctrlsSvc, frameworkOverrides } = beans;
        const p1Tasks = p1.list;
        const p2Tasks = p2.list;
        const f1Tasks = f1.list;
        const frameStart = Date.now();
        let duration = 0;
        // 16ms is 60 fps
        const noMaxMillis = millis <= 0;
        const scrollFeature = ctrlsSvc.getScrollFeature();
        while (noMaxMillis || duration < millis) {
            // scrollGridIfNeeded will cause tasks to be populated if scrolling was done and may have taken time
            // to do so. This is why we need to check if we have time left after scrolling before performing any tasks.
            const gridBodyDidSomething = scrollFeature.scrollGridIfNeeded();
            if (!gridBodyDidSomething) {
                let task;
                if (p1Tasks.length) {
                    this.sortTaskList(p1);
                    task = p1Tasks.pop().task;
                }
                else if (p2Tasks.length) {
                    this.sortTaskList(p2);
                    task = p2Tasks.pop().task;
                }
                else if (f1Tasks.length) {
                    // Assuming that framework tasks do not schedule p1 or p2 tasks so that it is safe
                    // to loop through all framework tasks for as long as we have time left
                    frameworkOverrides.wrapOutgoing(() => {
                        while (noMaxMillis || duration < millis) {
                            const gridBodyDidSomething = scrollFeature.scrollGridIfNeeded();
                            if (!gridBodyDidSomething) {
                                if (f1Tasks.length) {
                                    this.sortTaskList(f1);
                                    task = f1Tasks.pop().task;
                                    task();
                                }
                                else {
                                    break;
                                }
                            }
                            else {
                                // If the grid body did something, we need to break out of the framework loop as p1 and p2 tasks may have been scheduled.
                                break;
                            }
                            duration = Date.now() - frameStart;
                        }
                    });
                    // Empty task to avoid needing to check if task is defined in other path.
                    task = () => { };
                }
                else if (destroyTasks.length) {
                    task = destroyTasks.pop();
                }
                else {
                    break;
                }
                task();
            }
            duration = Date.now() - frameStart;
        }
        if (p1Tasks.length || p2Tasks.length || f1Tasks.length || destroyTasks.length) {
            this.requestFrame();
        }
        else {
            this.ticking = false;
        }
    }
    flushAllFrames() {
        if (!this.active) {
            return;
        }
        this.executeFrame(-1);
    }
    schedule() {
        if (!this.active) {
            return;
        }
        if (!this.ticking) {
            this.ticking = true;
            this.requestFrame();
        }
    }
    requestFrame() {
        // check for the existence of requestAnimationFrame, and if
        // it's missing, then we polyfill it with setTimeout()
        const callback = this.executeFrame.bind(this, 60);
        (0, dom_1._requestAnimationFrame)(this.beans, callback);
    }
    isQueueEmpty() {
        return !this.ticking;
    }
}
exports.AnimationFrameService = AnimationFrameService;


/***/ }),

/***/ 99410:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventApiModule = void 0;
const version_1 = __webpack_require__(97205);
const apiEventService_1 = __webpack_require__(46107);
const eventApi_1 = __webpack_require__(66470);
/**
 * @feature API -> Grid Events
 */
exports.EventApiModule = {
    moduleName: 'EventApi',
    version: version_1.VERSION,
    apiFunctions: {
        addEventListener: eventApi_1.addEventListener,
        addGlobalListener: eventApi_1.addGlobalListener,
        removeEventListener: eventApi_1.removeEventListener,
        removeGlobalListener: eventApi_1.removeGlobalListener,
    },
    beans: [apiEventService_1.ApiEventService],
};


/***/ }),

/***/ 46107:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApiEventService = void 0;
const beanStub_1 = __webpack_require__(68731);
const events_1 = __webpack_require__(57968);
class ApiEventService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'apiEventSvc';
        this.syncListeners = new Map();
        this.asyncListeners = new Map();
        this.syncGlobalListeners = new Set();
        this.globalListenerPairs = new Map();
    }
    postConstruct() {
        this.wrapSvc = this.beans.frameworkOverrides.createGlobalEventListenerWrapper?.();
    }
    addEventListener(eventType, userListener) {
        const listener = this.wrapSvc?.wrap(eventType, userListener) ?? userListener;
        const async = !events_1.ALWAYS_SYNC_GLOBAL_EVENTS.has(eventType);
        const listeners = async ? this.asyncListeners : this.syncListeners;
        if (!listeners.has(eventType)) {
            listeners.set(eventType, new Set());
        }
        listeners.get(eventType).add(listener);
        this.eventSvc.addEventListener(eventType, listener, async);
    }
    removeEventListener(eventType, userListener) {
        const listener = this.wrapSvc?.unwrap(eventType, userListener) ?? userListener;
        const asyncListeners = this.asyncListeners.get(eventType);
        const hasAsync = !!asyncListeners?.delete(listener);
        if (!hasAsync) {
            this.syncListeners.get(eventType)?.delete(listener);
        }
        this.eventSvc.removeEventListener(eventType, listener, hasAsync);
    }
    addGlobalListener(userListener) {
        const listener = this.wrapSvc?.wrapGlobal(userListener) ?? userListener;
        // if async then need to setup the global listener for sync to handle alwaysSyncGlobalEvents
        const syncListener = (eventType, event) => {
            if (events_1.ALWAYS_SYNC_GLOBAL_EVENTS.has(eventType)) {
                listener(eventType, event);
            }
        };
        const asyncListener = (eventType, event) => {
            if (!events_1.ALWAYS_SYNC_GLOBAL_EVENTS.has(eventType)) {
                listener(eventType, event);
            }
        };
        this.globalListenerPairs.set(userListener, { syncListener, asyncListener });
        const eventSvc = this.eventSvc;
        eventSvc.addGlobalListener(syncListener, false);
        eventSvc.addGlobalListener(asyncListener, true);
    }
    removeGlobalListener(userListener) {
        const { eventSvc, wrapSvc, globalListenerPairs } = this;
        const listener = wrapSvc?.unwrapGlobal(userListener) ?? userListener;
        const hasAsync = globalListenerPairs.has(listener);
        if (hasAsync) {
            // If it was async also remove the always sync listener we added
            const { syncListener, asyncListener } = globalListenerPairs.get(listener);
            eventSvc.removeGlobalListener(syncListener, false);
            eventSvc.removeGlobalListener(asyncListener, true);
            globalListenerPairs.delete(userListener);
        }
        else {
            this.syncGlobalListeners.delete(listener);
            eventSvc.removeGlobalListener(listener, false);
        }
    }
    destroyEventListeners(map, async) {
        map.forEach((listeners, eventType) => {
            listeners.forEach((listener) => this.eventSvc.removeEventListener(eventType, listener, async));
            listeners.clear();
        });
        map.clear();
    }
    destroyGlobalListeners(set, async) {
        set.forEach((listener) => this.eventSvc.removeGlobalListener(listener, async));
        set.clear();
    }
    destroy() {
        super.destroy();
        this.destroyEventListeners(this.syncListeners, false);
        this.destroyEventListeners(this.asyncListeners, true);
        this.destroyGlobalListeners(this.syncGlobalListeners, false);
        const { globalListenerPairs, eventSvc } = this;
        globalListenerPairs.forEach(({ syncListener, asyncListener }) => {
            eventSvc.removeGlobalListener(syncListener, false);
            eventSvc.removeGlobalListener(asyncListener, true);
        });
        globalListenerPairs.clear();
    }
}
exports.ApiEventService = ApiEventService;


/***/ }),

/***/ 66470:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.removeGlobalListener = exports.addGlobalListener = exports.removeEventListener = exports.addEventListener = void 0;
function addEventListener(beans, eventType, listener) {
    beans.apiEventSvc?.addEventListener(eventType, listener);
}
exports.addEventListener = addEventListener;
function removeEventListener(beans, eventType, listener) {
    beans.apiEventSvc?.removeEventListener(eventType, listener);
}
exports.removeEventListener = removeEventListener;
function addGlobalListener(beans, listener) {
    beans.apiEventSvc?.addGlobalListener(listener);
}
exports.addGlobalListener = addGlobalListener;
function removeGlobalListener(beans, listener) {
    beans.apiEventSvc?.removeGlobalListener(listener);
}
exports.removeGlobalListener = removeGlobalListener;


/***/ }),

/***/ 89519:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LocaleModule = void 0;
const version_1 = __webpack_require__(97205);
const localeService_1 = __webpack_require__(9944);
/**
 * @feature Interactivity -> Localisation
 * @gridOption localeText, getLocaleText
 */
exports.LocaleModule = {
    moduleName: 'Locale',
    version: version_1.VERSION,
    beans: [localeService_1.LocaleService],
};


/***/ }),

/***/ 9944:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LocaleService = void 0;
const beanStub_1 = __webpack_require__(68731);
class LocaleService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'localeSvc';
    }
    getLocaleTextFunc() {
        const gos = this.gos;
        const getLocaleText = gos.getCallback('getLocaleText');
        if (getLocaleText) {
            //key: string, defaultValue: string, variableValues?: string[]
            return (key, defaultValue, variableValues) => {
                const params = {
                    key,
                    defaultValue,
                    variableValues,
                };
                return getLocaleText(params);
            };
        }
        const localeText = gos.get('localeText');
        return (key, defaultValue, variableValues) => {
            let localisedText = localeText && localeText[key];
            if (localisedText && variableValues && variableValues.length) {
                let found = 0;
                while (true) {
                    if (found >= variableValues.length) {
                        break;
                    }
                    const idx = localisedText.indexOf('${variable}');
                    if (idx === -1) {
                        break;
                    }
                    localisedText = localisedText.replace('${variable}', variableValues[found++]);
                }
            }
            return localisedText ?? defaultValue;
        };
    }
}
exports.LocaleService = LocaleService;


/***/ }),

/***/ 87230:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._translate = exports._getLocaleTextFunc = void 0;
function defaultLocaleTextFunc(_key, defaultValue) {
    return defaultValue;
}
function _getLocaleTextFunc(localeSvc) {
    return localeSvc?.getLocaleTextFunc() ?? defaultLocaleTextFunc;
}
exports._getLocaleTextFunc = _getLocaleTextFunc;
function _translate(bean, localeValues, key, variableValues) {
    const defaultValue = localeValues[key];
    return bean.getLocaleTextFunc()(key, typeof defaultValue === 'function' ? defaultValue(variableValues) : defaultValue, variableValues);
}
exports._translate = _translate;


/***/ }),

/***/ 90297:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hidePopupMenu = exports.showColumnMenu = void 0;
const logging_1 = __webpack_require__(47764);
function showColumnMenu(beans, colKey) {
    const column = beans.colModel.getCol(colKey);
    if (!column) {
        // No column found, can't show menu
        (0, logging_1._error)(12, { colKey });
        return;
    }
    beans.menuSvc?.showColumnMenu({
        column,
        positionBy: 'auto',
    });
}
exports.showColumnMenu = showColumnMenu;
function hidePopupMenu(beans) {
    beans.menuSvc?.hidePopupMenu();
}
exports.hidePopupMenu = hidePopupMenu;


/***/ }),

/***/ 8994:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._setColMenuVisible = exports.MenuService = void 0;
const beanStub_1 = __webpack_require__(68731);
const agColumn_1 = __webpack_require__(13355);
const gridOptionsUtils_1 = __webpack_require__(67274);
const browser_1 = __webpack_require__(98667);
const dom_1 = __webpack_require__(33507);
class MenuService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'menuSvc';
    }
    postConstruct() {
        const { enterpriseMenuFactory, filterMenuFactory } = this.beans;
        this.activeMenuFactory = enterpriseMenuFactory ?? filterMenuFactory;
    }
    showColumnMenu(params) {
        this.showColumnMenuCommon(this.activeMenuFactory, params, 'columnMenu');
    }
    showFilterMenu(params) {
        const { enterpriseMenuFactory, filterMenuFactory } = this.beans;
        const menuFactory = enterpriseMenuFactory && (0, gridOptionsUtils_1._isLegacyMenuEnabled)(this.gos) ? enterpriseMenuFactory : filterMenuFactory;
        this.showColumnMenuCommon(menuFactory, params, params.containerType, true);
    }
    showHeaderContextMenu(column, mouseEvent, touchEvent) {
        this.activeMenuFactory?.showMenuAfterContextMenuEvent(column, mouseEvent, touchEvent);
    }
    hidePopupMenu() {
        // hide the context menu if in enterprise
        this.beans.contextMenuSvc?.hideActiveMenu();
        // and hide the column menu always
        this.activeMenuFactory?.hideActiveMenu();
    }
    isColumnMenuInHeaderEnabled(column) {
        const { suppressHeaderMenuButton } = column.getColDef();
        return (!suppressHeaderMenuButton &&
            !!this.activeMenuFactory?.isMenuEnabled(column) &&
            ((0, gridOptionsUtils_1._isLegacyMenuEnabled)(this.gos) || !!this.beans.enterpriseMenuFactory));
    }
    isFilterMenuInHeaderEnabled(column) {
        return !column.getColDef().suppressHeaderFilterButton && !!this.beans.filterManager?.isFilterAllowed(column);
    }
    isHeaderContextMenuEnabled(column) {
        const colDef = column && (0, agColumn_1.isColumn)(column) ? column.getColDef() : column?.getColGroupDef();
        return !colDef?.suppressHeaderContextMenu && this.gos.get('columnMenu') === 'new';
    }
    isHeaderMenuButtonAlwaysShowEnabled() {
        return this.isSuppressMenuHide();
    }
    isHeaderMenuButtonEnabled() {
        // we don't show the menu if on an iPad/iPhone, as the user cannot have a pointer device/
        // However if suppressMenuHide is set to true the menu will be displayed alwasys, so it's ok
        // to show it on iPad in this case (as hover isn't needed). If suppressMenuHide
        // is false (default) user will need to use longpress to display the menu.
        const menuHides = !this.isSuppressMenuHide();
        const onIpadAndMenuHides = (0, browser_1._isIOSUserAgent)() && menuHides;
        return !onIpadAndMenuHides;
    }
    isHeaderFilterButtonEnabled(column) {
        return (this.isFilterMenuInHeaderEnabled(column) &&
            !(0, gridOptionsUtils_1._isLegacyMenuEnabled)(this.gos) &&
            !this.isFloatingFilterButtonDisplayed(column));
    }
    isFilterMenuItemEnabled(column) {
        return (!!this.beans.filterManager?.isFilterAllowed(column) &&
            !(0, gridOptionsUtils_1._isLegacyMenuEnabled)(this.gos) &&
            !this.isFilterMenuInHeaderEnabled(column) &&
            !this.isFloatingFilterButtonDisplayed(column));
    }
    isFloatingFilterButtonEnabled(column) {
        return !column.getColDef().suppressFloatingFilterButton;
    }
    isFloatingFilterButtonDisplayed(column) {
        return !!column.getColDef().floatingFilter && this.isFloatingFilterButtonEnabled(column);
    }
    isSuppressMenuHide() {
        const gos = this.gos;
        const suppressMenuHide = gos.get('suppressMenuHide');
        if ((0, gridOptionsUtils_1._isLegacyMenuEnabled)(gos)) {
            // default to false for legacy
            return gos.exists('suppressMenuHide') ? suppressMenuHide : false;
        }
        return suppressMenuHide;
    }
    showColumnMenuCommon(menuFactory, params, containerType, filtersOnly) {
        const { positionBy, onClosedCallback } = params;
        const column = params.column;
        if (positionBy === 'button') {
            const { buttonElement } = params;
            menuFactory?.showMenuAfterButtonClick(column, buttonElement, containerType, onClosedCallback, filtersOnly);
        }
        else if (positionBy === 'mouse') {
            const { mouseEvent } = params;
            menuFactory?.showMenuAfterMouseEvent(column, mouseEvent, containerType, onClosedCallback, filtersOnly);
        }
        else if (column) {
            const beans = this.beans;
            const ctrlsSvc = beans.ctrlsSvc;
            // auto
            ctrlsSvc.getScrollFeature().ensureColumnVisible(column, 'auto');
            // make sure we've finished scrolling into view before displaying the menu
            (0, dom_1._requestAnimationFrame)(beans, () => {
                const headerCellCtrl = ctrlsSvc
                    .getHeaderRowContainerCtrl(column.getPinned())
                    ?.getHeaderCtrlForColumn(column);
                if (headerCellCtrl) {
                    menuFactory?.showMenuAfterButtonClick(column, headerCellCtrl.getAnchorElementForMenu(filtersOnly), containerType, onClosedCallback, filtersOnly);
                }
            });
        }
    }
}
exports.MenuService = MenuService;
function _setColMenuVisible(column, visible, source) {
    if (column.menuVisible !== visible) {
        column.menuVisible = visible;
        column.dispatchColEvent('menuVisibleChanged', source);
    }
}
exports._setColMenuVisible = _setColMenuVisible;


/***/ }),

/***/ 23472:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SharedMenuModule = void 0;
const version_1 = __webpack_require__(97205);
const menuApi_1 = __webpack_require__(90297);
const menuService_1 = __webpack_require__(8994);
/**
 * @internal
 */
exports.SharedMenuModule = {
    moduleName: 'SharedMenu',
    version: version_1.VERSION,
    beans: [menuService_1.MenuService],
    apiFunctions: {
        showColumnMenu: menuApi_1.showColumnMenu,
        hidePopupMenu: menuApi_1.hidePopupMenu,
    },
};


/***/ }),

/***/ 91997:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setState = exports.getState = void 0;
function getState(beans) {
    return beans.stateSvc?.getState() ?? {};
}
exports.getState = getState;
function setState(beans, state, propertiesToIgnore) {
    return beans.stateSvc?.setState(state, propertiesToIgnore);
}
exports.setState = setState;


/***/ }),

/***/ 6414:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.migrateGridStateModel = void 0;
const version_1 = __webpack_require__(97205);
/** This always returns a new object */
function migrateGridStateModel(state) {
    state = { ...state };
    // The `version` field was introduced in v32.2.0, so anything without that
    // field can be assumed to be compatible with v32.1.0
    if (!state.version) {
        state.version = '32.1.0';
    }
    switch (state.version) {
        case '32.1.0':
            state = migrateV32_1(state);
    }
    state.version = version_1.VERSION;
    return state;
}
exports.migrateGridStateModel = migrateGridStateModel;
/**
 * Copies `rangeSelection` (deprecated) to `cellSelection`, but doesn't remove the former
 * for backwards compatibility
 */
function migrateV32_1(state) {
    state.cellSelection = jsonGet(state, 'rangeSelection');
    return state;
}
function jsonGet(json, key) {
    if (json && typeof json === 'object') {
        return json[key];
    }
}


/***/ }),

/***/ 6989:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GridStateModule = void 0;
const version_1 = __webpack_require__(97205);
const stateApi_1 = __webpack_require__(91997);
const stateService_1 = __webpack_require__(73374);
/**
 * @feature API -> Grid State
 * @gridOption initialState
 */
exports.GridStateModule = {
    moduleName: 'GridState',
    version: version_1.VERSION,
    beans: [stateService_1.StateService],
    apiFunctions: {
        getState: stateApi_1.getState,
        setState: stateApi_1.setState,
    },
};


/***/ }),

/***/ 73374:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StateService = void 0;
const columnStateUtils_1 = __webpack_require__(2885);
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const function_1 = __webpack_require__(92043);
const generic_1 = __webpack_require__(34422);
const stateModelMigration_1 = __webpack_require__(6414);
const stateUtils_1 = __webpack_require__(73240);
class StateService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'stateSvc';
        this.updateRowGroupExpansionStateTimer = 0;
        this.suppressEvents = true;
        this.queuedUpdateSources = new Set();
        this.dispatchStateUpdateEventDebounced = (0, function_1._debounce)(this, () => this.dispatchQueuedStateUpdateEvents(), 0);
        // If user is doing a manual expand all node by node, we don't want to process one at a time.
        // EVENT_ROW_GROUP_OPENED is already async, so no impact of making the state async here.
        this.onRowGroupOpenedDebounced = (0, function_1._debounce)(this, () => {
            this.updateCachedState('rowGroupExpansion', this.getRowGroupExpansionState());
        }, 0);
        // similar to row expansion, want to debounce. However, selection is synchronous, so need to mark as stale in case `getState` is called.
        this.onRowSelectedDebounced = (0, function_1._debounce)(this, () => {
            this.staleStateKeys.delete('rowSelection');
            this.updateCachedState('rowSelection', this.getRowSelectionState());
        }, 0);
        this.staleStateKeys = new Set();
    }
    postConstruct() {
        this.isClientSideRowModel = (0, gridOptionsUtils_1._isClientSideRowModel)(this.gos);
        const initialState = (0, stateModelMigration_1.migrateGridStateModel)(this.gos.get('initialState') ?? {});
        const partialColumnState = initialState.partialColumnState;
        delete initialState.partialColumnState;
        this.cachedState = initialState;
        const suppressEventsAndDispatchInitEvent = this.suppressEventsAndDispatchInitEvent.bind(this);
        this.beans.ctrlsSvc.whenReady(this, () => suppressEventsAndDispatchInitEvent(() => this.setupStateOnGridReady(initialState)));
        const [newColumnsLoadedDestroyFunc, rowCountReadyDestroyFunc, firstDataRenderedDestroyFunc] = this.addManagedEventListeners({
            newColumnsLoaded: ({ source }) => {
                if (source === 'gridInitializing') {
                    newColumnsLoadedDestroyFunc();
                    suppressEventsAndDispatchInitEvent(() => this.setupStateOnColumnsInitialised(initialState, !!partialColumnState));
                }
            },
            rowCountReady: () => {
                rowCountReadyDestroyFunc?.();
                suppressEventsAndDispatchInitEvent(() => this.setupStateOnRowCountReady(initialState));
            },
            firstDataRendered: () => {
                firstDataRenderedDestroyFunc?.();
                suppressEventsAndDispatchInitEvent(() => this.setupStateOnFirstDataRendered(initialState));
            },
        });
    }
    destroy() {
        super.destroy();
        // Release memory
        clearTimeout(this.updateRowGroupExpansionStateTimer);
        this.queuedUpdateSources.clear();
    }
    getState() {
        if (this.staleStateKeys.size) {
            this.refreshStaleState();
        }
        return this.cachedState;
    }
    setState(providedState, propertiesToIgnore) {
        const state = (0, stateModelMigration_1.migrateGridStateModel)(providedState);
        delete state.partialColumnState;
        this.cachedState = state;
        this.startSuppressEvents();
        const source = 'api';
        const ignoreSet = propertiesToIgnore ? new Set(propertiesToIgnore) : undefined;
        this.setGridReadyState(state, source, ignoreSet);
        this.setColumnsInitialisedState(state, source, false, ignoreSet);
        this.setRowCountState(state, source, ignoreSet);
        setTimeout(() => {
            if (this.isAlive()) {
                this.setFirstDataRenderedState(state, source, ignoreSet);
            }
            this.stopSuppressEvents(source);
        });
    }
    setGridReadyState(state, source, ignoreSet) {
        // sidebar reads the initial state itself, so don't need to set on init
        if (source === 'api' && !ignoreSet?.has('sideBar')) {
            this.beans.sideBar?.comp?.setState(state.sideBar);
        }
        this.updateCachedState('sideBar', this.getSideBarState());
    }
    setupStateOnGridReady(initialState) {
        this.setGridReadyState(initialState, 'gridInitializing');
        const stateUpdater = () => this.updateCachedState('sideBar', this.getSideBarState());
        this.addManagedEventListeners({
            toolPanelVisibleChanged: stateUpdater,
            sideBarUpdated: stateUpdater,
        });
    }
    updateColumnAndGroupState() {
        this.updateColumnState([
            'aggregation',
            'columnOrder',
            'columnPinning',
            'columnSizing',
            'columnVisibility',
            'pivot',
            'rowGroup',
            'sort',
        ]);
        this.updateCachedState('columnGroup', this.getColumnGroupState());
    }
    setColumnsInitialisedState(state, source, partialColumnState, ignoreSet) {
        this.setColumnState(state, source, partialColumnState, ignoreSet);
        this.setColumnGroupState(state, source, ignoreSet);
        this.updateColumnAndGroupState();
    }
    setupStateOnColumnsInitialised(initialState, partialColumnState) {
        this.setColumnsInitialisedState(initialState, 'gridInitializing', partialColumnState);
        const onUpdate = (state) => () => this.updateColumnState([state]);
        this.addManagedEventListeners({
            columnValueChanged: onUpdate('aggregation'),
            columnMoved: onUpdate('columnOrder'),
            columnPinned: onUpdate('columnPinning'),
            columnResized: onUpdate('columnSizing'),
            columnVisible: onUpdate('columnVisibility'),
            columnPivotChanged: onUpdate('pivot'),
            columnPivotModeChanged: onUpdate('pivot'),
            columnRowGroupChanged: onUpdate('rowGroup'),
            sortChanged: onUpdate('sort'),
            newColumnsLoaded: this.updateColumnAndGroupState.bind(this),
            columnGroupOpened: () => this.updateCachedState('columnGroup', this.getColumnGroupState()),
        });
    }
    setRowCountState(state, source, ignoreSet) {
        const { filter: filterState, rowGroupExpansion: rowGroupExpansionState, rowSelection: rowSelectionState, pagination: paginationState, } = state;
        const shouldSetState = (prop, propState) => !ignoreSet?.has(prop) && (propState || source === 'api');
        if (shouldSetState('filter', filterState)) {
            this.setFilterState(filterState);
        }
        if (shouldSetState('rowGroupExpansion', rowGroupExpansionState)) {
            this.setRowGroupExpansionState(rowGroupExpansionState, source);
        }
        if (shouldSetState('rowSelection', rowSelectionState)) {
            this.setRowSelectionState(rowSelectionState, source);
        }
        if (shouldSetState('pagination', paginationState)) {
            this.setPaginationState(paginationState, source);
        }
        const updateCachedState = this.updateCachedState.bind(this);
        updateCachedState('filter', this.getFilterState());
        updateCachedState('rowGroupExpansion', this.getRowGroupExpansionState());
        updateCachedState('rowSelection', this.getRowSelectionState());
        updateCachedState('pagination', this.getPaginationState());
    }
    setupStateOnRowCountReady(initialState) {
        this.setRowCountState(initialState, 'gridInitializing');
        const updateCachedState = this.updateCachedState.bind(this);
        const updateRowGroupExpansionState = () => {
            this.updateRowGroupExpansionStateTimer = 0;
            updateCachedState('rowGroupExpansion', this.getRowGroupExpansionState());
        };
        const updateFilterState = () => updateCachedState('filter', this.getFilterState());
        const { gos, colFilter } = this.beans;
        this.addManagedEventListeners({
            filterChanged: updateFilterState,
            rowGroupOpened: () => this.onRowGroupOpenedDebounced(),
            expandOrCollapseAll: updateRowGroupExpansionState,
            // `groupDefaultExpanded`/`isGroupOpenByDefault` updates expansion state without an expansion event
            columnRowGroupChanged: updateRowGroupExpansionState,
            rowDataUpdated: () => {
                if (gos.get('groupDefaultExpanded') !== 0 || gos.get('isGroupOpenByDefault')) {
                    // once rows are loaded, they may be expanded, start the timer only once
                    this.updateRowGroupExpansionStateTimer || (this.updateRowGroupExpansionStateTimer = setTimeout(updateRowGroupExpansionState));
                }
            },
            selectionChanged: () => {
                this.staleStateKeys.add('rowSelection');
                this.onRowSelectedDebounced();
            },
            paginationChanged: (event) => {
                if (event.newPage || event.newPageSize) {
                    updateCachedState('pagination', this.getPaginationState());
                }
            },
        });
        if (colFilter) {
            this.addManagedListeners(colFilter, {
                filterStateChanged: updateFilterState,
            });
        }
    }
    setFirstDataRenderedState(state, source, ignoreSet) {
        const { scroll: scrollState, cellSelection: cellSelectionState, focusedCell: focusedCellState, columnOrder: columnOrderState, rowPinning, } = state;
        const shouldSetState = (prop, propState) => !ignoreSet?.has(prop) && (propState || source === 'api');
        if (shouldSetState('focusedCell', focusedCellState)) {
            this.setFocusedCellState(focusedCellState);
        }
        if (shouldSetState('cellSelection', cellSelectionState)) {
            this.setCellSelectionState(cellSelectionState);
        }
        if (shouldSetState('scroll', scrollState)) {
            this.setScrollState(scrollState);
        }
        if (shouldSetState('rowPinning', rowPinning)) {
            this.setRowPinningState(rowPinning);
        }
        this.setColumnPivotState(!!columnOrderState?.orderedColIds, source);
        const updateCachedState = this.updateCachedState.bind(this);
        // reset sidebar as it could have updated when columns changed
        updateCachedState('sideBar', this.getSideBarState());
        updateCachedState('focusedCell', this.getFocusedCellState());
        const cellSelection = this.getRangeSelectionState();
        updateCachedState('rangeSelection', cellSelection);
        updateCachedState('cellSelection', cellSelection);
        updateCachedState('scroll', this.getScrollState());
    }
    setupStateOnFirstDataRendered(initialState) {
        this.setFirstDataRenderedState(initialState, 'gridInitializing');
        const updateCachedState = this.updateCachedState.bind(this);
        this.addManagedEventListeners({
            cellFocused: () => updateCachedState('focusedCell', this.getFocusedCellState()),
            cellSelectionChanged: (event) => {
                if (event.finished) {
                    const cellSelection = this.getRangeSelectionState();
                    updateCachedState('rangeSelection', cellSelection);
                    updateCachedState('cellSelection', cellSelection);
                }
            },
            bodyScrollEnd: () => updateCachedState('scroll', this.getScrollState()),
            pinnedRowsChanged: () => updateCachedState('rowPinning', this.getRowPinningState()),
        });
    }
    getColumnState() {
        const beans = this.beans;
        return (0, stateUtils_1.convertColumnState)((0, columnStateUtils_1._getColumnState)(beans), beans.colModel.isPivotMode());
    }
    setColumnState(state, source, partialColumnState, ignoreSet) {
        const { sort: sortState, rowGroup: groupState, aggregation: aggregationState, pivot: pivotState, columnPinning: columnPinningState, columnVisibility: columnVisibilityState, columnSizing: columnSizingState, columnOrder: columnOrderState, } = state;
        const shouldSetState = (prop, propState) => !ignoreSet?.has(prop) && (propState || source === 'api');
        const columnStateMap = {};
        const getColumnState = (colId) => {
            let columnState = columnStateMap[colId];
            if (columnState) {
                return columnState;
            }
            columnState = { colId };
            columnStateMap[colId] = columnState;
            return columnState;
        };
        const defaultState = {};
        const shouldSetSortState = shouldSetState('sort', sortState);
        if (shouldSetSortState) {
            sortState?.sortModel.forEach(({ colId, sort }, sortIndex) => {
                const columnState = getColumnState(colId);
                columnState.sort = sort;
                columnState.sortIndex = sortIndex;
            });
        }
        if (shouldSetSortState || !partialColumnState) {
            defaultState.sort = null;
            defaultState.sortIndex = null;
        }
        const shouldSetGroupState = shouldSetState('rowGroup', groupState);
        if (shouldSetGroupState) {
            groupState?.groupColIds.forEach((colId, rowGroupIndex) => {
                const columnState = getColumnState(colId);
                columnState.rowGroup = true;
                columnState.rowGroupIndex = rowGroupIndex;
            });
        }
        if (shouldSetGroupState || !partialColumnState) {
            defaultState.rowGroup = null;
            defaultState.rowGroupIndex = null;
        }
        const shouldSetAggregationState = shouldSetState('aggregation', aggregationState);
        if (shouldSetAggregationState) {
            aggregationState?.aggregationModel.forEach(({ colId, aggFunc }) => {
                getColumnState(colId).aggFunc = aggFunc;
            });
        }
        if (shouldSetAggregationState || !partialColumnState) {
            defaultState.aggFunc = null;
        }
        const shouldSetPivotState = shouldSetState('pivot', pivotState);
        if (shouldSetPivotState) {
            pivotState?.pivotColIds.forEach((colId, pivotIndex) => {
                const columnState = getColumnState(colId);
                columnState.pivot = true;
                columnState.pivotIndex = pivotIndex;
            });
            this.gos.updateGridOptions({
                options: { pivotMode: !!pivotState?.pivotMode },
                source: source,
            });
        }
        if (shouldSetPivotState || !partialColumnState) {
            defaultState.pivot = null;
            defaultState.pivotIndex = null;
        }
        const shouldSetColumnPinningState = shouldSetState('columnPinning', columnPinningState);
        if (shouldSetColumnPinningState) {
            columnPinningState?.leftColIds.forEach((colId) => {
                getColumnState(colId).pinned = 'left';
            });
            columnPinningState?.rightColIds.forEach((colId) => {
                getColumnState(colId).pinned = 'right';
            });
        }
        if (shouldSetColumnPinningState || !partialColumnState) {
            defaultState.pinned = null;
        }
        const shouldSetColumnVisibilityState = shouldSetState('columnVisibility', columnVisibilityState);
        if (shouldSetColumnVisibilityState) {
            columnVisibilityState?.hiddenColIds.forEach((colId) => {
                getColumnState(colId).hide = true;
            });
        }
        if (shouldSetColumnVisibilityState || !partialColumnState) {
            defaultState.hide = null;
        }
        const shouldSetColumnSizingState = shouldSetState('columnSizing', columnSizingState);
        if (shouldSetColumnSizingState) {
            columnSizingState?.columnSizingModel.forEach(({ colId, flex, width }) => {
                const columnState = getColumnState(colId);
                columnState.flex = flex ?? null;
                columnState.width = width;
            });
        }
        if (shouldSetColumnSizingState || !partialColumnState) {
            defaultState.flex = null;
        }
        const columns = columnOrderState?.orderedColIds;
        const applyOrder = !!columns?.length && !ignoreSet?.has('columnOrder');
        const columnStates = applyOrder ? columns.map((colId) => getColumnState(colId)) : Object.values(columnStateMap);
        if (columnStates.length) {
            this.columnStates = columnStates;
            (0, columnStateUtils_1._applyColumnState)(this.beans, {
                state: columnStates,
                applyOrder,
                defaultState,
            }, source);
        }
    }
    setColumnPivotState(applyOrder, source) {
        const columnStates = this.columnStates;
        this.columnStates = undefined;
        const columnGroupStates = this.columnGroupStates;
        this.columnGroupStates = undefined;
        const beans = this.beans;
        const { pivotResultCols, colGroupSvc } = beans;
        if (!pivotResultCols?.isPivotResultColsPresent()) {
            return;
        }
        if (columnStates) {
            const secondaryColumnStates = [];
            for (const columnState of columnStates) {
                if (pivotResultCols.getPivotResultCol(columnState.colId)) {
                    secondaryColumnStates.push(columnState);
                }
            }
            (0, columnStateUtils_1._applyColumnState)(beans, {
                state: secondaryColumnStates,
                applyOrder,
            }, source);
        }
        if (columnGroupStates) {
            // no easy/performant way of knowing which column groups are pivot column groups
            colGroupSvc?.setColumnGroupState(columnGroupStates, source);
        }
    }
    getColumnGroupState() {
        const colGroupSvc = this.beans.colGroupSvc;
        if (!colGroupSvc) {
            return undefined;
        }
        const columnGroupState = colGroupSvc.getColumnGroupState();
        return (0, stateUtils_1._convertColumnGroupState)(columnGroupState);
    }
    setColumnGroupState(state, source, ignoreSet) {
        const colGroupSvc = this.beans.colGroupSvc;
        if (!colGroupSvc ||
            ignoreSet?.has('columnGroup') ||
            (source !== 'api' && !Object.prototype.hasOwnProperty.call(state, 'columnGroup'))) {
            return;
        }
        const openColumnGroups = new Set(state.columnGroup?.openColumnGroupIds);
        const existingColumnGroupState = colGroupSvc.getColumnGroupState();
        const stateItems = existingColumnGroupState.map(({ groupId }) => {
            const open = openColumnGroups.has(groupId);
            if (open) {
                openColumnGroups.delete(groupId);
            }
            return {
                groupId,
                open,
            };
        });
        // probably pivot cols
        openColumnGroups.forEach((groupId) => {
            stateItems.push({
                groupId,
                open: true,
            });
        });
        if (stateItems.length) {
            this.columnGroupStates = stateItems;
        }
        colGroupSvc.setColumnGroupState(stateItems, source);
    }
    getFilterState() {
        const filterManager = this.beans.filterManager;
        let filterModel = filterManager?.getFilterModel();
        if (filterModel && Object.keys(filterModel).length === 0) {
            filterModel = undefined;
        }
        const columnFilterState = filterManager?.getFilterState();
        const advancedFilterModel = filterManager?.getAdvFilterModel() ?? undefined;
        return filterModel || advancedFilterModel || columnFilterState
            ? { filterModel, columnFilterState, advancedFilterModel }
            : undefined;
    }
    setFilterState(filterState) {
        const filterManager = this.beans.filterManager;
        const { filterModel, columnFilterState, advancedFilterModel } = filterState ?? {
            filterModel: null,
            columnFilterState: null,
            advancedFilterModel: null,
        };
        if (filterModel !== undefined || columnFilterState !== undefined) {
            filterManager?.setFilterState(filterModel ?? null, columnFilterState ?? null, 'columnFilter');
        }
        if (advancedFilterModel !== undefined) {
            filterManager?.setAdvFilterModel(advancedFilterModel ?? null, 'advancedFilter');
        }
    }
    getRangeSelectionState() {
        const cellRanges = this.beans.rangeSvc?.getCellRanges().map((cellRange) => {
            const { id, type, startRow, endRow, columns, startColumn } = cellRange;
            return {
                id,
                type,
                startRow,
                endRow,
                colIds: columns.map((column) => column.getColId()),
                startColId: startColumn.getColId(),
            };
        });
        return cellRanges?.length ? { cellRanges } : undefined;
    }
    setCellSelectionState(cellSelectionState) {
        const { gos, rangeSvc, colModel, visibleCols } = this.beans;
        if (!(0, gridOptionsUtils_1._isCellSelectionEnabled)(gos) || !rangeSvc) {
            return;
        }
        const cellRanges = [];
        cellSelectionState?.cellRanges.forEach((cellRange) => {
            const columns = [];
            cellRange.colIds.forEach((colId) => {
                const column = colModel.getCol(colId);
                if (column) {
                    columns.push(column);
                }
            });
            if (!columns.length) {
                return;
            }
            let startColumn = colModel.getCol(cellRange.startColId);
            if (!startColumn) {
                // find the first remaining column
                const allColumns = visibleCols.allCols;
                const columnSet = new Set(columns);
                startColumn = allColumns.find((column) => columnSet.has(column));
            }
            cellRanges.push({
                ...cellRange,
                columns,
                startColumn,
            });
        });
        rangeSvc.setCellRanges(cellRanges);
    }
    getScrollState() {
        if (!this.isClientSideRowModel) {
            // can't restore, so don't provide
            return undefined;
        }
        const scrollFeature = this.beans.ctrlsSvc.getScrollFeature();
        const { left } = scrollFeature?.getHScrollPosition() ?? { left: 0 };
        const { top } = scrollFeature?.getVScrollPosition() ?? { top: 0 };
        return top || left
            ? {
                top,
                left,
            }
            : undefined;
    }
    setScrollState(scrollState) {
        if (!this.isClientSideRowModel) {
            return;
        }
        const { top, left } = scrollState ?? { top: 0, left: 0 };
        const { frameworkOverrides, rowRenderer, animationFrameSvc, ctrlsSvc } = this.beans;
        frameworkOverrides.wrapIncoming(() => {
            ctrlsSvc.get('center').setCenterViewportScrollLeft(left);
            ctrlsSvc.getScrollFeature()?.setVerticalScrollPosition(top);
            rowRenderer.redraw({ afterScroll: true });
            animationFrameSvc?.flushAllFrames();
        });
    }
    getSideBarState() {
        return this.beans.sideBar?.comp?.getState();
    }
    getFocusedCellState() {
        if (!this.isClientSideRowModel) {
            // can't restore, so don't provide
            return undefined;
        }
        const focusedCell = this.beans.focusSvc.getFocusedCell();
        if (focusedCell) {
            const { column, rowIndex, rowPinned } = focusedCell;
            return {
                colId: column.getColId(),
                rowIndex,
                rowPinned,
            };
        }
        return undefined;
    }
    setFocusedCellState(focusedCellState) {
        if (!this.isClientSideRowModel) {
            return;
        }
        const { focusSvc, colModel } = this.beans;
        if (!focusedCellState) {
            focusSvc.clearFocusedCell();
            return;
        }
        const { colId, rowIndex, rowPinned } = focusedCellState;
        focusSvc.setFocusedCell({
            column: colModel.getCol(colId),
            rowIndex,
            rowPinned,
            forceBrowserFocus: true,
            preventScrollOnBrowserFocus: true,
        });
    }
    getPaginationState() {
        const { pagination, gos } = this.beans;
        if (!pagination) {
            return undefined;
        }
        const page = pagination.getCurrentPage();
        const pageSize = !gos.get('paginationAutoPageSize') ? pagination.getPageSize() : undefined;
        if (!page && !pageSize) {
            return;
        }
        return { page, pageSize };
    }
    setPaginationState(paginationState, source) {
        const { pagination, gos } = this.beans;
        if (!pagination) {
            return;
        }
        const { pageSize, page } = paginationState ?? { page: 0, pageSize: gos.get('paginationPageSize') };
        const isInit = source === 'gridInitializing';
        if (pageSize && !gos.get('paginationAutoPageSize')) {
            pagination.setPageSize(pageSize, isInit ? 'initialState' : 'pageSizeSelector');
        }
        if (typeof page === 'number') {
            if (isInit) {
                pagination.setPage(page);
            }
            else {
                pagination.goToPage(page);
            }
        }
    }
    getRowSelectionState() {
        const selectionSvc = this.beans.selectionSvc;
        if (!selectionSvc) {
            return undefined;
        }
        const selectionState = selectionSvc.getSelectionState();
        const noSelections = !selectionState ||
            (!Array.isArray(selectionState) &&
                (selectionState.selectAll === false ||
                    selectionState.selectAllChildren === false) &&
                !selectionState?.toggledNodes?.length);
        return noSelections ? undefined : selectionState;
    }
    setRowSelectionState(rowSelectionState, source) {
        this.beans.selectionSvc?.setSelectionState(rowSelectionState, source, source === 'api');
    }
    getRowGroupExpansionState() {
        const { expansionSvc, rowModel } = this.beans;
        if (!expansionSvc) {
            return undefined;
        }
        const expandedRowGroups = [];
        rowModel.forEachNode(({ expanded, id }) => {
            if (expanded && id) {
                expandedRowGroups.push(id);
            }
        });
        return expandedRowGroups.length
            ? {
                expandedRowGroupIds: expandedRowGroups,
            }
            : undefined;
    }
    getRowPinningState() {
        return this.beans.pinnedRowModel?.getPinnedState();
    }
    setRowPinningState(state) {
        const pinnedRowModel = this.beans.pinnedRowModel;
        if (state) {
            pinnedRowModel?.setPinnedState(state);
        }
        else {
            pinnedRowModel?.reset();
        }
    }
    setRowGroupExpansionState(rowGroupExpansionState, source) {
        const expansionSvc = this.beans.expansionSvc;
        if (!expansionSvc) {
            return;
        }
        const rowGroupIdsToExpand = rowGroupExpansionState?.expandedRowGroupIds ?? [];
        let rowGroupIdsToCollapse;
        if (source === 'api') {
            const oldExpandedRowGroupIds = this.getRowGroupExpansionState()?.expandedRowGroupIds;
            if (oldExpandedRowGroupIds?.length) {
                const oldExpandedRowGroupIdsSet = new Set(oldExpandedRowGroupIds);
                for (const id of rowGroupIdsToExpand) {
                    oldExpandedRowGroupIdsSet.delete(id);
                }
                rowGroupIdsToCollapse = Array.from(oldExpandedRowGroupIdsSet);
            }
        }
        expansionSvc.expandRows(rowGroupIdsToExpand, rowGroupIdsToCollapse);
    }
    updateColumnState(features) {
        const newColumnState = this.getColumnState();
        let hasChanged = false;
        const cachedState = this.cachedState;
        for (const key of Object.keys(newColumnState)) {
            const value = newColumnState[key];
            if (!(0, generic_1._jsonEquals)(value, cachedState[key])) {
                hasChanged = true;
            }
        }
        this.cachedState = {
            ...cachedState,
            ...newColumnState,
        };
        if (hasChanged) {
            this.dispatchStateUpdateEvent(features);
        }
    }
    updateCachedState(key, value) {
        const existingValue = this.cachedState[key];
        this.setCachedStateValue(key, value);
        if (!(0, generic_1._jsonEquals)(value, existingValue)) {
            this.dispatchStateUpdateEvent([key]);
        }
    }
    setCachedStateValue(key, value) {
        this.cachedState = {
            ...this.cachedState,
            [key]: value,
        };
    }
    refreshStaleState() {
        const staleStateKeys = this.staleStateKeys;
        staleStateKeys.forEach((key) => {
            switch (key) {
                // only row selection supported for now
                case 'rowSelection':
                    this.setCachedStateValue(key, this.getRowSelectionState());
                    break;
            }
        });
        staleStateKeys.clear();
    }
    dispatchStateUpdateEvent(sources) {
        if (this.suppressEvents) {
            return;
        }
        sources.forEach((source) => this.queuedUpdateSources.add(source));
        this.dispatchStateUpdateEventDebounced();
    }
    dispatchQueuedStateUpdateEvents() {
        const queuedUpdateSources = this.queuedUpdateSources;
        const sources = Array.from(queuedUpdateSources);
        queuedUpdateSources.clear();
        this.eventSvc.dispatchEvent({
            type: 'stateUpdated',
            sources,
            state: this.cachedState,
        });
    }
    startSuppressEvents() {
        this.suppressEvents = true;
        this.beans.colAnimation?.setSuppressAnimation(true);
    }
    stopSuppressEvents(source) {
        // We want to suppress any grid events, but not user events.
        // Using a timeout here captures things like column resizing and emits a single grid initializing event.
        setTimeout(() => {
            this.suppressEvents = false;
            // We only want the grid initializing source.
            this.queuedUpdateSources.clear();
            if (!this.isAlive()) {
                // Ensure the grid is still alive before dispatching the event.
                return;
            }
            this.beans.colAnimation?.setSuppressAnimation(false);
            this.dispatchStateUpdateEvent([source]);
        });
    }
    suppressEventsAndDispatchInitEvent(updateFunc) {
        this.startSuppressEvents();
        updateFunc();
        this.stopSuppressEvents('gridInitializing');
    }
}
exports.StateService = StateService;


/***/ }),

/***/ 73240:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.convertColumnGroupState = exports._convertColumnGroupState = exports.convertColumnState = void 0;
/**
 * Converts state retrieved from `api.getColumnState()` to grid state.
 *
 * @param enablePivotMode Whether pivot mode should be enabled or not. Default `false`.
 * @returns A partial `GridState` object containing only the properties relevant to columns
 */
function convertColumnState(columnState, enablePivotMode = false) {
    const sortColumns = [];
    const groupColIds = [];
    const aggregationColumns = [];
    const pivotColIds = [];
    const leftColIds = [];
    const rightColIds = [];
    const hiddenColIds = [];
    const columnSizes = [];
    const columns = [];
    let defaultSortIndex = 0;
    for (let i = 0; i < columnState.length; i++) {
        const { colId, sort, sortIndex, rowGroup, rowGroupIndex, aggFunc, pivot, pivotIndex, pinned, hide, width, flex, } = columnState[i];
        columns.push(colId);
        if (sort) {
            sortColumns[sortIndex ?? defaultSortIndex++] = { colId, sort };
        }
        if (rowGroup) {
            groupColIds[rowGroupIndex ?? 0] = colId;
        }
        if (typeof aggFunc === 'string') {
            aggregationColumns.push({ colId, aggFunc });
        }
        if (pivot) {
            pivotColIds[pivotIndex ?? 0] = colId;
        }
        if (pinned) {
            (pinned === 'right' ? rightColIds : leftColIds).push(colId);
        }
        if (hide) {
            hiddenColIds.push(colId);
        }
        if (flex != null || width) {
            columnSizes.push({ colId, flex: flex ?? undefined, width });
        }
    }
    return {
        sort: sortColumns.length ? { sortModel: sortColumns } : undefined,
        rowGroup: groupColIds.length ? { groupColIds } : undefined,
        aggregation: aggregationColumns.length ? { aggregationModel: aggregationColumns } : undefined,
        pivot: pivotColIds.length || enablePivotMode ? { pivotMode: enablePivotMode, pivotColIds } : undefined,
        columnPinning: leftColIds.length || rightColIds.length ? { leftColIds, rightColIds } : undefined,
        columnVisibility: hiddenColIds.length ? { hiddenColIds } : undefined,
        columnSizing: columnSizes.length ? { columnSizingModel: columnSizes } : undefined,
        columnOrder: columns.length ? { orderedColIds: columns } : undefined,
    };
}
exports.convertColumnState = convertColumnState;
function _convertColumnGroupState(columnGroupState) {
    const openColumnGroups = [];
    columnGroupState.forEach(({ groupId, open }) => {
        if (open) {
            openColumnGroups.push(groupId);
        }
    });
    return openColumnGroups.length ? { openColumnGroupIds: openColumnGroups } : undefined;
}
exports._convertColumnGroupState = _convertColumnGroupState;
/**
 * Converts state retrieved from `api.getColumnGroupState()` to grid state.
 *
 * @returns A partial `GridState` object containing only the properties relevant to column groups
 */
function convertColumnGroupState(columnGroupState) {
    return { columnGroup: _convertColumnGroupState(columnGroupState) };
}
exports.convertColumnGroupState = convertColumnGroupState;


/***/ }),

/***/ 23705:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TouchModule = void 0;
const version_1 = __webpack_require__(97205);
const touchService_1 = __webpack_require__(53914);
/**
 * @feature Interactivity -> Touch
 */
exports.TouchModule = {
    moduleName: 'Touch',
    version: version_1.VERSION,
    beans: [touchService_1.TouchService],
};


/***/ }),

/***/ 53914:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TouchService = void 0;
const beanStub_1 = __webpack_require__(68731);
const mouseEventUtils_1 = __webpack_require__(8399);
const browser_1 = __webpack_require__(98667);
const event_1 = __webpack_require__(92979);
const generic_1 = __webpack_require__(34422);
const touchListener_1 = __webpack_require__(99644);
class TouchService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'touchSvc';
    }
    mockBodyContextMenu(ctrl, listener) {
        this.mockContextMenu(ctrl, ctrl.eBodyViewport, listener);
    }
    mockHeaderContextMenu(ctrl, listener) {
        this.mockContextMenu(ctrl, ctrl.eGui, listener);
    }
    mockRowContextMenu(ctrl) {
        // we do NOT want this when not in iPad, otherwise we will be doing
        if (!(0, browser_1._isIOSUserAgent)()) {
            return;
        }
        const listener = (mouseListener, touch, touchEvent) => {
            const { rowCtrl, cellCtrl } = ctrl.getControlsForEventTarget(touchEvent?.target ?? null);
            if (cellCtrl?.column) {
                cellCtrl.dispatchCellContextMenuEvent(touchEvent ?? null);
            }
            this.beans.contextMenuSvc?.handleContextMenuMouseEvent(undefined, touchEvent, rowCtrl, cellCtrl);
        };
        this.mockContextMenu(ctrl, ctrl.element, listener);
    }
    handleCellDoubleClick(ctrl, mouseEvent) {
        const isDoubleClickOnIPad = () => {
            if (!(0, browser_1._isIOSUserAgent)() || (0, event_1._isEventSupported)('dblclick')) {
                return false;
            }
            const nowMillis = Date.now();
            const res = nowMillis - ctrl.lastIPadMouseClickEvent < 200;
            ctrl.lastIPadMouseClickEvent = nowMillis;
            return res;
        };
        if (isDoubleClickOnIPad()) {
            ctrl.onCellDoubleClicked(mouseEvent);
            mouseEvent.preventDefault(); // if we don't do this, then iPad zooms in
            return true;
        }
        return false;
    }
    setupForHeader(comp) {
        const { gos, sortSvc, menuSvc } = this.beans;
        if (gos.get('suppressTouch')) {
            return;
        }
        const { params, eMenu, eFilterButton } = comp;
        const touchListener = new touchListener_1.TouchListener(comp.getGui(), true);
        const suppressMenuHide = comp.shouldSuppressMenuHide();
        const tapMenuButton = suppressMenuHide && (0, generic_1._exists)(eMenu) && params.enableMenu;
        const menuTouchListener = tapMenuButton ? new touchListener_1.TouchListener(eMenu, true) : touchListener;
        if (params.enableMenu || menuSvc?.isHeaderContextMenuEnabled(params.column)) {
            const eventType = tapMenuButton ? 'tap' : 'longTap';
            const showMenuFn = (event) => params.showColumnMenuAfterMouseClick(event.touchStart);
            comp.addManagedListeners(menuTouchListener, { [eventType]: showMenuFn });
        }
        if (params.enableSorting) {
            const tapListener = (event) => {
                const target = event.touchStart.target;
                // When suppressMenuHide is true, a tap on the menu icon or filter button will bubble up
                // to the header container, in that case we should not sort
                if (suppressMenuHide && (eMenu?.contains(target) || eFilterButton?.contains(target))) {
                    return;
                }
                sortSvc?.progressSort(params.column, false, 'uiColumnSorted');
            };
            comp.addManagedListeners(touchListener, { tap: tapListener });
        }
        if (params.enableFilterButton && eFilterButton) {
            const filterButtonTouchListener = new touchListener_1.TouchListener(eFilterButton, true);
            comp.addManagedListeners(filterButtonTouchListener, {
                tap: () => params.showFilter(eFilterButton),
            });
            comp.addDestroyFunc(() => filterButtonTouchListener.destroy());
        }
        // if tapMenuButton is true `touchListener` and `menuTouchListener` are different
        // so we need to make sure to destroy both listeners here
        comp.addDestroyFunc(() => touchListener.destroy());
        if (tapMenuButton) {
            comp.addDestroyFunc(() => menuTouchListener.destroy());
        }
    }
    setupForHeaderGroup(comp) {
        const params = comp.params;
        if (this.beans.menuSvc?.isHeaderContextMenuEnabled(params.columnGroup.getProvidedColumnGroup())) {
            const touchListener = new touchListener_1.TouchListener(params.eGridHeader, true);
            const showMenuFn = (event) => params.showColumnMenuAfterMouseClick(event.touchStart);
            comp.addManagedListeners(touchListener, { longTap: showMenuFn });
            comp.addDestroyFunc(() => touchListener.destroy());
        }
    }
    setupForHeaderGroupElement(comp, eElement, action) {
        const touchListener = new touchListener_1.TouchListener(eElement, true);
        comp.addManagedListeners(touchListener, { tap: action });
        comp.addDestroyFunc(() => touchListener.destroy());
    }
    mockContextMenu(ctrl, element, listener) {
        // we do NOT want this when not in iPad
        if (!(0, browser_1._isIOSUserAgent)()) {
            return;
        }
        const touchListener = new touchListener_1.TouchListener(element);
        const longTapListener = (event) => {
            if (!(0, mouseEventUtils_1._isEventFromThisGrid)(this.gos, event.touchEvent)) {
                return;
            }
            listener(undefined, event.touchStart, event.touchEvent);
        };
        ctrl.addManagedListeners(touchListener, { longTap: longTapListener });
        ctrl.addDestroyFunc(() => touchListener.destroy());
    }
}
exports.TouchService = TouchService;


/***/ }),

/***/ 2132:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ModuleRegistry = exports._setUmd = exports._isUmd = exports._hasUserRegistered = exports._getGridRegisteredModules = exports._getAllRegisteredModules = exports._getRegisteredModules = exports._areModulesGridScoped = exports._isModuleRegistered = exports._unRegisterGridModules = exports._registerModule = void 0;
const function_1 = __webpack_require__(92043);
const allRegisteredModules = new Set();
const globalModulesMap = {};
const gridModulesMap = {};
let currentModuleVersion;
let userHasRegistered = false;
let areGridScopedModules = false;
let isUmd = false;
function isValidModuleVersion(module) {
    const [moduleMajor, moduleMinor] = module.version.split('.') || [];
    const [currentModuleMajor, currentModuleMinor] = currentModuleVersion.split('.') || [];
    return moduleMajor === currentModuleMajor && moduleMinor === currentModuleMinor;
}
function runVersionChecks(module) {
    if (!currentModuleVersion) {
        currentModuleVersion = module.version;
    }
    const errorMsg = (details) => `You are using incompatible versions of AG Grid modules. Major and minor versions should always match across modules. ${details} Please update all modules to the same version.`;
    if (!module.version) {
        (0, function_1._errorOnce)(errorMsg(`'${module.moduleName}' is incompatible.`));
    }
    else if (!isValidModuleVersion(module)) {
        (0, function_1._errorOnce)(errorMsg(`'${module.moduleName}' is version ${module.version} but the other modules are version ${currentModuleVersion}.`));
    }
    if (module.validate) {
        const result = module.validate();
        if (!result.isValid) {
            const errorResult = result;
            (0, function_1._errorOnce)(`${errorResult.message}`);
        }
    }
}
function _registerModule(module, gridId, isInternalRegistration = false) {
    if (!isInternalRegistration) {
        userHasRegistered = true;
    }
    runVersionChecks(module);
    const rowModels = module.rowModels ?? ['all'];
    allRegisteredModules.add(module);
    let moduleStore;
    if (gridId !== undefined) {
        areGridScopedModules = true;
        if (gridModulesMap[gridId] === undefined) {
            gridModulesMap[gridId] = {};
        }
        moduleStore = gridModulesMap[gridId];
    }
    else {
        moduleStore = globalModulesMap;
    }
    rowModels.forEach((rowModel) => {
        if (moduleStore[rowModel] === undefined) {
            moduleStore[rowModel] = {};
        }
        moduleStore[rowModel][module.moduleName] = module;
    });
    if (module.dependsOn) {
        module.dependsOn.forEach((dependency) => _registerModule(dependency, gridId, isInternalRegistration));
    }
}
exports._registerModule = _registerModule;
function _unRegisterGridModules(gridId) {
    delete gridModulesMap[gridId];
}
exports._unRegisterGridModules = _unRegisterGridModules;
function _isModuleRegistered(moduleName, gridId, rowModel) {
    const isRegisteredForRowModel = (model) => !!globalModulesMap[model]?.[moduleName] || !!gridModulesMap[gridId]?.[model]?.[moduleName];
    return isRegisteredForRowModel(rowModel) || isRegisteredForRowModel('all');
}
exports._isModuleRegistered = _isModuleRegistered;
function _areModulesGridScoped() {
    return areGridScopedModules;
}
exports._areModulesGridScoped = _areModulesGridScoped;
function _getRegisteredModules(gridId, rowModel) {
    const gridModules = gridModulesMap[gridId] ?? {};
    return [
        ...Object.values(globalModulesMap['all'] ?? {}),
        ...Object.values(gridModules['all'] ?? {}),
        ...Object.values(globalModulesMap[rowModel] ?? {}),
        ...Object.values(gridModules[rowModel] ?? {}),
    ];
}
exports._getRegisteredModules = _getRegisteredModules;
function _getAllRegisteredModules() {
    return new Set(allRegisteredModules);
}
exports._getAllRegisteredModules = _getAllRegisteredModules;
function _getGridRegisteredModules(gridId, rowModel) {
    const gridModules = gridModulesMap[gridId] ?? {};
    return [...Object.values(gridModules['all'] ?? {}), ...Object.values(gridModules[rowModel] ?? {})];
}
exports._getGridRegisteredModules = _getGridRegisteredModules;
/** Internal logic to track if the user has registered modules so that we can give an optimised error message. */
function _hasUserRegistered() {
    return userHasRegistered;
}
exports._hasUserRegistered = _hasUserRegistered;
function _isUmd() {
    return isUmd;
}
exports._isUmd = _isUmd;
/** Internal use to provide clear error messages for UMD users. */
function _setUmd() {
    isUmd = true;
}
exports._setUmd = _setUmd;
class ModuleRegistry {
    /**
     * @deprecated v33 Use `registerModules([module])` instead.
     */
    static register(module) {
        _registerModule(module, undefined);
    }
    /**
     * Globally register the given modules for all grids.
     * @param modules - modules to register
     */
    static registerModules(modules) {
        modules.forEach((module) => _registerModule(module, undefined));
    }
}
exports.ModuleRegistry = ModuleRegistry;


/***/ }),

/***/ 39413:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CellNavigationService = void 0;
const keyCode_1 = __webpack_require__(39853);
const beanStub_1 = __webpack_require__(68731);
const positionUtils_1 = __webpack_require__(6257);
const array_1 = __webpack_require__(31502);
const generic_1 = __webpack_require__(34422);
const logging_1 = __webpack_require__(47764);
class CellNavigationService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'cellNavigation';
    }
    wireBeans(beans) {
        this.rowSpanSvc = beans.rowSpanSvc;
    }
    // returns null if no cell to focus on, ie at the end of the grid
    getNextCellToFocus(key, focusedCell, ctrlPressed = false) {
        if (ctrlPressed) {
            return this.getNextCellToFocusWithCtrlPressed(key, focusedCell);
        }
        return this.getNextCellToFocusWithoutCtrlPressed(key, focusedCell);
    }
    getNextCellToFocusWithCtrlPressed(key, focusedCell) {
        const upKey = key === keyCode_1.KeyCode.UP;
        const downKey = key === keyCode_1.KeyCode.DOWN;
        const leftKey = key === keyCode_1.KeyCode.LEFT;
        let column;
        let rowIndex;
        const { pageBounds, gos, visibleCols } = this.beans;
        if (upKey || downKey) {
            rowIndex = upKey ? pageBounds.getFirstRow() : pageBounds.getLastRow();
            column = focusedCell.column;
        }
        else {
            const isRtl = gos.get('enableRtl');
            rowIndex = focusedCell.rowIndex;
            const allColumns = leftKey !== isRtl ? visibleCols.allCols : [...visibleCols.allCols].reverse();
            column = allColumns.find((col) => this.isCellGoodToFocusOn({
                rowIndex,
                rowPinned: null,
                column: col,
            }));
        }
        return column
            ? {
                rowIndex,
                rowPinned: null,
                column,
            }
            : null;
    }
    getNextCellToFocusWithoutCtrlPressed(key, focusedCell) {
        // starting with the provided cell, we keep moving until we find a cell we can
        // focus on.
        let pointer = focusedCell;
        let finished = false;
        // finished will be true when either:
        // a) cell found that we can focus on
        // b) run out of cells (ie the method returns null)
        while (!finished) {
            switch (key) {
                case keyCode_1.KeyCode.UP:
                    pointer = this.getCellAbove(pointer);
                    break;
                case keyCode_1.KeyCode.DOWN:
                    pointer = this.getCellBelow(pointer);
                    break;
                case keyCode_1.KeyCode.RIGHT:
                    pointer = this.gos.get('enableRtl') ? this.getCellToLeft(pointer) : this.getCellToRight(pointer);
                    break;
                case keyCode_1.KeyCode.LEFT:
                    pointer = this.gos.get('enableRtl') ? this.getCellToRight(pointer) : this.getCellToLeft(pointer);
                    break;
                default:
                    pointer = null;
                    // unknown key, do nothing
                    (0, logging_1._warn)(8, { key });
                    break;
            }
            if (pointer) {
                finished = this.isCellGoodToFocusOn(pointer);
            }
            else {
                finished = true;
            }
        }
        return pointer;
    }
    isCellGoodToFocusOn(gridCell) {
        const column = gridCell.column;
        let rowNode;
        const { pinnedRowModel, rowModel } = this.beans;
        switch (gridCell.rowPinned) {
            case 'top':
                rowNode = pinnedRowModel?.getPinnedTopRow(gridCell.rowIndex);
                break;
            case 'bottom':
                rowNode = pinnedRowModel?.getPinnedBottomRow(gridCell.rowIndex);
                break;
            default:
                rowNode = rowModel.getRow(gridCell.rowIndex);
                break;
        }
        if (!rowNode) {
            return false;
        }
        const suppressNavigable = this.isSuppressNavigable(column, rowNode);
        return !suppressNavigable;
    }
    getCellToLeft(lastCell) {
        if (!lastCell) {
            return null;
        }
        const colToLeft = this.beans.visibleCols.getColBefore(lastCell.column);
        if (!colToLeft) {
            return null;
        }
        return {
            rowIndex: lastCell.rowIndex,
            column: colToLeft,
            rowPinned: lastCell.rowPinned,
        };
    }
    getCellToRight(lastCell) {
        if (!lastCell) {
            return null;
        }
        const colToRight = this.beans.visibleCols.getColAfter(lastCell.column);
        // if already on right, do nothing
        if (!colToRight) {
            return null;
        }
        return {
            rowIndex: lastCell.rowIndex,
            column: colToRight,
            rowPinned: lastCell.rowPinned,
        };
    }
    getCellBelow(lastCell) {
        if (!lastCell) {
            return null;
        }
        // adjust spanned cell so when moving down asserts use of last row in cell
        const adjustedLastCell = this.rowSpanSvc?.getCellEnd(lastCell) ?? lastCell;
        const rowBelow = (0, positionUtils_1._getRowBelow)(this.beans, adjustedLastCell);
        if (rowBelow) {
            return {
                rowIndex: rowBelow.rowIndex,
                column: lastCell.column,
                rowPinned: rowBelow.rowPinned,
            };
        }
        return null;
    }
    getCellAbove(lastCell) {
        if (!lastCell) {
            return null;
        }
        // adjust spanned cell so when moving up asserts use of first row in cell
        const adjustedLastCell = this.rowSpanSvc?.getCellStart(lastCell) ?? lastCell;
        const rowAbove = (0, positionUtils_1._getRowAbove)(this.beans, {
            rowIndex: adjustedLastCell.rowIndex,
            rowPinned: adjustedLastCell.rowPinned,
        });
        if (rowAbove) {
            return {
                rowIndex: rowAbove.rowIndex,
                column: lastCell.column,
                rowPinned: rowAbove.rowPinned,
            };
        }
        return null;
    }
    getNextTabbedCell(gridCell, backwards) {
        if (backwards) {
            return this.getNextTabbedCellBackwards(gridCell);
        }
        return this.getNextTabbedCellForwards(gridCell);
    }
    getNextTabbedCellForwards(gridCell) {
        const { visibleCols, pagination } = this.beans;
        const displayedColumns = visibleCols.allCols;
        let newRowIndex = gridCell.rowIndex;
        let newFloating = gridCell.rowPinned;
        // move along to the next cell
        let newColumn = visibleCols.getColAfter(gridCell.column);
        // check if end of the row, and if so, go forward a row
        if (!newColumn) {
            newColumn = displayedColumns[0];
            const rowBelow = (0, positionUtils_1._getRowBelow)(this.beans, gridCell);
            if ((0, generic_1._missing)(rowBelow)) {
                return null;
            }
            if (!rowBelow.rowPinned && !(pagination?.isRowInPage(rowBelow.rowIndex) ?? true)) {
                return null;
            }
            newRowIndex = rowBelow ? rowBelow.rowIndex : null;
            newFloating = rowBelow ? rowBelow.rowPinned : null;
        }
        return { rowIndex: newRowIndex, column: newColumn, rowPinned: newFloating };
    }
    getNextTabbedCellBackwards(gridCell) {
        const { beans } = this;
        const { visibleCols, pagination } = beans;
        const displayedColumns = visibleCols.allCols;
        let newRowIndex = gridCell.rowIndex;
        let newFloating = gridCell.rowPinned;
        // move along to the next cell
        let newColumn = visibleCols.getColBefore(gridCell.column);
        // check if end of the row, and if so, go forward a row
        if (!newColumn) {
            newColumn = (0, array_1._last)(displayedColumns);
            const rowAbove = (0, positionUtils_1._getRowAbove)(beans, { rowIndex: gridCell.rowIndex, rowPinned: gridCell.rowPinned });
            if ((0, generic_1._missing)(rowAbove)) {
                return null;
            }
            // If we are tabbing and there is a paging panel present, tabbing should go
            // to the paging panel instead of loading the next page.
            if (!rowAbove.rowPinned && !(pagination?.isRowInPage(rowAbove.rowIndex) ?? true)) {
                return null;
            }
            newRowIndex = rowAbove ? rowAbove.rowIndex : null;
            newFloating = rowAbove ? rowAbove.rowPinned : null;
        }
        return { rowIndex: newRowIndex, column: newColumn, rowPinned: newFloating };
    }
    isSuppressNavigable(column, rowNode) {
        const { suppressNavigable } = column.colDef;
        // if boolean set, then just use it
        if (typeof suppressNavigable === 'boolean') {
            return suppressNavigable;
        }
        // if function, then call the function to find out
        if (typeof suppressNavigable === 'function') {
            const params = column.createColumnFunctionCallbackParams(rowNode);
            const userFunc = suppressNavigable;
            return userFunc(params);
        }
        return false;
    }
}
exports.CellNavigationService = CellNavigationService;


/***/ }),

/***/ 93990:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HeaderNavigationService = exports.getHeaderIndexToFocus = void 0;
const beanStub_1 = __webpack_require__(68731);
const agColumnGroup_1 = __webpack_require__(56908);
const gridOptionsUtils_1 = __webpack_require__(67274);
const headerUtils_1 = __webpack_require__(1323);
const array_1 = __webpack_require__(31502);
function isAnyChildSpanningHeaderHeight(columnGroup) {
    if (!columnGroup) {
        return false;
    }
    return columnGroup.getLeafColumns().some((col) => col.isSpanHeaderHeight());
}
function getHeaderIndexToFocus(column, currentIndex) {
    let nextColumn;
    if ((0, agColumnGroup_1.isColumnGroup)(column) && isAnyChildSpanningHeaderHeight(column) && column.isPadding()) {
        const targetColumn = column;
        nextColumn = targetColumn.getLeafColumns()[0];
        let col = nextColumn;
        while (col !== targetColumn) {
            currentIndex++;
            col = col.getParent();
        }
    }
    return {
        column: nextColumn || column,
        headerRowIndex: currentIndex,
    };
}
exports.getHeaderIndexToFocus = getHeaderIndexToFocus;
class HeaderNavigationService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'headerNavigation';
        this.currentHeaderRowWithoutSpan = -1;
    }
    postConstruct() {
        const beans = this.beans;
        beans.ctrlsSvc.whenReady(this, (p) => {
            this.gridBodyCon = p.gridBodyCtrl;
        });
        const eDocument = (0, gridOptionsUtils_1._getDocument)(beans);
        this.addManagedElementListeners(eDocument, {
            mousedown: () => {
                this.currentHeaderRowWithoutSpan = -1;
            },
        });
    }
    getHeaderPositionForColumn(colKey, floatingFilter) {
        let column;
        const { colModel, colGroupSvc, ctrlsSvc } = this.beans;
        if (typeof colKey === 'string') {
            column = colModel.getCol(colKey);
            if (!column) {
                column = colGroupSvc?.getColumnGroup(colKey) ?? null;
            }
        }
        else {
            column = colKey;
        }
        if (!column) {
            return null;
        }
        const centerHeaderContainer = ctrlsSvc.getHeaderRowContainerCtrl();
        const allCtrls = centerHeaderContainer?.getAllCtrls();
        const isFloatingFilterVisible = (0, array_1._last)(allCtrls || []).type === 'filter';
        const headerRowCount = (0, headerUtils_1.getFocusHeaderRowCount)(this.beans) - 1;
        let row = -1;
        let col = column;
        while (col) {
            row++;
            col = col.getParent();
        }
        let headerRowIndex = row;
        if (floatingFilter && isFloatingFilterVisible && headerRowIndex === headerRowCount - 1) {
            headerRowIndex++;
        }
        return headerRowIndex === -1
            ? null
            : {
                headerRowIndex,
                column,
            };
    }
    /*
     * This method navigates grid header vertically
     * @returns {boolean} true to preventDefault on the event that caused this navigation.
     */
    navigateVertically(direction, event) {
        const focusSvc = this.beans.focusSvc;
        const fromHeader = focusSvc.focusedHeader;
        if (!fromHeader) {
            return false;
        }
        const { headerRowIndex } = fromHeader;
        const column = fromHeader.column;
        const rowLen = (0, headerUtils_1.getFocusHeaderRowCount)(this.beans);
        const isUp = direction === 'UP';
        const currentRowType = this.getHeaderRowType(headerRowIndex);
        let { headerRowIndex: nextRow, column: nextFocusColumn, headerRowIndexWithoutSpan, } = isUp
            ? getColumnVisibleParent(currentRowType, column, headerRowIndex)
            : getColumnVisibleChild(currentRowType, column, headerRowIndex);
        let skipColumn = false;
        if (nextRow < 0) {
            nextRow = 0;
            nextFocusColumn = column;
            skipColumn = true;
        }
        if (nextRow >= rowLen) {
            nextRow = -1; // -1 indicates the focus should move to grid rows.
            this.currentHeaderRowWithoutSpan = -1;
        }
        else if (headerRowIndexWithoutSpan !== undefined) {
            this.currentHeaderRowWithoutSpan = headerRowIndexWithoutSpan;
        }
        if (!skipColumn && !nextFocusColumn) {
            return false;
        }
        return focusSvc.focusHeaderPosition({
            headerPosition: { headerRowIndex: nextRow, column: nextFocusColumn },
            allowUserOverride: true,
            event,
        });
    }
    /*
     * This method navigates grid header horizontally
     * @returns {boolean} true to preventDefault on the event that caused this navigation.
     */
    navigateHorizontally(direction, fromTab = false, event) {
        const { focusSvc, gos } = this.beans;
        const focusedHeader = { ...focusSvc.focusedHeader };
        let nextHeader;
        let normalisedDirection;
        // either navigating to the left or isRtl (cannot be both)
        if (this.currentHeaderRowWithoutSpan !== -1) {
            focusedHeader.headerRowIndex = this.currentHeaderRowWithoutSpan;
        }
        else {
            this.currentHeaderRowWithoutSpan = focusedHeader.headerRowIndex;
        }
        if ((direction === 'LEFT') !== gos.get('enableRtl')) {
            normalisedDirection = 'Before';
            nextHeader = this.findHeader(focusedHeader, normalisedDirection);
        }
        else {
            normalisedDirection = 'After';
            nextHeader = this.findHeader(focusedHeader, normalisedDirection);
        }
        const userFunc = gos.getCallback('tabToNextHeader');
        if (fromTab && userFunc) {
            const wasFocusedFromUserFunc = focusSvc.focusHeaderPositionFromUserFunc({
                userFunc,
                headerPosition: nextHeader,
                direction: normalisedDirection,
            });
            // the user could have forced a change in rowHeaderIndex
            if (wasFocusedFromUserFunc) {
                const { headerRowIndex } = focusSvc.focusedHeader || {};
                if (headerRowIndex != null && headerRowIndex != focusedHeader.headerRowIndex) {
                    this.currentHeaderRowWithoutSpan = headerRowIndex;
                }
            }
            return wasFocusedFromUserFunc;
        }
        if (nextHeader || !fromTab) {
            return focusSvc.focusHeaderPosition({
                headerPosition: nextHeader,
                direction: normalisedDirection,
                fromTab,
                allowUserOverride: true,
                event,
            });
        }
        return this.focusNextHeaderRow(focusedHeader, normalisedDirection, event);
    }
    focusNextHeaderRow(focusedHeader, direction, event) {
        const currentIndex = focusedHeader.headerRowIndex;
        let nextPosition = null;
        let nextRowIndex;
        const beans = this.beans;
        if (direction === 'Before') {
            if (currentIndex > 0) {
                nextRowIndex = currentIndex - 1;
                this.currentHeaderRowWithoutSpan -= 1;
                nextPosition = this.findColAtEdgeForHeaderRow(nextRowIndex, 'end');
            }
        }
        else {
            nextRowIndex = currentIndex + 1;
            if (this.currentHeaderRowWithoutSpan < (0, headerUtils_1.getFocusHeaderRowCount)(beans)) {
                this.currentHeaderRowWithoutSpan += 1;
            }
            else {
                this.currentHeaderRowWithoutSpan = -1;
            }
            nextPosition = this.findColAtEdgeForHeaderRow(nextRowIndex, 'start');
        }
        if (!nextPosition) {
            return false;
        }
        const { column, headerRowIndex } = getHeaderIndexToFocus(nextPosition.column, nextPosition?.headerRowIndex);
        return beans.focusSvc.focusHeaderPosition({
            headerPosition: { column, headerRowIndex },
            direction,
            fromTab: true,
            allowUserOverride: true,
            event,
        });
    }
    scrollToColumn(column, direction = 'After') {
        if (column.getPinned()) {
            return;
        }
        let columnToScrollTo;
        if ((0, agColumnGroup_1.isColumnGroup)(column)) {
            const columns = column.getDisplayedLeafColumns();
            columnToScrollTo = direction === 'Before' ? (0, array_1._last)(columns) : columns[0];
        }
        else {
            columnToScrollTo = column;
        }
        this.gridBodyCon.scrollFeature.ensureColumnVisible(columnToScrollTo);
    }
    findHeader(focusedHeader, direction) {
        let nextColumn;
        let getColMethod;
        const { colGroupSvc, visibleCols } = this.beans;
        if ((0, agColumnGroup_1.isColumnGroup)(focusedHeader.column)) {
            nextColumn = colGroupSvc?.getGroupAtDirection(focusedHeader.column, direction) ?? undefined;
        }
        else {
            getColMethod = `getCol${direction}`;
            nextColumn = visibleCols[getColMethod](focusedHeader.column);
        }
        if (!nextColumn) {
            return;
        }
        const { headerRowIndex } = focusedHeader;
        if (this.getHeaderRowType(headerRowIndex) !== 'filter') {
            const columnsInPath = [nextColumn];
            while (nextColumn.getParent()) {
                nextColumn = nextColumn.getParent();
                columnsInPath.push(nextColumn);
            }
            nextColumn = columnsInPath[Math.max(0, columnsInPath.length - 1 - headerRowIndex)];
        }
        const { column, headerRowIndex: indexToFocus } = getHeaderIndexToFocus(nextColumn, headerRowIndex);
        return {
            column,
            headerRowIndex: indexToFocus,
        };
    }
    getHeaderRowType(rowIndex) {
        const centerHeaderContainer = this.beans.ctrlsSvc.getHeaderRowContainerCtrl();
        if (centerHeaderContainer) {
            return centerHeaderContainer.getRowType(rowIndex);
        }
    }
    findColAtEdgeForHeaderRow(level, position) {
        const { visibleCols, ctrlsSvc, colGroupSvc } = this.beans;
        const displayedColumns = visibleCols.allCols;
        const column = displayedColumns[position === 'start' ? 0 : displayedColumns.length - 1];
        if (!column) {
            return;
        }
        const childContainer = ctrlsSvc.getHeaderRowContainerCtrl(column.getPinned());
        const type = childContainer?.getRowType(level);
        if (type == 'group') {
            const columnGroup = colGroupSvc?.getColGroupAtLevel(column, level);
            return {
                headerRowIndex: level,
                column: columnGroup,
            };
        }
        return {
            // if type==null, means the header level didn't exist
            headerRowIndex: type == null ? -1 : level,
            column,
        };
    }
}
exports.HeaderNavigationService = HeaderNavigationService;
function getColumnVisibleParent(currentRowType, currentColumn, currentIndex) {
    const isFloatingFilter = currentRowType === 'filter';
    const isColumn = currentRowType === 'column';
    let nextFocusColumn = isFloatingFilter ? currentColumn : currentColumn.getParent();
    let nextRow = currentIndex - 1;
    let headerRowIndexWithoutSpan = nextRow;
    if (isColumn && isAnyChildSpanningHeaderHeight(currentColumn.getParent())) {
        while (nextFocusColumn && nextFocusColumn.isPadding()) {
            nextFocusColumn = nextFocusColumn.getParent();
            nextRow--;
        }
        headerRowIndexWithoutSpan = nextRow;
        if (nextRow < 0) {
            nextFocusColumn = currentColumn;
            nextRow = currentIndex;
            headerRowIndexWithoutSpan = undefined;
        }
    }
    return { column: nextFocusColumn, headerRowIndex: nextRow, headerRowIndexWithoutSpan };
}
function getColumnVisibleChild(currentRowType, column, currentIndex, direction = 'After') {
    let nextFocusColumn = column;
    let nextRow = currentIndex + 1;
    const headerRowIndexWithoutSpan = nextRow;
    if (currentRowType === 'group') {
        const leafColumns = column.getDisplayedLeafColumns();
        const leafColumn = direction === 'After' ? leafColumns[0] : (0, array_1._last)(leafColumns);
        const columnsInTheWay = [];
        let currentColumn = leafColumn;
        while (currentColumn.getParent() !== column) {
            currentColumn = currentColumn.getParent();
            columnsInTheWay.push(currentColumn);
        }
        nextFocusColumn = leafColumn;
        if (leafColumn.isSpanHeaderHeight()) {
            for (let i = columnsInTheWay.length - 1; i >= 0; i--) {
                const colToFocus = columnsInTheWay[i];
                if (!colToFocus.isPadding()) {
                    nextFocusColumn = colToFocus;
                    break;
                }
                nextRow++;
            }
        }
        else {
            nextFocusColumn = (0, array_1._last)(columnsInTheWay);
            if (!nextFocusColumn) {
                nextFocusColumn = leafColumn;
            }
        }
    }
    return { column: nextFocusColumn, headerRowIndex: nextRow, headerRowIndexWithoutSpan };
}


/***/ }),

/***/ 80322:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setFocusedHeader = exports.tabToPreviousCell = exports.tabToNextCell = exports.setFocusedCell = exports.clearFocusedCell = exports.getFocusedCell = void 0;
function getFocusedCell(beans) {
    return beans.focusSvc.getFocusedCell();
}
exports.getFocusedCell = getFocusedCell;
function clearFocusedCell(beans) {
    return beans.focusSvc.clearFocusedCell();
}
exports.clearFocusedCell = clearFocusedCell;
function setFocusedCell(beans, rowIndex, colKey, rowPinned) {
    beans.focusSvc.setFocusedCell({ rowIndex, column: colKey, rowPinned, forceBrowserFocus: true });
}
exports.setFocusedCell = setFocusedCell;
function tabToNextCell(beans, event) {
    return beans.navigation?.tabToNextCell(false, event) ?? false;
}
exports.tabToNextCell = tabToNextCell;
function tabToPreviousCell(beans, event) {
    return beans.navigation?.tabToNextCell(true, event) ?? false;
}
exports.tabToPreviousCell = tabToPreviousCell;
function setFocusedHeader(beans, colKey, floatingFilter = false) {
    const headerPosition = beans.headerNavigation?.getHeaderPositionForColumn(colKey, floatingFilter);
    if (!headerPosition) {
        return;
    }
    beans.focusSvc.focusHeaderPosition({ headerPosition });
}
exports.setFocusedHeader = setFocusedHeader;


/***/ }),

/***/ 928:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KeyboardNavigationModule = void 0;
const version_1 = __webpack_require__(97205);
const cellNavigationService_1 = __webpack_require__(39413);
const headerNavigationService_1 = __webpack_require__(93990);
const navigationApi_1 = __webpack_require__(80322);
const navigationService_1 = __webpack_require__(12321);
/**
 * @feature Interactivity -> Keyboard Navigation
 */
exports.KeyboardNavigationModule = {
    moduleName: 'KeyboardNavigation',
    version: version_1.VERSION,
    beans: [navigationService_1.NavigationService, cellNavigationService_1.CellNavigationService, headerNavigationService_1.HeaderNavigationService],
    apiFunctions: {
        getFocusedCell: navigationApi_1.getFocusedCell,
        clearFocusedCell: navigationApi_1.clearFocusedCell,
        setFocusedCell: navigationApi_1.setFocusedCell,
        setFocusedHeader: navigationApi_1.setFocusedHeader,
        tabToNextCell: navigationApi_1.tabToNextCell,
        tabToPreviousCell: navigationApi_1.tabToPreviousCell,
    },
};


/***/ }),

/***/ 12321:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NavigationService = void 0;
const keyCode_1 = __webpack_require__(39853);
const beanStub_1 = __webpack_require__(68731);
const positionUtils_1 = __webpack_require__(6257);
const mouseEventUtils_1 = __webpack_require__(8399);
const gridOptionsUtils_1 = __webpack_require__(67274);
const headerUtils_1 = __webpack_require__(1323);
const cellCtrl_1 = __webpack_require__(60814);
const rowCtrl_1 = __webpack_require__(7632);
const array_1 = __webpack_require__(31502);
const focus_1 = __webpack_require__(82331);
const function_1 = __webpack_require__(92043);
const generic_1 = __webpack_require__(34422);
class NavigationService extends beanStub_1.BeanStub {
    constructor() {
        super();
        this.beanName = 'navigation';
        this.onPageDown = (0, function_1._throttle)(this.onPageDown, 100);
        this.onPageUp = (0, function_1._throttle)(this.onPageUp, 100);
    }
    postConstruct() {
        this.beans.ctrlsSvc.whenReady(this, (p) => {
            this.gridBodyCon = p.gridBodyCtrl;
        });
    }
    handlePageScrollingKey(event, fromFullWidth = false) {
        const key = event.key;
        const alt = event.altKey;
        const ctrl = event.ctrlKey || event.metaKey;
        const rangeServiceShouldHandleShift = !!this.beans.rangeSvc && event.shiftKey;
        // home and end can be processed without knowing the currently selected cell, this can occur for full width rows.
        const currentCell = (0, mouseEventUtils_1._getCellPositionForEvent)(this.gos, event);
        let processed = false;
        switch (key) {
            case keyCode_1.KeyCode.PAGE_HOME:
            case keyCode_1.KeyCode.PAGE_END:
                // handle home and end when ctrl & alt are NOT pressed
                if (!ctrl && !alt) {
                    this.onHomeOrEndKey(key);
                    processed = true;
                }
                break;
            case keyCode_1.KeyCode.LEFT:
            case keyCode_1.KeyCode.RIGHT:
            case keyCode_1.KeyCode.UP:
            case keyCode_1.KeyCode.DOWN:
                if (!currentCell) {
                    return false;
                }
                // handle when ctrl is pressed only, if shift is pressed
                // it will be handled by the rangeService
                if (ctrl && !alt && !rangeServiceShouldHandleShift) {
                    this.onCtrlUpDownLeftRight(key, currentCell);
                    processed = true;
                }
                break;
            case keyCode_1.KeyCode.PAGE_DOWN:
            case keyCode_1.KeyCode.PAGE_UP:
                // handle page up and page down when ctrl & alt are NOT pressed
                if (!ctrl && !alt) {
                    processed = this.handlePageUpDown(key, currentCell, fromFullWidth);
                }
                break;
        }
        if (processed) {
            event.preventDefault();
        }
        return processed;
    }
    handlePageUpDown(key, currentCell, fromFullWidth) {
        if (fromFullWidth) {
            currentCell = this.beans.focusSvc.getFocusedCell();
        }
        if (!currentCell) {
            return false;
        }
        if (key === keyCode_1.KeyCode.PAGE_UP) {
            this.onPageUp(currentCell);
        }
        else {
            this.onPageDown(currentCell);
        }
        return true;
    }
    navigateTo(navigateParams) {
        const { scrollIndex, scrollType, scrollColumn, focusIndex, focusColumn } = navigateParams;
        const { scrollFeature } = this.gridBodyCon;
        if ((0, generic_1._exists)(scrollColumn) && !scrollColumn.isPinned()) {
            scrollFeature.ensureColumnVisible(scrollColumn);
        }
        if ((0, generic_1._exists)(scrollIndex)) {
            scrollFeature.ensureIndexVisible(scrollIndex, scrollType);
        }
        // setFocusedCell relies on the browser default focus behavior to scroll the focused cell into view,
        // however, this behavior will cause the cell border to be cut off, or if we have sticky rows, the
        // cell will be completely hidden, so we call ensureIndexVisible without a position to guarantee
        // minimal scroll to get the row into view.
        if (!navigateParams.isAsync) {
            scrollFeature.ensureIndexVisible(focusIndex);
        }
        const { focusSvc, rangeSvc } = this.beans;
        // if we don't do this, the range will be left on the last cell, which will leave the last focused cell
        // highlighted.
        focusSvc.setFocusedCell({
            rowIndex: focusIndex,
            column: focusColumn,
            rowPinned: null,
            forceBrowserFocus: true,
        });
        rangeSvc?.setRangeToCell({ rowIndex: focusIndex, rowPinned: null, column: focusColumn });
    }
    // this method is throttled, see the `constructor`
    onPageDown(gridCell) {
        const beans = this.beans;
        const scrollPosition = getVScroll(beans);
        const pixelsInOnePage = this.getViewportHeight();
        const { pageBounds, rowModel, rowAutoHeight } = beans;
        const pagingPixelOffset = pageBounds.getPixelOffset();
        const currentPageBottomPixel = scrollPosition.top + pixelsInOnePage;
        const currentPageBottomRow = rowModel.getRowIndexAtPixel(currentPageBottomPixel + pagingPixelOffset);
        if (rowAutoHeight?.active) {
            this.navigateToNextPageWithAutoHeight(gridCell, currentPageBottomRow);
        }
        else {
            this.navigateToNextPage(gridCell, currentPageBottomRow);
        }
    }
    // this method is throttled, see the `constructor`
    onPageUp(gridCell) {
        const beans = this.beans;
        const scrollPosition = getVScroll(beans);
        const { pageBounds, rowModel, rowAutoHeight } = beans;
        const pagingPixelOffset = pageBounds.getPixelOffset();
        const currentPageTopPixel = scrollPosition.top;
        const currentPageTopRow = rowModel.getRowIndexAtPixel(currentPageTopPixel + pagingPixelOffset);
        if (rowAutoHeight?.active) {
            this.navigateToNextPageWithAutoHeight(gridCell, currentPageTopRow, true);
        }
        else {
            this.navigateToNextPage(gridCell, currentPageTopRow, true);
        }
    }
    navigateToNextPage(gridCell, scrollIndex, up = false) {
        const { pageBounds, rowModel } = this.beans;
        const pixelsInOnePage = this.getViewportHeight();
        const firstRow = pageBounds.getFirstRow();
        const lastRow = pageBounds.getLastRow();
        const pagingPixelOffset = pageBounds.getPixelOffset();
        const currentRowNode = rowModel.getRow(gridCell.rowIndex);
        const rowPixelDiff = up
            ? // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
                currentRowNode?.rowHeight - pixelsInOnePage - pagingPixelOffset
            : pixelsInOnePage - pagingPixelOffset;
        // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
        const nextCellPixel = currentRowNode?.rowTop + rowPixelDiff;
        let focusIndex = rowModel.getRowIndexAtPixel(nextCellPixel + pagingPixelOffset);
        if (focusIndex === gridCell.rowIndex) {
            const diff = up ? -1 : 1;
            scrollIndex = focusIndex = gridCell.rowIndex + diff;
        }
        let scrollType;
        if (up) {
            scrollType = 'bottom';
            if (focusIndex < firstRow) {
                focusIndex = firstRow;
            }
            if (scrollIndex < firstRow) {
                scrollIndex = firstRow;
            }
        }
        else {
            scrollType = 'top';
            if (focusIndex > lastRow) {
                focusIndex = lastRow;
            }
            if (scrollIndex > lastRow) {
                scrollIndex = lastRow;
            }
        }
        if (this.isRowTallerThanView(rowModel.getRow(focusIndex))) {
            scrollIndex = focusIndex;
            scrollType = 'top';
        }
        this.navigateTo({
            scrollIndex,
            scrollType,
            scrollColumn: null,
            focusIndex,
            focusColumn: gridCell.column,
        });
    }
    navigateToNextPageWithAutoHeight(gridCell, scrollIndex, up = false) {
        // because autoHeight will calculate the height of rows after scroll
        // first we scroll towards the required point, then we add a small
        // delay to allow the height to be recalculated, check which index
        // should be focused and then finally navigate to that index.
        // TODO: we should probably have an event fired once to scrollbar has
        // settled and all rowHeights have been calculated instead of relying
        // on a setTimeout of 50ms.
        this.navigateTo({
            scrollIndex: scrollIndex,
            scrollType: up ? 'bottom' : 'top',
            scrollColumn: null,
            focusIndex: scrollIndex,
            focusColumn: gridCell.column,
        });
        setTimeout(() => {
            const focusIndex = this.getNextFocusIndexForAutoHeight(gridCell, up);
            this.navigateTo({
                scrollIndex: scrollIndex,
                scrollType: up ? 'bottom' : 'top',
                scrollColumn: null,
                focusIndex: focusIndex,
                focusColumn: gridCell.column,
                isAsync: true,
            });
        }, 50);
    }
    getNextFocusIndexForAutoHeight(gridCell, up = false) {
        const step = up ? -1 : 1;
        const pixelsInOnePage = this.getViewportHeight();
        const { pageBounds, rowModel } = this.beans;
        const lastRowIndex = pageBounds.getLastRow();
        let pixelSum = 0;
        let currentIndex = gridCell.rowIndex;
        while (currentIndex >= 0 && currentIndex <= lastRowIndex) {
            const currentCell = rowModel.getRow(currentIndex);
            if (currentCell) {
                const currentCellHeight = currentCell.rowHeight ?? 0;
                if (pixelSum + currentCellHeight > pixelsInOnePage) {
                    break;
                }
                pixelSum += currentCellHeight;
            }
            currentIndex += step;
        }
        return Math.max(0, Math.min(currentIndex, lastRowIndex));
    }
    getViewportHeight() {
        const beans = this.beans;
        const scrollPosition = getVScroll(beans);
        const scrollbarWidth = this.beans.scrollVisibleSvc.getScrollbarWidth();
        let pixelsInOnePage = scrollPosition.bottom - scrollPosition.top;
        if (beans.ctrlsSvc.get('center').isHorizontalScrollShowing()) {
            pixelsInOnePage -= scrollbarWidth;
        }
        return pixelsInOnePage;
    }
    isRowTallerThanView(rowNode) {
        if (!rowNode) {
            return false;
        }
        const rowHeight = rowNode.rowHeight;
        if (typeof rowHeight !== 'number') {
            return false;
        }
        return rowHeight > this.getViewportHeight();
    }
    onCtrlUpDownLeftRight(key, gridCell) {
        const cellToFocus = this.beans.cellNavigation.getNextCellToFocus(key, gridCell, true);
        const { rowIndex } = cellToFocus;
        const column = cellToFocus.column;
        this.navigateTo({
            scrollIndex: rowIndex,
            scrollType: null,
            scrollColumn: column,
            focusIndex: rowIndex,
            focusColumn: column,
        });
    }
    // home brings focus to top left cell, end brings focus to bottom right, grid scrolled to bring
    // same cell into view (which means either scroll all the way up, or all the way down).
    onHomeOrEndKey(key) {
        const homeKey = key === keyCode_1.KeyCode.PAGE_HOME;
        const { visibleCols, pageBounds, rowModel } = this.beans;
        const allColumns = visibleCols.allCols;
        const scrollIndex = homeKey ? pageBounds.getFirstRow() : pageBounds.getLastRow();
        const rowNode = rowModel.getRow(scrollIndex);
        if (!rowNode) {
            return;
        }
        const columnToSelect = (homeKey ? allColumns : [...allColumns].reverse()).find((col) => !col.isSuppressNavigable(rowNode));
        if (!columnToSelect) {
            return;
        }
        this.navigateTo({
            scrollIndex: scrollIndex,
            scrollType: null,
            scrollColumn: columnToSelect,
            focusIndex: scrollIndex,
            focusColumn: columnToSelect,
        });
    }
    // result of keyboard event
    onTabKeyDown(previous, keyboardEvent) {
        const backwards = keyboardEvent.shiftKey;
        const movedToNextCell = this.tabToNextCellCommon(previous, backwards, keyboardEvent);
        const beans = this.beans;
        const { ctrlsSvc, pageBounds, focusSvc, gos } = beans;
        if (movedToNextCell !== false) {
            // only prevent default if we found a cell. so if user is on last cell and hits tab, then we default
            // to the normal tabbing so user can exit the grid.
            if (movedToNextCell) {
                keyboardEvent.preventDefault();
            }
            else if (movedToNextCell === null) {
                // want to let browser handle, however some of the containers prevent browser focus
                ctrlsSvc.get('gridCtrl').allowFocusForNextCoreContainer(backwards);
            }
            return;
        }
        // if we didn't move to next cell, then need to tab out of the cells, ie to the header (if going
        // backwards)
        if (backwards) {
            const { rowIndex, rowPinned } = previous.getRowPosition();
            const firstRow = rowPinned ? rowIndex === 0 : rowIndex === pageBounds.getFirstRow();
            if (firstRow) {
                if (gos.get('headerHeight') === 0 || (0, focus_1._isHeaderFocusSuppressed)(beans)) {
                    (0, focus_1._focusNextGridCoreContainer)(beans, true, true);
                }
                else {
                    keyboardEvent.preventDefault();
                    focusSvc.focusPreviousFromFirstCell(keyboardEvent);
                }
            }
        }
        else {
            // if the case it's a popup editor, the focus is on the editor and not the previous cell.
            // in order for the tab navigation to work, we need to focus the browser back onto the
            // previous cell.
            if (previous instanceof cellCtrl_1.CellCtrl) {
                previous.focusCell(true);
            }
            if ((!backwards && focusSvc.focusOverlay(false)) || (0, focus_1._focusNextGridCoreContainer)(beans, backwards)) {
                keyboardEvent.preventDefault();
            }
        }
    }
    // comes from API
    tabToNextCell(backwards, event) {
        const beans = this.beans;
        const { focusSvc, rowRenderer } = beans;
        const focusedCell = focusSvc.getFocusedCell();
        // if no focus, then cannot navigate
        if (!focusedCell) {
            return false;
        }
        let cellOrRow = (0, positionUtils_1._getCellByPosition)(beans, focusedCell);
        // if cell is not rendered, means user has scrolled away from the cell
        // or that the focusedCell is a Full Width Row
        if (!cellOrRow) {
            cellOrRow = rowRenderer.getRowByPosition(focusedCell);
            if (!cellOrRow || !cellOrRow.isFullWidth()) {
                return false;
            }
        }
        return !!this.tabToNextCellCommon(cellOrRow, backwards, event, 'api');
    }
    tabToNextCellCommon(previous, backwards, event, source = 'ui') {
        const { editSvc, focusSvc } = this.beans;
        let res = undefined;
        const cellCtrl = previous instanceof cellCtrl_1.CellCtrl ? previous : previous.getAllCellCtrls()?.[0];
        if (editSvc?.isEditing()) {
            res = editSvc?.moveToNextCell(cellCtrl, backwards, event, source);
        }
        else {
            res = this.moveToNextCellNotEditing(previous, backwards, event);
        }
        if (res === null) {
            return res;
        }
        // if a cell wasn't found, it's possible that focus was moved to the header
        return res || !!focusSvc.focusedHeader;
    }
    // returns null if no navigation should be performed
    moveToNextCellNotEditing(previousCell, backwards, event) {
        const displayedColumns = this.beans.visibleCols.allCols;
        let cellPos;
        if (previousCell instanceof rowCtrl_1.RowCtrl) {
            cellPos = {
                ...previousCell.getRowPosition(),
                column: backwards ? displayedColumns[0] : (0, array_1._last)(displayedColumns),
            };
            if (this.gos.get('embedFullWidthRows') && event) {
                const focusedContainer = previousCell.findFullWidthInfoForEvent(event);
                if (focusedContainer) {
                    cellPos.column = focusedContainer.column;
                }
            }
        }
        else {
            cellPos = previousCell.getFocusedCellPosition();
        }
        // find the next cell to start editing
        const nextCell = this.findNextCellToFocusOn(cellPos, { backwards, startEditing: false });
        // only prevent default if we found a cell. so if user is on last cell and hits tab, then we default
        // to the normal tabbing so user can exit the grid.
        if (nextCell === false) {
            return null;
        }
        if (nextCell instanceof cellCtrl_1.CellCtrl) {
            nextCell.focusCell(true);
        }
        else if (nextCell) {
            return this.tryToFocusFullWidthRow(nextCell, backwards);
        }
        return (0, generic_1._exists)(nextCell);
    }
    /**
     * called by the cell, when tab is pressed while editing.
     * @returns RenderedCell when navigation successful, false if navigation should not be performed, otherwise null
     */
    findNextCellToFocusOn(previousPosition, { backwards, startEditing, skipToNextEditableCell }) {
        let nextPosition = previousPosition;
        const beans = this.beans;
        const { cellNavigation, gos, focusSvc, rowRenderer, rangeSvc } = beans;
        while (true) {
            if (previousPosition !== nextPosition) {
                previousPosition = nextPosition;
            }
            if (!backwards) {
                nextPosition = this.getLastCellOfColSpan(nextPosition);
            }
            nextPosition = cellNavigation.getNextTabbedCell(nextPosition, backwards);
            // allow user to override what cell to go to next
            const userFunc = gos.getCallback('tabToNextCell');
            if ((0, generic_1._exists)(userFunc)) {
                const params = {
                    backwards: backwards,
                    editing: startEditing,
                    previousCellPosition: previousPosition,
                    nextCellPosition: nextPosition ? nextPosition : null,
                };
                const userResult = userFunc(params);
                if (userResult === true) {
                    nextPosition = previousPosition;
                }
                else if (userResult === false) {
                    return false;
                }
                else {
                    nextPosition = {
                        rowIndex: userResult.rowIndex,
                        column: userResult.column,
                        rowPinned: userResult.rowPinned,
                    };
                }
            }
            // if no 'next cell', means we have got to last cell of grid, so nothing to move to,
            // so bottom right cell going forwards, or top left going backwards
            if (!nextPosition) {
                return null;
            }
            if (nextPosition.rowIndex < 0) {
                const headerLen = (0, headerUtils_1.getFocusHeaderRowCount)(beans);
                focusSvc.focusHeaderPosition({
                    headerPosition: {
                        headerRowIndex: headerLen + nextPosition.rowIndex,
                        column: nextPosition.column,
                    },
                    fromCell: true,
                });
                return null;
            }
            // if editing, but cell not editable, skip cell. we do this before we do all of
            // the 'ensure index visible' and 'flush all frames', otherwise if we are skipping
            // a bunch of cells (eg 10 rows) then all the work on ensuring cell visible is useless
            // (except for the last one) which causes grid to stall for a while.
            // note - for full row edit, we do focus non-editable cells, as the row stays in edit mode.
            const fullRowEdit = gos.get('editType') === 'fullRow';
            if (startEditing && (!fullRowEdit || skipToNextEditableCell)) {
                const cellIsEditable = this.isCellEditable(nextPosition);
                if (!cellIsEditable) {
                    continue;
                }
            }
            this.ensureCellVisible(nextPosition);
            // we have to call this after ensureColumnVisible - otherwise it could be a virtual column
            // or row that is not currently in view, hence the renderedCell would not exist
            const nextCell = (0, positionUtils_1._getCellByPosition)(beans, nextPosition);
            // if next cell is fullWidth row, then no rendered cell,
            // as fullWidth rows have no cells, so we skip it
            if (!nextCell) {
                const row = rowRenderer.getRowByPosition(nextPosition);
                if (!row || !row.isFullWidth() || startEditing) {
                    continue;
                }
                return { ...row.getRowPosition(), column: nextPosition?.column };
            }
            if (cellNavigation.isSuppressNavigable(nextCell.column, nextCell.rowNode)) {
                continue;
            }
            // when spanning we need to focus a specific index of the spanned cell, by
            // setting it into the focused cell position we can try to force focus to this specific pos
            nextCell.setFocusedCellPosition(nextPosition);
            // by default, when we click a cell, it gets selected into a range, so to keep keyboard navigation
            // consistent, we set into range here also.
            rangeSvc?.setRangeToCell(nextPosition);
            // we successfully tabbed onto a grid cell, so return true
            return nextCell;
        }
    }
    isCellEditable(cell) {
        const rowNode = this.lookupRowNodeForCell(cell);
        if (rowNode) {
            return cell.column.isCellEditable(rowNode);
        }
        return false;
    }
    lookupRowNodeForCell({ rowIndex, rowPinned }) {
        const { pinnedRowModel, rowModel } = this.beans;
        if (rowPinned === 'top') {
            return pinnedRowModel?.getPinnedTopRow(rowIndex);
        }
        if (rowPinned === 'bottom') {
            return pinnedRowModel?.getPinnedBottomRow(rowIndex);
        }
        return rowModel.getRow(rowIndex);
    }
    // we use index for rows, but column object for columns, as the next column (by index) might not
    // be visible (header grouping) so it's not reliable, so using the column object instead.
    navigateToNextCell(event, key, currentCell, allowUserOverride) {
        // we keep searching for a next cell until we find one. this is how the group rows get skipped
        let nextCell = currentCell;
        let hitEdgeOfGrid = false;
        const beans = this.beans;
        const { cellNavigation, focusSvc, gos } = beans;
        while (nextCell && (nextCell === currentCell || !this.isValidNavigateCell(nextCell))) {
            // if the current cell is spanning across multiple columns, we need to move
            // our current position to be the last cell on the right before finding the
            // the next target.
            if (gos.get('enableRtl')) {
                if (key === keyCode_1.KeyCode.LEFT) {
                    nextCell = this.getLastCellOfColSpan(nextCell);
                }
            }
            else if (key === keyCode_1.KeyCode.RIGHT) {
                nextCell = this.getLastCellOfColSpan(nextCell);
            }
            nextCell = cellNavigation.getNextCellToFocus(key, nextCell);
            // eg if going down, and nextCell=undefined, means we are gone past the last row
            hitEdgeOfGrid = (0, generic_1._missing)(nextCell);
        }
        if (hitEdgeOfGrid && event && event.key === keyCode_1.KeyCode.UP) {
            nextCell = {
                rowIndex: -1,
                rowPinned: null,
                column: currentCell.column,
            };
        }
        // allow user to override what cell to go to next. when doing normal cell navigation (with keys)
        // we allow this, however if processing 'enter after edit' we don't allow override
        if (allowUserOverride) {
            const userFunc = gos.getCallback('navigateToNextCell');
            if ((0, generic_1._exists)(userFunc)) {
                const params = {
                    key: key,
                    previousCellPosition: currentCell,
                    nextCellPosition: nextCell ? nextCell : null,
                    event: event,
                };
                const userCell = userFunc(params);
                if ((0, generic_1._exists)(userCell)) {
                    nextCell = {
                        rowPinned: userCell.rowPinned,
                        rowIndex: userCell.rowIndex,
                        column: userCell.column,
                    };
                }
                else {
                    nextCell = null;
                }
            }
        }
        // no next cell means we have reached a grid boundary, eg left, right, top or bottom of grid
        if (!nextCell) {
            return;
        }
        if (nextCell.rowIndex < 0) {
            const headerLen = (0, headerUtils_1.getFocusHeaderRowCount)(beans);
            focusSvc.focusHeaderPosition({
                headerPosition: { headerRowIndex: headerLen + nextCell.rowIndex, column: currentCell.column },
                event: event || undefined,
                fromCell: true,
            });
            return;
        }
        // in case we have col spanning we get the cellComp and use it to get the
        // position. This was we always focus the first cell inside the spanning.
        const normalisedPosition = this.getNormalisedPosition(nextCell);
        if (normalisedPosition) {
            this.focusPosition(normalisedPosition);
        }
        else {
            this.tryToFocusFullWidthRow(nextCell);
        }
    }
    getNormalisedPosition(cellPosition) {
        const isSpannedCell = !!this.beans.spannedRowRenderer?.getCellByPosition(cellPosition);
        if (isSpannedCell) {
            return cellPosition;
        }
        // ensureCellVisible first, to make sure cell at position is rendered.
        this.ensureCellVisible(cellPosition);
        const cellCtrl = (0, positionUtils_1._getCellByPosition)(this.beans, cellPosition);
        // not guaranteed to have a cellComp when using the SSRM as blocks are loading.
        if (!cellCtrl) {
            return null;
        }
        cellPosition = cellCtrl.getFocusedCellPosition();
        // we call this again, as nextCell can be different to it's previous value due to Column Spanning
        // (ie if cursor moving from right to left, and cell is spanning columns, then nextCell was the
        // last column in the group, however now it's the first column in the group). if we didn't do
        // ensureCellVisible again, then we could only be showing the last portion (last column) of the
        // merged cells.
        this.ensureCellVisible(cellPosition);
        return cellPosition;
    }
    tryToFocusFullWidthRow(position, backwards) {
        const { visibleCols, rowRenderer, focusSvc, eventSvc } = this.beans;
        const displayedColumns = visibleCols.allCols;
        const rowComp = rowRenderer.getRowByPosition(position);
        if (!rowComp || !rowComp.isFullWidth()) {
            return false;
        }
        const currentCellFocused = focusSvc.getFocusedCell();
        const cellPosition = {
            rowIndex: position.rowIndex,
            rowPinned: position.rowPinned,
            column: position.column || (backwards ? (0, array_1._last)(displayedColumns) : displayedColumns[0]),
        };
        this.focusPosition(cellPosition);
        const fromBelow = backwards == null
            ? currentCellFocused != null && (0, positionUtils_1._isRowBefore)(cellPosition, currentCellFocused)
            : backwards;
        eventSvc.dispatchEvent({
            type: 'fullWidthRowFocused',
            rowIndex: cellPosition.rowIndex,
            rowPinned: cellPosition.rowPinned,
            column: cellPosition.column,
            isFullWidthCell: true,
            fromBelow,
        });
        return true;
    }
    focusPosition(cellPosition) {
        const { focusSvc, rangeSvc } = this.beans;
        focusSvc.setFocusedCell({
            rowIndex: cellPosition.rowIndex,
            column: cellPosition.column,
            rowPinned: cellPosition.rowPinned,
            forceBrowserFocus: true,
        });
        rangeSvc?.setRangeToCell(cellPosition);
    }
    isValidNavigateCell(cell) {
        const rowNode = (0, positionUtils_1._getRowNode)(this.beans, cell);
        // we do not allow focusing on detail rows and full width rows
        return !!rowNode;
    }
    getLastCellOfColSpan(cell) {
        const cellCtrl = (0, positionUtils_1._getCellByPosition)(this.beans, cell);
        if (!cellCtrl) {
            return cell;
        }
        const colSpanningList = cellCtrl.getColSpanningList();
        if (colSpanningList.length === 1) {
            return cell;
        }
        return {
            rowIndex: cell.rowIndex,
            column: (0, array_1._last)(colSpanningList),
            rowPinned: cell.rowPinned,
        };
    }
    ensureCellVisible(gridCell) {
        const isGroupStickyEnabled = (0, gridOptionsUtils_1._isGroupRowsSticky)(this.gos);
        const rowNode = this.beans.rowModel.getRow(gridCell.rowIndex);
        // sticky rows are always visible, so the grid shouldn't scroll to focus them.
        const skipScrollToRow = isGroupStickyEnabled && rowNode?.sticky;
        const { scrollFeature } = this.gridBodyCon;
        // this scrolls the row into view
        if (!skipScrollToRow && (0, generic_1._missing)(gridCell.rowPinned)) {
            scrollFeature.ensureIndexVisible(gridCell.rowIndex);
        }
        if (!gridCell.column.isPinned()) {
            scrollFeature.ensureColumnVisible(gridCell.column);
        }
    }
}
exports.NavigationService = NavigationService;
function getVScroll(beans) {
    return beans.ctrlsSvc.getScrollFeature().getVScrollPosition();
}


/***/ }),

/***/ 82550:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PageBoundsListener = void 0;
const beanStub_1 = __webpack_require__(68731);
class PageBoundsListener extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'pageBoundsListener';
    }
    postConstruct() {
        this.addManagedEventListeners({
            modelUpdated: this.onModelUpdated.bind(this),
            recalculateRowBounds: this.calculatePages.bind(this),
        });
        this.onModelUpdated();
    }
    onModelUpdated(modelUpdatedEvent) {
        this.calculatePages();
        this.eventSvc.dispatchEvent({
            type: 'paginationChanged',
            animate: modelUpdatedEvent?.animate ?? false,
            newData: modelUpdatedEvent?.newData ?? false,
            newPage: modelUpdatedEvent?.newPage ?? false,
            newPageSize: modelUpdatedEvent?.newPageSize ?? false,
            keepRenderedRows: modelUpdatedEvent?.keepRenderedRows ?? false,
        });
    }
    calculatePages() {
        const { pageBounds, pagination, rowModel } = this.beans;
        if (pagination) {
            pagination.calculatePages();
        }
        else {
            pageBounds.calculateBounds(0, rowModel.getRowCount() - 1);
        }
    }
}
exports.PageBoundsListener = PageBoundsListener;


/***/ }),

/***/ 93003:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PageBoundsService = void 0;
const beanStub_1 = __webpack_require__(68731);
// note that everything in this service is used even when pagination is off
class PageBoundsService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'pageBounds';
        this.pixelOffset = 0;
    }
    getFirstRow() {
        return this.topRowBounds?.rowIndex ?? -1;
    }
    getLastRow() {
        return this.bottomRowBounds?.rowIndex ?? -1;
    }
    getCurrentPageHeight() {
        const { topRowBounds, bottomRowBounds } = this;
        if (!topRowBounds || !bottomRowBounds) {
            return 0;
        }
        return Math.max(bottomRowBounds.rowTop + bottomRowBounds.rowHeight - topRowBounds.rowTop, 0);
    }
    getCurrentPagePixelRange() {
        const { topRowBounds, bottomRowBounds } = this;
        const pageFirstPixel = topRowBounds?.rowTop ?? 0;
        const pageLastPixel = bottomRowBounds ? bottomRowBounds.rowTop + bottomRowBounds.rowHeight : 0;
        return { pageFirstPixel, pageLastPixel };
    }
    calculateBounds(topDisplayedRowIndex, bottomDisplayedRowIndex) {
        const { rowModel } = this.beans;
        const topRowBounds = rowModel.getRowBounds(topDisplayedRowIndex);
        if (topRowBounds) {
            topRowBounds.rowIndex = topDisplayedRowIndex;
        }
        this.topRowBounds = topRowBounds;
        const bottomRowBounds = rowModel.getRowBounds(bottomDisplayedRowIndex);
        if (bottomRowBounds) {
            bottomRowBounds.rowIndex = bottomDisplayedRowIndex;
        }
        this.bottomRowBounds = bottomRowBounds;
        this.calculatePixelOffset();
    }
    getPixelOffset() {
        return this.pixelOffset;
    }
    calculatePixelOffset() {
        const value = this.topRowBounds?.rowTop ?? 0;
        if (this.pixelOffset === value) {
            return;
        }
        this.pixelOffset = value;
        // this event is required even when pagination is off
        this.eventSvc.dispatchEvent({ type: 'paginationPixelOffsetChanged' });
    }
}
exports.PageBoundsService = PageBoundsService;


/***/ }),

/***/ 42078:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PageSizeSelectorSelector = exports.PageSizeSelectorComp = void 0;
const array_1 = __webpack_require__(31502);
const dom_1 = __webpack_require__(33507);
const logging_1 = __webpack_require__(47764);
const agSelect_1 = __webpack_require__(70159);
const component_1 = __webpack_require__(78020);
const paginationPageSizeSelector = 'paginationPageSizeSelector';
const PageSizeSelectorCompElement = { tag: 'span', cls: 'ag-paging-page-size' };
class PageSizeSelectorComp extends component_1.Component {
    wireBeans(beans) {
        this.pagination = beans.pagination;
    }
    constructor() {
        super(PageSizeSelectorCompElement);
        this.hasEmptyOption = false;
        this.handlePageSizeItemSelected = () => {
            if (!this.selectPageSizeComp) {
                return;
            }
            const newValue = this.selectPageSizeComp.getValue();
            if (!newValue) {
                return;
            }
            const paginationPageSize = Number(newValue);
            if (isNaN(paginationPageSize) ||
                paginationPageSize < 1 ||
                paginationPageSize === this.pagination.getPageSize()) {
                return;
            }
            this.pagination.setPageSize(paginationPageSize, 'pageSizeSelector');
            if (this.hasEmptyOption) {
                // Toggle the selector to force a refresh of the options and hide the empty option,
                // as it's no longer needed.
                this.toggleSelectDisplay(true);
            }
            this.selectPageSizeComp.getFocusableElement().focus();
        };
    }
    postConstruct() {
        this.addManagedPropertyListener(paginationPageSizeSelector, () => {
            this.onPageSizeSelectorValuesChange();
        });
        this.addManagedEventListeners({ paginationChanged: (event) => this.handlePaginationChanged(event) });
    }
    handlePaginationChanged(paginationChangedEvent) {
        if (!this.selectPageSizeComp || !paginationChangedEvent?.newPageSize) {
            return;
        }
        const paginationPageSize = this.pagination.getPageSize();
        if (this.getPageSizeSelectorValues().includes(paginationPageSize)) {
            this.selectPageSizeComp.setValue(paginationPageSize.toString());
        }
        else {
            if (this.hasEmptyOption) {
                this.selectPageSizeComp.setValue('');
            }
            else {
                this.toggleSelectDisplay(true);
            }
        }
    }
    toggleSelectDisplay(show) {
        if (this.selectPageSizeComp && !show) {
            this.reset();
        }
        if (!show) {
            return;
        }
        this.reloadPageSizesSelector();
        if (!this.selectPageSizeComp) {
            return;
        }
    }
    reset() {
        (0, dom_1._clearElement)(this.getGui());
        if (!this.selectPageSizeComp) {
            return;
        }
        this.selectPageSizeComp = this.destroyBean(this.selectPageSizeComp);
    }
    onPageSizeSelectorValuesChange() {
        if (!this.selectPageSizeComp) {
            return;
        }
        if (this.shouldShowPageSizeSelector()) {
            this.reloadPageSizesSelector();
        }
    }
    shouldShowPageSizeSelector() {
        return (this.gos.get('pagination') &&
            !this.gos.get('suppressPaginationPanel') &&
            !this.gos.get('paginationAutoPageSize') &&
            this.gos.get(paginationPageSizeSelector) !== false);
    }
    reloadPageSizesSelector() {
        const pageSizeOptions = this.getPageSizeSelectorValues();
        const paginationPageSizeOption = this.pagination.getPageSize();
        const shouldAddAndSelectEmptyOption = !paginationPageSizeOption || !pageSizeOptions.includes(paginationPageSizeOption);
        if (shouldAddAndSelectEmptyOption) {
            const pageSizeSet = this.gos.exists('paginationPageSize');
            const pageSizesSet = this.gos.get(paginationPageSizeSelector) !== true;
            (0, logging_1._warn)(94, { pageSizeSet, pageSizesSet, pageSizeOptions, paginationPageSizeOption });
            if (!pageSizesSet) {
                (0, logging_1._warn)(95, { paginationPageSizeOption, paginationPageSizeSelector });
            }
            // When the paginationPageSize option is set to a value that is
            // not in the list of page size options.
            pageSizeOptions.unshift('');
        }
        const value = String(shouldAddAndSelectEmptyOption ? '' : paginationPageSizeOption);
        if (this.selectPageSizeComp) {
            if (!(0, array_1._areEqual)(this.pageSizeOptions, pageSizeOptions)) {
                this.selectPageSizeComp.clearOptions().addOptions(this.createPageSizeSelectOptions(pageSizeOptions));
                this.pageSizeOptions = pageSizeOptions;
            }
            this.selectPageSizeComp.setValue(value, true);
        }
        else {
            this.createPageSizeSelectorComp(pageSizeOptions, value);
        }
        this.hasEmptyOption = shouldAddAndSelectEmptyOption;
    }
    createPageSizeSelectOptions(pageSizeOptions) {
        return pageSizeOptions.map((value) => ({
            value: String(value),
        }));
    }
    createPageSizeSelectorComp(pageSizeOptions, value) {
        const localeTextFunc = this.getLocaleTextFunc();
        const localisedLabel = localeTextFunc('pageSizeSelectorLabel', 'Page Size:');
        const localisedAriaLabel = localeTextFunc('ariaPageSizeSelectorLabel', 'Page Size');
        this.selectPageSizeComp = this.createManagedBean(new agSelect_1.AgSelect())
            .addOptions(this.createPageSizeSelectOptions(pageSizeOptions))
            .setValue(value)
            .setAriaLabel(localisedAriaLabel)
            .setLabel(localisedLabel)
            .onValueChange(() => this.handlePageSizeItemSelected());
        this.appendChild(this.selectPageSizeComp);
    }
    getPageSizeSelectorValues() {
        const defaultValues = [20, 50, 100];
        const paginationPageSizeSelectorValues = this.gos.get(paginationPageSizeSelector);
        if (!Array.isArray(paginationPageSizeSelectorValues) || !paginationPageSizeSelectorValues?.length) {
            return defaultValues;
        }
        return [...paginationPageSizeSelectorValues].sort((a, b) => a - b);
    }
    destroy() {
        this.toggleSelectDisplay(false);
        super.destroy();
    }
}
exports.PageSizeSelectorComp = PageSizeSelectorComp;
exports.PageSizeSelectorSelector = {
    selector: 'AG-PAGE-SIZE-SELECTOR',
    component: PageSizeSelectorComp,
};


/***/ }),

/***/ 35794:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginationGoToPage = exports.paginationGoToLastPage = exports.paginationGoToFirstPage = exports.paginationGoToPreviousPage = exports.paginationGoToNextPage = exports.paginationGetRowCount = exports.paginationGetTotalPages = exports.paginationGetCurrentPage = exports.paginationGetPageSize = exports.paginationIsLastPageFound = void 0;
function paginationIsLastPageFound(beans) {
    return beans.rowModel.isLastRowIndexKnown();
}
exports.paginationIsLastPageFound = paginationIsLastPageFound;
function paginationGetPageSize(beans) {
    return beans.pagination?.getPageSize() ?? 100;
}
exports.paginationGetPageSize = paginationGetPageSize;
function paginationGetCurrentPage(beans) {
    return beans.pagination?.getCurrentPage() ?? 0;
}
exports.paginationGetCurrentPage = paginationGetCurrentPage;
function paginationGetTotalPages(beans) {
    return beans.pagination?.getTotalPages() ?? 1;
}
exports.paginationGetTotalPages = paginationGetTotalPages;
function paginationGetRowCount(beans) {
    return beans.pagination ? beans.pagination.getMasterRowCount() : beans.rowModel.getRowCount();
}
exports.paginationGetRowCount = paginationGetRowCount;
function paginationGoToNextPage(beans) {
    beans.pagination?.goToNextPage();
}
exports.paginationGoToNextPage = paginationGoToNextPage;
function paginationGoToPreviousPage(beans) {
    beans.pagination?.goToPreviousPage();
}
exports.paginationGoToPreviousPage = paginationGoToPreviousPage;
function paginationGoToFirstPage(beans) {
    beans.pagination?.goToFirstPage();
}
exports.paginationGoToFirstPage = paginationGoToFirstPage;
function paginationGoToLastPage(beans) {
    beans.pagination?.goToLastPage();
}
exports.paginationGoToLastPage = paginationGoToLastPage;
function paginationGoToPage(beans, page) {
    beans.pagination?.goToPage(page);
}
exports.paginationGoToPage = paginationGoToPage;


/***/ }),

/***/ 90:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PaginationAutoPageSizeService = void 0;
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const function_1 = __webpack_require__(92043);
class PaginationAutoPageSizeService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'paginationAutoPageSizeSvc';
    }
    postConstruct() {
        this.beans.ctrlsSvc.whenReady(this, (p) => {
            this.centerRowsCtrl = p.center;
            const listener = this.checkPageSize.bind(this);
            this.addManagedEventListeners({
                bodyHeightChanged: listener,
                scrollVisibilityChanged: listener,
            });
            this.addManagedPropertyListener('paginationAutoPageSize', this.onPaginationAutoSizeChanged.bind(this));
            this.checkPageSize();
        });
    }
    notActive() {
        return !this.gos.get('paginationAutoPageSize') || this.centerRowsCtrl == null;
    }
    onPaginationAutoSizeChanged() {
        if (this.notActive()) {
            this.beans.pagination.unsetAutoCalculatedPageSize();
        }
        else {
            this.checkPageSize();
        }
    }
    checkPageSize() {
        if (this.notActive()) {
            return;
        }
        const bodyHeight = this.centerRowsCtrl.viewportSizeFeature.getBodyHeight();
        if (bodyHeight > 0) {
            const beans = this.beans;
            const update = () => {
                const rowHeight = Math.max((0, gridOptionsUtils_1._getRowHeightAsNumber)(beans), 1); // prevent divide by zero error if row height is 0
                const newPageSize = Math.floor(bodyHeight / rowHeight);
                beans.pagination.setPageSize(newPageSize, 'autoCalculated');
            };
            if (!this.isBodyRendered) {
                update();
                this.isBodyRendered = true;
            }
            else {
                // TODO: this is weird, since this _debounce is inlined here this seems to act just as a setTimeout?
                (0, function_1._debounce)(this, update, 50)();
            }
        }
        else {
            this.isBodyRendered = false;
        }
    }
}
exports.PaginationAutoPageSizeService = PaginationAutoPageSizeService;


/***/ }),

/***/ 40462:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginationCompCSS = void 0;
exports.paginationCompCSS = `.ag-paging-panel{align-items:center;border-top:var(--ag-footer-row-border);display:flex;gap:calc(var(--ag-spacing)*4);height:var(--ag-pagination-panel-height);justify-content:flex-end;padding:0 var(--ag-cell-horizontal-padding)}:where(.ag-paging-page-size) .ag-wrapper{min-width:50px}.ag-paging-page-summary-panel{align-items:center;display:flex;gap:var(--ag-cell-widget-spacing);.ag-disabled &{pointer-events:none}}.ag-paging-button{cursor:pointer;position:relative;&.ag-disabled{cursor:default;opacity:.5}}.ag-paging-number,.ag-paging-row-summary-panel-number{font-weight:500}`;


/***/ }),

/***/ 97919:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PaginationSelector = exports.PaginationComp = void 0;
const keyCode_1 = __webpack_require__(39853);
const aria_1 = __webpack_require__(95230);
const focus_1 = __webpack_require__(82331);
const icon_1 = __webpack_require__(59970);
const number_1 = __webpack_require__(27698);
const component_1 = __webpack_require__(78020);
const tabGuardComp_1 = __webpack_require__(68332);
const pageSizeSelectorComp_1 = __webpack_require__(42078);
const paginationComp_css_GENERATED_1 = __webpack_require__(40462);
class PaginationComp extends tabGuardComp_1.TabGuardComp {
    wireBeans(beans) {
        this.rowModel = beans.rowModel;
        this.pagination = beans.pagination;
        this.ariaAnnounce = beans.ariaAnnounce;
    }
    constructor() {
        super();
        this.btFirst = component_1.RefPlaceholder;
        this.btPrevious = component_1.RefPlaceholder;
        this.btNext = component_1.RefPlaceholder;
        this.btLast = component_1.RefPlaceholder;
        this.lbRecordCount = component_1.RefPlaceholder;
        this.lbFirstRowOnPage = component_1.RefPlaceholder;
        this.lbLastRowOnPage = component_1.RefPlaceholder;
        this.lbCurrent = component_1.RefPlaceholder;
        this.lbTotal = component_1.RefPlaceholder;
        this.pageSizeComp = component_1.RefPlaceholder;
        this.previousAndFirstButtonsDisabled = false;
        this.nextButtonDisabled = false;
        this.lastButtonDisabled = false;
        this.areListenersSetup = false;
        this.allowFocusInnerElement = false;
        this.registerCSS(paginationComp_css_GENERATED_1.paginationCompCSS);
    }
    postConstruct() {
        const isRtl = this.gos.get('enableRtl');
        this.setTemplate(this.getTemplate(), [pageSizeSelectorComp_1.PageSizeSelectorSelector]);
        const { btFirst, btPrevious, btNext, btLast } = this;
        this.activateTabIndex([btFirst, btPrevious, btNext, btLast]);
        btFirst.insertAdjacentElement('afterbegin', (0, icon_1._createIconNoSpan)(isRtl ? 'last' : 'first', this.beans));
        btPrevious.insertAdjacentElement('afterbegin', (0, icon_1._createIconNoSpan)(isRtl ? 'next' : 'previous', this.beans));
        btNext.insertAdjacentElement('afterbegin', (0, icon_1._createIconNoSpan)(isRtl ? 'previous' : 'next', this.beans));
        btLast.insertAdjacentElement('afterbegin', (0, icon_1._createIconNoSpan)(isRtl ? 'first' : 'last', this.beans));
        this.addManagedPropertyListener('pagination', this.onPaginationChanged.bind(this));
        this.addManagedPropertyListener('suppressPaginationPanel', this.onPaginationChanged.bind(this));
        this.addManagedPropertyListeners(['paginationPageSizeSelector', 'paginationAutoPageSize', 'suppressPaginationPanel'], () => this.onPageSizeRelatedOptionsChange());
        this.pageSizeComp.toggleSelectDisplay(this.pageSizeComp.shouldShowPageSizeSelector());
        this.initialiseTabGuard({
            // prevent tab guard default logic
            onTabKeyDown: () => { },
            focusInnerElement: (fromBottom) => {
                if (this.allowFocusInnerElement) {
                    return this.tabGuardFeature.getTabGuardCtrl().focusInnerElement(fromBottom);
                }
                else {
                    return (0, focus_1._focusGridInnerElement)(this.beans, fromBottom);
                }
            },
            forceFocusOutWhenTabGuardsAreEmpty: true,
        });
        this.onPaginationChanged();
    }
    setAllowFocus(allowFocus) {
        this.allowFocusInnerElement = allowFocus;
    }
    onPaginationChanged() {
        const isPaging = this.gos.get('pagination');
        const paginationPanelEnabled = isPaging && !this.gos.get('suppressPaginationPanel');
        this.setDisplayed(paginationPanelEnabled);
        if (!paginationPanelEnabled) {
            return;
        }
        this.setupListeners();
        this.enableOrDisableButtons();
        this.updateLabels();
        this.onPageSizeRelatedOptionsChange();
    }
    onPageSizeRelatedOptionsChange() {
        this.pageSizeComp.toggleSelectDisplay(this.pageSizeComp.shouldShowPageSizeSelector());
    }
    setupListeners() {
        if (!this.areListenersSetup) {
            this.addManagedEventListeners({ paginationChanged: this.onPaginationChanged.bind(this) });
            [
                { el: this.btFirst, fn: this.onBtFirst.bind(this) },
                { el: this.btPrevious, fn: this.onBtPrevious.bind(this) },
                { el: this.btNext, fn: this.onBtNext.bind(this) },
                { el: this.btLast, fn: this.onBtLast.bind(this) },
            ].forEach((item) => {
                const { el, fn } = item;
                this.addManagedListeners(el, {
                    click: fn,
                    keydown: (e) => {
                        if (e.key === keyCode_1.KeyCode.ENTER || e.key === keyCode_1.KeyCode.SPACE) {
                            e.preventDefault();
                            fn();
                        }
                    },
                });
            });
            (0, focus_1._addFocusableContainerListener)(this.beans, this, this.getGui());
            this.areListenersSetup = true;
        }
    }
    onBtFirst() {
        if (!this.previousAndFirstButtonsDisabled) {
            this.pagination.goToFirstPage();
        }
    }
    formatNumber(value) {
        const userFunc = this.gos.getCallback('paginationNumberFormatter');
        if (userFunc) {
            const params = { value: value };
            return userFunc(params);
        }
        return (0, number_1._formatNumberCommas)(value, this.getLocaleTextFunc.bind(this));
    }
    getTemplate() {
        const localeTextFunc = this.getLocaleTextFunc();
        const idPrefix = `ag-${this.getCompId()}`;
        return {
            tag: 'div',
            cls: 'ag-paging-panel ag-unselectable',
            attrs: { id: `${idPrefix}` },
            children: [
                {
                    tag: 'ag-page-size-selector',
                    ref: 'pageSizeComp',
                },
                {
                    tag: 'span',
                    cls: 'ag-paging-row-summary-panel',
                    children: [
                        {
                            tag: 'span',
                            ref: 'lbFirstRowOnPage',
                            cls: 'ag-paging-row-summary-panel-number',
                            attrs: { id: `${idPrefix}-first-row` },
                        },
                        { tag: 'span', attrs: { id: `${idPrefix}-to` }, children: localeTextFunc('to', 'to') },
                        {
                            tag: 'span',
                            ref: 'lbLastRowOnPage',
                            cls: 'ag-paging-row-summary-panel-number',
                            attrs: { id: `${idPrefix}-last-row` },
                        },
                        { tag: 'span', attrs: { id: `${idPrefix}-of` }, children: localeTextFunc('of', 'of') },
                        {
                            tag: 'span',
                            ref: 'lbRecordCount',
                            cls: 'ag-paging-row-summary-panel-number',
                            attrs: { id: `${idPrefix}-row-count` },
                        },
                    ],
                },
                {
                    tag: 'span',
                    cls: 'ag-paging-page-summary-panel',
                    role: 'presentation',
                    children: [
                        {
                            tag: 'div',
                            ref: 'btFirst',
                            cls: 'ag-button ag-paging-button',
                            role: 'button',
                            attrs: { 'aria-label': localeTextFunc('firstPage', 'First Page') },
                        },
                        {
                            tag: 'div',
                            ref: 'btPrevious',
                            cls: 'ag-button ag-paging-button',
                            role: 'button',
                            attrs: { 'aria-label': localeTextFunc('previousPage', 'Previous Page') },
                        },
                        {
                            tag: 'span',
                            cls: 'ag-paging-description',
                            children: [
                                {
                                    tag: 'span',
                                    attrs: {
                                        id: `${idPrefix}-start-page`,
                                    },
                                    children: localeTextFunc('page', 'Page'),
                                },
                                {
                                    tag: 'span',
                                    ref: 'lbCurrent',
                                    cls: 'ag-paging-number',
                                    attrs: { id: `${idPrefix}-start-page-number` },
                                },
                                {
                                    tag: 'span',
                                    attrs: {
                                        id: `${idPrefix}-of-page`,
                                    },
                                    children: localeTextFunc('of', 'of'),
                                },
                                {
                                    tag: 'span',
                                    ref: 'lbTotal',
                                    cls: 'ag-paging-number',
                                    attrs: { id: `${idPrefix}-of-page-number` },
                                },
                            ],
                        },
                        {
                            tag: 'div',
                            ref: 'btNext',
                            cls: 'ag-button ag-paging-button',
                            role: 'button',
                            attrs: { 'aria-label': localeTextFunc('nextPage', 'Next Page') },
                        },
                        {
                            tag: 'div',
                            ref: 'btLast',
                            cls: 'ag-button ag-paging-button',
                            role: 'button',
                            attrs: { 'aria-label': localeTextFunc('lastPage', 'Last Page') },
                        },
                    ],
                },
            ],
        };
    }
    onBtNext() {
        if (!this.nextButtonDisabled) {
            this.pagination.goToNextPage();
        }
    }
    onBtPrevious() {
        if (!this.previousAndFirstButtonsDisabled) {
            this.pagination.goToPreviousPage();
        }
    }
    onBtLast() {
        if (!this.lastButtonDisabled) {
            this.pagination.goToLastPage();
        }
    }
    enableOrDisableButtons() {
        const currentPage = this.pagination.getCurrentPage();
        const maxRowFound = this.rowModel.isLastRowIndexKnown();
        const totalPages = this.pagination.getTotalPages();
        this.previousAndFirstButtonsDisabled = currentPage === 0;
        this.toggleButtonDisabled(this.btFirst, this.previousAndFirstButtonsDisabled);
        this.toggleButtonDisabled(this.btPrevious, this.previousAndFirstButtonsDisabled);
        const zeroPagesToDisplay = this.isZeroPagesToDisplay();
        const onLastPage = currentPage === totalPages - 1;
        this.nextButtonDisabled = onLastPage || zeroPagesToDisplay;
        this.lastButtonDisabled = !maxRowFound || zeroPagesToDisplay || currentPage === totalPages - 1;
        this.toggleButtonDisabled(this.btNext, this.nextButtonDisabled);
        this.toggleButtonDisabled(this.btLast, this.lastButtonDisabled);
    }
    toggleButtonDisabled(button, disabled) {
        (0, aria_1._setAriaDisabled)(button, disabled);
        button.classList.toggle('ag-disabled', disabled);
    }
    isZeroPagesToDisplay() {
        const maxRowFound = this.rowModel.isLastRowIndexKnown();
        const totalPages = this.pagination.getTotalPages();
        return maxRowFound && totalPages === 0;
    }
    updateLabels() {
        const lastPageFound = this.rowModel.isLastRowIndexKnown();
        const totalPages = this.pagination.getTotalPages();
        const masterRowCount = this.pagination.getMasterRowCount();
        const rowCount = lastPageFound ? masterRowCount : null;
        const currentPage = this.pagination.getCurrentPage();
        const pageSize = this.pagination.getPageSize();
        let startRow;
        let endRow;
        if (this.isZeroPagesToDisplay()) {
            startRow = endRow = 0;
        }
        else {
            startRow = pageSize * currentPage + 1;
            endRow = startRow + pageSize - 1;
            if (lastPageFound && endRow > rowCount) {
                endRow = rowCount;
            }
        }
        const theoreticalEndRow = startRow + pageSize - 1;
        const isLoadingPageSize = !lastPageFound && masterRowCount < theoreticalEndRow;
        const lbFirstRowOnPage = this.formatNumber(startRow);
        this.lbFirstRowOnPage.textContent = lbFirstRowOnPage;
        let lbLastRowOnPage;
        const localeTextFunc = this.getLocaleTextFunc();
        if (isLoadingPageSize) {
            lbLastRowOnPage = localeTextFunc('pageLastRowUnknown', '?');
        }
        else {
            lbLastRowOnPage = this.formatNumber(endRow);
        }
        this.lbLastRowOnPage.textContent = lbLastRowOnPage;
        const pagesExist = totalPages > 0;
        const toDisplay = pagesExist ? currentPage + 1 : 0;
        const lbCurrent = this.formatNumber(toDisplay);
        this.lbCurrent.textContent = lbCurrent;
        let lbTotal;
        let lbRecordCount;
        if (lastPageFound) {
            lbTotal = this.formatNumber(totalPages);
            lbRecordCount = this.formatNumber(rowCount);
        }
        else {
            const moreText = localeTextFunc('more', 'more');
            lbTotal = moreText;
            lbRecordCount = moreText;
        }
        this.lbTotal.textContent = lbTotal;
        this.lbRecordCount.textContent = lbRecordCount;
        this.announceAriaStatus(lbFirstRowOnPage, lbLastRowOnPage, lbRecordCount, lbCurrent, lbTotal);
    }
    announceAriaStatus(lbFirstRowOnPage, lbLastRowOnPage, lbRecordCount, lbCurrent, lbTotal) {
        const localeTextFunc = this.getLocaleTextFunc();
        const strPage = localeTextFunc('page', 'Page');
        const strTo = localeTextFunc('to', 'to');
        const strOf = localeTextFunc('of', 'of');
        const ariaRowStatus = `${lbFirstRowOnPage} ${strTo} ${lbLastRowOnPage} ${strOf} ${lbRecordCount}`;
        const ariaPageStatus = `${strPage} ${lbCurrent} ${strOf} ${lbTotal}`;
        if (ariaRowStatus !== this.ariaRowStatus) {
            this.ariaRowStatus = ariaRowStatus;
            this.ariaAnnounce?.announceValue(ariaRowStatus, 'paginationRow');
        }
        if (ariaPageStatus !== this.ariaPageStatus) {
            this.ariaPageStatus = ariaPageStatus;
            this.ariaAnnounce?.announceValue(ariaPageStatus, 'paginationPage');
        }
    }
    setTotalLabelsToZero() {
        const strZero = this.formatNumber(0);
        this.lbFirstRowOnPage.textContent = strZero;
        this.lbCurrent.textContent = strZero;
        this.lbLastRowOnPage.textContent = strZero;
        this.lbTotal.textContent = strZero;
        this.lbRecordCount.textContent = strZero;
        this.announceAriaStatus(strZero, strZero, strZero, strZero, strZero);
    }
}
exports.PaginationComp = PaginationComp;
exports.PaginationSelector = {
    selector: 'AG-PAGINATION',
    component: PaginationComp,
};


/***/ }),

/***/ 71824:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PaginationModule = void 0;
const version_1 = __webpack_require__(97205);
const popupModule_1 = __webpack_require__(3137);
const paginationApi_1 = __webpack_require__(35794);
const paginationAutoPageSizeService_1 = __webpack_require__(90);
const paginationService_1 = __webpack_require__(73937);
/**
 * @feature Rows -> Row Pagination
 * @gridOption pagination
 */
exports.PaginationModule = {
    moduleName: 'Pagination',
    version: version_1.VERSION,
    beans: [paginationService_1.PaginationService, paginationAutoPageSizeService_1.PaginationAutoPageSizeService],
    icons: {
        // "go to first" button in pagination controls
        first: 'first',
        // "go to previous" button in pagination controls
        previous: 'previous',
        // "go to next" button in pagination controls
        next: 'next',
        // "go to last" button in pagination controls
        last: 'last',
    },
    apiFunctions: {
        paginationIsLastPageFound: paginationApi_1.paginationIsLastPageFound,
        paginationGetPageSize: paginationApi_1.paginationGetPageSize,
        paginationGetCurrentPage: paginationApi_1.paginationGetCurrentPage,
        paginationGetTotalPages: paginationApi_1.paginationGetTotalPages,
        paginationGetRowCount: paginationApi_1.paginationGetRowCount,
        paginationGoToNextPage: paginationApi_1.paginationGoToNextPage,
        paginationGoToPreviousPage: paginationApi_1.paginationGoToPreviousPage,
        paginationGoToFirstPage: paginationApi_1.paginationGoToFirstPage,
        paginationGoToLastPage: paginationApi_1.paginationGoToLastPage,
        paginationGoToPage: paginationApi_1.paginationGoToPage,
    },
    dependsOn: [popupModule_1.PopupModule],
};


/***/ }),

/***/ 73937:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PaginationService = void 0;
const beanStub_1 = __webpack_require__(68731);
const generic_1 = __webpack_require__(34422);
const paginationComp_1 = __webpack_require__(97919);
class PaginationService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'pagination';
        this.currentPage = 0;
        this.topDisplayedRowIndex = 0;
        this.bottomDisplayedRowIndex = 0;
        this.masterRowCount = 0;
    }
    postConstruct() {
        const gos = this.gos;
        this.active = gos.get('pagination');
        this.pageSizeFromGridOptions = gos.get('paginationPageSize');
        this.paginateChildRows = this.isPaginateChildRows();
        this.addManagedPropertyListener('pagination', this.onPaginationGridOptionChanged.bind(this));
        this.addManagedPropertyListener('paginationPageSize', this.onPageSizeGridOptionChanged.bind(this));
    }
    getPaginationSelector() {
        return paginationComp_1.PaginationSelector;
    }
    isPaginateChildRows() {
        const gos = this.gos;
        const shouldPaginate = gos.get('groupHideParentOfSingleChild') ||
            // following two properties deprecated v32.3.0
            gos.get('groupRemoveSingleChildren') ||
            gos.get('groupRemoveLowestSingleChildren');
        if (shouldPaginate) {
            return true;
        }
        return gos.get('paginateChildRows');
    }
    onPaginationGridOptionChanged() {
        this.active = this.gos.get('pagination');
        this.calculatePages();
        // important to keep rendered rows, otherwise every time grid is resized,
        // we would destroy all the rows.
        this.dispatchPaginationChangedEvent({ keepRenderedRows: true });
    }
    onPageSizeGridOptionChanged() {
        this.setPageSize(this.gos.get('paginationPageSize'), 'gridOptions');
    }
    goToPage(page) {
        const currentPage = this.currentPage;
        if (!this.active || currentPage === page || typeof currentPage !== 'number') {
            return;
        }
        const { editSvc } = this.beans;
        if (editSvc?.isEditing()) {
            if (editSvc.isBatchEditing()) {
                editSvc.cleanupEditors();
            }
            else {
                editSvc.stopEditing(undefined, { source: 'api' });
            }
        }
        this.currentPage = page;
        this.calculatePages();
        this.dispatchPaginationChangedEvent({ newPage: true });
    }
    goToPageWithIndex(index) {
        if (!this.active) {
            return;
        }
        let adjustedIndex = index;
        if (!this.paginateChildRows) {
            adjustedIndex = this.beans.rowModel.getTopLevelIndexFromDisplayedIndex?.(index) ?? index;
        }
        this.goToPage(Math.floor(adjustedIndex / this.pageSize));
    }
    isRowInPage(rowIndex) {
        if (!this.active) {
            return true;
        }
        return rowIndex >= this.topDisplayedRowIndex && rowIndex <= this.bottomDisplayedRowIndex;
    }
    getCurrentPage() {
        return this.currentPage;
    }
    goToNextPage() {
        this.goToPage(this.currentPage + 1);
    }
    goToPreviousPage() {
        this.goToPage(this.currentPage - 1);
    }
    goToFirstPage() {
        this.goToPage(0);
    }
    goToLastPage() {
        const rowCount = this.beans.rowModel.getRowCount();
        const lastPage = Math.floor(rowCount / this.pageSize);
        this.goToPage(lastPage);
    }
    getPageSize() {
        return this.pageSize;
    }
    getTotalPages() {
        return this.totalPages;
    }
    /** This is only for state setting before data has been loaded */
    setPage(page) {
        this.currentPage = page;
    }
    get pageSize() {
        // Explicitly check for autosize status as this can be set to false before the calculated value is cleared.
        // Due to a race condition in when event listeners are added.
        if ((0, generic_1._exists)(this.pageSizeAutoCalculated) && this.gos.get('paginationAutoPageSize')) {
            return this.pageSizeAutoCalculated;
        }
        if ((0, generic_1._exists)(this.pageSizeFromPageSizeSelector)) {
            return this.pageSizeFromPageSizeSelector;
        }
        if ((0, generic_1._exists)(this.pageSizeFromInitialState)) {
            return this.pageSizeFromInitialState;
        }
        if ((0, generic_1._exists)(this.pageSizeFromGridOptions)) {
            return this.pageSizeFromGridOptions;
        }
        return this.defaultPageSize;
    }
    calculatePages() {
        if (this.active) {
            if (this.paginateChildRows) {
                this.calculatePagesAllRows();
            }
            else {
                this.calculatePagesMasterRowsOnly();
            }
        }
        else {
            this.calculatedPagesNotActive();
        }
        this.beans.pageBounds.calculateBounds(this.topDisplayedRowIndex, this.bottomDisplayedRowIndex);
    }
    unsetAutoCalculatedPageSize() {
        if (this.pageSizeAutoCalculated === undefined) {
            return;
        }
        const oldPageSize = this.pageSizeAutoCalculated;
        this.pageSizeAutoCalculated = undefined;
        if (this.pageSize === oldPageSize) {
            return;
        }
        this.calculatePages();
        this.dispatchPaginationChangedEvent({ newPageSize: true });
    }
    setPageSize(size, source) {
        const currentSize = this.pageSize;
        switch (source) {
            case 'autoCalculated':
                this.pageSizeAutoCalculated = size;
                break;
            case 'pageSizeSelector':
                this.pageSizeFromPageSizeSelector = size;
                if (this.currentPage !== 0) {
                    this.goToFirstPage();
                }
                break;
            case 'initialState':
                this.pageSizeFromInitialState = size;
                break;
            case 'gridOptions':
                this.pageSizeFromGridOptions = size;
                this.pageSizeFromInitialState = undefined;
                this.pageSizeFromPageSizeSelector = undefined;
                if (this.currentPage !== 0) {
                    this.goToFirstPage();
                }
                break;
        }
        if (currentSize !== this.pageSize) {
            this.calculatePages();
            this.dispatchPaginationChangedEvent({ newPageSize: true, keepRenderedRows: true });
        }
    }
    setZeroRows() {
        this.masterRowCount = 0;
        this.topDisplayedRowIndex = 0;
        this.bottomDisplayedRowIndex = -1;
        this.currentPage = 0;
        this.totalPages = 0;
    }
    adjustCurrentPageIfInvalid() {
        const totalPages = this.totalPages;
        if (this.currentPage >= totalPages) {
            this.currentPage = totalPages - 1;
        }
        const currentPage = this.currentPage;
        if (!isFinite(currentPage) || isNaN(currentPage) || currentPage < 0) {
            this.currentPage = 0;
        }
    }
    calculatePagesMasterRowsOnly() {
        const rowModel = this.beans.rowModel;
        const masterRowCount = rowModel.getTopLevelRowCount();
        this.masterRowCount = masterRowCount;
        // we say <=0 (rather than =0) as viewport returns -1 when no rows
        if (masterRowCount <= 0) {
            this.setZeroRows();
            return;
        }
        const pageSize = this.pageSize;
        const masterLastRowIndex = masterRowCount - 1;
        this.totalPages = Math.floor(masterLastRowIndex / pageSize) + 1;
        this.adjustCurrentPageIfInvalid();
        const currentPage = this.currentPage;
        const masterPageStartIndex = pageSize * currentPage;
        let masterPageEndIndex = pageSize * (currentPage + 1) - 1;
        if (masterPageEndIndex > masterLastRowIndex) {
            masterPageEndIndex = masterLastRowIndex;
        }
        this.topDisplayedRowIndex = rowModel.getTopLevelRowDisplayedIndex(masterPageStartIndex);
        // masterRows[masterPageStartIndex].rowIndex;
        if (masterPageEndIndex === masterLastRowIndex) {
            // if showing the last master row, then we want to show the very last row of the model
            this.bottomDisplayedRowIndex = rowModel.getRowCount() - 1;
        }
        else {
            const firstIndexNotToShow = rowModel.getTopLevelRowDisplayedIndex(masterPageEndIndex + 1);
            //masterRows[masterPageEndIndex + 1].rowIndex;
            // this gets the index of the last child - eg current row is open, we want to display all children,
            // the index of the last child is one less than the index of the next parent row.
            this.bottomDisplayedRowIndex = firstIndexNotToShow - 1;
        }
    }
    getMasterRowCount() {
        return this.masterRowCount;
    }
    calculatePagesAllRows() {
        const masterRowCount = this.beans.rowModel.getRowCount();
        this.masterRowCount = masterRowCount;
        if (masterRowCount === 0) {
            this.setZeroRows();
            return;
        }
        const { pageSize, currentPage } = this;
        const maxRowIndex = masterRowCount - 1;
        this.totalPages = Math.floor(maxRowIndex / pageSize) + 1;
        this.adjustCurrentPageIfInvalid();
        this.topDisplayedRowIndex = pageSize * currentPage;
        this.bottomDisplayedRowIndex = pageSize * (currentPage + 1) - 1;
        if (this.bottomDisplayedRowIndex > maxRowIndex) {
            this.bottomDisplayedRowIndex = maxRowIndex;
        }
    }
    calculatedPagesNotActive() {
        // when pagination is not active we don't use any page size variables,
        // however need to unset this so if enabled we recalculate.
        this.setPageSize(undefined, 'autoCalculated');
        this.totalPages = 1;
        this.currentPage = 0;
        this.topDisplayedRowIndex = 0;
        this.bottomDisplayedRowIndex = this.beans.rowModel.getRowCount() - 1;
    }
    dispatchPaginationChangedEvent(params) {
        const { keepRenderedRows = false, newPage = false, newPageSize = false } = params;
        this.eventSvc.dispatchEvent({
            type: 'paginationChanged',
            animate: false,
            newData: false,
            newPage,
            newPageSize,
            keepRenderedRows,
        });
    }
}
exports.PaginationService = PaginationService;


/***/ }),

/***/ 47186:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.pinnedColumnModuleCSS = void 0;
exports.pinnedColumnModuleCSS = `.ag-pinned-left-floating-bottom,.ag-pinned-left-floating-top,.ag-pinned-right-floating-bottom,.ag-pinned-right-floating-top{min-width:0;overflow:hidden;position:relative}.ag-pinned-left-sticky-top,.ag-pinned-right-sticky-top{height:100%;overflow:hidden;position:relative}.ag-sticky-bottom-full-width-container,.ag-sticky-top-full-width-container{height:100%;overflow:hidden;width:100%}.ag-pinned-left-header,.ag-pinned-right-header{display:inline-block;height:100%;overflow:hidden;position:relative}.ag-body-horizontal-scroll:not(.ag-scrollbar-invisible){.ag-horizontal-left-spacer:not(.ag-scroller-corner){border-right:var(--ag-pinned-column-border)}.ag-horizontal-right-spacer:not(.ag-scroller-corner){border-left:var(--ag-pinned-column-border)}}.ag-pinned-right-header{border-left:var(--ag-pinned-column-border)}.ag-pinned-left-header{border-right:var(--ag-pinned-column-border)}.ag-cell.ag-cell-first-right-pinned:not(.ag-cell-range-left,.ag-cell-range-single-cell,.ag-cell-focus:not(.ag-cell-range-selected):focus-within){border-left:var(--ag-pinned-column-border)}.ag-cell.ag-cell-last-left-pinned:not(.ag-cell-range-right,.ag-cell-range-single-cell,.ag-cell-focus:not(.ag-cell-range-selected):focus-within){border-right:var(--ag-pinned-column-border)}.ag-pinned-left-header .ag-header-cell-resize:after{left:calc(50% - var(--ag-header-column-resize-handle-width))}.ag-pinned-right-header .ag-header-cell-resize:after{left:50%}.ag-pinned-left-header .ag-header-cell-resize{right:-3px}.ag-pinned-right-header .ag-header-cell-resize{left:-3px}`;


/***/ }),

/***/ 46219:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PinnedColumnModule = void 0;
const version_1 = __webpack_require__(97205);
const pinnedColumnModule_css_GENERATED_1 = __webpack_require__(47186);
const pinnedColumnService_1 = __webpack_require__(77076);
/**
 * @feature Columns -> Column Pinning
 * @colDef pinned
 */
exports.PinnedColumnModule = {
    moduleName: 'PinnedColumn',
    version: version_1.VERSION,
    beans: [pinnedColumnService_1.PinnedColumnService],
    css: [pinnedColumnModule_css_GENERATED_1.pinnedColumnModuleCSS],
};


/***/ }),

/***/ 77076:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PinnedColumnService = void 0;
const columnEventUtils_1 = __webpack_require__(72934);
const columnUtils_1 = __webpack_require__(73146);
const beanStub_1 = __webpack_require__(68731);
const setPinnedWidthFeature_1 = __webpack_require__(2865);
const gridOptionsUtils_1 = __webpack_require__(67274);
const dom_1 = __webpack_require__(33507);
const logging_1 = __webpack_require__(47764);
class PinnedColumnService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'pinnedCols';
    }
    postConstruct() {
        this.beans.ctrlsSvc.whenReady(this, (p) => {
            this.gridBodyCtrl = p.gridBodyCtrl;
        });
        const listener = this.checkContainerWidths.bind(this);
        this.addManagedEventListeners({
            displayedColumnsChanged: listener,
            displayedColumnsWidthChanged: listener,
        });
        this.addManagedPropertyListener('domLayout', listener);
    }
    checkContainerWidths() {
        const { gos, visibleCols, eventSvc } = this.beans;
        const printLayout = (0, gridOptionsUtils_1._isDomLayout)(gos, 'print');
        const newLeftWidth = printLayout ? 0 : visibleCols.getColsLeftWidth();
        const newRightWidth = printLayout ? 0 : visibleCols.getDisplayedColumnsRightWidth();
        if (newLeftWidth != this.leftWidth) {
            this.leftWidth = newLeftWidth;
            eventSvc.dispatchEvent({ type: 'leftPinnedWidthChanged' });
        }
        if (newRightWidth != this.rightWidth) {
            this.rightWidth = newRightWidth;
            eventSvc.dispatchEvent({ type: 'rightPinnedWidthChanged' });
        }
    }
    keepPinnedColumnsNarrowerThanViewport() {
        const eBodyViewport = this.gridBodyCtrl.eBodyViewport;
        const bodyWidth = (0, dom_1._getInnerWidth)(eBodyViewport);
        if (bodyWidth <= 50) {
            return;
        }
        // remove 50px from the bodyWidth to give some margin
        const processedColumnsToRemove = this.getPinnedColumnsOverflowingViewport(bodyWidth - 50);
        const processUnpinnedColumns = this.gos.getCallback('processUnpinnedColumns');
        const { columns, hasLockedPinned } = processedColumnsToRemove;
        let columnsToRemove = columns;
        if (!columnsToRemove.length && !hasLockedPinned) {
            return;
        }
        if (processUnpinnedColumns) {
            const params = {
                columns: columnsToRemove,
                viewportWidth: bodyWidth,
            };
            columnsToRemove = processUnpinnedColumns(params);
        }
        if (!columnsToRemove || !columnsToRemove.length) {
            return;
        }
        columnsToRemove = columnsToRemove.filter((col) => !(0, columnUtils_1.isRowNumberCol)(col));
        this.setColsPinned(columnsToRemove, null, 'viewportSizeFeature');
    }
    createPinnedWidthFeature(isLeft, ...elements) {
        return new setPinnedWidthFeature_1.SetPinnedWidthFeature(isLeft, elements);
    }
    setColsPinned(keys, pinned, source) {
        const { colModel, colAnimation, visibleCols, gos } = this.beans;
        if (!colModel.cols) {
            return;
        }
        if (!keys?.length) {
            return;
        }
        if ((0, gridOptionsUtils_1._isDomLayout)(gos, 'print')) {
            (0, logging_1._warn)(37);
            return;
        }
        colAnimation?.start();
        let actualPinned;
        if (pinned === true || pinned === 'left') {
            actualPinned = 'left';
        }
        else if (pinned === 'right') {
            actualPinned = 'right';
        }
        else {
            actualPinned = null;
        }
        const updatedCols = [];
        keys.forEach((key) => {
            if (!key) {
                return;
            }
            const column = colModel.getCol(key);
            if (!column) {
                return;
            }
            if (column.getPinned() !== actualPinned) {
                this.setColPinned(column, actualPinned);
                updatedCols.push(column);
            }
        });
        if (updatedCols.length) {
            visibleCols.refresh(source);
            (0, columnEventUtils_1.dispatchColumnPinnedEvent)(this.eventSvc, updatedCols, source);
        }
        colAnimation?.finish();
    }
    initCol(column) {
        const { pinned, initialPinned } = column.colDef;
        if (pinned !== undefined) {
            this.setColPinned(column, pinned);
        }
        else {
            this.setColPinned(column, initialPinned);
        }
    }
    setColPinned(column, pinned) {
        if (pinned === true || pinned === 'left') {
            column.pinned = 'left';
        }
        else if (pinned === 'right') {
            column.pinned = 'right';
        }
        else {
            column.pinned = null;
        }
        column.dispatchStateUpdatedEvent('pinned');
    }
    setupHeaderPinnedWidth(ctrl) {
        const { scrollVisibleSvc } = this.beans;
        if (ctrl.pinned == null) {
            return;
        }
        const pinningLeft = ctrl.pinned === 'left';
        const pinningRight = ctrl.pinned === 'right';
        ctrl.hidden = true;
        const listener = () => {
            const width = pinningLeft ? this.leftWidth : this.rightWidth;
            if (width == null) {
                return;
            } // can happen at initialisation, width not yet set
            const hidden = width == 0;
            const hiddenChanged = ctrl.hidden !== hidden;
            const isRtl = this.gos.get('enableRtl');
            const scrollbarWidth = scrollVisibleSvc.getScrollbarWidth();
            // if there is a scroll showing (and taking up space, so Windows, and not iOS)
            // in the body, then we add extra space to keep header aligned with the body,
            // as body width fits the cols and the scrollbar
            const addPaddingForScrollbar = scrollVisibleSvc.verticalScrollShowing && ((isRtl && pinningLeft) || (!isRtl && pinningRight));
            const widthWithPadding = addPaddingForScrollbar ? width + scrollbarWidth : width;
            ctrl.comp.setPinnedContainerWidth(`${widthWithPadding}px`);
            ctrl.comp.setDisplayed(!hidden);
            if (hiddenChanged) {
                ctrl.hidden = hidden;
                ctrl.refresh();
            }
        };
        ctrl.addManagedEventListeners({
            leftPinnedWidthChanged: listener,
            rightPinnedWidthChanged: listener,
            scrollVisibilityChanged: listener,
            scrollbarWidthChanged: listener,
        });
    }
    getHeaderResizeDiff(diff, column) {
        const pinned = column.getPinned();
        if (pinned) {
            const { leftWidth, rightWidth } = this;
            const bodyWidth = (0, dom_1._getInnerWidth)(this.beans.ctrlsSvc.getGridBodyCtrl().eBodyViewport) - 50;
            if (leftWidth + rightWidth + diff > bodyWidth) {
                if (bodyWidth > leftWidth + rightWidth) {
                    // allow body width to ignore resize multiplier and fill space for last tick
                    diff = bodyWidth - leftWidth - rightWidth;
                }
                else {
                    return 0;
                }
            }
        }
        return diff;
    }
    getPinnedColumnsOverflowingViewport(viewportWidth) {
        const pinnedRightWidth = this.rightWidth ?? 0;
        const pinnedLeftWidth = this.leftWidth ?? 0;
        const totalPinnedWidth = pinnedRightWidth + pinnedLeftWidth;
        let hasLockedPinned = false;
        if (totalPinnedWidth < viewportWidth) {
            return { columns: [], hasLockedPinned };
        }
        const { visibleCols } = this.beans;
        const pinnedLeftColumns = [...visibleCols.leftCols];
        const pinnedRightColumns = [...visibleCols.rightCols];
        let indexRight = 0;
        let indexLeft = 0;
        const totalWidthRemoved = 0;
        const columnsToRemove = [];
        let spaceNecessary = totalPinnedWidth - totalWidthRemoved - viewportWidth;
        while ((indexLeft < pinnedLeftColumns.length || indexRight < pinnedRightColumns.length) && spaceNecessary > 0) {
            if (indexRight < pinnedRightColumns.length) {
                const currentColumn = pinnedRightColumns[indexRight++];
                if (currentColumn.colDef.lockPinned) {
                    hasLockedPinned = true;
                    continue;
                }
                spaceNecessary -= currentColumn.getActualWidth();
                columnsToRemove.push(currentColumn);
            }
            if (indexLeft < pinnedLeftColumns.length && spaceNecessary > 0) {
                const currentColumn = pinnedLeftColumns[indexLeft++];
                if (currentColumn.colDef.lockPinned) {
                    hasLockedPinned = true;
                    continue;
                }
                spaceNecessary -= currentColumn.getActualWidth();
                columnsToRemove.push(currentColumn);
            }
        }
        return { columns: columnsToRemove, hasLockedPinned };
    }
}
exports.PinnedColumnService = PinnedColumnService;


/***/ }),

/***/ 40436:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.manualPinnedRowCSS = void 0;
exports.manualPinnedRowCSS = `.ag-row-pinned-source{background-color:var(--ag-pinned-source-row-background-color);color:var(--ag-pinned-source-row-text-color);font-weight:var(--ag-pinned-source-row-font-weight)}.ag-row-pinned-manual{background-color:var(--ag-pinned-row-background-color);color:var(--ag-pinned-row-text-color);font-weight:var(--ag-pinned-row-font-weight)}`;


/***/ }),

/***/ 29596:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ManualPinnedRowModel = void 0;
const beanStub_1 = __webpack_require__(68731);
const rowNode_1 = __webpack_require__(3373);
const rowNodeUtils_1 = __webpack_require__(9888);
const gridOptionsUtils_1 = __webpack_require__(67274);
const manualPinnedRowUtils_1 = __webpack_require__(28188);
class ManualPinnedRowModel extends beanStub_1.BeanStub {
    postConstruct() {
        const { gos, beans } = this;
        this.top = new manualPinnedRowUtils_1.PinnedRows(beans, 'top');
        this.bottom = new manualPinnedRowUtils_1.PinnedRows(beans, 'bottom');
        const shouldHide = (node) => (0, manualPinnedRowUtils_1._shouldHidePinnedRows)(beans, node.pinnedSibling);
        const runIsRowPinned = () => {
            const isRowPinned = gos.get('isRowPinned');
            if (isRowPinned && gos.get('enableRowPinning')) {
                beans.rowModel.forEachNode((node) => this.pinRow(node, isRowPinned(node)), true);
            }
            this.refreshRowPositions();
            this.dispatchRowPinnedEvents();
        };
        this.addManagedEventListeners({
            gridStylesChanged: this.onGridStylesChanges.bind(this),
            modelUpdated: () => {
                this.tryToEmptyQueues();
                this.pinGrandTotalRow();
                this.forContainers((container) => container.hide(shouldHide));
                this.refreshRowPositions();
                this.dispatchRowPinnedEvents();
            },
            columnRowGroupChanged: () => {
                this.forContainers(removeGroupRows);
                this.refreshRowPositions();
            },
            rowNodeDataChanged: ({ node }) => {
                const isRowPinnable = gos.get('isRowPinnable');
                const pinnable = isRowPinnable?.(node) ?? true;
                if (!pinnable) {
                    this.pinRow(node, null);
                }
            },
            firstDataRendered: runIsRowPinned,
        });
        this.addManagedPropertyListener('pivotMode', () => {
            this.forContainers((container) => container.hide(shouldHide));
            this.dispatchRowPinnedEvents();
        });
        this.addManagedPropertyListener('grandTotalRow', ({ currentValue }) => {
            this._grandTotalPinned =
                currentValue === 'pinnedBottom' ? 'bottom' : currentValue === 'pinnedTop' ? 'top' : null;
        });
        this.addManagedPropertyListener('isRowPinned', runIsRowPinned);
    }
    destroy() {
        this.reset(false);
        super.destroy();
    }
    reset(dispatch = true) {
        this.forContainers((container) => {
            const nodesToUnpin = [];
            container.forEach((n) => nodesToUnpin.push(n));
            // Have to collect up the nodes to unpin because unpinning mutates the container
            nodesToUnpin.forEach((n) => this.pinRow(n, null));
            container.clear();
        });
        if (dispatch) {
            this.dispatchRowPinnedEvents();
        }
    }
    pinRow(rowNode, float, column) {
        // Forbid pinning group footers
        if (rowNode.footer && rowNode.level > -1)
            return;
        // Pinning grand total row is the only case in which pinned rows are not duplicates of rows
        // in the main viewport. So we have to handle them differently:
        // 1. We first set `_grandTotalPinned` to mark the location the grand total row should be pinned to.
        // 2. Then we refresh the row model to hide the sticky footer.
        // 3. We then react to the `modelUpdated` event (above) to actually add the footer to the pinned row model.
        // Otherwise we would run into either an infinite recursion of `modelUpdated` events, or be missing the `sibling`
        // on the root node.
        if (rowNode.footer && rowNode.level === -1) {
            this._grandTotalPinned = float;
            refreshCSRM(this.beans);
            return;
        }
        // May have been called on either the pinned row or the source row, check both
        const currentFloat = rowNode.rowPinned ?? rowNode.pinnedSibling?.rowPinned;
        // We're only switching if neither the current nor the target container are null
        const switching = currentFloat != null && float != null && float != currentFloat;
        if (switching) {
            // call unpin on pinned row, re-pin on source row, since we always want to dispatch events
            // on the source rows
            const pinned = rowNode.rowPinned ? rowNode : rowNode.pinnedSibling;
            const source = rowNode.rowPinned ? rowNode.pinnedSibling : rowNode;
            this.pinRow(pinned, null, column);
            this.pinRow(source, float, column);
            return;
        }
        // cell-span pinning/unpinning
        const spannedRows = column && getSpannedRows(this.beans, rowNode, column);
        if (spannedRows) {
            spannedRows.forEach((node) => this.pinRow(node, float));
            return;
        }
        // unpinning
        if (float == null) {
            // Want to act on the pinned row, not the source row
            const node = rowNode.rowPinned ? rowNode : rowNode.pinnedSibling;
            const found = this.findPinnedRowNode(node);
            if (!found)
                return;
            found.delete(node);
            const source = node.pinnedSibling;
            _destroyRowNodeSibling(node);
            this.refreshRowPositions(float);
            this.dispatchRowPinnedEvents(source);
        }
        else {
            // pinning
            const sibling = _createPinnedSibling(this.beans, rowNode, float);
            const container = this.getContainer(float);
            container.add(sibling);
            // Check if we should hide this row -- covers us for some asynchronicities
            // between (e.g.) applying filters and pinning rows.
            if ((0, manualPinnedRowUtils_1._shouldHidePinnedRows)(this.beans, rowNode)) {
                container.hide((node) => (0, manualPinnedRowUtils_1._shouldHidePinnedRows)(this.beans, node.pinnedSibling));
            }
            this.refreshRowPositions(float);
            this.dispatchRowPinnedEvents(rowNode);
        }
    }
    isManual() {
        return true;
    }
    isEmpty(floating) {
        return this.getContainer(floating).size() === 0;
    }
    isRowsToRender(floating) {
        return !this.isEmpty(floating);
    }
    ensureRowHeightsValid() {
        let anyChange = false;
        let rowTop = 0;
        const updateRowHeight = (rowNode) => {
            if (rowNode.rowHeightEstimated) {
                const rowHeight = (0, gridOptionsUtils_1._getRowHeightForNode)(this.beans, rowNode);
                rowNode.setRowTop(rowTop);
                rowNode.setRowHeight(rowHeight.height);
                rowTop += rowHeight.height;
                anyChange = true;
            }
        };
        this.bottom.forEach(updateRowHeight);
        rowTop = 0;
        this.top.forEach(updateRowHeight);
        this.eventSvc.dispatchEvent({
            type: 'pinnedHeightChanged',
        });
        return anyChange;
    }
    getPinnedTopTotalHeight() {
        return getTotalHeight(this.top);
    }
    getPinnedBottomTotalHeight() {
        return getTotalHeight(this.bottom);
    }
    getPinnedTopRowCount() {
        return this.top.size();
    }
    getPinnedBottomRowCount() {
        return this.bottom.size();
    }
    getPinnedTopRow(index) {
        return this.top.getByIndex(index);
    }
    getPinnedBottomRow(index) {
        return this.bottom.getByIndex(index);
    }
    getPinnedRowById(id, floating) {
        return this.getContainer(floating).getById(id);
    }
    forEachPinnedRow(floating, callback) {
        this.getContainer(floating).forEach(callback);
    }
    getPinnedState() {
        const buildState = (floating) => {
            const list = [];
            this.forEachPinnedRow(floating, (node) => list.push(node.pinnedSibling.id));
            return list;
        };
        return {
            top: buildState('top'),
            bottom: buildState('bottom'),
        };
    }
    setPinnedState(state) {
        this.forContainers((pinned, floating) => {
            for (const id of state[floating]) {
                const node = this.beans.rowModel.getRowNode(id);
                if (node) {
                    this.pinRow(node, floating);
                }
                else {
                    pinned.queue(id);
                }
            }
        });
    }
    getGrandTotalPinned() {
        return this._grandTotalPinned;
    }
    setGrandTotalPinned(value) {
        this._grandTotalPinned = value;
    }
    tryToEmptyQueues() {
        this.forContainers((pinned, container) => {
            const nodesToPin = new Set();
            pinned.forEachQueued((id) => {
                const node = this.beans.rowModel.getRowNode(id);
                if (node) {
                    nodesToPin.add(node);
                }
            });
            for (const node of nodesToPin) {
                pinned.unqueue(node.id);
                this.pinRow(node, container);
            }
        });
    }
    pinGrandTotalRow() {
        const { gos, beans, _grandTotalPinned: float } = this;
        const rowModel = beans.rowModel;
        if (!(0, gridOptionsUtils_1._isClientSideRowModel)(gos, rowModel))
            return;
        const sibling = rowModel.rootNode?.sibling;
        if (!sibling)
            return;
        const pinnedSibling = sibling.pinnedSibling;
        const container = pinnedSibling && this.findPinnedRowNode(pinnedSibling);
        if (!float) {
            // unpin
            if (!container)
                return;
            container.delete(pinnedSibling);
            _destroyRowNodeSibling(pinnedSibling);
        }
        else {
            // pin
            if (container && container.floating !== float) {
                // already have pinned grand total row, need to unpin first
                container.delete(pinnedSibling);
                _destroyRowNodeSibling(pinnedSibling);
            }
            if (!container || container.floating !== float) {
                const newPinnedSibling = _createPinnedSibling(beans, sibling, float);
                this.getContainer(float).add(newPinnedSibling);
            }
        }
    }
    onGridStylesChanges(e) {
        if (e.rowHeightChanged) {
            this.forContainers((container) => container.forEach((rowNode) => rowNode.setRowHeight(rowNode.rowHeight, true)));
        }
    }
    getContainer(floating) {
        return floating === 'top' ? this.top : this.bottom;
    }
    findPinnedRowNode(node) {
        if (this.top.has(node))
            return this.top;
        if (this.bottom.has(node))
            return this.bottom;
    }
    refreshRowPositions(floating) {
        const refreshAll = (pinned) => refreshRowPositions(this.beans, pinned);
        return floating == null ? this.forContainers(refreshAll) : refreshAll(this.getContainer(floating));
    }
    forContainers(fn) {
        fn(this.top, 'top');
        fn(this.bottom, 'bottom');
    }
    dispatchRowPinnedEvents(node) {
        this.eventSvc.dispatchEvent({ type: 'pinnedRowsChanged' });
        node?.dispatchRowEvent('rowPinned');
    }
}
exports.ManualPinnedRowModel = ManualPinnedRowModel;
function refreshRowPositions(beans, container) {
    let rowTop = 0;
    container.forEach((node, index) => {
        node.setRowTop(rowTop);
        if (node.rowHeightEstimated || node.rowHeight == null) {
            node.setRowHeight((0, gridOptionsUtils_1._getRowHeightForNode)(beans, node).height);
        }
        node.setRowIndex(index);
        rowTop += node.rowHeight;
    });
}
function _createPinnedSibling(beans, rowNode, floating) {
    // only create sibling node once, otherwise we have daemons and
    // the animate screws up with the daemons hanging around
    if (rowNode.pinnedSibling) {
        return rowNode.pinnedSibling;
    }
    const sibling = (0, rowNodeUtils_1._createRowNodeSibling)(rowNode, beans);
    sibling.setRowTop(null);
    sibling.setRowIndex(null);
    sibling.rowPinned = floating;
    const prefix = floating === 'top' ? rowNode_1.ROW_ID_PREFIX_TOP_PINNED : rowNode_1.ROW_ID_PREFIX_BOTTOM_PINNED;
    sibling.id = `${prefix}${floating}-${rowNode.id}`;
    // get both header and footer to reference each other as siblings
    sibling.pinnedSibling = rowNode;
    rowNode.pinnedSibling = sibling;
    return sibling;
}
/** Expect to be passed the pinned node, not the original node. Therefore `pinnedSibling` is the original. */
function _destroyRowNodeSibling(rowNode) {
    if (!rowNode.pinnedSibling) {
        return;
    }
    rowNode.rowPinned = null;
    rowNode.setRowTop(null);
    rowNode.setRowIndex(null);
    const mainNode = rowNode.pinnedSibling;
    rowNode.pinnedSibling = undefined;
    if (mainNode) {
        mainNode.pinnedSibling = undefined;
        mainNode.rowPinned = null;
    }
}
function removeGroupRows(set) {
    const rowsToRemove = new Set();
    set.forEach((node) => {
        if (node.group) {
            rowsToRemove.add(node);
        }
    });
    rowsToRemove.forEach((node) => set.delete(node));
}
function getSpannedRows(beans, rowNode, column) {
    const { rowSpanSvc } = beans;
    const isCellSpanning = (column && rowSpanSvc?.isCellSpanning(column, rowNode)) ?? false;
    if (column && isCellSpanning) {
        return rowSpanSvc?.getCellSpan(column, rowNode)?.spannedNodes;
    }
}
function getTotalHeight(container) {
    const size = container.size();
    if (size === 0)
        return 0;
    const node = container.getByIndex(size - 1);
    if (node === undefined)
        return 0;
    return node.rowTop + node.rowHeight;
}
function refreshCSRM({ gos, rowModel }) {
    if ((0, gridOptionsUtils_1._isClientSideRowModel)(gos, rowModel)) {
        rowModel.refreshModel({ step: 'map' });
    }
}


/***/ }),

/***/ 28188:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._shouldHidePinnedRows = exports.PinnedRows = void 0;
const gridOptionsUtils_1 = __webpack_require__(67274);
const array_1 = __webpack_require__(31502);
class PinnedRows {
    constructor(beans, floating) {
        this.beans = beans;
        this.floating = floating;
        /** Canonical set of pinned nodes */
        this.all = new Set();
        /**
         * Set of nodes that should currently be visible given the context of the grid.
         * This is currently used for hiding leaf nodes in pivot mode and filtered nodes.
         */
        this.visible = new Set();
        /** Ordering of nodes in the pinned area */
        this.order = [];
        /** IDs of nodes that need to be pinned once they are available from the row model (SSRM) */
        this.queued = new Set();
    }
    size() {
        return this.visible.size;
    }
    add(node) {
        const { all, visible, order } = this;
        if (all.has(node))
            return;
        all.add(node);
        visible.add(node);
        order.push(node);
        this.sort();
    }
    delete(item) {
        this.all.delete(item);
        this.visible.delete(item);
        this.queued.delete(item.id);
        (0, array_1._removeFromArray)(this.order, item);
    }
    has(item) {
        return this.visible.has(item);
    }
    forEach(fn) {
        this.order.forEach(fn);
    }
    getByIndex(i) {
        return this.order[i];
    }
    getById(id) {
        for (const node of this.visible) {
            if (node.id == id)
                return node;
        }
    }
    clear() {
        const { all, visible, order, queued } = this;
        all.clear();
        queued.clear();
        visible.clear();
        order.length = 0;
    }
    sort() {
        const { sortSvc, rowNodeSorter, gos } = this.beans;
        const sortOptions = sortSvc?.getSortOptions() ?? [];
        // first remove the grand total row so it doesn't get sorted
        const grandTotalNode = _removeGrandTotalRow(this.order);
        // pre-sort by existing row-index otherwise we'll fall back to order in which rows are pinned
        this.order.sort((a, b) => (a.pinnedSibling?.rowIndex ?? 0) - (b.pinnedSibling?.rowIndex ?? 0));
        this.order = rowNodeSorter?.doFullSort(this.order, sortOptions) ?? this.order;
        // post-sort re-insert the grand total row in the correct place
        if (!grandTotalNode)
            return;
        const grandTotalRow = (0, gridOptionsUtils_1._getGrandTotalRow)(gos);
        if (grandTotalRow === 'bottom' || grandTotalRow === 'pinnedBottom') {
            this.order.push(grandTotalNode);
        }
        else {
            this.order.unshift(grandTotalNode);
        }
    }
    hide(shouldHide) {
        const { all, visible } = this;
        all.forEach((node) => (shouldHide(node) ? visible.delete(node) : visible.add(node)));
        this.order = Array.from(visible);
        this.sort();
    }
    queue(id) {
        this.queued.add(id);
    }
    unqueue(id) {
        this.queued.delete(id);
    }
    forEachQueued(fn) {
        this.queued.forEach(fn);
    }
}
exports.PinnedRows = PinnedRows;
/**
 * Recursively check the parent node's `childrenAfterSort`.
 * For CSRM, this is currently the "least bad" way to check whether a node is
 * displayed after filtering, accounting for both normal filters and aggregate filters.
 */
function _isDisplayedAfterFilterCSRM(node) {
    if (node.level === -1)
        return true;
    const parent = node.parent;
    if (parent?.childrenAfterSort?.some((child) => child == node)) {
        return _isDisplayedAfterFilterCSRM(parent);
    }
    return false;
}
/** Expect to be passed the source node, not the pinned node */
function _shouldHidePinnedRows(beans, node) {
    const { gos, rowModel, filterManager } = beans;
    if ((0, gridOptionsUtils_1._isServerSideRowModel)(gos, rowModel)) {
        // For SSRM the best we can do for now is check if the node is in the cache.
        // This will let us display the node when a group is collapsed.
        return !rowModel.getRowNode(node.id);
    }
    if (filterManager?.isAnyFilterPresent()) {
        return !_isDisplayedAfterFilterCSRM(node);
    }
    if (gos.get('pivotMode')) {
        return !node.group;
    }
    return false;
}
exports._shouldHidePinnedRows = _shouldHidePinnedRows;
function _isNodeGrandTotal(node) {
    return !!node.footer && node.level === -1;
}
function _isPinnedNodeGrandTotal(node) {
    return !!node.pinnedSibling && _isNodeGrandTotal(node.pinnedSibling);
}
function _removeGrandTotalRow(order) {
    const index = order.findIndex(_isPinnedNodeGrandTotal);
    if (index > -1) {
        return order.splice(index, 1)?.[0];
    }
}


/***/ }),

/***/ 71879:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.forEachPinnedRow = exports.getPinnedBottomRow = exports.getPinnedTopRow = exports.getPinnedBottomRowCount = exports.getPinnedTopRowCount = void 0;
function getPinnedTopRowCount(beans) {
    return beans.pinnedRowModel?.getPinnedTopRowCount() ?? 0;
}
exports.getPinnedTopRowCount = getPinnedTopRowCount;
function getPinnedBottomRowCount(beans) {
    return beans.pinnedRowModel?.getPinnedBottomRowCount() ?? 0;
}
exports.getPinnedBottomRowCount = getPinnedBottomRowCount;
function getPinnedTopRow(beans, index) {
    return beans.pinnedRowModel?.getPinnedTopRow(index);
}
exports.getPinnedTopRow = getPinnedTopRow;
function getPinnedBottomRow(beans, index) {
    return beans.pinnedRowModel?.getPinnedBottomRow(index);
}
exports.getPinnedBottomRow = getPinnedBottomRow;
function forEachPinnedRow(beans, floating, callback) {
    return beans.pinnedRowModel?.forEachPinnedRow(floating, callback);
}
exports.forEachPinnedRow = forEachPinnedRow;


/***/ }),

/***/ 9294:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PinnedRowModel = void 0;
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const manualPinnedRowModel_1 = __webpack_require__(29596);
const staticPinnedRowModel_1 = __webpack_require__(31572);
class PinnedRowModel extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'pinnedRowModel';
    }
    postConstruct() {
        const { gos } = this;
        const initialiseRowModel = () => {
            const enableRowPinning = gos.get('enableRowPinning');
            const grandTotalRow = (0, gridOptionsUtils_1._getGrandTotalRow)(gos);
            const isGrandTotalRowPinned = grandTotalRow === 'pinnedBottom' || grandTotalRow === 'pinnedTop';
            const useManualPinnedRowModel = !!enableRowPinning || isGrandTotalRowPinned;
            const shouldDestroy = useManualPinnedRowModel
                ? this.inner instanceof staticPinnedRowModel_1.StaticPinnedRowModel
                : this.inner instanceof manualPinnedRowModel_1.ManualPinnedRowModel;
            if (this.inner && shouldDestroy) {
                this.destroyBean(this.inner);
            }
            if (shouldDestroy || !this.inner) {
                this.inner = this.createManagedBean(useManualPinnedRowModel ? new manualPinnedRowModel_1.ManualPinnedRowModel() : new staticPinnedRowModel_1.StaticPinnedRowModel());
            }
        };
        this.addManagedPropertyListeners(['enableRowPinning', 'grandTotalRow'], initialiseRowModel);
        initialiseRowModel();
    }
    reset() {
        return this.inner.reset();
    }
    isEmpty(container) {
        return this.inner.isEmpty(container);
    }
    isManual() {
        return this.inner.isManual();
    }
    isRowsToRender(container) {
        return this.inner.isRowsToRender(container);
    }
    pinRow(node, container, column) {
        return this.inner.pinRow(node, container, column);
    }
    ensureRowHeightsValid() {
        return this.inner.ensureRowHeightsValid();
    }
    getPinnedRowById(id, container) {
        return this.inner.getPinnedRowById(id, container);
    }
    getPinnedTopTotalHeight() {
        return this.inner.getPinnedTopTotalHeight();
    }
    getPinnedBottomTotalHeight() {
        return this.inner.getPinnedBottomTotalHeight();
    }
    getPinnedTopRowCount() {
        return this.inner.getPinnedTopRowCount();
    }
    getPinnedBottomRowCount() {
        return this.inner.getPinnedBottomRowCount();
    }
    getPinnedTopRow(index) {
        return this.inner.getPinnedTopRow(index);
    }
    getPinnedBottomRow(index) {
        return this.inner.getPinnedBottomRow(index);
    }
    forEachPinnedRow(container, callback) {
        return this.inner.forEachPinnedRow(container, callback);
    }
    getPinnedState() {
        return this.inner.getPinnedState();
    }
    setPinnedState(state) {
        return this.inner.setPinnedState(state);
    }
    setGrandTotalPinned(value) {
        return this.inner.setGrandTotalPinned(value);
    }
    getGrandTotalPinned() {
        return this.inner.getGrandTotalPinned();
    }
}
exports.PinnedRowModel = PinnedRowModel;


/***/ }),

/***/ 15423:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PinnedRowModule = void 0;
const version_1 = __webpack_require__(97205);
const manualPinnedRow_css_GENERATED_1 = __webpack_require__(40436);
const pinnedRowApi_1 = __webpack_require__(71879);
const pinnedRowModel_1 = __webpack_require__(9294);
/**
 * @feature Rows -> Row Pinning
 * @gridOption enableRowPinning, isRowPinnable, isRowPinned, pinnedTopRowData, pinnedBottomRowData
 */
exports.PinnedRowModule = {
    moduleName: 'PinnedRow',
    version: version_1.VERSION,
    beans: [pinnedRowModel_1.PinnedRowModel],
    css: [manualPinnedRow_css_GENERATED_1.manualPinnedRowCSS],
    apiFunctions: {
        getPinnedTopRowCount: pinnedRowApi_1.getPinnedTopRowCount,
        getPinnedBottomRowCount: pinnedRowApi_1.getPinnedBottomRowCount,
        getPinnedTopRow: pinnedRowApi_1.getPinnedTopRow,
        getPinnedBottomRow: pinnedRowApi_1.getPinnedBottomRow,
        forEachPinnedRow: pinnedRowApi_1.forEachPinnedRow,
    },
    icons: {
        rowPin: 'pin',
        rowPinTop: 'pinned-top',
        rowPinBottom: 'pinned-bottom',
        rowUnpin: 'un-pin',
    },
};


/***/ }),

/***/ 78638:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._getNodesInRangeForSelection = exports._isManualPinnedRow = void 0;
/** Whether the given node is pinned manually to the top or bottom container */
function _isManualPinnedRow(rowNode) {
    // `rowPinned` is only truthy for rows actually in the pinned containers.
    // `pinnedSibling` is only defined when the row has been pinned manually.
    return !!(rowNode.rowPinned && rowNode.pinnedSibling);
}
exports._isManualPinnedRow = _isManualPinnedRow;
function _getNodesInRangeForSelection(rowModel, float, start, end) {
    const isTop = float === 'top';
    if (!start) {
        return _getNodesInRangeForSelection(rowModel, float, isTop ? rowModel.getPinnedTopRow(0) : rowModel.getPinnedBottomRow(0), end);
    }
    if (!end) {
        const count = isTop ? rowModel.getPinnedTopRowCount() : rowModel.getPinnedBottomRowCount();
        return _getNodesInRangeForSelection(rowModel, float, start, isTop ? rowModel.getPinnedTopRow(count - 1) : rowModel.getPinnedBottomRow(count - 1));
    }
    let started = false;
    let finished = false;
    const range = [];
    rowModel.forEachPinnedRow(float, (node) => {
        if (node === start && !started) {
            started = true;
            range.push(node);
            return;
        }
        if (started && node === end) {
            finished = true;
            range.push(node);
            return;
        }
        if (started && !finished) {
            range.push(node);
        }
    });
    return range;
}
exports._getNodesInRangeForSelection = _getNodesInRangeForSelection;


/***/ }),

/***/ 31572:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StaticPinnedRowModel = void 0;
const beanStub_1 = __webpack_require__(68731);
const rowNode_1 = __webpack_require__(3373);
const gridOptionsUtils_1 = __webpack_require__(67274);
const logging_1 = __webpack_require__(47764);
class StaticPinnedRowModel extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.nextId = 0;
        this.pinnedTopRows = { cache: {}, order: [] };
        this.pinnedBottomRows = { cache: {}, order: [] };
    }
    postConstruct() {
        const gos = this.gos;
        this.setPinnedRowData(gos.get('pinnedTopRowData'), 'top');
        this.setPinnedRowData(gos.get('pinnedBottomRowData'), 'bottom');
        this.addManagedPropertyListener('pinnedTopRowData', (e) => this.setPinnedRowData(e.currentValue, 'top'));
        this.addManagedPropertyListener('pinnedBottomRowData', (e) => this.setPinnedRowData(e.currentValue, 'bottom'));
        this.addManagedEventListeners({ gridStylesChanged: this.onGridStylesChanges.bind(this) });
    }
    reset() {
        // Not implemented for static pinned row model
    }
    isEmpty(floating) {
        return this.getCache(floating).order.length === 0;
    }
    isRowsToRender(floating) {
        return !this.isEmpty(floating);
    }
    isManual() {
        return false;
    }
    pinRow(_node, _container) {
        // Not implemented for static pinned row model
    }
    onGridStylesChanges(e) {
        if (e.rowHeightChanged) {
            const estimateRowHeight = (rowNode) => {
                rowNode.setRowHeight(rowNode.rowHeight, true);
            };
            forEach(this.pinnedBottomRows, estimateRowHeight);
            forEach(this.pinnedTopRows, estimateRowHeight);
        }
    }
    ensureRowHeightsValid() {
        let anyChange = false;
        let rowTop = 0;
        const updateRowHeight = (rowNode) => {
            if (rowNode.rowHeightEstimated) {
                const rowHeight = (0, gridOptionsUtils_1._getRowHeightForNode)(this.beans, rowNode);
                rowNode.setRowTop(rowTop);
                rowNode.setRowHeight(rowHeight.height);
                rowTop += rowHeight.height;
                anyChange = true;
            }
        };
        forEach(this.pinnedBottomRows, updateRowHeight);
        rowTop = 0;
        forEach(this.pinnedTopRows, updateRowHeight);
        this.eventSvc.dispatchEvent({
            type: 'pinnedHeightChanged',
        });
        return anyChange;
    }
    setPinnedRowData(rowData, floating) {
        this.updateNodesFromRowData(rowData, floating);
        this.eventSvc.dispatchEvent({
            type: 'pinnedRowDataChanged',
        });
    }
    /**
     * Updates existing RowNode instances and creates new ones if necessary
     *
     * Setting data as `undefined` will clear row nodes
     */
    updateNodesFromRowData(allData, floating) {
        const nodes = this.getCache(floating);
        if (allData === undefined) {
            nodes.order.length = 0;
            nodes.cache = {};
            return;
        }
        const getRowId = (0, gridOptionsUtils_1._getRowIdCallback)(this.gos);
        const idPrefix = floating === 'top' ? rowNode_1.ROW_ID_PREFIX_TOP_PINNED : rowNode_1.ROW_ID_PREFIX_BOTTOM_PINNED;
        // We'll want to remove all nodes that aren't matched to data
        const nodesToRemove = new Set(nodes.order);
        // Data that matches based on ID can nonetheless still appear in a different order than before
        const newOrder = [];
        // Used for catching duplicate IDs/rows within `allData` itself
        const dataIds = new Set();
        let nextRowTop = 0;
        let i = -1;
        for (const data of allData) {
            const id = getRowId?.({ data, level: 0, rowPinned: floating }) ?? idPrefix + this.nextId++;
            if (dataIds.has(id)) {
                (0, logging_1._warn)(96, { id, data });
                continue;
            }
            i++;
            dataIds.add(id);
            newOrder.push(id);
            const existingNode = getById(nodes, id);
            if (existingNode !== undefined) {
                if (existingNode.data !== data) {
                    existingNode.updateData(data);
                }
                nextRowTop += this.setRowTopAndRowIndex(existingNode, nextRowTop, i);
                // existing nodes that are re-used/updated shouldn't be deleted
                nodesToRemove.delete(id);
            }
            else {
                // new node
                const rowNode = new rowNode_1.RowNode(this.beans);
                rowNode.id = id;
                rowNode.data = data;
                rowNode.rowPinned = floating;
                nextRowTop += this.setRowTopAndRowIndex(rowNode, nextRowTop, i);
                nodes.cache[id] = rowNode;
                nodes.order.push(id);
            }
        }
        nodesToRemove.forEach((id) => {
            getById(nodes, id)?.clearRowTopAndRowIndex();
            delete nodes.cache[id];
        });
        nodes.order = newOrder;
    }
    setRowTopAndRowIndex(rowNode, rowTop, rowIndex) {
        rowNode.setRowTop(rowTop);
        rowNode.setRowHeight((0, gridOptionsUtils_1._getRowHeightForNode)(this.beans, rowNode).height);
        rowNode.setRowIndex(rowIndex);
        return rowNode.rowHeight;
    }
    getPinnedTopTotalHeight() {
        return getTotalHeight(this.pinnedTopRows);
    }
    getPinnedBottomTotalHeight() {
        return getTotalHeight(this.pinnedBottomRows);
    }
    getPinnedTopRowCount() {
        return getSize(this.pinnedTopRows);
    }
    getPinnedBottomRowCount() {
        return getSize(this.pinnedBottomRows);
    }
    getPinnedTopRow(index) {
        return getByIndex(this.pinnedTopRows, index);
    }
    getPinnedBottomRow(index) {
        return getByIndex(this.pinnedBottomRows, index);
    }
    getPinnedRowById(id, floating) {
        return getById(this.getCache(floating), id);
    }
    forEachPinnedRow(floating, callback) {
        return forEach(this.getCache(floating), callback);
    }
    getCache(floating) {
        return floating === 'top' ? this.pinnedTopRows : this.pinnedBottomRows;
    }
    getPinnedState() {
        // Not implemented for static pinned row model
        return { top: [], bottom: [] };
    }
    setPinnedState() {
        // Not implemented for static pinned row model
    }
    getGrandTotalPinned() {
        // Not implemented for static pinned row model
        return;
    }
    setGrandTotalPinned() {
        // Not implemented for static pinned row model
    }
}
exports.StaticPinnedRowModel = StaticPinnedRowModel;
function getTotalHeight(rowNodes) {
    const size = getSize(rowNodes);
    if (size === 0) {
        return 0;
    }
    const node = getByIndex(rowNodes, size - 1);
    if (node === undefined) {
        return 0;
    }
    return node.rowTop + node.rowHeight;
}
function getById(cache, id) {
    return cache.cache[id];
}
function getByIndex(cache, i) {
    return getById(cache, cache.order[i]);
}
function forEach(cache, callback) {
    cache.order.forEach((id, index) => {
        const node = getById(cache, id);
        node && callback(node, index);
    });
}
function getSize(cache) {
    return cache.order.length;
}


/***/ }),

/***/ 40920:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._GET_ALL_GRID_OPTIONS = exports._FUNCTION_GRID_OPTIONS = exports._BOOLEAN_GRID_OPTIONS = exports._BOOLEAN_MIXED_GRID_OPTIONS = exports._NUMBER_GRID_OPTIONS = void 0;
/**
 * These keys are used for validating properties supplied on a gridOptions object, and for code generation.
 * If you change the properties on the gridOptions interface, you *must* update this file as well to be consistent.
 */
// only used internally
const STRING_GRID_OPTIONS = [
    'overlayLoadingTemplate',
    'overlayNoRowsTemplate',
    'gridId',
    'quickFilterText',
    'rowModelType',
    'editType',
    'domLayout',
    'clipboardDelimiter',
    'rowGroupPanelShow',
    'multiSortKey',
    'pivotColumnGroupTotals',
    'pivotRowTotals',
    'pivotPanelShow',
    'fillHandleDirection',
    'groupDisplayType',
    'treeDataDisplayType',
    'treeDataChildrenField',
    'treeDataParentIdField',
    'colResizeDefault',
    'tooltipTrigger',
    'serverSidePivotResultFieldSeparator',
    'columnMenu',
    'tooltipShowMode',
    'invalidEditValueMode',
    'grandTotalRow',
    'themeCssLayer',
    'findSearchValue',
    'styleNonce',
    'renderingMode',
];
// only used internally
const OBJECT_GRID_OPTIONS = [
    'components',
    'rowStyle',
    'context',
    'autoGroupColumnDef',
    'localeText',
    'icons',
    'datasource',
    'dragAndDropImageComponentParams',
    'serverSideDatasource',
    'viewportDatasource',
    'groupRowRendererParams',
    'aggFuncs',
    'fullWidthCellRendererParams',
    'defaultColGroupDef',
    'defaultColDef',
    'defaultCsvExportParams',
    'defaultExcelExportParams',
    'columnTypes',
    'rowClassRules',
    'detailCellRendererParams',
    'loadingCellRendererParams',
    'loadingOverlayComponentParams',
    'noRowsOverlayComponentParams',
    'popupParent',
    'themeStyleContainer',
    'statusBar',
    'chartThemeOverrides',
    'customChartThemes',
    'chartToolPanelsDef',
    'dataTypeDefinitions',
    'advancedFilterParent',
    'advancedFilterBuilderParams',
    'initialState',
    'autoSizeStrategy',
    'selectionColumnDef',
    'findOptions',
    'filterHandlers',
];
// only used internally
const ARRAY_GRID_OPTIONS = [
    'sortingOrder',
    'alignedGrids',
    'rowData',
    'columnDefs',
    'excelStyles',
    'pinnedTopRowData',
    'pinnedBottomRowData',
    'chartThemes',
    'rowClass',
    'paginationPageSizeSelector',
];
// Used in validations to check type of number inputs
exports._NUMBER_GRID_OPTIONS = [
    'rowHeight',
    'detailRowHeight',
    'rowBuffer',
    'headerHeight',
    'groupHeaderHeight',
    'groupLockGroupColumns',
    'floatingFiltersHeight',
    'pivotHeaderHeight',
    'pivotGroupHeaderHeight',
    'groupDefaultExpanded',
    'pivotDefaultExpanded',
    'viewportRowModelPageSize',
    'viewportRowModelBufferSize',
    'autoSizePadding',
    'maxBlocksInCache',
    'maxConcurrentDatasourceRequests',
    'tooltipShowDelay',
    'tooltipHideDelay',
    'cacheOverflowSize',
    'paginationPageSize',
    'cacheBlockSize',
    'infiniteInitialRowCount',
    'serverSideInitialRowCount',
    'scrollbarWidth',
    'asyncTransactionWaitMillis',
    'blockLoadDebounceMillis',
    'keepDetailRowsCount',
    'undoRedoCellEditingLimit',
    'cellFlashDuration',
    'cellFadeDuration',
    'tabIndex',
    'pivotMaxGeneratedColumns',
    'rowDragInsertDelay',
];
// If property does not fit above, i.e union that should not be coerced.
// used internally
const OTHER_GRID_OPTIONS = ['theme', 'rowSelection'];
// Used by Angular to support the user setting these
// as plain HTML attributes and us correctly mapping that to true
// These are all of type boolean | something else
exports._BOOLEAN_MIXED_GRID_OPTIONS = [
    'cellSelection',
    'sideBar',
    'rowNumbers',
    'suppressGroupChangesColumnVisibility',
    'groupAggFiltering',
    'suppressStickyTotalRow',
    'groupHideParentOfSingleChild',
    'enableRowPinning',
];
// Used in validations to check type of pure boolean inputs
exports._BOOLEAN_GRID_OPTIONS = [
    'loadThemeGoogleFonts',
    'suppressMakeColumnVisibleAfterUnGroup',
    'suppressRowClickSelection',
    'suppressCellFocus',
    'suppressHeaderFocus',
    'suppressHorizontalScroll',
    'groupSelectsChildren',
    'alwaysShowHorizontalScroll',
    'alwaysShowVerticalScroll',
    'debug',
    'enableBrowserTooltips',
    'enableCellExpressions',
    'groupSuppressBlankHeader',
    'suppressMenuHide',
    'suppressRowDeselection',
    'unSortIcon',
    'suppressMultiSort',
    'alwaysMultiSort',
    'singleClickEdit',
    'suppressLoadingOverlay',
    'suppressNoRowsOverlay',
    'suppressAutoSize',
    'skipHeaderOnAutoSize',
    'suppressColumnMoveAnimation',
    'suppressMoveWhenColumnDragging',
    'suppressMovableColumns',
    'suppressFieldDotNotation',
    'enableRangeSelection',
    'enableRangeHandle',
    'enableFillHandle',
    'suppressClearOnFillReduction',
    'deltaSort',
    'suppressTouch',
    'allowContextMenuWithControlKey',
    'suppressContextMenu',
    'suppressDragLeaveHidesColumns',
    'suppressRowGroupHidesColumns',
    'suppressMiddleClickScrolls',
    'suppressPreventDefaultOnMouseWheel',
    'suppressCopyRowsToClipboard',
    'copyHeadersToClipboard',
    'copyGroupHeadersToClipboard',
    'pivotMode',
    'suppressAggFuncInHeader',
    'suppressColumnVirtualisation',
    'alwaysAggregateAtRootLevel',
    'suppressFocusAfterRefresh',
    'functionsReadOnly',
    'animateRows',
    'groupSelectsFiltered',
    'groupRemoveSingleChildren',
    'groupRemoveLowestSingleChildren',
    'enableRtl',
    'enableCellSpan',
    'suppressClickEdit',
    'rowDragEntireRow',
    'rowDragManaged',
    'suppressRowDrag',
    'suppressMoveWhenRowDragging',
    'rowDragMultiRow',
    'enableGroupEdit',
    'embedFullWidthRows',
    'suppressPaginationPanel',
    'groupHideOpenParents',
    'groupAllowUnbalanced',
    'pagination',
    'paginationAutoPageSize',
    'suppressScrollOnNewData',
    'suppressScrollWhenPopupsAreOpen',
    'purgeClosedRowNodes',
    'cacheQuickFilter',
    'includeHiddenColumnsInQuickFilter',
    'ensureDomOrder',
    'accentedSort',
    'suppressChangeDetection',
    'valueCache',
    'valueCacheNeverExpires',
    'aggregateOnlyChangedColumns',
    'suppressAnimationFrame',
    'suppressExcelExport',
    'suppressCsvExport',
    'includeHiddenColumnsInAdvancedFilter',
    'suppressMultiRangeSelection',
    'enterNavigatesVerticallyAfterEdit',
    'enterNavigatesVertically',
    'suppressPropertyNamesCheck',
    'rowMultiSelectWithClick',
    'suppressRowHoverHighlight',
    'suppressRowTransform',
    'suppressClipboardPaste',
    'suppressLastEmptyLineOnPaste',
    'enableCharts',
    'suppressMaintainUnsortedOrder',
    'enableCellTextSelection',
    'suppressBrowserResizeObserver',
    'suppressMaxRenderedRowRestriction',
    'excludeChildrenWhenTreeDataFiltering',
    'tooltipMouseTrack',
    'tooltipInteraction',
    'keepDetailRows',
    'paginateChildRows',
    'preventDefaultOnContextMenu',
    'undoRedoCellEditing',
    'allowDragFromColumnsToolPanel',
    'pivotSuppressAutoColumn',
    'suppressExpandablePivotGroups',
    'debounceVerticalScrollbar',
    'detailRowAutoHeight',
    'serverSideSortAllLevels',
    'serverSideEnableClientSideSort',
    'serverSideOnlyRefreshFilteredGroups',
    'suppressAggFilteredOnly',
    'showOpenedGroup',
    'suppressClipboardApi',
    'suppressModelUpdateAfterUpdateTransaction',
    'stopEditingWhenCellsLoseFocus',
    'groupMaintainOrder',
    'columnHoverHighlight',
    'readOnlyEdit',
    'suppressRowVirtualisation',
    'enableCellEditingOnBackspace',
    'resetRowDataOnUpdate',
    'removePivotHeaderRowWhenSingleValueColumn',
    'suppressCopySingleCellRanges',
    'suppressGroupRowsSticky',
    'suppressCutToClipboard',
    'rowGroupPanelSuppressSort',
    'allowShowChangeAfterFilter',
    'enableAdvancedFilter',
    'masterDetail',
    'treeData',
    'reactiveCustomComponents',
    'applyQuickFilterBeforePivotOrAgg',
    'suppressServerSideFullWidthLoadingRow',
    'suppressAdvancedFilterEval',
    'loading',
    'maintainColumnOrder',
    'enableStrictPivotColumnOrder',
    'suppressSetFilterByDefault',
    'enableFilterHandlers',
];
// Used in example generation
exports._FUNCTION_GRID_OPTIONS = [
    'doesExternalFilterPass',
    'processPivotResultColDef',
    'processPivotResultColGroupDef',
    'getBusinessKeyForNode',
    'isRowSelectable',
    'rowDragText',
    'groupRowRenderer',
    'dragAndDropImageComponent',
    'fullWidthCellRenderer',
    'loadingCellRenderer',
    'loadingOverlayComponent',
    'noRowsOverlayComponent',
    'detailCellRenderer',
    'quickFilterParser',
    'quickFilterMatcher',
    'getLocaleText',
    'isExternalFilterPresent',
    'getRowHeight',
    'getRowClass',
    'getRowStyle',
    'getFullRowEditValidationErrors',
    'getContextMenuItems',
    'getMainMenuItems',
    'processRowPostCreate',
    'processCellForClipboard',
    'getGroupRowAgg',
    'isFullWidthRow',
    'sendToClipboard',
    'focusGridInnerElement',
    'navigateToNextHeader',
    'tabToNextHeader',
    'navigateToNextCell',
    'tabToNextCell',
    'processCellFromClipboard',
    'getDocument',
    'postProcessPopup',
    'getChildCount',
    'getDataPath',
    'isRowMaster',
    'postSortRows',
    'processHeaderForClipboard',
    'processUnpinnedColumns',
    'processGroupHeaderForClipboard',
    'paginationNumberFormatter',
    'processDataFromClipboard',
    'getServerSideGroupKey',
    'isServerSideGroup',
    'createChartContainer',
    'getChartToolbarItems',
    'fillOperation',
    'isApplyServerSideTransaction',
    'getServerSideGroupLevelParams',
    'isServerSideGroupOpenByDefault',
    'isGroupOpenByDefault',
    'initialGroupOrderComparator',
    'loadingCellRendererSelector',
    'getRowId',
    'chartMenuItems',
    'groupTotalRow',
    'alwaysPassFilter',
    'isRowPinnable',
    'isRowPinned',
    'isRowValidDropPosition',
];
// angular generation of component
// validation of properties
// Vue Runtime prop changes
// example generation
// We define as a callback to help with tree shaking (esbuild)
const _GET_ALL_GRID_OPTIONS = () => [
    ...ARRAY_GRID_OPTIONS,
    ...OBJECT_GRID_OPTIONS,
    ...STRING_GRID_OPTIONS,
    ...exports._NUMBER_GRID_OPTIONS,
    ...exports._FUNCTION_GRID_OPTIONS,
    ...exports._BOOLEAN_GRID_OPTIONS,
    ...exports._BOOLEAN_MIXED_GRID_OPTIONS,
    ...OTHER_GRID_OPTIONS,
];
exports._GET_ALL_GRID_OPTIONS = _GET_ALL_GRID_OPTIONS;


/***/ }),

/***/ 8829:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._PUBLIC_EVENT_HANDLERS_MAP = void 0;
const eventTypes_1 = __webpack_require__(73080);
const gridOptionsUtils_1 = __webpack_require__(67274);
/** Map of public events to their handler names in GridOptions */
exports._PUBLIC_EVENT_HANDLERS_MAP = eventTypes_1._PUBLIC_EVENTS.reduce((mem, ev) => {
    mem[ev] = (0, gridOptionsUtils_1._getCallbackForEvent)(ev);
    return mem;
}, {});


/***/ }),

/***/ 61331:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AriaAnnouncementService = void 0;
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const aria_1 = __webpack_require__(95230);
const dom_1 = __webpack_require__(33507);
const function_1 = __webpack_require__(92043);
class AriaAnnouncementService extends beanStub_1.BeanStub {
    constructor() {
        super();
        this.beanName = 'ariaAnnounce';
        this.descriptionContainer = null;
        this.pendingAnnouncements = new Map();
        this.lastAnnouncement = '';
        this.updateAnnouncement = (0, function_1._debounce)(this, this.updateAnnouncement.bind(this), 200);
    }
    postConstruct() {
        const beans = this.beans;
        const eDocument = (0, gridOptionsUtils_1._getDocument)(beans);
        const div = (this.descriptionContainer = eDocument.createElement('div'));
        div.classList.add('ag-aria-description-container');
        (0, aria_1._setAriaLive)(div, 'polite');
        (0, aria_1._setAriaRelevant)(div, 'additions text');
        (0, aria_1._setAriaAtomic)(div, true);
        beans.eGridDiv.appendChild(div);
    }
    /**
     * @param key used for debouncing calls
     */
    announceValue(value, key) {
        this.pendingAnnouncements.set(key, value);
        this.updateAnnouncement();
    }
    updateAnnouncement() {
        if (!this.descriptionContainer) {
            return;
        }
        const value = Array.from(this.pendingAnnouncements.values()).join('. ');
        this.pendingAnnouncements.clear();
        // screen readers announce a change in content, so we set it to an empty value
        // and then use a setTimeout to force the Screen Reader announcement
        this.descriptionContainer.textContent = '';
        setTimeout(() => {
            this.handleAnnouncementUpdate(value);
        }, 50);
    }
    handleAnnouncementUpdate(value) {
        if (!this.isAlive() || !this.descriptionContainer) {
            return;
        }
        let valueToAnnounce = value;
        // if the value is null or an empty string, or if it's a string
        // that only contains spaces and dots, it should not be announced
        if (valueToAnnounce == null || valueToAnnounce.replace(/[ .]/g, '') == '') {
            this.lastAnnouncement = '';
            return;
        }
        // if the announcement is the same (static announcement)
        // we add a zero-width space at the end to force screen readers to announce
        if (this.lastAnnouncement === valueToAnnounce) {
            valueToAnnounce = `${valueToAnnounce}\u200B`;
        }
        this.lastAnnouncement = valueToAnnounce;
        this.descriptionContainer.textContent = valueToAnnounce;
    }
    destroy() {
        super.destroy();
        const { descriptionContainer } = this;
        if (descriptionContainer) {
            (0, dom_1._clearElement)(descriptionContainer);
            descriptionContainer.parentElement?.removeChild(descriptionContainer);
        }
        this.descriptionContainer = null;
        this.pendingAnnouncements.clear();
    }
}
exports.AriaAnnouncementService = AriaAnnouncementService;


/***/ }),

/***/ 73433:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AriaModule = void 0;
const version_1 = __webpack_require__(97205);
const ariaAnnouncementService_1 = __webpack_require__(61331);
/**
 * @feature Interactivity -> Accessibility (ARIA)
 */
exports.AriaModule = {
    moduleName: 'Aria',
    version: version_1.VERSION,
    beans: [ariaAnnouncementService_1.AriaAnnouncementService],
};


/***/ }),

/***/ 8763:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AutoWidthCalculator = void 0;
const beanStub_1 = __webpack_require__(68731);
class AutoWidthCalculator extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'autoWidthCalc';
    }
    postConstruct() {
        this.beans.ctrlsSvc.whenReady(this, (p) => {
            this.centerRowContainerCtrl = p.center;
        });
    }
    // this is the trick: we create a dummy container and clone all the cells
    // into the dummy, then check the dummy's width. then destroy the dummy
    // as we don't need it any more.
    // drawback: only the cells visible on the screen are considered
    getPreferredWidthForColumn(column, skipHeader) {
        const eHeaderCell = this.getHeaderCellForColumn(column);
        // cell isn't visible
        if (!eHeaderCell) {
            return -1;
        }
        const elements = this.beans.rowRenderer.getAllCellsNotSpanningForColumn(column);
        if (!skipHeader) {
            // we only consider the lowest level cell, not the group cell. in 99% of the time, this
            // will be enough. if we consider groups, then it gets too complicated for what it's worth,
            // as the groups can span columns and this class only considers one column at a time.
            elements.push(eHeaderCell);
        }
        return this.getPreferredWidthForElements(elements);
    }
    getPreferredWidthForColumnGroup(columnGroup) {
        const eHeaderCell = this.getHeaderCellForColumn(columnGroup);
        if (!eHeaderCell) {
            return -1;
        }
        return this.getPreferredWidthForElements([eHeaderCell]);
    }
    getPreferredWidthForElements(elements, extraPadding) {
        // this element has to be a form, otherwise form elements within a cell
        // will be validated while being cloned. This can cause issues such as
        // radio buttons being reset and losing their values.
        const eDummyContainer = document.createElement('form');
        // position fixed, so it isn't restricted to the boundaries of the parent
        eDummyContainer.style.position = 'fixed';
        // we put the dummy into the body container, so it will inherit all the
        // css styles that the real cells are inheriting
        const eBodyContainer = this.centerRowContainerCtrl.eContainer;
        elements.forEach((el) => this.cloneItemIntoDummy(el, eDummyContainer));
        // only append the dummyContainer to the DOM after it contains all the necessary items
        eBodyContainer.appendChild(eDummyContainer);
        // at this point, all the clones are lined up vertically with natural widths. the dummy
        // container will have a width wide enough just to fit the largest.
        const dummyContainerWidth = eDummyContainer.offsetWidth;
        // we are finished with the dummy container, so get rid of it
        eBodyContainer.removeChild(eDummyContainer);
        // we add padding as I found sometimes the gui still put '...' after some of the texts. so the
        // user can configure the grid to add a few more pixels after the calculated width
        extraPadding = extraPadding ?? this.gos.get('autoSizePadding');
        return dummyContainerWidth + extraPadding;
    }
    getHeaderCellForColumn(column) {
        let element = null;
        this.beans.ctrlsSvc.getHeaderRowContainerCtrls().forEach((container) => {
            const res = container.getHtmlElementForColumnHeader(column);
            if (res != null) {
                element = res;
            }
        });
        return element;
    }
    cloneItemIntoDummy(eCell, eDummyContainer) {
        // make a deep clone of the cell
        const eCellClone = eCell.cloneNode(true);
        // the original has a fixed width, we remove this to allow the natural width based on content
        eCellClone.style.width = '';
        // the original has position = absolute, we need to remove this so it's positioned normally
        eCellClone.style.position = 'static';
        eCellClone.style.left = '';
        // we put the cell into a containing div, as otherwise the cells would just line up
        // on the same line, standard flow layout, by putting them into divs, they are laid
        // out one per line
        const eCloneParent = document.createElement('div');
        const eCloneParentClassList = eCloneParent.classList;
        const isHeader = ['ag-header-cell', 'ag-header-group-cell'].some((cls) => eCellClone.classList.contains(cls));
        if (isHeader) {
            eCloneParentClassList.add('ag-header', 'ag-header-row');
            eCloneParent.style.position = 'static';
        }
        else {
            eCloneParentClassList.add('ag-row');
        }
        // find parent using classes (headers have ag-header-cell, rows have ag-row), and copy classes from it.
        // if we didn't do this, things like ag-row-level-2 would be missing if present, which sets indents
        // onto group items.
        let pointer = eCell.parentElement;
        while (pointer) {
            const isRow = ['ag-header-row', 'ag-row'].some((cls) => pointer.classList.contains(cls));
            if (isRow) {
                for (let i = 0; i < pointer.classList.length; i++) {
                    const item = pointer.classList[i];
                    // we skip ag-row-position-absolute, as this has structural CSS applied that stops the
                    // element from fitting into it's parent, and we need the element to stretch the parent
                    // as we are measuring the parents width
                    if (item != 'ag-row-position-absolute') {
                        eCloneParentClassList.add(item);
                    }
                }
                break;
            }
            pointer = pointer.parentElement;
        }
        // the twig on the branch, the branch on the tree, the tree in the hole,
        // the hole in the bog, the bog in the clone, the clone in the parent,
        // the parent in the dummy, and the dummy down in the vall-e-ooo, OOOOOOOOO! Oh row the rattling bog....
        eCloneParent.appendChild(eCellClone);
        eDummyContainer.appendChild(eCloneParent);
    }
}
exports.AutoWidthCalculator = AutoWidthCalculator;


/***/ }),

/***/ 40447:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AutoWidthModule = void 0;
const version_1 = __webpack_require__(97205);
const autoWidthCalculator_1 = __webpack_require__(8763);
/**
 * @internal
 */
exports.AutoWidthModule = {
    moduleName: 'AutoWidth',
    version: version_1.VERSION,
    beans: [autoWidthCalculator_1.AutoWidthCalculator],
};


/***/ }),

/***/ 32308:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CellComp = void 0;
const gridOptionsUtils_1 = __webpack_require__(67274);
const localeUtils_1 = __webpack_require__(87230);
const dom_1 = __webpack_require__(33507);
const generic_1 = __webpack_require__(34422);
const string_1 = __webpack_require__(37766);
const logging_1 = __webpack_require__(47764);
const component_1 = __webpack_require__(78020);
const cssClassManager_1 = __webpack_require__(21734);
class CellComp extends component_1.Component {
    constructor(beans, cellCtrl, printLayout, eRow, editingCell) {
        super();
        this.cellCtrl = cellCtrl;
        // every time we go into edit mode, or back again, this gets incremented.
        // it's the components way of dealing with the async nature of framework components,
        // so if a framework component takes a while to be created, we know if the object
        // is still relevant when creating is finished. eg we could click edit / un-edit 20
        // times before the first React edit component comes back - we should discard
        // the first 19.
        this.rendererVersion = 0;
        this.editorVersion = 0;
        this.beans = beans;
        this.gos = beans.gos;
        this.column = cellCtrl.column;
        this.rowNode = cellCtrl.rowNode;
        this.eRow = eRow;
        const cellDiv = (0, dom_1._createElement)({
            tag: 'div',
            role: cellCtrl.getCellAriaRole(),
            attrs: {
                'comp-id': `${this.getCompId()}`,
                'col-id': cellCtrl.column.colIdSanitised,
            },
        });
        this.eCell = cellDiv;
        let wrapperDiv;
        // if doing a cell span, need to wrap the cell in a container with background-color to avoid
        // transparent cells displaying row lines
        if (cellCtrl.isCellSpanning()) {
            wrapperDiv = (0, dom_1._createElement)({
                tag: 'div',
                cls: 'ag-spanned-cell-wrapper',
                role: 'presentation',
            });
            wrapperDiv.appendChild(cellDiv);
            this.setTemplateFromElement(wrapperDiv);
        }
        else {
            this.setTemplateFromElement(cellDiv);
        }
        this.cellCssManager = new cssClassManager_1.CssClassManager(() => cellDiv);
        this.forceWrapper = cellCtrl.isForceWrapper();
        this.refreshWrapper(false);
        const compProxy = {
            toggleCss: (cssClassName, on) => this.cellCssManager.toggleCss(cssClassName, on),
            setUserStyles: (styles) => (0, dom_1._addStylesToElement)(cellDiv, styles),
            getFocusableElement: () => cellDiv,
            setIncludeSelection: (include) => (this.includeSelection = include),
            setIncludeRowDrag: (include) => (this.includeRowDrag = include),
            setIncludeDndSource: (include) => (this.includeDndSource = include),
            setRenderDetails: (compDetails, valueToDisplay, force) => this.setRenderDetails(compDetails, valueToDisplay, force),
            setEditDetails: (compDetails, popup, position) => this.setEditDetails(compDetails, popup, position),
            getCellEditor: () => this.cellEditor || null,
            getCellRenderer: () => this.cellRenderer || null,
            getParentOfValue: () => this.getParentOfValue(),
            refreshEditStyles: (editing, isPopup) => this.refreshEditStyles(editing, isPopup),
        };
        cellCtrl.setComp(compProxy, cellDiv, wrapperDiv, this.eCellWrapper, printLayout, editingCell, undefined);
    }
    getParentOfValue() {
        // if not editing, and using wrapper, then value goes in eCellValue
        // if editing, and using wrapper, value (cell editor) goes in eCellWrapper
        // if editing or rendering, and not using wrapper, value (or comp) is directly inside cell
        return this.eCellValue ?? this.eCellWrapper ?? this.eCell;
    }
    setRenderDetails(compDetails, valueToDisplay, forceNewCellRendererInstance) {
        // this can happen if the users asks for the cell to refresh, but we are not showing the vale as we are editing
        const isInlineEditing = this.cellEditor && !this.cellEditorPopupWrapper;
        if (isInlineEditing) {
            return;
        }
        // this means firstRender will be true for one pass only, as it's initialised to undefined
        this.firstRender = this.firstRender == null;
        // if display template has changed, means any previous Cell Renderer is in the wrong location
        const controlWrapperChanged = this.refreshWrapper(false);
        this.refreshEditStyles(false);
        // all of these have dependencies on the eGui, so only do them after eGui is set
        if (compDetails) {
            const neverRefresh = forceNewCellRendererInstance || controlWrapperChanged;
            const cellRendererRefreshSuccessful = neverRefresh ? false : this.refreshCellRenderer(compDetails);
            if (!cellRendererRefreshSuccessful) {
                this.destroyRenderer();
                this.createCellRendererInstance(compDetails);
            }
        }
        else {
            this.destroyRenderer();
            this.insertValueWithoutCellRenderer(valueToDisplay);
        }
    }
    setEditDetails(compDetails, popup, position) {
        if (compDetails) {
            this.createCellEditorInstance(compDetails, popup, position);
        }
        else {
            this.destroyEditor();
        }
    }
    removeControls() {
        const context = this.beans.context;
        this.checkboxSelectionComp = context.destroyBean(this.checkboxSelectionComp);
        this.dndSourceComp = context.destroyBean(this.dndSourceComp);
        this.rowDraggingComp = context.destroyBean(this.rowDraggingComp);
    }
    // returns true if wrapper was changed
    refreshWrapper(editing) {
        const providingControls = this.includeRowDrag || this.includeDndSource || this.includeSelection;
        const usingWrapper = providingControls || this.forceWrapper;
        const putWrapperIn = usingWrapper && this.eCellWrapper == null;
        if (putWrapperIn) {
            this.eCellWrapper = (0, dom_1._createElement)({ tag: 'div', cls: 'ag-cell-wrapper', role: 'presentation' });
            this.eCell.appendChild(this.eCellWrapper);
        }
        const takeWrapperOut = !usingWrapper && this.eCellWrapper != null;
        if (takeWrapperOut) {
            (0, dom_1._removeFromParent)(this.eCellWrapper);
            this.eCellWrapper = undefined;
        }
        this.cellCssManager.toggleCss('ag-cell-value', !usingWrapper);
        const usingCellValue = !editing && usingWrapper;
        const putCellValueIn = usingCellValue && this.eCellValue == null;
        if (putCellValueIn) {
            this.eCellValue = (0, dom_1._createElement)({ tag: 'span', cls: 'ag-cell-value', role: 'presentation' });
            this.eCellWrapper.appendChild(this.eCellValue);
        }
        const takeCellValueOut = !usingCellValue && this.eCellValue != null;
        if (takeCellValueOut) {
            (0, dom_1._removeFromParent)(this.eCellValue);
            this.eCellValue = undefined;
        }
        const templateChanged = putWrapperIn || takeWrapperOut || putCellValueIn || takeCellValueOut;
        if (templateChanged) {
            this.removeControls();
        }
        if (!editing && providingControls) {
            this.addControls();
        }
        return templateChanged;
    }
    addControls() {
        const { cellCtrl, eCellWrapper, eCellValue, includeRowDrag, includeDndSource, includeSelection } = this;
        const insertBefore = (comp) => {
            if (comp) {
                eCellWrapper.insertBefore(comp.getGui(), eCellValue);
            }
        };
        if (includeRowDrag && this.rowDraggingComp == null) {
            this.rowDraggingComp = cellCtrl.createRowDragComp();
            insertBefore(this.rowDraggingComp);
        }
        if (includeDndSource && this.dndSourceComp == null) {
            this.dndSourceComp = cellCtrl.createDndSource();
            insertBefore(this.dndSourceComp);
        }
        if (includeSelection && this.checkboxSelectionComp == null) {
            this.checkboxSelectionComp = cellCtrl.createSelectionCheckbox();
            insertBefore(this.checkboxSelectionComp);
        }
    }
    createCellEditorInstance(compDetails, popup, position) {
        const versionCopy = this.editorVersion;
        const cellEditorPromise = compDetails.newAgStackInstance();
        const { params } = compDetails;
        cellEditorPromise.then((c) => this.afterCellEditorCreated(versionCopy, c, params, popup, position));
        // if we don't do this, and editor component is async, then there will be a period
        // when the component isn't present and keyboard navigation won't work - so example
        // of user hitting tab quickly (more quickly than renderers getting created) won't work
        const cellEditorAsync = (0, generic_1._missing)(this.cellEditor);
        if (cellEditorAsync && params.cellStartedEdit) {
            this.cellCtrl.focusCell(true);
        }
    }
    insertValueWithoutCellRenderer(valueToDisplay) {
        const eParent = this.getParentOfValue();
        (0, dom_1._clearElement)(eParent);
        const escapedValue = (0, string_1._toString)(valueToDisplay);
        if (escapedValue != null) {
            eParent.textContent = escapedValue;
        }
    }
    destroyRenderer() {
        const { context } = this.beans;
        this.cellRenderer = context.destroyBean(this.cellRenderer);
        (0, dom_1._removeFromParent)(this.cellRendererGui);
        this.cellRendererGui = null;
        this.rendererVersion++;
    }
    destroyEditor() {
        const { context } = this.beans;
        // if leaving editor & editor is focused, move focus to the cell
        const recoverFocus = this.cellEditorPopupWrapper?.getGui().contains((0, gridOptionsUtils_1._getActiveDomElement)(this.beans)) ||
            this.cellCtrl.hasBrowserFocus();
        if (recoverFocus) {
            this.eCell.focus({ preventScroll: true });
        }
        this.hideEditorPopup?.();
        this.hideEditorPopup = undefined;
        this.cellEditor = context.destroyBean(this.cellEditor);
        this.cellEditorPopupWrapper = context.destroyBean(this.cellEditorPopupWrapper);
        (0, dom_1._removeFromParent)(this.cellEditorGui);
        this.cellCtrl.disableEditorTooltipFeature();
        this.cellEditorGui = null;
        this.editorVersion++;
    }
    refreshCellRenderer(compClassAndParams) {
        if (this.cellRenderer?.refresh == null) {
            return false;
        }
        // if different Cell Renderer configured this time (eg user is using selector, and
        // returns different component) then don't refresh, force recreate of Cell Renderer
        if (this.cellRendererClass !== compClassAndParams.componentClass) {
            return false;
        }
        // take any custom params off of the user
        const result = this.cellRenderer.refresh(compClassAndParams.params);
        // NOTE on undefined: previous version of the cellRenderer.refresh() interface
        // returned nothing, if the method existed, we assumed it refreshed. so for
        // backwards compatibility, we assume if method exists and returns nothing,
        // that it was successful.
        return result === true || result === undefined;
    }
    createCellRendererInstance(compDetails) {
        const displayComponentVersionCopy = this.rendererVersion;
        const createCellRendererFunc = (details) => (_) => {
            const staleTask = this.rendererVersion !== displayComponentVersionCopy || !this.isAlive();
            if (staleTask) {
                return;
            }
            // this can return null in the event that the user has switched from a renderer component to nothing, for example
            // when using a cellRendererSelect to return a component or null depending on row data etc
            const componentPromise = details.newAgStackInstance();
            const callback = this.afterCellRendererCreated.bind(this, displayComponentVersionCopy, details.componentClass);
            componentPromise?.then(callback);
        };
        // we only use task service when rendering for first time, which means it is not used when doing edits.
        // if we changed this (always use task service) would make sense, however it would break tests, possibly
        // test of users.
        const { animationFrameSvc } = this.beans;
        let createTask;
        if (animationFrameSvc?.active && this.firstRender) {
            createTask = (details, isDeferred = false) => {
                animationFrameSvc.createTask(createCellRendererFunc(details), this.rowNode.rowIndex, 'p2', details.componentFromFramework, isDeferred);
            };
        }
        else {
            createTask = (details) => createCellRendererFunc(details)();
        }
        if (compDetails.params?.deferRender && !this.cellCtrl.rowNode.group) {
            // show loading cell and then pass the task to the animationFrameSvc
            const { loadingComp, onReady } = this.cellCtrl.getDeferLoadingCellRenderer();
            if (loadingComp) {
                // Render the loading component and setup the task to create the actual cell renderer
                // Still use the animationFrameSvc (if active) to ensure the loading component is rendered after group rows
                createTask(loadingComp);
                onReady.then(() => createTask(compDetails, true));
            }
        }
        else {
            createTask(compDetails);
        }
    }
    afterCellRendererCreated(cellRendererVersion, cellRendererClass, cellRenderer) {
        const staleTask = !this.isAlive() || cellRendererVersion !== this.rendererVersion;
        if (staleTask) {
            this.beans.context.destroyBean(cellRenderer);
            return;
        }
        this.cellRenderer = cellRenderer;
        this.cellRendererClass = cellRendererClass;
        const cellGui = cellRenderer.getGui();
        this.cellRendererGui = cellGui;
        if (cellGui != null) {
            const eParent = this.getParentOfValue();
            (0, dom_1._clearElement)(eParent);
            eParent.appendChild(cellGui);
        }
    }
    afterCellEditorCreated(requestVersion, cellEditor, params, popup, position) {
        // if editingCell=false, means user cancelled the editor before component was ready.
        // if versionMismatch, then user cancelled the edit, then started the edit again, and this
        //   is the first editor which is now stale.
        const staleComp = requestVersion !== this.editorVersion;
        const { context } = this.beans;
        if (staleComp) {
            context.destroyBean(cellEditor);
            return;
        }
        const editingCancelledByUserComp = cellEditor.isCancelBeforeStart && cellEditor.isCancelBeforeStart();
        if (editingCancelledByUserComp) {
            context.destroyBean(cellEditor);
            this.cellCtrl.stopEditing(true);
            return;
        }
        if (!cellEditor.getGui) {
            (0, logging_1._warn)(97, { colId: this.column.getId() });
            context.destroyBean(cellEditor);
            return;
        }
        this.cellEditor = cellEditor;
        this.cellEditorGui = cellEditor.getGui();
        const cellEditorInPopup = popup || (cellEditor.isPopup !== undefined && cellEditor.isPopup());
        if (cellEditorInPopup) {
            this.addPopupCellEditor(params, position);
        }
        else {
            this.addInCellEditor();
        }
        this.refreshEditStyles(true, cellEditorInPopup);
        cellEditor.afterGuiAttached?.();
        this.cellCtrl.enableEditorTooltipFeature(cellEditor);
        this.cellCtrl.cellEditorAttached();
    }
    refreshEditStyles(editing, isPopup) {
        const { cellCssManager } = this;
        cellCssManager.toggleCss('ag-cell-inline-editing', editing && !isPopup);
        cellCssManager.toggleCss('ag-cell-popup-editing', editing && !!isPopup);
        cellCssManager.toggleCss('ag-cell-not-inline-editing', !editing || !!isPopup);
    }
    addInCellEditor() {
        const { eCell } = this;
        // if focus is inside the cell, we move focus to the cell itself
        // before removing it's contents, otherwise errors could be thrown.
        if (eCell.contains((0, gridOptionsUtils_1._getActiveDomElement)(this.beans))) {
            eCell.focus();
        }
        this.destroyRenderer();
        this.refreshWrapper(true);
        // clear the parent of value element
        (0, dom_1._clearElement)(this.getParentOfValue());
        if (this.cellEditorGui) {
            const eParent = this.getParentOfValue();
            eParent.appendChild(this.cellEditorGui);
        }
    }
    addPopupCellEditor(params, position) {
        const { gos, context, popupSvc, localeSvc, editSvc } = this.beans;
        if (gos.get('editType') === 'fullRow') {
            //popup cellEditor does not work with fullRowEdit
            (0, logging_1._warn)(98);
        }
        const cellEditor = this.cellEditor;
        // if a popup, then we wrap in a popup editor and return the popup
        this.cellEditorPopupWrapper = context.createBean(editSvc.createPopupEditorWrapper(params));
        const ePopupGui = this.cellEditorPopupWrapper.getGui();
        if (this.cellEditorGui) {
            ePopupGui.appendChild(this.cellEditorGui);
        }
        const useModelPopup = gos.get('stopEditingWhenCellsLoseFocus');
        // see if position provided by colDef, if not then check old way of method on cellComp
        const positionToUse = position != null ? position : cellEditor.getPopupPosition?.() ?? 'over';
        const isRtl = gos.get('enableRtl');
        const positionParams = {
            ePopup: ePopupGui,
            column: this.column,
            rowNode: this.rowNode,
            type: 'popupCellEditor',
            eventSource: this.eCell,
            position: positionToUse,
            alignSide: isRtl ? 'right' : 'left',
            keepWithinBounds: true,
        };
        const positionCallback = popupSvc.positionPopupByComponent.bind(popupSvc, positionParams);
        const translate = (0, localeUtils_1._getLocaleTextFunc)(localeSvc);
        const addPopupRes = popupSvc.addPopup({
            modal: useModelPopup,
            eChild: ePopupGui,
            closeOnEsc: true,
            closedCallback: () => {
                this.cellCtrl.onPopupEditorClosed();
            },
            anchorToElement: this.eCell,
            positionCallback,
            ariaLabel: translate('ariaLabelCellEditor', 'Cell Editor'),
        });
        if (addPopupRes) {
            this.hideEditorPopup = addPopupRes.hideFunc;
        }
    }
    detach() {
        this.eRow.removeChild(this.getGui());
    }
    // if the row is also getting destroyed, then we don't need to remove from dom,
    // as the row will also get removed, so no need to take out the cells from the row
    // if the row is going (removing is an expensive operation, so only need to remove
    // the top part)
    //
    // note - this is NOT called by context, as we don't wire / unwire the CellComp for performance reasons.
    destroy() {
        this.destroyRenderer();
        this.destroyEditor();
        this.removeControls();
        super.destroy();
    }
}
exports.CellComp = CellComp;


/***/ }),

/***/ 60814:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CellCtrl = exports._getCellCtrlForEventTarget = exports.DOM_DATA_KEY_CELL_CTRL = void 0;
const columnUtils_1 = __webpack_require__(73146);
const userCompUtils_1 = __webpack_require__(12036);
const beanStub_1 = __webpack_require__(68731);
const editors_1 = __webpack_require__(78994);
const gridOptionsUtils_1 = __webpack_require__(67274);
const cssClassApplier_1 = __webpack_require__(91295);
const pinnedRowUtils_1 = __webpack_require__(78638);
const aria_1 = __webpack_require__(95230);
const dom_1 = __webpack_require__(33507);
const event_1 = __webpack_require__(92979);
const focus_1 = __webpack_require__(82331);
const generic_1 = __webpack_require__(34422);
const promise_1 = __webpack_require__(57990);
const cellEvent_1 = __webpack_require__(67043);
const cellKeyboardListenerFeature_1 = __webpack_require__(57038);
const cellMouseListenerFeature_1 = __webpack_require__(86368);
const cellPositionFeature_1 = __webpack_require__(63976);
const CSS_CELL = 'ag-cell';
const CSS_AUTO_HEIGHT = 'ag-cell-auto-height';
const CSS_NORMAL_HEIGHT = 'ag-cell-normal-height';
const CSS_CELL_FOCUS = 'ag-cell-focus';
const CSS_CELL_FIRST_RIGHT_PINNED = 'ag-cell-first-right-pinned';
const CSS_CELL_LAST_LEFT_PINNED = 'ag-cell-last-left-pinned';
const CSS_CELL_NOT_INLINE_EDITING = 'ag-cell-not-inline-editing';
const CSS_CELL_WRAP_TEXT = 'ag-cell-wrap-text';
exports.DOM_DATA_KEY_CELL_CTRL = 'cellCtrl';
function _getCellCtrlForEventTarget(gos, eventTarget) {
    return (0, event_1._getCtrlForEventTarget)(gos, eventTarget, exports.DOM_DATA_KEY_CELL_CTRL);
}
exports._getCellCtrlForEventTarget = _getCellCtrlForEventTarget;
let instanceIdSequence = 0;
class CellCtrl extends beanStub_1.BeanStub {
    constructor(column, rowNode, beans, rowCtrl) {
        super();
        this.column = column;
        this.rowNode = rowNode;
        this.rowCtrl = rowCtrl;
        this.rangeFeature = undefined;
        this.rowResizeFeature = undefined;
        this.positionFeature = undefined;
        this.customStyleFeature = undefined;
        this.editStyleFeature = undefined;
        this.mouseListener = undefined;
        this.keyboardListener = undefined;
        this.suppressRefreshCell = false;
        this.onCompAttachedFuncs = [];
        this.onEditorAttachedFuncs = [];
        this.focusEventWhileNotReady = null;
        // if cell has been focused, check if it's focused when destroyed
        this.hasBeenFocused = false;
        this.hasEdit = false;
        this.tooltipFeature = undefined;
        this.editorTooltipFeature = undefined;
        this.beans = beans;
        this.gos = beans.gos;
        this.editSvc = beans.editSvc;
        this.hasEdit = !!beans.editSvc;
        const { colId } = column;
        // unique id to this instance, including the column ID to help with debugging in React as it's used in 'key'
        this.instanceId = (colId + '-' + instanceIdSequence++);
        this.createCellPosition();
        this.updateAndFormatValue(false);
    }
    addFeatures() {
        const { beans } = this;
        this.positionFeature = new cellPositionFeature_1.CellPositionFeature(this, beans);
        this.customStyleFeature = beans.cellStyles?.createCellCustomStyleFeature(this, beans);
        this.editStyleFeature = beans.editSvc?.createCellStyleFeature(this, beans);
        this.mouseListener = new cellMouseListenerFeature_1.CellMouseListenerFeature(this, beans, this.column);
        this.keyboardListener = new cellKeyboardListenerFeature_1.CellKeyboardListenerFeature(this, beans, this.rowNode, this.rowCtrl);
        this.enableTooltipFeature();
        const { rangeSvc } = beans;
        const cellSelectionEnabled = rangeSvc && (0, gridOptionsUtils_1._isCellSelectionEnabled)(beans.gos);
        if (cellSelectionEnabled) {
            this.rangeFeature = rangeSvc.createCellRangeFeature(beans, this);
        }
        if ((0, columnUtils_1.isRowNumberCol)(this.column)) {
            this.rowResizeFeature = this.beans.rowNumbersSvc.createRowNumbersRowResizerFeature(beans, this);
        }
    }
    isCellSpanning() {
        return false;
    }
    getCellSpan() {
        return undefined;
    }
    removeFeatures() {
        const context = this.beans.context;
        this.positionFeature = context.destroyBean(this.positionFeature);
        this.editorTooltipFeature = context.destroyBean(this.editorTooltipFeature);
        this.customStyleFeature = context.destroyBean(this.customStyleFeature);
        this.editStyleFeature = context.destroyBean(this.editStyleFeature);
        this.mouseListener = context.destroyBean(this.mouseListener);
        this.keyboardListener = context.destroyBean(this.keyboardListener);
        this.rangeFeature = context.destroyBean(this.rangeFeature);
        this.rowResizeFeature = context.destroyBean(this.rowResizeFeature);
        this.disableTooltipFeature();
    }
    enableTooltipFeature(value, shouldDisplayTooltip) {
        this.tooltipFeature = this.beans.tooltipSvc?.enableCellTooltipFeature(this, value, shouldDisplayTooltip);
    }
    disableTooltipFeature() {
        this.tooltipFeature = this.beans.context.destroyBean(this.tooltipFeature);
    }
    enableEditorTooltipFeature(editor) {
        if (this.editorTooltipFeature) {
            this.disableEditorTooltipFeature();
        }
        this.editorTooltipFeature = this.beans.tooltipSvc?.setupCellEditorTooltip(this, editor);
        (0, editors_1._populateModelValidationErrors)(this.beans);
    }
    disableEditorTooltipFeature() {
        this.editorTooltipFeature = this.beans.context.destroyBean(this.editorTooltipFeature);
    }
    setComp(comp, eCell, _eWrapper, eCellWrapper, printLayout, startEditing, compBean) {
        this.comp = comp;
        this.eGui = eCell;
        this.printLayout = printLayout;
        compBean ?? (compBean = this);
        this.addDomData(compBean);
        this.addFeatures();
        compBean.addDestroyFunc(() => this.removeFeatures());
        this.onSuppressCellFocusChanged(this.beans.gos.get('suppressCellFocus'));
        this.setupFocus();
        this.applyStaticCssClasses();
        this.setWrapText();
        this.onFirstRightPinnedChanged();
        this.onLastLeftPinnedChanged();
        this.onColumnHover();
        this.setupControlComps();
        this.setupAutoHeight(eCellWrapper, compBean);
        this.refreshFirstAndLastStyles();
        this.refreshAriaColIndex();
        this.positionFeature?.init();
        this.customStyleFeature?.setComp(comp);
        this.editStyleFeature?.setComp(comp);
        this.tooltipFeature?.refreshTooltip();
        this.keyboardListener?.init();
        this.rangeFeature?.setComp(comp);
        this.rowResizeFeature?.refreshRowResizer();
        if (startEditing && this.isCellEditable()) {
            this.editSvc?.startEditing(this, { startedEdit: true, source: 'api' });
        }
        else {
            // We can skip refreshing the range handle as this is done in this.rangeFeature.setComp above
            this.showValue(false, true);
        }
        if (this.onCompAttachedFuncs.length) {
            this.onCompAttachedFuncs.forEach((func) => func());
            this.onCompAttachedFuncs = [];
        }
    }
    setupAutoHeight(eCellWrapper, compBean) {
        this.isAutoHeight = this.beans.rowAutoHeight?.setupCellAutoHeight(this, eCellWrapper, compBean) ?? false;
    }
    getCellAriaRole() {
        return this.column.getColDef().cellAriaRole ?? 'gridcell';
    }
    isCellRenderer() {
        const colDef = this.column.getColDef();
        return colDef.cellRenderer != null || colDef.cellRendererSelector != null;
    }
    getValueToDisplay() {
        return this.valueFormatted ?? this.value;
    }
    getDeferLoadingCellRenderer() {
        const { beans, column } = this;
        const { userCompFactory, ctrlsSvc, eventSvc } = beans;
        const colDef = column.getColDef();
        const params = this.createCellRendererParams();
        params.deferRender = true;
        const loadingDetails = (0, userCompUtils_1._getLoadingCellRendererDetails)(userCompFactory, colDef, params);
        if (ctrlsSvc.getGridBodyCtrl()?.scrollFeature?.isScrolling()) {
            // If the grid is scrolling return a promise that resolves when scrolling is finished
            // This prevents scroll being blocked by the rendering of a slow component
            let resolver;
            const onReady = new promise_1.AgPromise((resolve) => {
                resolver = resolve;
            });
            this.addManagedListeners(eventSvc, {
                bodyScrollEnd: () => resolver(),
            });
            return { loadingComp: loadingDetails, onReady };
        }
        // If not scrolling return a resolved promise immediately
        return { loadingComp: loadingDetails, onReady: promise_1.AgPromise.resolve() };
    }
    showValue(forceNewCellRendererInstance, skipRangeHandleRefresh) {
        const { beans, column, rowNode, rangeFeature } = this;
        const { userCompFactory } = beans;
        let valueToDisplay = this.getValueToDisplay();
        let compDetails;
        // if node is stub, and no group data for this node (groupSelectsChildren can populate group data)
        const isSsrmLoading = rowNode.stub && rowNode.groupData?.[column.getId()] == null;
        const colDef = column.getColDef();
        if (isSsrmLoading || this.isCellRenderer()) {
            const params = this.createCellRendererParams();
            if (!isSsrmLoading || (0, columnUtils_1.isRowNumberCol)(column)) {
                compDetails = (0, userCompUtils_1._getCellRendererDetails)(userCompFactory, colDef, params);
            }
            else {
                compDetails = (0, userCompUtils_1._getLoadingCellRendererDetails)(userCompFactory, colDef, params);
            }
        }
        if (!compDetails && !isSsrmLoading && beans.findSvc?.isMatch(rowNode, column)) {
            const params = this.createCellRendererParams();
            compDetails = (0, userCompUtils_1._getCellRendererDetails)(userCompFactory, { ...column.getColDef(), cellRenderer: 'agFindCellRenderer' }, params);
        }
        if (this.hasEdit &&
            this.editSvc.isBatchEditing() &&
            this.editSvc.isRowEditing(rowNode, { checkSiblings: true })) {
            const result = this.editSvc.prepDetailsDuringBatch(this, { compDetails, valueToDisplay });
            if (result) {
                if (result.compDetails) {
                    compDetails = result.compDetails;
                }
                else if (result.valueToDisplay) {
                    valueToDisplay = result.valueToDisplay;
                }
            }
        }
        this.comp.setRenderDetails(compDetails, valueToDisplay, forceNewCellRendererInstance);
        // Don't call expensive _requestAnimationFrame if we don't have to
        if (!skipRangeHandleRefresh && rangeFeature) {
            (0, dom_1._requestAnimationFrame)(beans, () => rangeFeature?.refreshHandle());
        }
        this.rowResizeFeature?.refreshRowResizer();
    }
    setupControlComps() {
        const colDef = this.column.getColDef();
        this.includeSelection = this.isIncludeControl(this.isCheckboxSelection(colDef), true);
        this.includeRowDrag = this.isIncludeControl(colDef.rowDrag);
        this.includeDndSource = this.isIncludeControl(colDef.dndSource);
        this.comp.setIncludeSelection(this.includeSelection);
        this.comp.setIncludeDndSource(this.includeDndSource);
        this.comp.setIncludeRowDrag(this.includeRowDrag);
    }
    isForceWrapper() {
        // text selection requires the value to be wrapped in another element
        return this.beans.gos.get('enableCellTextSelection') || this.column.isAutoHeight();
    }
    /**
     * Wrapper providing general conditions under which control elements (e.g. checkboxes and drag handles)
     * are rendered for a particular cell.
     * @param value Whether to render the control in the specific context of the caller
     * @param allowManuallyPinned Whether manually pinned rows are permitted this form of control element
     */
    // eslint-disable-next-line @typescript-eslint/ban-types
    isIncludeControl(value, allowManuallyPinned = false) {
        const rowUnpinned = this.rowNode.rowPinned == null;
        return (rowUnpinned || (allowManuallyPinned && (0, pinnedRowUtils_1._isManualPinnedRow)(this.rowNode))) && !!value;
    }
    isCheckboxSelection(colDef) {
        const { rowSelection, groupDisplayType } = this.beans.gridOptions;
        const checkboxLocation = (0, gridOptionsUtils_1._getCheckboxLocation)(rowSelection);
        const isSelectionColumn = (0, columnUtils_1.isColumnSelectionCol)(this.column);
        // Specific check for custom group display type here because we assume one of the non-selection
        // columns will have `showRowGroup != null` and so in this case we will be rendering the checkbox
        // in the group cell rather than here (the selection column)
        if (groupDisplayType === 'custom' && checkboxLocation !== 'selectionColumn' && isSelectionColumn) {
            return false;
        }
        return (colDef.checkboxSelection ||
            (isSelectionColumn && typeof rowSelection === 'object' && (0, gridOptionsUtils_1._getCheckboxes)(rowSelection)));
    }
    refreshShouldDestroy() {
        const colDef = this.column.getColDef();
        const selectionChanged = this.includeSelection != this.isIncludeControl(this.isCheckboxSelection(colDef), true);
        const rowDragChanged = this.includeRowDrag != this.isIncludeControl(colDef.rowDrag);
        const dndSourceChanged = this.includeDndSource != this.isIncludeControl(colDef.dndSource);
        // auto height uses wrappers, so need to destroy
        const autoHeightChanged = this.isAutoHeight != this.column.isAutoHeight();
        return selectionChanged || rowDragChanged || dndSourceChanged || autoHeightChanged;
    }
    onPopupEditorClosed() {
        const { editSvc } = this.beans;
        if (!editSvc?.isEditing(this)) {
            return;
        }
        // note: this happens because of a click outside of the grid or if the popupEditor
        // is closed with `Escape` key. if another cell was clicked, then the editing will
        // have already stopped and returned on the conditional above.
        editSvc?.stopEditing(this, { source: editSvc?.isBatchEditing() ? 'ui' : 'api' });
    }
    /**
     * Ends the Cell Editing
     * @param cancel `True` if the edit process is being canceled.
     * @returns `True` if the value of the `GridCell` has been updated, otherwise `False`.
     */
    stopEditing(cancel = false) {
        const { editSvc } = this.beans;
        return editSvc?.stopEditing(this, { cancel, source: editSvc?.isBatchEditing() ? 'ui' : 'api' }) ?? false;
    }
    createCellRendererParams() {
        const { value, valueFormatted, column, rowNode, comp, eGui, beans: { valueSvc, gos, editSvc }, } = this;
        const res = (0, gridOptionsUtils_1._addGridCommonParams)(gos, {
            value: value,
            valueFormatted: valueFormatted,
            getValue: () => valueSvc.getValueForDisplay(column, rowNode).value,
            setValue: (value) => editSvc?.setDataValue({ rowNode, column }, value) || valueSvc.setValue(rowNode, column, value),
            formatValue: this.formatValue.bind(this),
            data: rowNode.data,
            node: rowNode,
            pinned: column.getPinned(),
            colDef: column.getColDef(),
            column,
            refreshCell: this.refreshCell.bind(this),
            eGridCell: eGui,
            eParentOfValue: comp.getParentOfValue(),
            registerRowDragger: (rowDraggerElement, dragStartPixels, value, suppressVisibilityChange) => this.registerRowDragger(rowDraggerElement, dragStartPixels, suppressVisibilityChange),
            setTooltip: (value, shouldDisplayTooltip) => {
                gos.assertModuleRegistered('Tooltip', 3);
                if (this.tooltipFeature) {
                    this.disableTooltipFeature();
                }
                this.enableTooltipFeature(value, shouldDisplayTooltip);
                this.tooltipFeature?.refreshTooltip();
            },
        });
        return res;
    }
    onCellChanged(event) {
        const eventImpactsThisCell = event.column === this.column;
        if (eventImpactsThisCell) {
            this.refreshCell({});
        }
    }
    refreshOrDestroyCell(params) {
        if (this.refreshShouldDestroy()) {
            this.rowCtrl?.recreateCell(this);
        }
        else {
            this.refreshCell(params);
        }
    }
    // + stop editing {force: true, suppressFlash: true}
    // + event cellChanged {}
    // + cellRenderer.params.refresh() {} -> method passes 'as is' to the cellRenderer, so params could be anything
    // + rowCtrl: event dataChanged {suppressFlash: !update, newData: !update}
    // + rowCtrl: api refreshCells() {animate: true/false}
    // + rowRenderer: api softRefreshView() {}
    refreshCell({ force, suppressFlash, newData } = {}) {
        // if we are in the middle of 'stopEditing', then we don't refresh here, as refresh gets called explicitly
        if (this.suppressRefreshCell) {
            return;
        }
        const colDef = this.column.getColDef();
        // we always refresh if cell has no value - this can happen when user provides Cell Renderer and the
        // cell renderer doesn't rely on a value, instead it could be looking directly at the data, or maybe
        // printing the current time (which would be silly)???. Generally speaking
        // non of {field, valueGetter, showRowGroup} is bad in the users application, however for this edge case, it's
        // best always refresh and take the performance hit rather than never refresh and users complaining in support
        // that cells are not updating.
        const noValueProvided = colDef.field == null && colDef.valueGetter == null && colDef.showRowGroup == null;
        const forceRefresh = force || noValueProvided || newData;
        const isCellCompReady = !!this.comp;
        // Only worth comparing values if the cellComp is ready
        const valuesDifferent = this.updateAndFormatValue(isCellCompReady);
        const dataNeedsUpdating = forceRefresh || valuesDifferent;
        // In React, due to async, it's possible a refresh was asked for before the CellComp was created and calls setComp()
        // So we do not run the cell comp refresh logic at this point in time.
        if (!isCellCompReady) {
            return;
        }
        if (dataNeedsUpdating) {
            // if it's 'new data', then we don't refresh the cellRenderer, even if refresh method is available.
            // this is because if the whole data is new (ie we are showing stock price 'BBA' now and not 'SSD')
            // then we are not showing a movement in the stock price, rather we are showing different stock.
            this.showValue(!!newData, false);
            // we don't want to flash the cells when processing a filter change, as otherwise the UI would
            // be to busy. see comment in FilterManager with regards processingFilterChange
            const processingFilterChange = this.beans.filterManager?.isSuppressFlashingCellsBecauseFiltering();
            const flashCell = !suppressFlash && !processingFilterChange && colDef.enableCellChangeFlash;
            if (flashCell) {
                this.beans.cellFlashSvc?.flashCell(this);
            }
            this.editStyleFeature?.applyCellStyles?.();
            this.customStyleFeature?.applyUserStyles();
            this.customStyleFeature?.applyClassesFromColDef();
        }
        this.tooltipFeature?.refreshTooltip();
        // we do cellClassRules even if the value has not changed, so that users who have rules that
        // look at other parts of the row (where the other part of the row might of changed) will work.
        this.customStyleFeature?.applyCellClassRules();
    }
    isCellEditable() {
        return this.column.isCellEditable(this.rowNode);
    }
    formatValue(value) {
        return this.callValueFormatter(value) ?? value;
    }
    callValueFormatter(value) {
        return this.beans.valueSvc.formatValue(this.column, this.rowNode, value);
    }
    updateAndFormatValue(compareValues) {
        const oldValue = this.value;
        const oldValueFormatted = this.valueFormatted;
        const { value, valueFormatted } = this.beans.valueSvc.getValueForDisplay(this.column, this.rowNode, true);
        this.value = value;
        this.valueFormatted = valueFormatted;
        if (compareValues) {
            return !this.valuesAreEqual(oldValue, this.value) || this.valueFormatted != oldValueFormatted;
        }
        return true;
    }
    valuesAreEqual(val1, val2) {
        // if the user provided an equals method, use that, otherwise do simple comparison
        const colDef = this.column.getColDef();
        return colDef.equals ? colDef.equals(val1, val2) : val1 === val2;
    }
    addDomData(compBean) {
        const element = this.eGui;
        (0, gridOptionsUtils_1._setDomData)(this.beans.gos, element, exports.DOM_DATA_KEY_CELL_CTRL, this);
        compBean.addDestroyFunc(() => (0, gridOptionsUtils_1._setDomData)(this.beans.gos, element, exports.DOM_DATA_KEY_CELL_CTRL, null));
    }
    createEvent(domEvent, eventType) {
        const { rowNode, column, value, beans } = this;
        return (0, cellEvent_1._createCellEvent)(beans, domEvent, eventType, { rowNode, column }, value);
    }
    processCharacter(event) {
        this.keyboardListener?.processCharacter(event);
    }
    onKeyDown(event) {
        this.keyboardListener?.onKeyDown(event);
    }
    onMouseEvent(eventName, mouseEvent) {
        this.mouseListener?.onMouseEvent(eventName, mouseEvent);
    }
    getColSpanningList() {
        return this.positionFeature?.getColSpanningList() ?? [];
    }
    onLeftChanged() {
        if (!this.comp) {
            return;
        }
        this.positionFeature?.onLeftChanged();
    }
    onDisplayedColumnsChanged() {
        if (!this.eGui) {
            return;
        }
        this.refreshAriaColIndex();
        this.refreshFirstAndLastStyles();
    }
    refreshFirstAndLastStyles() {
        const { comp, column, beans } = this;
        (0, cssClassApplier_1.refreshFirstAndLastStyles)(comp, column, beans.visibleCols);
    }
    refreshAriaColIndex() {
        const colIdx = this.beans.visibleCols.getAriaColIndex(this.column);
        (0, aria_1._setAriaColIndex)(this.eGui, colIdx); // for react, we don't use JSX, as it slowed down column moving
    }
    onWidthChanged() {
        return this.positionFeature?.onWidthChanged();
    }
    getRowPosition() {
        const { rowIndex, rowPinned } = this.cellPosition;
        return {
            rowIndex,
            rowPinned,
        };
    }
    updateRangeBordersIfRangeCount() {
        if (!this.comp) {
            return;
        }
        this.rangeFeature?.updateRangeBordersIfRangeCount();
    }
    onCellSelectionChanged() {
        if (!this.comp) {
            return;
        }
        this.rangeFeature?.onCellSelectionChanged();
    }
    isRangeSelectionEnabled() {
        return this.rangeFeature != null;
    }
    focusCell(forceBrowserFocus = false, sourceEvent) {
        this.beans.focusSvc.setFocusedCell({
            ...this.getFocusedCellPosition(),
            forceBrowserFocus,
            sourceEvent,
        });
    }
    /**
     * Restores focus to the cell, if it should have it
     * @param waitForRender if the cell has just setComp, it may not be rendered yet, so we wait for the next render
     */
    restoreFocus(waitForRender = false) {
        const { beans: { editSvc, focusSvc }, comp, } = this;
        if (!comp || editSvc?.isEditing(this) || !this.isCellFocused() || !focusSvc.shouldTakeFocus()) {
            return;
        }
        const focus = () => {
            if (!this.isAlive()) {
                return;
            }
            const focusableElement = comp.getFocusableElement();
            if (this.isCellFocused()) {
                focusableElement.focus({ preventScroll: true });
            }
        };
        // if first render; wait for the component to mount to dom
        if (waitForRender) {
            setTimeout(focus, 0);
            return;
        }
        focus();
    }
    onRowIndexChanged() {
        // when index changes, this influences items that need the index, so we update the
        // grid cell so they are working off the new index.
        this.createCellPosition();
        // when the index of the row changes, ie means the cell may have lost or gained focus
        this.onCellFocused();
        // if row index changed, this cell may now need focus
        this.restoreFocus();
        // check range selection
        this.rangeFeature?.onCellSelectionChanged();
        this.rowResizeFeature?.refreshRowResizer();
    }
    onSuppressCellFocusChanged(suppressCellFocus) {
        const element = this.eGui;
        if (!element) {
            return;
        }
        if ((0, columnUtils_1.isRowNumberCol)(this.column)) {
            suppressCellFocus = true;
        }
        (0, dom_1._addOrRemoveAttribute)(element, 'tabindex', suppressCellFocus ? undefined : -1);
    }
    onFirstRightPinnedChanged() {
        if (!this.comp) {
            return;
        }
        const firstRightPinned = this.column.isFirstRightPinned();
        this.comp.toggleCss(CSS_CELL_FIRST_RIGHT_PINNED, firstRightPinned);
    }
    onLastLeftPinnedChanged() {
        if (!this.comp) {
            return;
        }
        const lastLeftPinned = this.column.isLastLeftPinned();
        this.comp.toggleCss(CSS_CELL_LAST_LEFT_PINNED, lastLeftPinned);
    }
    /**
     * Returns whether cell is focused by the focusSvc, overridden by spannedCellCtrl
     */
    checkCellFocused() {
        return this.beans.focusSvc.isCellFocused(this.cellPosition);
    }
    isCellFocused() {
        const isFocused = this.checkCellFocused();
        this.hasBeenFocused || (this.hasBeenFocused = isFocused);
        return isFocused;
    }
    setupFocus() {
        // when cell is created, if it should be focus the grid should take focus from the focused cell
        this.restoreFocus(true);
        this.onCellFocused(this.focusEventWhileNotReady ?? undefined);
    }
    onCellFocused(event) {
        const { beans } = this;
        if ((0, focus_1._isCellFocusSuppressed)(beans)) {
            return;
        }
        if (!this.comp) {
            // scenario: focusing event on cell outside viewport causes cells to force render
            // preserve event for when cell renders.
            if (event) {
                this.focusEventWhileNotReady = event;
            }
            return;
        }
        const cellFocused = this.isCellFocused();
        const editing = beans.editSvc?.isEditing(this) ?? false;
        this.comp.toggleCss(CSS_CELL_FOCUS, cellFocused);
        // see if we need to force browser focus - this can happen if focus is programmatically set
        if (cellFocused && event && event.forceBrowserFocus) {
            let focusEl = this.comp.getFocusableElement();
            if (editing) {
                const focusableEls = (0, focus_1._findFocusableElements)(focusEl, null, true);
                if (focusableEls.length) {
                    focusEl = focusableEls[0];
                }
            }
            focusEl.focus({ preventScroll: !!event.preventScrollOnBrowserFocus });
        }
        if (cellFocused) {
            this.rowCtrl.announceDescription();
        }
    }
    createCellPosition() {
        const { rowIndex, rowPinned } = this.rowNode;
        this.cellPosition = {
            rowIndex: rowIndex,
            rowPinned: (0, generic_1._makeNull)(rowPinned),
            column: this.column,
        };
    }
    // CSS Classes that only get applied once, they never change
    applyStaticCssClasses() {
        const { comp } = this;
        comp.toggleCss(CSS_CELL, true);
        comp.toggleCss(CSS_CELL_NOT_INLINE_EDITING, true);
        // normal cells fill the height of the row. autoHeight cells have no height to let them
        // fit the height of content.
        const autoHeight = this.column.isAutoHeight() == true;
        comp.toggleCss(CSS_AUTO_HEIGHT, autoHeight);
        comp.toggleCss(CSS_NORMAL_HEIGHT, !autoHeight);
    }
    onColumnHover() {
        this.beans.colHover?.onCellColumnHover(this.column, this.comp);
    }
    onColDefChanged() {
        if (!this.comp) {
            return;
        }
        if (this.column.isTooltipEnabled()) {
            this.disableTooltipFeature();
            this.enableTooltipFeature();
        }
        else {
            this.disableTooltipFeature();
        }
        this.setWrapText();
        if (this.editSvc?.isEditing(this)) {
            this.editSvc?.handleColDefChanged(this);
        }
        else {
            this.refreshOrDestroyCell({ force: true, suppressFlash: true });
        }
    }
    setWrapText() {
        const value = this.column.getColDef().wrapText == true;
        this.comp.toggleCss(CSS_CELL_WRAP_TEXT, value);
    }
    dispatchCellContextMenuEvent(event) {
        const colDef = this.column.getColDef();
        const cellContextMenuEvent = this.createEvent(event, 'cellContextMenu');
        const { beans } = this;
        beans.eventSvc.dispatchEvent(cellContextMenuEvent);
        if (colDef.onCellContextMenu) {
            // to make the callback async, do in a timeout
            window.setTimeout(() => {
                beans.frameworkOverrides.wrapOutgoing(() => {
                    colDef.onCellContextMenu(cellContextMenuEvent);
                });
            }, 0);
        }
    }
    getCellRenderer() {
        return this.comp?.getCellRenderer() ?? null;
    }
    destroy() {
        this.onCompAttachedFuncs = [];
        this.onEditorAttachedFuncs = [];
        // if this was focused; (e.g cell span status changes) then we need to restore focus
        if (this.isCellFocused() && this.hasBrowserFocus()) {
            this.beans.focusSvc.attemptToRecoverFocus();
        }
        super.destroy();
    }
    hasBrowserFocus() {
        return this.eGui?.contains((0, gridOptionsUtils_1._getActiveDomElement)(this.beans)) ?? false;
    }
    createSelectionCheckbox() {
        const cbSelectionComponent = this.beans.selectionSvc?.createCheckboxSelectionComponent();
        if (!cbSelectionComponent) {
            return undefined;
        }
        this.beans.context.createBean(cbSelectionComponent);
        cbSelectionComponent.init({ rowNode: this.rowNode, column: this.column });
        // put the checkbox in before the value
        return cbSelectionComponent;
    }
    createDndSource() {
        const dndSourceComp = this.beans.registry.createDynamicBean('dndSourceComp', false, this.rowNode, this.column, this.eGui);
        if (dndSourceComp) {
            this.beans.context.createBean(dndSourceComp);
        }
        return dndSourceComp;
    }
    registerRowDragger(customElement, dragStartPixels, suppressVisibilityChange) {
        // if previously existed, then we are only updating
        if (this.customRowDragComp) {
            this.customRowDragComp.setDragElement(customElement, dragStartPixels);
            return;
        }
        const newComp = this.createRowDragComp(customElement, dragStartPixels, suppressVisibilityChange);
        if (newComp) {
            this.customRowDragComp = newComp;
            this.addDestroyFunc(() => {
                this.beans.context.destroyBean(newComp);
                this.customRowDragComp = null;
            });
        }
    }
    createRowDragComp(customElement, dragStartPixels, suppressVisibilityChange) {
        const rowDragComp = this.beans.rowDragSvc?.createRowDragCompForCell(this.rowNode, this.column, () => this.value, customElement, dragStartPixels, suppressVisibilityChange);
        if (!rowDragComp) {
            return undefined;
        }
        this.beans.context.createBean(rowDragComp);
        return rowDragComp;
    }
    cellEditorAttached() {
        this.onEditorAttachedFuncs.forEach((func) => func());
        this.onEditorAttachedFuncs = [];
    }
    setFocusedCellPosition(_cellPosition) {
        // noop, used by spannedCellCtrl
    }
    getFocusedCellPosition() {
        return this.cellPosition;
    }
    // used by spannedCellCtrl
    refreshAriaRowIndex() { }
    /**
     * Returns the root element of the cell, could be a span container rather than the cell element.
     * @returns The root element of the cell.
     */
    getRootElement() {
        return this.eGui;
    }
}
exports.CellCtrl = CellCtrl;


/***/ }),

/***/ 67043:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._createCellEvent = void 0;
const gridOptionsUtils_1 = __webpack_require__(67274);
function _createCellEvent(beans, domEvent, eventType, { rowNode, column }, value) {
    const event = (0, gridOptionsUtils_1._addGridCommonParams)(beans.gos, {
        type: eventType,
        node: rowNode,
        data: rowNode.data,
        value,
        column,
        colDef: column.getColDef(),
        rowPinned: rowNode.rowPinned,
        event: domEvent,
        rowIndex: rowNode.rowIndex,
    });
    return event;
}
exports._createCellEvent = _createCellEvent;


/***/ }),

/***/ 34534:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CellFlashService = void 0;
const beanStub_1 = __webpack_require__(68731);
const positionUtils_1 = __webpack_require__(6257);
class CellFlashService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'cellFlashSvc';
        this.nextAnimationTime = null;
        this.nextAnimationCycle = null;
        this.animations = {
            highlight: new Map(),
            'data-changed': new Map(),
        };
    }
    animateCell(cellCtrl, cssName, flashDuration = this.beans.gos.get('cellFlashDuration'), fadeDuration = this.beans.gos.get('cellFadeDuration')) {
        const animations = this.animations[cssName];
        // cancel any pre-existing animation for this cell
        animations.delete(cellCtrl);
        const time = Date.now();
        const flashEndTime = time + flashDuration;
        const fadeEndTime = time + flashDuration + fadeDuration;
        const animState = {
            phase: 'flash',
            flashEndTime,
            fadeEndTime,
        };
        animations.set(cellCtrl, animState);
        const cssBase = `ag-cell-${cssName}`;
        const cssAnimation = `${cssBase}-animation`;
        const { comp, eGui: { style }, } = cellCtrl;
        // we want to highlight the cells, without any animation
        comp.toggleCss(cssBase, true);
        comp.toggleCss(cssAnimation, false);
        style.removeProperty('transition');
        style.removeProperty('transition-delay');
        // need an earlier animation cycle, but we delay flash end by 15ms as it's ok if fade starts a little late
        // in favour of batching
        if (this.nextAnimationTime && flashEndTime + 15 < this.nextAnimationTime) {
            clearTimeout(this.nextAnimationCycle);
            this.nextAnimationCycle = null;
            this.nextAnimationTime = null;
        }
        if (!this.nextAnimationCycle) {
            // then once that is applied, we remove the highlight with animation
            this.beans.frameworkOverrides.wrapIncoming(() => {
                this.nextAnimationCycle = setTimeout(this.advanceAnimations.bind(this), flashDuration);
            });
            this.nextAnimationTime = flashEndTime;
        }
    }
    advanceAnimations() {
        const time = Date.now();
        let nextAnimationTime = null;
        for (const cssName of Object.keys(this.animations)) {
            const animations = this.animations[cssName];
            const cssBase = `ag-cell-${cssName}`;
            const cssAnimation = `${cssBase}-animation`;
            for (const [cell, animState] of animations) {
                if (!cell.isAlive() || !cell.comp) {
                    animations.delete(cell);
                    continue;
                }
                const { phase, flashEndTime, fadeEndTime } = animState;
                const nextActionableTime = phase === 'flash' ? flashEndTime : fadeEndTime;
                const requiresAction = time + 15 >= nextActionableTime; // if need to act up to 15ms in future, batch into now.
                if (!requiresAction) {
                    nextAnimationTime = Math.min(nextActionableTime, nextAnimationTime ?? Infinity);
                    continue;
                }
                const { comp, eGui: { style }, } = cell;
                switch (phase) {
                    case 'flash':
                        comp.toggleCss(cssBase, false);
                        comp.toggleCss(cssAnimation, true);
                        style.transition = `background-color ${fadeEndTime - flashEndTime}ms`;
                        // transition delay accounts for the fact that the timeout may be late
                        // and allows the animation to delay or start part way through
                        style.transitionDelay = `${flashEndTime - time}ms`;
                        nextAnimationTime = Math.min(fadeEndTime, nextAnimationTime ?? Infinity);
                        animState.phase = 'fade';
                        break;
                    case 'fade':
                        comp.toggleCss(cssBase, false);
                        comp.toggleCss(cssAnimation, false);
                        style.removeProperty('transition');
                        style.removeProperty('transition-delay');
                        animations.delete(cell);
                        break;
                }
            }
        }
        if (nextAnimationTime == null) {
            this.nextAnimationTime = null;
            this.nextAnimationCycle = null;
        }
        else if (nextAnimationTime) {
            this.nextAnimationCycle = setTimeout(this.advanceAnimations.bind(this), nextAnimationTime - time);
            this.nextAnimationTime = nextAnimationTime;
        }
    }
    onFlashCells(cellCtrl, event) {
        if (!cellCtrl.comp) {
            return;
        }
        const cellId = (0, positionUtils_1._createCellId)(cellCtrl.cellPosition);
        const shouldFlash = event.cells[cellId];
        if (shouldFlash) {
            this.animateCell(cellCtrl, 'highlight');
        }
    }
    flashCell(cellCtrl, delays) {
        this.animateCell(cellCtrl, 'data-changed', delays?.flashDuration, delays?.fadeDuration);
    }
    destroy() {
        for (const cssName of Object.keys(this.animations)) {
            const animations = this.animations[cssName];
            animations.clear();
        }
    }
}
exports.CellFlashService = CellFlashService;


/***/ }),

/***/ 57038:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CellKeyboardListenerFeature = void 0;
const keyCode_1 = __webpack_require__(39853);
const beanStub_1 = __webpack_require__(68731);
const editors_1 = __webpack_require__(78994);
const gridOptionsUtils_1 = __webpack_require__(67274);
const browser_1 = __webpack_require__(98667);
function _isDeleteKey(key, alwaysReturnFalseOnBackspace = false) {
    if (key === keyCode_1.KeyCode.DELETE) {
        return true;
    }
    if (!alwaysReturnFalseOnBackspace && key === keyCode_1.KeyCode.BACKSPACE) {
        return (0, browser_1._isMacOsUserAgent)();
    }
    return false;
}
class CellKeyboardListenerFeature extends beanStub_1.BeanStub {
    constructor(cellCtrl, beans, rowNode, rowCtrl) {
        super();
        this.cellCtrl = cellCtrl;
        this.rowNode = rowNode;
        this.rowCtrl = rowCtrl;
        this.beans = beans;
    }
    init() {
        this.eGui = this.cellCtrl.eGui;
    }
    onKeyDown(event) {
        const key = event.key;
        switch (key) {
            case keyCode_1.KeyCode.ENTER:
                this.onEnterKeyDown(event);
                break;
            case keyCode_1.KeyCode.F2:
                this.onF2KeyDown(event);
                break;
            case keyCode_1.KeyCode.ESCAPE:
                this.onEscapeKeyDown(event);
                break;
            case keyCode_1.KeyCode.TAB:
                this.onTabKeyDown(event);
                break;
            case keyCode_1.KeyCode.BACKSPACE:
            case keyCode_1.KeyCode.DELETE:
                this.onBackspaceOrDeleteKeyDown(key, event);
                break;
            case keyCode_1.KeyCode.DOWN:
            case keyCode_1.KeyCode.UP:
            case keyCode_1.KeyCode.RIGHT:
            case keyCode_1.KeyCode.LEFT:
                this.onNavigationKeyDown(event, key);
                break;
        }
    }
    onNavigationKeyDown(event, key) {
        const { cellCtrl, beans } = this;
        if (beans.editSvc?.isEditing(cellCtrl, { withOpenEditor: true })) {
            return;
        }
        if (event.shiftKey && cellCtrl.isRangeSelectionEnabled()) {
            this.onShiftRangeSelect(event);
        }
        else {
            const currentCellPosition = cellCtrl.getFocusedCellPosition();
            beans.navigation?.navigateToNextCell(event, key, currentCellPosition, true);
        }
        // if we don't prevent default, the grid will scroll with the navigation keys
        event.preventDefault();
    }
    onShiftRangeSelect(event) {
        const { rangeSvc, navigation } = this.beans;
        if (!rangeSvc) {
            return;
        }
        const endCell = rangeSvc.extendLatestRangeInDirection(event);
        if (endCell) {
            navigation?.ensureCellVisible(endCell);
        }
    }
    onTabKeyDown(event) {
        this.beans.navigation?.onTabKeyDown(this.cellCtrl, event);
    }
    onBackspaceOrDeleteKeyDown(key, event) {
        const { cellCtrl, beans, rowNode } = this;
        const { gos, rangeSvc, eventSvc, editSvc } = beans;
        eventSvc.dispatchEvent({ type: 'keyShortcutChangedCellStart' });
        if (_isDeleteKey(key, gos.get('enableCellEditingOnBackspace')) &&
            !editSvc?.isEditing(cellCtrl, { withOpenEditor: true })) {
            if (rangeSvc && (0, gridOptionsUtils_1._isCellSelectionEnabled)(gos)) {
                rangeSvc.clearCellRangeCellValues({ dispatchWrapperEvents: true, wrapperEventSource: 'deleteKey' });
            }
            else if (cellCtrl.isCellEditable()) {
                const { column } = cellCtrl;
                const emptyValue = this.beans.valueSvc.getDeleteValue(column, rowNode);
                rowNode.setDataValue(column, emptyValue, 'cellClear');
            }
        }
        else if (!editSvc?.isEditing(cellCtrl, { withOpenEditor: true })) {
            beans.editSvc?.startEditing(cellCtrl, { startedEdit: true, event });
        }
        eventSvc.dispatchEvent({ type: 'keyShortcutChangedCellEnd' });
    }
    onEnterKeyDown(event) {
        const { cellCtrl, beans } = this;
        const { editSvc, navigation } = beans;
        const cellEditing = editSvc?.isEditing(cellCtrl);
        const rowNode = cellCtrl.rowNode;
        const rowEditing = editSvc?.isRowEditing(rowNode);
        const startEditingAction = (cellCtrl) => {
            const started = editSvc?.startEditing(cellCtrl, {
                startedEdit: true,
                event,
            });
            if (started) {
                // if we started editing, then we need to prevent default, otherwise the Enter action can get
                // applied to the cell editor. this happened, for example, with largeTextCellEditor where not
                // preventing default results in a 'new line' character getting inserted in the text area
                // when the editing was started
                event.preventDefault();
            }
        };
        if (cellEditing || rowEditing) {
            if (this.isCtrlEnter(event)) {
                // bulk edit, apply currently editing value to all selected cells
                editSvc?.applyBulkEdit(cellCtrl, beans?.rangeSvc?.getCellRanges() || []);
                return;
            }
            // re-run ALL validations, Enter key is used to commit the edit, so we want to ensure it's valid
            (0, editors_1._populateModelValidationErrors)(beans);
            if (editSvc?.checkNavWithValidation(cellCtrl, event) === 'block-stop') {
                return;
            }
            if (editSvc?.isEditing(cellCtrl, { withOpenEditor: true })) {
                editSvc?.stopEditing(cellCtrl, {
                    event,
                });
            }
            else if (rowEditing && !cellCtrl.isCellEditable()) {
                // must be on a read only cell
                editSvc?.stopEditing({ rowNode }, { event });
            }
            else {
                startEditingAction(cellCtrl);
            }
        }
        else {
            if (beans.gos.get('enterNavigatesVertically')) {
                const key = event.shiftKey ? keyCode_1.KeyCode.UP : keyCode_1.KeyCode.DOWN;
                navigation?.navigateToNextCell(null, key, cellCtrl.cellPosition, false);
            }
            else {
                if (editSvc?.hasValidationErrors()) {
                    return;
                }
                if (editSvc?.hasValidationErrors(cellCtrl)) {
                    editSvc.revertSingleCellEdit(cellCtrl, true);
                }
                startEditingAction(cellCtrl);
            }
        }
    }
    isCtrlEnter(e) {
        return (e.ctrlKey || e.metaKey) && e.key === keyCode_1.KeyCode.ENTER;
    }
    onF2KeyDown(event) {
        const { cellCtrl, beans: { editSvc }, } = this;
        editSvc?.startEditing(cellCtrl, { startedEdit: true, event });
    }
    onEscapeKeyDown(event) {
        const { cellCtrl, beans: { editSvc }, } = this;
        if (editSvc?.checkNavWithValidation(cellCtrl, event) === 'block-stop') {
            // for escape we always revert, even if blocking
            editSvc.revertSingleCellEdit(cellCtrl);
        }
        editSvc?.stopEditing(cellCtrl, {
            event,
            cancel: true,
        });
    }
    processCharacter(event) {
        // check this, in case focus is on a (for example) a text field inside the cell,
        // in which cse we should not be listening for these key pressed
        const eventTarget = event.target;
        const eventOnChildComponent = eventTarget !== this.eGui;
        const { beans: { editSvc }, cellCtrl, } = this;
        if (eventOnChildComponent) {
            return;
        }
        if (editSvc?.isEditing(cellCtrl, { withOpenEditor: true })) {
            // if we have an open editor, then we don't want to process the character on the cell
            return;
        }
        const key = event.key;
        if (key === keyCode_1.KeyCode.SPACE) {
            this.onSpaceKeyDown(event);
        }
        else if (editSvc?.isCellEditable(cellCtrl, 'ui')) {
            if (editSvc?.hasValidationErrors() && !editSvc?.hasValidationErrors(cellCtrl)) {
                return;
            }
            editSvc?.startEditing(cellCtrl, { startedEdit: true, event, source: 'api' });
            // if we don't prevent default, then the event also gets applied to the text field
            // (at least when doing the default editor), but we need to allow the editor to decide
            // what it wants to do. we only do this IF editing was started - otherwise it messes
            // up when the user is not doing editing, but using rendering with text fields in cellRenderer
            // (as it would block the the user from typing into text fields).
            const compDetails = cellCtrl.editCompDetails;
            const shouldPreventDefault = !compDetails?.params
                ?.suppressPreventDefault;
            if (shouldPreventDefault) {
                event.preventDefault();
            }
        }
    }
    onSpaceKeyDown(event) {
        const { gos, editSvc } = this.beans;
        const { rowNode } = this.cellCtrl;
        if (!editSvc?.isEditing(this.cellCtrl, { withOpenEditor: true }) && (0, gridOptionsUtils_1._isRowSelection)(gos)) {
            this.beans.selectionSvc?.handleSelectionEvent(event, rowNode, 'spaceKey');
        }
        // prevent default as space key, by default, moves browser scroll down
        event.preventDefault();
    }
}
exports.CellKeyboardListenerFeature = CellKeyboardListenerFeature;


/***/ }),

/***/ 86368:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CellMouseListenerFeature = void 0;
const columnUtils_1 = __webpack_require__(73146);
const beanStub_1 = __webpack_require__(68731);
const browser_1 = __webpack_require__(98667);
const dom_1 = __webpack_require__(33507);
const event_1 = __webpack_require__(92979);
const mouse_1 = __webpack_require__(3276);
class CellMouseListenerFeature extends beanStub_1.BeanStub {
    constructor(cellCtrl, beans, column) {
        super();
        this.cellCtrl = cellCtrl;
        this.column = column;
        this.beans = beans;
    }
    onMouseEvent(eventName, mouseEvent) {
        if ((0, event_1._isStopPropagationForAgGrid)(mouseEvent)) {
            return;
        }
        switch (eventName) {
            case 'click':
                this.onCellClicked(mouseEvent);
                break;
            case 'mousedown':
            case 'touchstart':
                this.onMouseDown(mouseEvent);
                break;
            case 'dblclick':
                this.onCellDoubleClicked(mouseEvent);
                break;
            case 'mouseout':
                this.onMouseOut(mouseEvent);
                break;
            case 'mouseover':
                this.onMouseOver(mouseEvent);
                break;
        }
    }
    onCellClicked(event) {
        // iPad doesn't have double click - so we need to mimic it to enable editing for iPad.
        if (this.beans.touchSvc?.handleCellDoubleClick(this, event)) {
            return;
        }
        const { eventSvc, rangeSvc, editSvc, editModelSvc, frameworkOverrides } = this.beans;
        const isMultiKey = event.ctrlKey || event.metaKey;
        const { cellCtrl } = this;
        const { column, cellPosition } = cellCtrl;
        if (rangeSvc && isMultiKey) {
            // the mousedown event has created the range already, so we only intersect if there is more than one
            // range on this cell
            if (rangeSvc.getCellRangeCount(cellPosition) > 1) {
                rangeSvc.intersectLastRange(true);
            }
        }
        const cellClickedEvent = cellCtrl.createEvent(event, 'cellClicked');
        eventSvc.dispatchEvent(cellClickedEvent);
        const colDef = column.getColDef();
        if (colDef.onCellClicked) {
            // to make callback async, do in a timeout
            window.setTimeout(() => {
                frameworkOverrides.wrapOutgoing(() => {
                    colDef.onCellClicked(cellClickedEvent);
                });
            }, 0);
        }
        if (editModelSvc?.getState(cellCtrl) !== 'editing') {
            const editing = editSvc?.isEditing();
            const cellValidations = editModelSvc?.getCellValidationModel().getCellValidationMap().size ?? 0;
            const rowValidations = editModelSvc?.getRowValidationModel().getRowValidationMap().size ?? 0;
            if (editing && (cellValidations > 0 || rowValidations > 0)) {
                return;
            }
            if (editSvc?.shouldStartEditing(cellCtrl, event)) {
                editSvc?.startEditing(cellCtrl, { event });
            }
            else if (editSvc?.shouldStopEditing(cellCtrl, event)) {
                editSvc?.stopEditing(cellCtrl);
            }
        }
    }
    onCellDoubleClicked(event) {
        const { column, beans, cellCtrl } = this;
        const { eventSvc, frameworkOverrides, editSvc, editModelSvc } = beans;
        const colDef = column.getColDef();
        // always dispatch event to eventService
        const cellDoubleClickedEvent = cellCtrl.createEvent(event, 'cellDoubleClicked');
        eventSvc.dispatchEvent(cellDoubleClickedEvent);
        // check if colDef also wants to handle event
        if (typeof colDef.onCellDoubleClicked === 'function') {
            // to make the callback async, do in a timeout
            window.setTimeout(() => {
                frameworkOverrides.wrapOutgoing(() => {
                    colDef.onCellDoubleClicked(cellDoubleClickedEvent);
                });
            }, 0);
        }
        if (editSvc?.shouldStartEditing(this.cellCtrl, event) &&
            this.beans.editModelSvc?.getState(this.cellCtrl) !== 'editing') {
            const editing = editSvc?.isEditing();
            const cellValidations = editModelSvc?.getCellValidationModel().getCellValidationMap().size ?? 0;
            const rowValidations = editModelSvc?.getRowValidationModel().getRowValidationMap().size ?? 0;
            if (editing && (cellValidations > 0 || rowValidations > 0)) {
                return;
            }
            editSvc?.startEditing(cellCtrl, { event });
        }
    }
    onMouseDown(mouseEvent) {
        const { ctrlKey, metaKey, shiftKey } = mouseEvent;
        const target = mouseEvent.target;
        const { cellCtrl, beans } = this;
        const { eventSvc, rangeSvc, rowNumbersSvc, focusSvc, gos, editSvc } = beans;
        // do not change the range for right-clicks inside an existing range
        if (this.isRightClickInExistingRange(mouseEvent)) {
            return;
        }
        const hasRanges = rangeSvc && !rangeSvc.isEmpty();
        const containsWidget = this.containsWidget(target);
        const { cellPosition, column } = cellCtrl;
        const isRowNumberColumn = (0, columnUtils_1.isRowNumberCol)(column);
        if (rowNumbersSvc && isRowNumberColumn && !rowNumbersSvc.handleMouseDownOnCell(cellPosition, mouseEvent)) {
            if (rangeSvc) {
                mouseEvent.preventDefault();
            }
            mouseEvent.stopImmediatePropagation();
            return;
        }
        if (!shiftKey || !hasRanges) {
            const editing = editSvc?.isEditing(cellCtrl);
            const isEnableCellTextSelection = gos.get('enableCellTextSelection');
            // when `enableCellTextSelection` is true, we call prevent default on `mousedown`
            // within the row dragger to block text selection while dragging, but the cell
            // should still be selected/focused.
            const shouldFocus = isEnableCellTextSelection && mouseEvent.defaultPrevented;
            // however, this should never be true if the mousedown was triggered
            // due to a click on a cell editor for example, otherwise cell selection within
            // an editor would be blocked.
            const forceBrowserFocus = ((0, browser_1._isBrowserSafari)() || shouldFocus) && !editing && !(0, dom_1._isFocusableFormField)(target) && !containsWidget;
            cellCtrl.focusCell(forceBrowserFocus, mouseEvent);
        }
        // if shift clicking, and a range exists, we keep the focus on the cell that started the
        // range as the user then changes the range selection.
        if (shiftKey && hasRanges && !focusSvc.isCellFocused(cellPosition)) {
            // this stops the cell from getting focused
            mouseEvent.preventDefault();
            const focusedCell = focusSvc.getFocusedCell();
            if (focusedCell) {
                const { column, rowIndex, rowPinned } = focusedCell;
                // if the focused cell is editing, need to stop editing first
                if (editSvc?.isEditing(focusedCell)) {
                    editSvc?.stopEditing(focusedCell);
                }
                // focus could have been lost, so restore it to the starting cell in the range if needed
                focusSvc.setFocusedCell({
                    column,
                    rowIndex,
                    rowPinned,
                    forceBrowserFocus: true,
                    preventScrollOnBrowserFocus: true,
                    sourceEvent: mouseEvent,
                });
            }
        }
        // if we are clicking on a checkbox, we need to make sure the cell wrapping that checkbox
        // is focused but we don't want to change the range selection, so return here.
        if (containsWidget) {
            return;
        }
        if (rangeSvc) {
            if (isRowNumberColumn) {
                mouseEvent.preventDefault();
            }
            const hasRightClickedOnRowNumber = (0, mouse_1._interpretAsRightClick)(this.beans, mouseEvent) && isRowNumberColumn;
            if (shiftKey) {
                rangeSvc.extendLatestRangeToCell(cellPosition);
            }
            else if (!hasRightClickedOnRowNumber) {
                const isMultiKey = ctrlKey || metaKey;
                rangeSvc.setRangeToCell(cellPosition, isMultiKey);
            }
        }
        eventSvc.dispatchEvent(this.cellCtrl.createEvent(mouseEvent, 'cellMouseDown'));
    }
    isRightClickInExistingRange(mouseEvent) {
        const { rangeSvc } = this.beans;
        if (rangeSvc) {
            const cellInRange = rangeSvc.isCellInAnyRange(this.cellCtrl.cellPosition);
            const isRightClick = (0, mouse_1._interpretAsRightClick)(this.beans, mouseEvent);
            if (cellInRange && isRightClick) {
                return true;
            }
        }
        return false;
    }
    containsWidget(target) {
        return ((0, dom_1._isElementChildOfClass)(target, 'ag-selection-checkbox', 3) ||
            (0, dom_1._isElementChildOfClass)(target, 'ag-drag-handle', 3));
    }
    onMouseOut(mouseEvent) {
        if (this.mouseStayingInsideCell(mouseEvent)) {
            return;
        }
        const { eventSvc, colHover } = this.beans;
        eventSvc.dispatchEvent(this.cellCtrl.createEvent(mouseEvent, 'cellMouseOut'));
        colHover?.clearMouseOver();
    }
    onMouseOver(mouseEvent) {
        if (this.mouseStayingInsideCell(mouseEvent)) {
            return;
        }
        const { eventSvc, colHover } = this.beans;
        eventSvc.dispatchEvent(this.cellCtrl.createEvent(mouseEvent, 'cellMouseOver'));
        colHover?.setMouseOver([this.column]);
    }
    mouseStayingInsideCell(e) {
        if (!e.target || !e.relatedTarget) {
            return false;
        }
        const eCell = this.cellCtrl.eGui;
        const cellContainsTarget = eCell.contains(e.target);
        const cellContainsRelatedTarget = eCell.contains(e.relatedTarget);
        return cellContainsTarget && cellContainsRelatedTarget;
    }
}
exports.CellMouseListenerFeature = CellMouseListenerFeature;


/***/ }),

/***/ 63976:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CellPositionFeature = void 0;
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const array_1 = __webpack_require__(31502);
const generic_1 = __webpack_require__(34422);
/**
 * Takes care of:
 *  #) Cell Width (including when doing cell spanning, which makes width cover many columns)
 *  #) Cell Height (when doing row span, otherwise we don't touch the height as it's just row height)
 *  #) Cell Left (the horizontal positioning of the cell, the vertical positioning is on the row)
 */
class CellPositionFeature extends beanStub_1.BeanStub {
    constructor(cellCtrl, beans) {
        super();
        this.cellCtrl = cellCtrl;
        this.beans = beans;
        this.column = cellCtrl.column;
        this.rowNode = cellCtrl.rowNode;
    }
    setupRowSpan() {
        this.rowSpan = this.column.getRowSpan(this.rowNode);
        this.addManagedListeners(this.beans.eventSvc, { newColumnsLoaded: () => this.onNewColumnsLoaded() });
    }
    init() {
        this.eSetLeft = this.cellCtrl.getRootElement();
        this.eContent = this.cellCtrl.eGui;
        const cellSpan = this.cellCtrl.getCellSpan();
        // add event handlers only after GUI is attached,
        // so we don't get events before we are ready
        if (!cellSpan) {
            this.setupColSpan();
            this.setupRowSpan();
        }
        this.onLeftChanged();
        this.onWidthChanged();
        if (!cellSpan) {
            this._legacyApplyRowSpan();
        }
        if (cellSpan) {
            const refreshSpanHeight = this.refreshSpanHeight.bind(this, cellSpan);
            refreshSpanHeight();
            this.addManagedListeners(this.beans.eventSvc, {
                paginationChanged: refreshSpanHeight,
                recalculateRowBounds: refreshSpanHeight,
                pinnedHeightChanged: refreshSpanHeight,
            });
        }
    }
    refreshSpanHeight(cellSpan) {
        const spanHeight = cellSpan.getCellHeight();
        if (spanHeight != null) {
            this.eContent.style.height = `${spanHeight}px`;
        }
    }
    onNewColumnsLoaded() {
        const rowSpan = this.column.getRowSpan(this.rowNode);
        if (this.rowSpan === rowSpan) {
            return;
        }
        this.rowSpan = rowSpan;
        this._legacyApplyRowSpan(true);
    }
    onDisplayColumnsChanged() {
        const colsSpanning = this.getColSpanningList();
        if (!(0, array_1._areEqual)(this.colsSpanning, colsSpanning)) {
            this.colsSpanning = colsSpanning;
            this.onWidthChanged();
            this.onLeftChanged(); // left changes when doing RTL
        }
    }
    setupColSpan() {
        // if no col span is active, then we don't set it up, as it would be wasteful of CPU
        if (this.column.getColDef().colSpan == null) {
            return;
        }
        this.colsSpanning = this.getColSpanningList();
        this.addManagedListeners(this.beans.eventSvc, {
            // because we are col spanning, a reorder of the cols can change what cols we are spanning over
            displayedColumnsChanged: this.onDisplayColumnsChanged.bind(this),
            // because we are spanning over multiple cols, we check for width any time any cols width changes.
            // this is expensive - really we should be explicitly checking only the cols we are spanning over
            // instead of every col, however it would be tricky code to track the cols we are spanning over, so
            // because hardly anyone will be using colSpan, am favouring this easier way for more maintainable code.
            displayedColumnsWidthChanged: this.onWidthChanged.bind(this),
        });
    }
    onWidthChanged() {
        if (!this.eContent) {
            return;
        }
        const width = this.getCellWidth();
        this.eContent.style.width = `${width}px`;
    }
    getCellWidth() {
        if (!this.colsSpanning) {
            return this.column.getActualWidth();
        }
        return this.colsSpanning.reduce((width, col) => width + col.getActualWidth(), 0);
    }
    getColSpanningList() {
        const { column, rowNode } = this;
        const colSpan = column.getColSpan(rowNode);
        const colsSpanning = [];
        // if just one col, the col span is just the column we are in
        if (colSpan === 1) {
            colsSpanning.push(column);
        }
        else {
            let pointer = column;
            const pinned = column.getPinned();
            for (let i = 0; pointer && i < colSpan; i++) {
                colsSpanning.push(pointer);
                pointer = this.beans.visibleCols.getColAfter(pointer);
                if (!pointer || (0, generic_1._missing)(pointer)) {
                    break;
                }
                // we do not allow col spanning to span outside of pinned areas
                if (pinned !== pointer.getPinned()) {
                    break;
                }
            }
        }
        return colsSpanning;
    }
    onLeftChanged() {
        if (!this.eSetLeft) {
            return;
        }
        const left = this.modifyLeftForPrintLayout(this.getCellLeft());
        this.eSetLeft.style.left = left + 'px';
    }
    getCellLeft() {
        let mostLeftCol;
        if (this.beans.gos.get('enableRtl') && this.colsSpanning) {
            mostLeftCol = (0, array_1._last)(this.colsSpanning);
        }
        else {
            mostLeftCol = this.column;
        }
        return mostLeftCol.getLeft();
    }
    modifyLeftForPrintLayout(leftPosition) {
        if (!this.cellCtrl.printLayout || this.column.getPinned() === 'left') {
            return leftPosition;
        }
        const { visibleCols } = this.beans;
        const leftWidth = visibleCols.getColsLeftWidth();
        if (this.column.getPinned() === 'right') {
            const bodyWidth = visibleCols.bodyWidth;
            return leftWidth + bodyWidth + (leftPosition || 0);
        }
        // is in body
        return leftWidth + (leftPosition || 0);
    }
    _legacyApplyRowSpan(force) {
        if (this.rowSpan === 1 && !force) {
            return;
        }
        const singleRowHeight = (0, gridOptionsUtils_1._getRowHeightAsNumber)(this.beans);
        const totalRowHeight = singleRowHeight * this.rowSpan;
        this.eContent.style.height = `${totalRowHeight}px`;
        this.eContent.style.zIndex = '1';
    }
    // overriding to make public, as we don't dispose this bean via context
    destroy() {
        super.destroy();
    }
}
exports.CellPositionFeature = CellPositionFeature;


/***/ }),

/***/ 30916:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.flashCells = void 0;
function flashCells(beans, params = {}) {
    const { cellFlashSvc } = beans;
    if (!cellFlashSvc) {
        return;
    }
    beans.frameworkOverrides.wrapIncoming(() => {
        beans.rowRenderer
            .getCellCtrls(params.rowNodes, params.columns)
            .forEach((cellCtrl) => cellFlashSvc.flashCell(cellCtrl, params));
    });
}
exports.flashCells = flashCells;


/***/ }),

/***/ 83498:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HighlightChangesModule = void 0;
const version_1 = __webpack_require__(97205);
const animateShowChangeCellRenderer_1 = __webpack_require__(48868);
const animateSlideCellRenderer_1 = __webpack_require__(72346);
const cellFlashService_1 = __webpack_require__(34534);
const highlightChangesApi_1 = __webpack_require__(30916);
/**
 * @feature Cells -> Highlighting Changes
 * @colDef enableCellChangeFlash
 */
exports.HighlightChangesModule = {
    moduleName: 'HighlightChanges',
    version: version_1.VERSION,
    beans: [cellFlashService_1.CellFlashService],
    userComponents: {
        agAnimateShowChangeCellRenderer: animateShowChangeCellRenderer_1.AnimateShowChangeCellRenderer,
        agAnimateSlideCellRenderer: animateSlideCellRenderer_1.AnimateSlideCellRenderer,
    },
    apiFunctions: {
        flashCells: highlightChangesApi_1.flashCells,
    },
};


/***/ }),

/***/ 48868:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnimateShowChangeCellRenderer = void 0;
const dom_1 = __webpack_require__(33507);
const generic_1 = __webpack_require__(34422);
const component_1 = __webpack_require__(78020);
const ARROW_UP = '\u2191';
const ARROW_DOWN = '\u2193';
const AnimateShowChangeCellRendererElement = {
    tag: 'span',
    children: [
        { tag: 'span', ref: 'eDelta', cls: 'ag-value-change-delta' },
        { tag: 'span', ref: 'eValue', cls: 'ag-value-change-value' },
    ],
};
class AnimateShowChangeCellRenderer extends component_1.Component {
    constructor() {
        super(AnimateShowChangeCellRendererElement);
        this.eValue = component_1.RefPlaceholder;
        this.eDelta = component_1.RefPlaceholder;
        this.refreshCount = 0;
    }
    init(params) {
        this.refresh(params, true);
    }
    showDelta(params, delta) {
        const absDelta = Math.abs(delta);
        const valueFormatted = params.formatValue(absDelta);
        const valueToUse = (0, generic_1._exists)(valueFormatted) ? valueFormatted : absDelta;
        const deltaUp = delta >= 0;
        const eDelta = this.eDelta;
        if (deltaUp) {
            eDelta.textContent = ARROW_UP + valueToUse;
        }
        else {
            // because negative, use ABS to remove sign
            eDelta.textContent = ARROW_DOWN + valueToUse;
        }
        eDelta.classList.toggle('ag-value-change-delta-up', deltaUp);
        eDelta.classList.toggle('ag-value-change-delta-down', !deltaUp);
    }
    setTimerToRemoveDelta() {
        // the refreshCount makes sure that if the value updates again while
        // the below timer is waiting, then the below timer will realise it
        // is not the most recent and will not try to remove the delta value.
        this.refreshCount++;
        const refreshCountCopy = this.refreshCount;
        this.beans.frameworkOverrides.wrapIncoming(() => {
            window.setTimeout(() => {
                if (refreshCountCopy === this.refreshCount) {
                    this.hideDeltaValue();
                }
            }, 2000);
        });
    }
    hideDeltaValue() {
        this.eValue.classList.remove('ag-value-change-value-highlight');
        (0, dom_1._clearElement)(this.eDelta);
    }
    refresh(params, isInitialRender = false) {
        const { value, valueFormatted } = params;
        const { eValue, lastValue, beans } = this;
        if (value === lastValue) {
            return false;
        }
        if ((0, generic_1._exists)(valueFormatted)) {
            eValue.textContent = valueFormatted;
        }
        else if ((0, generic_1._exists)(value)) {
            eValue.textContent = value;
        }
        else {
            (0, dom_1._clearElement)(eValue);
        }
        // we don't show the delta if we are in the middle of a filter. see comment on FilterManager
        // with regards processingFilterChange
        if (beans.filterManager?.isSuppressFlashingCellsBecauseFiltering()) {
            return false;
        }
        const numericValue = value && typeof value === 'object' && 'toNumber' in value ? value.toNumber() : value;
        const numericLastValue = lastValue && typeof lastValue === 'object' && 'toNumber' in lastValue ? lastValue.toNumber() : lastValue;
        if (numericValue === numericLastValue) {
            return false;
        }
        if (typeof numericValue === 'number' && typeof numericLastValue === 'number') {
            const delta = numericValue - numericLastValue;
            this.showDelta(params, delta);
        }
        // highlight the current value, but only if it's not new, otherwise it
        // would get highlighted first time the value is shown
        if (lastValue) {
            eValue.classList.add('ag-value-change-value-highlight');
        }
        if (!isInitialRender) {
            this.setTimerToRemoveDelta();
        }
        this.lastValue = value;
        return true;
    }
}
exports.AnimateShowChangeCellRenderer = AnimateShowChangeCellRenderer;


/***/ }),

/***/ 79707:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.animateSlideCellRendererCSS = void 0;
exports.animateSlideCellRendererCSS = `.ag-value-slide-out{opacity:1}:where(.ag-ltr) .ag-value-slide-out{margin-right:5px;transition:opacity 3s,margin-right 3s}:where(.ag-rtl) .ag-value-slide-out{margin-left:5px;transition:opacity 3s,margin-left 3s}:where(.ag-ltr,.ag-rtl) .ag-value-slide-out{transition-timing-function:linear}.ag-value-slide-out-end{opacity:0}:where(.ag-ltr) .ag-value-slide-out-end{margin-right:10px}:where(.ag-rtl) .ag-value-slide-out-end{margin-left:10px}`;


/***/ }),

/***/ 72346:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnimateSlideCellRenderer = void 0;
const dom_1 = __webpack_require__(33507);
const generic_1 = __webpack_require__(34422);
const component_1 = __webpack_require__(78020);
const animateSlideCellRenderer_css_GENERATED_1 = __webpack_require__(79707);
const AnimateSlideCellRendererElement = {
    tag: 'span',
    children: [{ tag: 'span', ref: 'eCurrent', cls: 'ag-value-slide-current' }],
};
class AnimateSlideCellRenderer extends component_1.Component {
    constructor() {
        super(AnimateSlideCellRendererElement);
        this.eCurrent = component_1.RefPlaceholder;
        this.refreshCount = 0;
        this.registerCSS(animateSlideCellRenderer_css_GENERATED_1.animateSlideCellRendererCSS);
    }
    init(params) {
        this.refresh(params, true);
    }
    addSlideAnimation() {
        this.refreshCount++;
        // below we keep checking this, and stop working on the animation
        // if it no longer matches - this means another animation has started
        // and this one is stale.
        const refreshCountCopy = this.refreshCount;
        // if old animation, remove it
        if (this.ePrevious) {
            this.getGui().removeChild(this.ePrevious);
        }
        const { beans, eCurrent } = this;
        const prevElement = (0, dom_1._createElement)({ tag: 'span', cls: 'ag-value-slide-previous ag-value-slide-out' });
        this.ePrevious = prevElement;
        prevElement.textContent = eCurrent.textContent;
        this.getGui().insertBefore(prevElement, eCurrent);
        // having timeout of 0 allows use to skip to the next css turn,
        // so we know the previous css classes have been applied. so the
        // complex set of setTimeout below creates the animation
        beans.frameworkOverrides.wrapIncoming(() => {
            window.setTimeout(() => {
                if (refreshCountCopy !== this.refreshCount) {
                    return;
                }
                this.ePrevious.classList.add('ag-value-slide-out-end');
            }, 50);
            window.setTimeout(() => {
                if (refreshCountCopy !== this.refreshCount) {
                    return;
                }
                this.getGui().removeChild(this.ePrevious);
                this.ePrevious = null;
            }, 3000);
        });
    }
    refresh(params, isInitialRender = false) {
        let value = params.value;
        if ((0, generic_1._missing)(value)) {
            value = '';
        }
        if (value === this.lastValue) {
            return false;
        }
        // we don't show the delta if we are in the middle of a filter. see comment on FilterManager
        // with regards processingFilterChange
        if (this.beans.filterManager?.isSuppressFlashingCellsBecauseFiltering()) {
            return false;
        }
        if (!isInitialRender) {
            this.addSlideAnimation();
        }
        this.lastValue = value;
        const eCurrent = this.eCurrent;
        if ((0, generic_1._exists)(params.valueFormatted)) {
            eCurrent.textContent = params.valueFormatted;
        }
        else if ((0, generic_1._exists)(params.value)) {
            eCurrent.textContent = value;
        }
        else {
            (0, dom_1._clearElement)(eCurrent);
        }
        return true;
    }
}
exports.AnimateSlideCellRenderer = AnimateSlideCellRenderer;


/***/ }),

/***/ 37358:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SkeletonCellRendererModule = exports.CheckboxCellRendererModule = void 0;
const version_1 = __webpack_require__(97205);
const checkboxCellRenderer_1 = __webpack_require__(23987);
const skeletonCellRenderer_1 = __webpack_require__(97717);
/**
 * @feature Cells -> Cell Data Types
 * @colDef cellDataType
 */
exports.CheckboxCellRendererModule = {
    moduleName: 'CheckboxCellRenderer',
    version: version_1.VERSION,
    userComponents: {
        agCheckboxCellRenderer: checkboxCellRenderer_1.CheckboxCellRenderer,
    },
};
/**
 * @internal
 */
exports.SkeletonCellRendererModule = {
    moduleName: 'SkeletonCellRenderer',
    version: version_1.VERSION,
    userComponents: {
        agSkeletonCellRenderer: skeletonCellRenderer_1.SkeletonCellRenderer,
    },
};


/***/ }),

/***/ 72522:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkboxCellRendererCSS = void 0;
exports.checkboxCellRendererCSS = `.ag-checkbox-cell{height:100%}`;


/***/ }),

/***/ 23987:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CheckboxCellRenderer = void 0;
const columnUtils_1 = __webpack_require__(73146);
const keyCode_1 = __webpack_require__(39853);
const gridOptionsUtils_1 = __webpack_require__(67274);
const aria_1 = __webpack_require__(95230);
const event_1 = __webpack_require__(92979);
const agCheckbox_1 = __webpack_require__(90066);
const component_1 = __webpack_require__(78020);
const checkboxCellRenderer_css_GENERATED_1 = __webpack_require__(72522);
const CheckboxCellRendererElement = {
    tag: 'div',
    cls: 'ag-cell-wrapper ag-checkbox-cell',
    role: 'presentation',
    children: [
        {
            tag: 'ag-checkbox',
            ref: 'eCheckbox',
            role: 'presentation',
        },
    ],
};
class CheckboxCellRenderer extends component_1.Component {
    constructor() {
        super(CheckboxCellRendererElement, [agCheckbox_1.AgCheckboxSelector]);
        this.eCheckbox = component_1.RefPlaceholder;
        this.registerCSS(checkboxCellRenderer_css_GENERATED_1.checkboxCellRendererCSS);
    }
    init(params) {
        this.refresh(params);
        const { eCheckbox, beans } = this;
        const inputEl = eCheckbox.getInputElement();
        inputEl.setAttribute('tabindex', '-1');
        (0, aria_1._setAriaLive)(inputEl, 'polite');
        this.addManagedListeners(inputEl, {
            click: (event) => {
                (0, event_1._stopPropagationForAgGrid)(event);
                if (eCheckbox.isDisabled()) {
                    return;
                }
                const isSelected = eCheckbox.getValue();
                this.onCheckboxChanged(isSelected);
            },
            dblclick: (event) => {
                (0, event_1._stopPropagationForAgGrid)(event);
            },
        });
        this.addManagedElementListeners(params.eGridCell, {
            keydown: (event) => {
                if (event.key === keyCode_1.KeyCode.SPACE && !eCheckbox.isDisabled()) {
                    if (params.eGridCell === (0, gridOptionsUtils_1._getActiveDomElement)(beans)) {
                        eCheckbox.toggle();
                    }
                    const isSelected = eCheckbox.getValue();
                    this.onCheckboxChanged(isSelected);
                    event.preventDefault();
                }
            },
        });
    }
    refresh(params) {
        this.params = params;
        this.updateCheckbox(params);
        return true;
    }
    updateCheckbox(params) {
        let isSelected;
        let displayed = true;
        const { value, column, node } = params;
        if (node.group && column) {
            if (typeof value === 'boolean') {
                isSelected = value;
            }
            else {
                const colId = column.getColId();
                if (colId.startsWith(columnUtils_1.GROUP_AUTO_COLUMN_ID)) {
                    // if we're grouping by this column then the value is a string and we need to parse it
                    isSelected = value == null || value === '' ? undefined : value === 'true';
                }
                else if (node.aggData && node.aggData[colId] !== undefined) {
                    isSelected = value ?? undefined;
                }
                else {
                    displayed = false;
                }
            }
        }
        else {
            isSelected = value ?? undefined;
        }
        const { eCheckbox } = this;
        if (!displayed) {
            eCheckbox.setDisplayed(false);
            return;
        }
        eCheckbox.setValue(isSelected);
        const disabled = params.disabled ?? !column?.isCellEditable(node);
        eCheckbox.setDisabled(disabled);
        const translate = this.getLocaleTextFunc();
        const stateName = (0, aria_1._getAriaCheckboxStateName)(translate, isSelected);
        const ariaLabel = disabled
            ? stateName
            : `${translate('ariaToggleCellValue', 'Press SPACE to toggle cell value')} (${stateName})`;
        eCheckbox.setInputAriaLabel(ariaLabel);
    }
    onCheckboxChanged(isSelected) {
        const { params } = this;
        const { column, node, value } = params;
        // prep edit state
        this.beans?.editSvc?.setEditingCells([
            {
                column: column,
                colId: column.getColId(),
                rowIndex: node.rowIndex,
                rowPinned: node.rowPinned,
                state: 'changed',
                oldValue: value,
                newValue: value,
            },
        ], { update: true });
        // set new value
        const valueChanged = node.setDataValue(column, isSelected, 'renderer');
        // stop editing
        this.beans.editSvc?.stopEditing({
            rowNode: node,
            column,
        }, { source: this.beans.editSvc?.isBatchEditing() ? 'ui' : 'api' });
        if (!valueChanged) {
            // need to reset to original
            this.updateCheckbox(params);
        }
    }
}
exports.CheckboxCellRenderer = CheckboxCellRenderer;


/***/ }),

/***/ 97717:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SkeletonCellRenderer = void 0;
const aria_1 = __webpack_require__(95230);
const dom_1 = __webpack_require__(33507);
const component_1 = __webpack_require__(78020);
const SkeletonCellRendererElement = { tag: 'div', cls: 'ag-skeleton-container' };
class SkeletonCellRenderer extends component_1.Component {
    constructor() {
        super(SkeletonCellRendererElement);
    }
    init(params) {
        const id = `ag-cell-skeleton-renderer-${this.getCompId()}`;
        this.getGui().setAttribute('id', id);
        this.addDestroyFunc(() => (0, aria_1._setAriaLabelledBy)(params.eParentOfValue));
        (0, aria_1._setAriaLabelledBy)(params.eParentOfValue, id);
        if (params.deferRender) {
            this.setupLoading(params);
        }
        else {
            params.node.failedLoad ? this.setupFailed() : this.setupLoading(params);
        }
    }
    setupFailed() {
        const localeTextFunc = this.getLocaleTextFunc();
        this.getGui().textContent = localeTextFunc('loadingError', 'ERR');
        const ariaFailed = localeTextFunc('ariaSkeletonCellLoadingFailed', 'Row failed to load');
        (0, aria_1._setAriaLabel)(this.getGui(), ariaFailed);
    }
    setupLoading(params) {
        const skeletonEffect = (0, dom_1._createElement)({
            tag: 'div',
            cls: 'ag-skeleton-effect',
        });
        // Use the row index to derive a width value for the skeleton cell
        // to avoid them having uniform width when rendering
        const rowIndex = params.node.rowIndex;
        if (rowIndex != null) {
            // Base value of 75% with variation between [-25%, 25%]. We alternate between sin and
            // cos to achieve a semi-random appearance without actually needing a random number.
            // We avoid using random numbers because then skeletons have consistent widths after
            // being scrolled on and off screen.
            const width = 75 + 25 * (rowIndex % 2 === 0 ? Math.sin(rowIndex) : Math.cos(rowIndex));
            skeletonEffect.style.width = `${width}%`;
        }
        this.getGui().appendChild(skeletonEffect);
        const localeTextFunc = this.getLocaleTextFunc();
        const ariaLoading = params.deferRender
            ? localeTextFunc('ariaDeferSkeletonCellLoading', 'Cell is loading')
            : localeTextFunc('ariaSkeletonCellLoading', 'Row data is loading');
        (0, aria_1._setAriaLabel)(this.getGui(), ariaLoading);
    }
    refresh(_params) {
        return false;
    }
}
exports.SkeletonCellRenderer = SkeletonCellRenderer;


/***/ }),

/***/ 21734:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CssClassManager = void 0;
class CssClassManager {
    constructor(getGui) {
        // to minimise DOM hits, we only apply CSS classes if they have changed. as adding a CSS class that is already
        // there, or removing one that wasn't present, all takes CPU.
        this.cssClassStates = {};
        this.getGui = getGui;
    }
    toggleCss(className, addOrRemove) {
        if (!className) {
            return;
        }
        // we check for spaces before doing the split, as doing the split
        // created a performance problem (on windows only, see AG-6765)
        if (className.indexOf(' ') >= 0) {
            const list = (className || '').split(' ');
            if (list.length > 1) {
                list.forEach((cls) => this.toggleCss(cls, addOrRemove));
                return;
            }
        }
        const updateNeeded = this.cssClassStates[className] !== addOrRemove;
        if (updateNeeded && className.length) {
            this.getGui()?.classList.toggle(className, addOrRemove);
            this.cssClassStates[className] = addOrRemove;
        }
    }
}
exports.CssClassManager = CssClassManager;


/***/ }),

/***/ 60714:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DndSourceComp = void 0;
const gridOptionsUtils_1 = __webpack_require__(67274);
const icon_1 = __webpack_require__(59970);
const component_1 = __webpack_require__(78020);
const DndSourceElement = { tag: 'div', cls: 'ag-drag-handle ag-row-drag', attrs: { draggable: 'true' } };
class DndSourceComp extends component_1.Component {
    constructor(rowNode, column, eCell) {
        super(DndSourceElement);
        this.rowNode = rowNode;
        this.column = column;
        this.eCell = eCell;
    }
    postConstruct() {
        const eGui = this.getGui();
        eGui.appendChild((0, icon_1._createIconNoSpan)('rowDrag', this.beans, null));
        // we need to stop the event propagation here to avoid starting a range selection while dragging
        this.addGuiEventListener('mousedown', (e) => {
            e.stopPropagation();
        });
        this.addDragSource();
        this.checkVisibility();
    }
    addDragSource() {
        this.addGuiEventListener('dragstart', this.onDragStart.bind(this));
    }
    onDragStart(dragEvent) {
        const { rowNode, column, eCell, gos } = this;
        const providedOnRowDrag = column.getColDef().dndSourceOnRowDrag;
        const dataTransfer = dragEvent.dataTransfer;
        dataTransfer.setDragImage(eCell, 0, 0);
        if (providedOnRowDrag) {
            const params = (0, gridOptionsUtils_1._addGridCommonParams)(gos, {
                rowNode,
                dragEvent,
            });
            providedOnRowDrag(params);
        }
        else {
            // default behaviour is to convert data to json and set into drag component
            try {
                const jsonData = JSON.stringify(rowNode.data);
                dataTransfer.setData('application/json', jsonData);
                dataTransfer.setData('text/plain', jsonData);
            }
            catch (e) {
                // if we cannot convert the data to json, then we do not set the type
            }
        }
    }
    checkVisibility() {
        const visible = this.column.isDndSource(this.rowNode);
        this.setDisplayed(visible);
    }
}
exports.DndSourceComp = DndSourceComp;


/***/ }),

/***/ 2147:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PositionableFeature = void 0;
const beanStub_1 = __webpack_require__(68731);
const dom_1 = __webpack_require__(33507);
const RESIZE_CONTAINER_STYLE = 'ag-resizer-wrapper';
const makeDiv = (dataRefPrefix, classSuffix) => ({
    tag: 'div',
    ref: `${dataRefPrefix}Resizer`,
    cls: `ag-resizer ag-resizer-${classSuffix}`,
});
const RESIZE_TEMPLATE = {
    tag: 'div',
    cls: RESIZE_CONTAINER_STYLE,
    children: [
        makeDiv('eTopLeft', 'topLeft'),
        makeDiv('eTop', 'top'),
        makeDiv('eTopRight', 'topRight'),
        makeDiv('eRight', 'right'),
        makeDiv('eBottomRight', 'bottomRight'),
        makeDiv('eBottom', 'bottom'),
        makeDiv('eBottomLeft', 'bottomLeft'),
        makeDiv('eLeft', 'left'),
    ],
};
class PositionableFeature extends beanStub_1.BeanStub {
    wireBeans(beans) {
        this.popupSvc = beans.popupSvc;
        this.dragSvc = beans.dragSvc;
    }
    constructor(element, config) {
        super();
        this.element = element;
        this.dragStartPosition = {
            x: 0,
            y: 0,
        };
        this.position = {
            x: 0,
            y: 0,
        };
        this.lastSize = {
            width: -1,
            height: -1,
        };
        this.positioned = false;
        this.resizersAdded = false;
        this.resizeListeners = [];
        this.boundaryEl = null;
        this.isResizing = false;
        this.isMoving = false;
        this.resizable = {};
        this.movable = false;
        this.currentResizer = null;
        this.config = Object.assign({}, { popup: false }, config);
    }
    center() {
        const { clientHeight, clientWidth } = this.offsetParent;
        const x = clientWidth / 2 - this.getWidth() / 2;
        const y = clientHeight / 2 - this.getHeight() / 2;
        this.offsetElement(x, y);
    }
    initialisePosition() {
        if (this.positioned) {
            return;
        }
        const { centered, forcePopupParentAsOffsetParent, minWidth, width, minHeight, height, x, y } = this.config;
        if (!this.offsetParent) {
            this.setOffsetParent();
        }
        let computedMinHeight = 0;
        let computedMinWidth = 0;
        // here we don't use the main offset parent but the element's offsetParent
        // in order to calculated the minWidth and minHeight correctly
        const isElementVisible = (0, dom_1._isVisible)(this.element);
        if (isElementVisible) {
            const boundaryEl = this.findBoundaryElement();
            const offsetParentComputedStyles = window.getComputedStyle(boundaryEl);
            if (offsetParentComputedStyles.minWidth != null) {
                const paddingWidth = boundaryEl.offsetWidth - this.element.offsetWidth;
                computedMinWidth = parseInt(offsetParentComputedStyles.minWidth, 10) - paddingWidth;
            }
            if (offsetParentComputedStyles.minHeight != null) {
                const paddingHeight = boundaryEl.offsetHeight - this.element.offsetHeight;
                computedMinHeight = parseInt(offsetParentComputedStyles.minHeight, 10) - paddingHeight;
            }
        }
        this.minHeight = minHeight || computedMinHeight;
        this.minWidth = minWidth || computedMinWidth;
        if (width) {
            this.setWidth(width);
        }
        if (height) {
            this.setHeight(height);
        }
        if (!width || !height) {
            this.refreshSize();
        }
        if (centered) {
            this.center();
        }
        else if (x || y) {
            this.offsetElement(x, y);
        }
        else if (isElementVisible && forcePopupParentAsOffsetParent) {
            let boundaryEl = this.boundaryEl;
            let initialisedDuringPositioning = true;
            if (!boundaryEl) {
                boundaryEl = this.findBoundaryElement();
                initialisedDuringPositioning = false;
            }
            if (boundaryEl) {
                const top = parseFloat(boundaryEl.style.top);
                const left = parseFloat(boundaryEl.style.left);
                if (initialisedDuringPositioning) {
                    this.offsetElement(isNaN(left) ? 0 : left, isNaN(top) ? 0 : top);
                }
                else {
                    this.setPosition(left, top);
                }
            }
        }
        this.positioned = !!this.offsetParent;
    }
    isPositioned() {
        return this.positioned;
    }
    getPosition() {
        return this.position;
    }
    setMovable(movable, moveElement) {
        if (!this.config.popup || movable === this.movable) {
            return;
        }
        this.movable = movable;
        const params = this.moveElementDragListener || {
            eElement: moveElement,
            onDragStart: this.onMoveStart.bind(this),
            onDragging: this.onMove.bind(this),
            onDragStop: this.onMoveEnd.bind(this),
        };
        if (movable) {
            this.dragSvc?.addDragSource(params);
            this.moveElementDragListener = params;
        }
        else {
            this.dragSvc?.removeDragSource(params);
            this.moveElementDragListener = undefined;
        }
    }
    setResizable(resizable) {
        this.clearResizeListeners();
        if (resizable) {
            this.addResizers();
        }
        else {
            this.removeResizers();
        }
        if (typeof resizable === 'boolean') {
            if (resizable === false) {
                return;
            }
            resizable = {
                topLeft: resizable,
                top: resizable,
                topRight: resizable,
                right: resizable,
                bottomRight: resizable,
                bottom: resizable,
                bottomLeft: resizable,
                left: resizable,
            };
        }
        Object.keys(resizable).forEach((side) => {
            const resizableStructure = resizable;
            const isSideResizable = !!resizableStructure[side];
            const resizerEl = this.getResizerElement(side);
            const params = {
                dragStartPixels: 0,
                eElement: resizerEl,
                onDragStart: (e) => this.onResizeStart(e, side),
                onDragging: this.onResize.bind(this),
                onDragStop: (e) => this.onResizeEnd(e, side),
            };
            if (isSideResizable || (!this.isAlive() && !isSideResizable)) {
                if (isSideResizable) {
                    this.dragSvc?.addDragSource(params);
                    this.resizeListeners.push(params);
                    resizerEl.style.pointerEvents = 'all';
                }
                else {
                    resizerEl.style.pointerEvents = 'none';
                }
                this.resizable[side] = isSideResizable;
            }
        });
    }
    removeSizeFromEl() {
        this.element.style.removeProperty('height');
        this.element.style.removeProperty('width');
        this.element.style.removeProperty('flex');
    }
    restoreLastSize() {
        this.element.style.flex = '0 0 auto';
        const { height, width } = this.lastSize;
        if (width !== -1) {
            this.element.style.width = `${width}px`;
        }
        if (height !== -1) {
            this.element.style.height = `${height}px`;
        }
    }
    getHeight() {
        return this.element.offsetHeight;
    }
    setHeight(height) {
        const { popup } = this.config;
        const eGui = this.element;
        let isPercent = false;
        if (typeof height === 'string' && height.indexOf('%') !== -1) {
            (0, dom_1._setFixedHeight)(eGui, height);
            height = (0, dom_1._getAbsoluteHeight)(eGui);
            isPercent = true;
        }
        else {
            height = Math.max(this.minHeight, height);
            if (this.positioned) {
                const availableHeight = this.getAvailableHeight();
                if (availableHeight && height > availableHeight) {
                    height = availableHeight;
                }
            }
        }
        if (this.getHeight() === height) {
            return;
        }
        if (!isPercent) {
            if (popup) {
                (0, dom_1._setFixedHeight)(eGui, height);
            }
            else {
                eGui.style.height = `${height}px`;
                eGui.style.flex = '0 0 auto';
                this.lastSize.height = typeof height === 'number' ? height : parseFloat(height);
            }
        }
        else {
            eGui.style.maxHeight = 'unset';
            eGui.style.minHeight = 'unset';
        }
    }
    getAvailableHeight() {
        const { popup, forcePopupParentAsOffsetParent } = this.config;
        if (!this.positioned) {
            this.initialisePosition();
        }
        const { clientHeight } = this.offsetParent;
        if (!clientHeight) {
            return null;
        }
        const elRect = this.element.getBoundingClientRect();
        const offsetParentRect = this.offsetParent.getBoundingClientRect();
        const yPosition = popup ? this.position.y : elRect.top;
        const parentTop = popup ? 0 : offsetParentRect.top;
        // When `forcePopupParentAsOffsetParent`, there may be elements that appear after the resizable element, but aren't included in the height.
        // Take these into account here
        let additionalHeight = 0;
        if (forcePopupParentAsOffsetParent) {
            const parentEl = this.element.parentElement;
            if (parentEl) {
                const { bottom } = parentEl.getBoundingClientRect();
                additionalHeight = bottom - elRect.bottom;
            }
        }
        const availableHeight = clientHeight + parentTop - yPosition - additionalHeight;
        return availableHeight;
    }
    getWidth() {
        return this.element.offsetWidth;
    }
    setWidth(width) {
        const eGui = this.element;
        const { popup } = this.config;
        let isPercent = false;
        if (typeof width === 'string' && width.indexOf('%') !== -1) {
            (0, dom_1._setFixedWidth)(eGui, width);
            width = (0, dom_1._getAbsoluteWidth)(eGui);
            isPercent = true;
        }
        else if (this.positioned) {
            width = Math.max(this.minWidth, width);
            const { clientWidth } = this.offsetParent;
            const xPosition = popup ? this.position.x : this.element.getBoundingClientRect().left;
            if (clientWidth && width + xPosition > clientWidth) {
                width = clientWidth - xPosition;
            }
        }
        if (this.getWidth() === width) {
            return;
        }
        if (!isPercent) {
            if (this.config.popup) {
                (0, dom_1._setFixedWidth)(eGui, width);
            }
            else {
                eGui.style.width = `${width}px`;
                eGui.style.flex = ' unset';
                this.lastSize.width = typeof width === 'number' ? width : parseFloat(width);
            }
        }
        else {
            eGui.style.maxWidth = 'unset';
            eGui.style.minWidth = 'unset';
        }
    }
    offsetElement(x = 0, y = 0) {
        const { forcePopupParentAsOffsetParent } = this.config;
        const ePopup = forcePopupParentAsOffsetParent ? this.boundaryEl : this.element;
        if (!ePopup) {
            return;
        }
        this.popupSvc?.positionPopup({
            ePopup,
            keepWithinBounds: true,
            skipObserver: this.movable || this.isResizable(),
            updatePosition: () => ({ x, y }),
        });
        this.setPosition(parseFloat(ePopup.style.left), parseFloat(ePopup.style.top));
    }
    constrainSizeToAvailableHeight(constrain) {
        if (!this.config.forcePopupParentAsOffsetParent) {
            return;
        }
        const applyMaxHeightToElement = () => {
            const availableHeight = this.getAvailableHeight();
            this.element.style.setProperty('max-height', `${availableHeight}px`);
        };
        if (constrain && this.popupSvc) {
            this.resizeObserverSubscriber?.();
            this.resizeObserverSubscriber = (0, dom_1._observeResize)(this.beans, this.popupSvc?.getPopupParent(), applyMaxHeightToElement);
        }
        else {
            this.element.style.removeProperty('max-height');
            if (this.resizeObserverSubscriber) {
                this.resizeObserverSubscriber();
                this.resizeObserverSubscriber = undefined;
            }
        }
    }
    setPosition(x, y) {
        this.position.x = x;
        this.position.y = y;
    }
    updateDragStartPosition(x, y) {
        this.dragStartPosition = { x, y };
    }
    calculateMouseMovement(params) {
        const { e, isLeft, isTop, anywhereWithin, topBuffer } = params;
        const xDiff = e.clientX - this.dragStartPosition.x;
        const yDiff = e.clientY - this.dragStartPosition.y;
        const movementX = this.shouldSkipX(e, !!isLeft, !!anywhereWithin, xDiff) ? 0 : xDiff;
        const movementY = this.shouldSkipY(e, !!isTop, topBuffer, yDiff) ? 0 : yDiff;
        return { movementX, movementY };
    }
    shouldSkipX(e, isLeft, anywhereWithin, diff) {
        const elRect = this.element.getBoundingClientRect();
        const parentRect = this.offsetParent.getBoundingClientRect();
        const boundaryElRect = this.boundaryEl.getBoundingClientRect();
        const xPosition = this.config.popup ? this.position.x : elRect.left;
        // skip if cursor is outside of popupParent horizontally
        let skipX = (xPosition <= 0 && parentRect.left >= e.clientX) ||
            (parentRect.right <= e.clientX && parentRect.right <= boundaryElRect.right);
        if (skipX) {
            return true;
        }
        if (isLeft) {
            skipX =
                // skip if we are moving to the left and the cursor
                // is positioned to the right of the left side anchor
                (diff < 0 && e.clientX > xPosition + parentRect.left) ||
                    // skip if we are moving to the right and the cursor
                    // is positioned to the left of the dialog
                    (diff > 0 && e.clientX < xPosition + parentRect.left);
        }
        else {
            if (anywhereWithin) {
                // if anywhereWithin is true, we allow to move
                // as long as the cursor is within the dialog
                skipX =
                    (diff < 0 && e.clientX > boundaryElRect.right) ||
                        (diff > 0 && e.clientX < xPosition + parentRect.left);
            }
            else {
                skipX =
                    // if the movement is bound to the right side of the dialog
                    // we skip if we are moving to the left and the cursor
                    // is to the right of the dialog
                    (diff < 0 && e.clientX > boundaryElRect.right) ||
                        // or skip if we are moving to the right and the cursor
                        // is to the left of the right side anchor
                        (diff > 0 && e.clientX < boundaryElRect.right);
            }
        }
        return skipX;
    }
    shouldSkipY(e, isTop, topBuffer = 0, diff) {
        const elRect = this.element.getBoundingClientRect();
        const parentRect = this.offsetParent.getBoundingClientRect();
        const boundaryElRect = this.boundaryEl.getBoundingClientRect();
        const yPosition = this.config.popup ? this.position.y : elRect.top;
        // skip if cursor is outside of popupParent vertically
        let skipY = (yPosition <= 0 && parentRect.top >= e.clientY) ||
            (parentRect.bottom <= e.clientY && parentRect.bottom <= boundaryElRect.bottom);
        if (skipY) {
            return true;
        }
        if (isTop) {
            skipY =
                // skip if we are moving to towards top and the cursor is
                // below the top anchor + topBuffer
                // note: topBuffer is used when moving the dialog using the title bar
                (diff < 0 && e.clientY > yPosition + parentRect.top + topBuffer) ||
                    // skip if we are moving to the bottom and the cursor is
                    // above the top anchor
                    (diff > 0 && e.clientY < yPosition + parentRect.top);
        }
        else {
            skipY =
                // skip if we are moving towards the top and the cursor
                // is below the bottom anchor
                (diff < 0 && e.clientY > boundaryElRect.bottom) ||
                    // skip if we are moving towards the bottom and the cursor
                    // is above the bottom anchor
                    (diff > 0 && e.clientY < boundaryElRect.bottom);
        }
        return skipY;
    }
    createResizeMap() {
        const getElement = (ref) => ({
            element: this.element.querySelector(`[data-ref=${ref}Resizer]`),
        });
        this.resizerMap = {
            topLeft: getElement('eTopLeft'),
            top: getElement('eTop'),
            topRight: getElement('eTopRight'),
            right: getElement('eRight'),
            bottomRight: getElement('eBottomRight'),
            bottom: getElement('eBottom'),
            bottomLeft: getElement('eBottomLeft'),
            left: getElement('eLeft'),
        };
    }
    addResizers() {
        if (this.resizersAdded) {
            return;
        }
        const eGui = this.element;
        if (!eGui) {
            return;
        }
        eGui.appendChild((0, dom_1._createElement)(RESIZE_TEMPLATE));
        this.createResizeMap();
        this.resizersAdded = true;
    }
    removeResizers() {
        this.resizerMap = undefined;
        const resizerEl = this.element.querySelector(`.${RESIZE_CONTAINER_STYLE}`);
        if (resizerEl) {
            this.element.removeChild(resizerEl);
        }
        this.resizersAdded = false;
    }
    getResizerElement(side) {
        return this.resizerMap[side].element;
    }
    onResizeStart(e, side) {
        this.boundaryEl = this.findBoundaryElement();
        if (!this.positioned) {
            this.initialisePosition();
        }
        this.currentResizer = {
            isTop: !!side.match(/top/i),
            isRight: !!side.match(/right/i),
            isBottom: !!side.match(/bottom/i),
            isLeft: !!side.match(/left/i),
        };
        this.element.classList.add('ag-resizing');
        this.resizerMap[side].element.classList.add('ag-active');
        const { popup, forcePopupParentAsOffsetParent } = this.config;
        if (!popup && !forcePopupParentAsOffsetParent) {
            this.applySizeToSiblings(this.currentResizer.isBottom || this.currentResizer.isTop);
        }
        this.isResizing = true;
        this.updateDragStartPosition(e.clientX, e.clientY);
    }
    getSiblings() {
        const element = this.element;
        const parent = element.parentElement;
        if (!parent) {
            return null;
        }
        return Array.prototype.slice
            .call(parent.children)
            .filter((el) => !el.classList.contains('ag-hidden'));
    }
    getMinSizeOfSiblings() {
        const siblings = this.getSiblings() || [];
        let height = 0;
        let width = 0;
        for (let i = 0; i < siblings.length; i++) {
            const currentEl = siblings[i];
            const isFlex = !!currentEl.style.flex && currentEl.style.flex !== '0 0 auto';
            if (currentEl === this.element) {
                continue;
            }
            let nextHeight = this.minHeight || 0;
            let nextWidth = this.minWidth || 0;
            if (isFlex) {
                const computedStyle = window.getComputedStyle(currentEl);
                if (computedStyle.minHeight) {
                    nextHeight = parseInt(computedStyle.minHeight, 10);
                }
                if (computedStyle.minWidth) {
                    nextWidth = parseInt(computedStyle.minWidth, 10);
                }
            }
            else {
                nextHeight = currentEl.offsetHeight;
                nextWidth = currentEl.offsetWidth;
            }
            height += nextHeight;
            width += nextWidth;
        }
        return { height, width };
    }
    applySizeToSiblings(vertical) {
        let containerToFlex = null;
        const siblings = this.getSiblings();
        if (!siblings) {
            return;
        }
        for (let i = 0; i < siblings.length; i++) {
            const el = siblings[i];
            if (el === containerToFlex) {
                continue;
            }
            if (vertical) {
                el.style.height = `${el.offsetHeight}px`;
            }
            else {
                el.style.width = `${el.offsetWidth}px`;
            }
            el.style.flex = '0 0 auto';
            if (el === this.element) {
                containerToFlex = siblings[i + 1];
            }
        }
        if (containerToFlex) {
            containerToFlex.style.removeProperty('height');
            containerToFlex.style.removeProperty('min-height');
            containerToFlex.style.removeProperty('max-height');
            containerToFlex.style.flex = '1 1 auto';
        }
    }
    isResizable() {
        return Object.values(this.resizable).some((value) => value);
    }
    onResize(e) {
        if (!this.isResizing || !this.currentResizer) {
            return;
        }
        const { popup, forcePopupParentAsOffsetParent } = this.config;
        const { isTop, isRight, isBottom, isLeft } = this.currentResizer;
        const isHorizontal = isRight || isLeft;
        const isVertical = isBottom || isTop;
        const { movementX, movementY } = this.calculateMouseMovement({ e, isLeft, isTop });
        const xPosition = this.position.x;
        const yPosition = this.position.y;
        let offsetLeft = 0;
        let offsetTop = 0;
        if (isHorizontal && movementX) {
            const direction = isLeft ? -1 : 1;
            const oldWidth = this.getWidth();
            const newWidth = oldWidth + movementX * direction;
            let skipWidth = false;
            if (isLeft) {
                offsetLeft = oldWidth - newWidth;
                if (xPosition + offsetLeft <= 0 || newWidth <= this.minWidth) {
                    skipWidth = true;
                    offsetLeft = 0;
                }
            }
            if (!skipWidth) {
                this.setWidth(newWidth);
            }
        }
        if (isVertical && movementY) {
            const direction = isTop ? -1 : 1;
            const oldHeight = this.getHeight();
            const newHeight = oldHeight + movementY * direction;
            let skipHeight = false;
            if (isTop) {
                offsetTop = oldHeight - newHeight;
                if (yPosition + offsetTop <= 0 || newHeight <= this.minHeight) {
                    skipHeight = true;
                    offsetTop = 0;
                }
            }
            else {
                // do not let the size of all siblings be higher than the parent container
                if (!this.config.popup &&
                    !this.config.forcePopupParentAsOffsetParent &&
                    oldHeight < newHeight &&
                    this.getMinSizeOfSiblings().height + newHeight > this.element.parentElement.offsetHeight) {
                    skipHeight = true;
                }
            }
            if (!skipHeight) {
                this.setHeight(newHeight);
            }
        }
        this.updateDragStartPosition(e.clientX, e.clientY);
        if (((popup || forcePopupParentAsOffsetParent) && offsetLeft) || offsetTop) {
            this.offsetElement(xPosition + offsetLeft, yPosition + offsetTop);
        }
    }
    onResizeEnd(e, side) {
        this.isResizing = false;
        this.currentResizer = null;
        this.boundaryEl = null;
        this.element.classList.remove('ag-resizing');
        this.resizerMap[side].element.classList.remove('ag-active');
        this.dispatchLocalEvent({ type: 'resize' });
    }
    refreshSize() {
        const eGui = this.element;
        if (this.config.popup) {
            if (!this.config.width) {
                this.setWidth(eGui.offsetWidth);
            }
            if (!this.config.height) {
                this.setHeight(eGui.offsetHeight);
            }
        }
    }
    onMoveStart(e) {
        this.boundaryEl = this.findBoundaryElement();
        if (!this.positioned) {
            this.initialisePosition();
        }
        this.isMoving = true;
        this.element.classList.add('ag-moving');
        this.updateDragStartPosition(e.clientX, e.clientY);
    }
    onMove(e) {
        if (!this.isMoving) {
            return;
        }
        const { x, y } = this.position;
        let topBuffer;
        if (this.config.calculateTopBuffer) {
            topBuffer = this.config.calculateTopBuffer();
        }
        const { movementX, movementY } = this.calculateMouseMovement({
            e,
            isTop: true,
            anywhereWithin: true,
            topBuffer,
        });
        this.offsetElement(x + movementX, y + movementY);
        this.updateDragStartPosition(e.clientX, e.clientY);
    }
    onMoveEnd() {
        this.isMoving = false;
        this.boundaryEl = null;
        this.element.classList.remove('ag-moving');
    }
    setOffsetParent() {
        if (this.config.forcePopupParentAsOffsetParent && this.popupSvc) {
            this.offsetParent = this.popupSvc.getPopupParent();
        }
        else {
            this.offsetParent = this.element.offsetParent;
        }
    }
    findBoundaryElement() {
        let el = this.element;
        while (el) {
            if (window.getComputedStyle(el).position !== 'static') {
                return el;
            }
            el = el.parentElement;
        }
        return this.element;
    }
    clearResizeListeners() {
        while (this.resizeListeners.length) {
            const params = this.resizeListeners.pop();
            this.dragSvc?.removeDragSource(params);
        }
    }
    destroy() {
        super.destroy();
        if (this.moveElementDragListener) {
            this.dragSvc?.removeDragSource(this.moveElementDragListener);
        }
        this.constrainSizeToAvailableHeight(false);
        this.clearResizeListeners();
        this.removeResizers();
    }
}
exports.PositionableFeature = PositionableFeature;


/***/ }),

/***/ 68703:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetLeftFeature = void 0;
const beanStub_1 = __webpack_require__(68731);
const agColumnGroup_1 = __webpack_require__(56908);
const gridOptionsUtils_1 = __webpack_require__(67274);
const aria_1 = __webpack_require__(95230);
const array_1 = __webpack_require__(31502);
const generic_1 = __webpack_require__(34422);
class SetLeftFeature extends beanStub_1.BeanStub {
    constructor(columnOrGroup, eCell, beans, colsSpanning) {
        super();
        this.columnOrGroup = columnOrGroup;
        this.eCell = eCell;
        this.colsSpanning = colsSpanning;
        this.columnOrGroup = columnOrGroup;
        this.ariaEl = eCell.querySelector('[role=columnheader]') || eCell;
        this.beans = beans;
    }
    setColsSpanning(colsSpanning) {
        this.colsSpanning = colsSpanning;
        this.onLeftChanged();
    }
    getColumnOrGroup() {
        const { beans, colsSpanning } = this;
        if (beans.gos.get('enableRtl') && colsSpanning) {
            return (0, array_1._last)(colsSpanning);
        }
        return this.columnOrGroup;
    }
    postConstruct() {
        const onLeftChanged = this.onLeftChanged.bind(this);
        this.addManagedListeners(this.columnOrGroup, { leftChanged: onLeftChanged });
        this.setLeftFirstTime();
        // when in print layout, the left position is also dependent on the width of the pinned sections.
        // so additionally update left if any column width changes.
        this.addManagedEventListeners({ displayedColumnsWidthChanged: onLeftChanged });
        // setting left has a dependency on print layout
        this.addManagedPropertyListener('domLayout', onLeftChanged);
    }
    setLeftFirstTime() {
        const { gos, colAnimation } = this.beans;
        const suppressMoveAnimation = gos.get('suppressColumnMoveAnimation');
        const oldLeftExists = (0, generic_1._exists)(this.columnOrGroup.getOldLeft());
        const animateColumnMove = colAnimation?.isActive() && oldLeftExists && !suppressMoveAnimation;
        if (animateColumnMove) {
            this.animateInLeft();
        }
        else {
            this.onLeftChanged();
        }
    }
    animateInLeft() {
        const colOrGroup = this.getColumnOrGroup();
        const oldActualLeft = this.modifyLeftForPrintLayout(colOrGroup, colOrGroup.getOldLeft());
        const actualLeft = this.modifyLeftForPrintLayout(colOrGroup, colOrGroup.getLeft());
        this.setLeft(oldActualLeft);
        // we must keep track of the left we want to set to, as this would otherwise lead to a race
        // condition, if the user changed the left value many times in one VM turn, then we want to make
        // make sure the actualLeft we set in the timeout below (in the next VM turn) is the correct left
        // position. eg if user changes column position twice, then setLeft() below executes twice in next
        // VM turn, but only one (the correct one) should get applied.
        this.actualLeft = actualLeft;
        this.beans.colAnimation.executeNextVMTurn(() => {
            // test this left value is the latest one to be applied, and if not, do nothing
            if (this.actualLeft === actualLeft) {
                this.setLeft(actualLeft);
            }
        });
    }
    onLeftChanged() {
        const colOrGroup = this.getColumnOrGroup();
        const left = colOrGroup.getLeft();
        this.actualLeft = this.modifyLeftForPrintLayout(colOrGroup, left);
        this.setLeft(this.actualLeft);
    }
    modifyLeftForPrintLayout(colOrGroup, leftPosition) {
        const { gos, visibleCols } = this.beans;
        const printLayout = (0, gridOptionsUtils_1._isDomLayout)(gos, 'print');
        if (!printLayout) {
            return leftPosition;
        }
        if (colOrGroup.getPinned() === 'left') {
            return leftPosition;
        }
        const leftWidth = visibleCols.getColsLeftWidth();
        if (colOrGroup.getPinned() === 'right') {
            const bodyWidth = visibleCols.bodyWidth;
            return leftWidth + bodyWidth + leftPosition;
        }
        // is in body
        return leftWidth + leftPosition;
    }
    setLeft(value) {
        // if the value is null, then that means the column is no longer
        // displayed. there is logic in the rendering to fade these columns
        // out, so we don't try and change their left positions.
        if ((0, generic_1._exists)(value)) {
            this.eCell.style.left = `${value}px`;
        }
        if ((0, agColumnGroup_1.isColumnGroup)(this.columnOrGroup)) {
            const children = this.columnOrGroup.getLeafColumns();
            if (!children.length) {
                return;
            }
            if (children.length > 1) {
                (0, aria_1._setAriaColSpan)(this.ariaEl, children.length);
            }
        }
    }
}
exports.SetLeftFeature = SetLeftFeature;


/***/ }),

/***/ 26105:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoadingOverlayComponent = void 0;
const generic_1 = __webpack_require__(34422);
const overlayComponent_1 = __webpack_require__(94679);
const LoadingOverlayElement = {
    tag: 'span',
    cls: 'ag-overlay-loading-center',
    attrs: { 'aria-live': 'polite', 'aria-atomic': 'true' },
};
class LoadingOverlayComponent extends overlayComponent_1.OverlayComponent {
    init() {
        const customTemplate = (0, generic_1._makeNull)(this.gos.get('overlayLoadingTemplate')?.trim());
        this.setTemplate(customTemplate ?? LoadingOverlayElement);
        if (!customTemplate) {
            const localeTextFunc = this.getLocaleTextFunc();
            // setTimeout is used because some screen readers only announce `aria-live` text when
            // there is a "text change", so we force a change from empty.
            setTimeout(() => {
                this.getGui().textContent = localeTextFunc('loadingOoo', 'Loading...');
            });
        }
    }
}
exports.LoadingOverlayComponent = LoadingOverlayComponent;


/***/ }),

/***/ 35233:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NoRowsOverlayComponent = void 0;
const generic_1 = __webpack_require__(34422);
const overlayComponent_1 = __webpack_require__(94679);
const NoRowsOverlayElement = { tag: 'span', cls: 'ag-overlay-no-rows-center' };
class NoRowsOverlayComponent extends overlayComponent_1.OverlayComponent {
    init() {
        const customTemplate = (0, generic_1._makeNull)(this.gos.get('overlayNoRowsTemplate')?.trim());
        this.setTemplate(customTemplate ?? NoRowsOverlayElement);
        if (!customTemplate) {
            const localeTextFunc = this.getLocaleTextFunc();
            // setTimeout is used because some screen readers only announce `aria-live` text when
            // there is a "text change", so we force a change from empty.
            setTimeout(() => {
                this.getGui().textContent = localeTextFunc('noRowsToShow', 'No Rows To Show');
            });
        }
    }
}
exports.NoRowsOverlayComponent = NoRowsOverlayComponent;


/***/ }),

/***/ 57896:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hideOverlay = exports.showNoRowsOverlay = exports.showLoadingOverlay = void 0;
function showLoadingOverlay(beans) {
    beans.overlays?.showLoadingOverlay();
}
exports.showLoadingOverlay = showLoadingOverlay;
function showNoRowsOverlay(beans) {
    beans.overlays?.showNoRowsOverlay();
}
exports.showNoRowsOverlay = showNoRowsOverlay;
function hideOverlay(beans) {
    beans.overlays?.hideOverlay();
}
exports.hideOverlay = hideOverlay;


/***/ }),

/***/ 94679:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OverlayComponent = void 0;
const component_1 = __webpack_require__(78020);
class OverlayComponent extends component_1.Component {
    constructor() {
        super();
    }
}
exports.OverlayComponent = OverlayComponent;


/***/ }),

/***/ 75366:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OverlayModule = void 0;
const version_1 = __webpack_require__(97205);
const loadingOverlayComponent_1 = __webpack_require__(26105);
const noRowsOverlayComponent_1 = __webpack_require__(35233);
const overlayApi_1 = __webpack_require__(57896);
const overlayService_1 = __webpack_require__(2351);
/**
 * @feature Accessories -> Overlays
 * @gridOption loading, overlayLoadingTemplate, loadingOverlayComponent, overlayNoRowsTemplate, noRowsOverlayComponent
 */
exports.OverlayModule = {
    moduleName: 'Overlay',
    version: version_1.VERSION,
    userComponents: {
        agLoadingOverlay: loadingOverlayComponent_1.LoadingOverlayComponent,
        agNoRowsOverlay: noRowsOverlayComponent_1.NoRowsOverlayComponent,
    },
    apiFunctions: {
        showLoadingOverlay: overlayApi_1.showLoadingOverlay,
        showNoRowsOverlay: overlayApi_1.showNoRowsOverlay,
        hideOverlay: overlayApi_1.hideOverlay,
    },
    beans: [overlayService_1.OverlayService],
};


/***/ }),

/***/ 2351:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OverlayService = void 0;
const userCompUtils_1 = __webpack_require__(12036);
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const logging_1 = __webpack_require__(47764);
const overlayWrapperComponent_1 = __webpack_require__(68360);
class OverlayService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'overlays';
        this.state = 0 /* OverlayServiceState.Hidden */;
        this.showInitialOverlay = true;
        this.wrapperPadding = 0;
    }
    postConstruct() {
        this.isClientSide = (0, gridOptionsUtils_1._isClientSideRowModel)(this.gos);
        this.isServerSide = !this.isClientSide && (0, gridOptionsUtils_1._isServerSideRowModel)(this.gos);
        const updateOverlayVisibility = () => this.updateOverlayVisibility();
        this.addManagedEventListeners({
            newColumnsLoaded: updateOverlayVisibility,
            rowDataUpdated: updateOverlayVisibility,
            gridSizeChanged: this.refreshWrapperPadding.bind(this),
            rowCountReady: () => {
                // Support hiding the initial overlay when data is set via transactions.
                this.showInitialOverlay = false;
                this.updateOverlayVisibility();
            },
        });
        this.addManagedPropertyListener('loading', updateOverlayVisibility);
    }
    setOverlayWrapperComp(overlayWrapperComp) {
        this.eWrapper = overlayWrapperComp;
        this.updateOverlayVisibility();
    }
    /** Returns true if the overlay is visible. */
    isVisible() {
        return this.state !== 0 /* OverlayServiceState.Hidden */ && !!this.eWrapper;
    }
    /** Returns true if the overlay is visible and is exclusive (popup over the grid) */
    isExclusive() {
        return this.state === 1 /* OverlayServiceState.Loading */ && !!this.eWrapper;
    }
    showLoadingOverlay() {
        this.showInitialOverlay = false;
        const gos = this.gos;
        const loading = gos.get('loading');
        if (!loading && (loading !== undefined || gos.get('suppressLoadingOverlay'))) {
            return;
        }
        this.doShowLoadingOverlay();
    }
    showNoRowsOverlay() {
        this.showInitialOverlay = false;
        const gos = this.gos;
        if (gos.get('loading') || gos.get('suppressNoRowsOverlay')) {
            return;
        }
        this.doShowNoRowsOverlay();
    }
    hideOverlay() {
        this.showInitialOverlay = false;
        if (this.gos.get('loading')) {
            (0, logging_1._warn)(99);
            return;
        }
        this.doHideOverlay();
    }
    getOverlayWrapperSelector() {
        return overlayWrapperComponent_1.OverlayWrapperSelector;
    }
    getOverlayWrapperCompClass() {
        return overlayWrapperComponent_1.OverlayWrapperComponent;
    }
    updateOverlayVisibility() {
        if (!this.eWrapper) {
            this.state = 0 /* OverlayServiceState.Hidden */;
            return;
        }
        const { state, isClientSide, isServerSide, beans: { gos, colModel, rowModel }, } = this;
        let loading = this.gos.get('loading');
        if (loading !== undefined) {
            // If loading is defined, we don't show the initial overlay.
            this.showInitialOverlay = false;
        }
        if (this.showInitialOverlay && loading === undefined && !gos.get('suppressLoadingOverlay')) {
            loading = !gos.get('columnDefs') || !colModel.ready || (!gos.get('rowData') && isClientSide);
        }
        if (loading) {
            if (state !== 1 /* OverlayServiceState.Loading */) {
                this.doShowLoadingOverlay();
            }
        }
        else {
            this.showInitialOverlay = false;
            if (isClientSide && rowModel.isEmpty() && !gos.get('suppressNoRowsOverlay')) {
                if (state !== 2 /* OverlayServiceState.NoRows */) {
                    this.doShowNoRowsOverlay();
                }
            }
            else if (state === 1 /* OverlayServiceState.Loading */ ||
                (!isServerSide && state !== 0 /* OverlayServiceState.Hidden */)) {
                this.doHideOverlay();
            }
        }
    }
    doShowLoadingOverlay() {
        if (!this.eWrapper) {
            return;
        }
        this.state = 1 /* OverlayServiceState.Loading */;
        this.showOverlay((0, userCompUtils_1._getLoadingOverlayCompDetails)(this.beans.userCompFactory, (0, gridOptionsUtils_1._addGridCommonParams)(this.gos, {})), 'ag-overlay-loading-wrapper', 'loadingOverlayComponentParams');
        this.updateExclusive();
    }
    doShowNoRowsOverlay() {
        if (!this.eWrapper) {
            return;
        }
        this.state = 2 /* OverlayServiceState.NoRows */;
        this.showOverlay((0, userCompUtils_1._getNoRowsOverlayCompDetails)(this.beans.userCompFactory, (0, gridOptionsUtils_1._addGridCommonParams)(this.gos, {})), 'ag-overlay-no-rows-wrapper', 'noRowsOverlayComponentParams');
        this.updateExclusive();
    }
    doHideOverlay() {
        if (!this.eWrapper) {
            return;
        }
        this.state = 0 /* OverlayServiceState.Hidden */;
        this.eWrapper.hideOverlay();
        this.updateExclusive();
    }
    showOverlay(compDetails, wrapperCssClass, gridOption) {
        const promise = compDetails?.newAgStackInstance() ?? null;
        this.eWrapper?.showOverlay(promise, wrapperCssClass, this.isExclusive(), gridOption);
        this.refreshWrapperPadding();
    }
    updateExclusive() {
        const wasExclusive = this.exclusive;
        this.exclusive = this.isExclusive();
        if (this.exclusive !== wasExclusive) {
            this.eventSvc.dispatchEvent({
                type: 'overlayExclusiveChanged',
            });
        }
    }
    refreshWrapperPadding() {
        const eWrapper = this.eWrapper;
        if (!eWrapper) {
            return;
        }
        let newPadding = 0;
        if (this.state === 2 /* OverlayServiceState.NoRows */) {
            const headerCtrl = this.beans.ctrlsSvc.get('gridHeaderCtrl');
            const headerHeight = headerCtrl?.headerHeight || 0;
            newPadding = headerHeight;
        }
        else if (this.wrapperPadding !== 0) {
            newPadding = 0;
        }
        if (this.wrapperPadding === newPadding) {
            return;
        }
        this.wrapperPadding = newPadding;
        eWrapper.updateOverlayWrapperPaddingTop(newPadding);
    }
}
exports.OverlayService = OverlayService;


/***/ }),

/***/ 73893:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.overlayWrapperComponentCSS = void 0;
exports.overlayWrapperComponentCSS = `.ag-overlay{inset:0;pointer-events:none;position:absolute;z-index:2}.ag-overlay-panel,.ag-overlay-wrapper{display:flex;height:100%;width:100%}.ag-overlay-wrapper{align-items:center;flex:none;justify-content:center;text-align:center}.ag-overlay-loading-wrapper{pointer-events:all}.ag-overlay-loading-center{background:var(--ag-background-color);border:solid var(--ag-border-width) var(--ag-border-color);border-radius:var(--ag-border-radius);box-shadow:var(--ag-popup-shadow);padding:var(--ag-spacing)}`;


/***/ }),

/***/ 68360:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OverlayWrapperSelector = exports.OverlayWrapperComponent = void 0;
const keyCode_1 = __webpack_require__(39853);
const gridOptionsUtils_1 = __webpack_require__(67274);
const layoutFeature_1 = __webpack_require__(59360);
const array_1 = __webpack_require__(31502);
const dom_1 = __webpack_require__(33507);
const event_1 = __webpack_require__(92979);
const focus_1 = __webpack_require__(82331);
const component_1 = __webpack_require__(78020);
const overlayWrapperComponent_css_GENERATED_1 = __webpack_require__(73893);
const OverlayWrapperElement = {
    tag: 'div',
    cls: 'ag-overlay',
    role: 'presentation',
    children: [
        {
            tag: 'div',
            cls: 'ag-overlay-panel',
            role: 'presentation',
            children: [{ tag: 'div', ref: 'eOverlayWrapper', cls: 'ag-overlay-wrapper', role: 'presentation' }],
        },
    ],
};
class OverlayWrapperComponent extends component_1.Component {
    constructor() {
        // wrapping in outer div, and wrapper, is needed to center the loading icon
        super(OverlayWrapperElement);
        this.eOverlayWrapper = component_1.RefPlaceholder;
        this.activePromise = null;
        this.activeOverlay = null;
        this.updateListenerDestroyFunc = null;
        this.activeCssClass = null;
        this.elToFocusAfter = null;
        this.registerCSS(overlayWrapperComponent_css_GENERATED_1.overlayWrapperComponentCSS);
    }
    handleKeyDown(e) {
        if (e.key !== keyCode_1.KeyCode.TAB || e.defaultPrevented || (0, event_1._isStopPropagationForAgGrid)(e)) {
            return;
        }
        const beans = this.beans;
        const nextEl = (0, focus_1._findNextFocusableElement)(beans, this.eOverlayWrapper, false, e.shiftKey);
        if (nextEl) {
            return;
        }
        let isFocused = false;
        if (e.shiftKey) {
            isFocused = beans.focusSvc.focusGridView({
                column: (0, array_1._last)(beans.visibleCols.allCols),
                backwards: true,
                canFocusOverlay: false,
            });
        }
        else {
            isFocused = (0, focus_1._focusNextGridCoreContainer)(beans, false);
        }
        if (isFocused) {
            e.preventDefault();
        }
    }
    updateLayoutClasses(cssClass, params) {
        const overlayWrapperClassList = this.eOverlayWrapper.classList;
        const { AUTO_HEIGHT, NORMAL, PRINT } = layoutFeature_1.LayoutCssClasses;
        overlayWrapperClassList.toggle(AUTO_HEIGHT, params.autoHeight);
        overlayWrapperClassList.toggle(NORMAL, params.normal);
        overlayWrapperClassList.toggle(PRINT, params.print);
    }
    postConstruct() {
        this.createManagedBean(new layoutFeature_1.LayoutFeature(this));
        this.setDisplayed(false, { skipAriaHidden: true });
        this.beans.overlays.setOverlayWrapperComp(this);
        this.addManagedElementListeners(this.getFocusableElement(), { keydown: this.handleKeyDown.bind(this) });
    }
    setWrapperTypeClass(overlayWrapperCssClass) {
        const overlayWrapperClassList = this.eOverlayWrapper.classList;
        if (this.activeCssClass) {
            overlayWrapperClassList.toggle(this.activeCssClass, false);
        }
        this.activeCssClass = overlayWrapperCssClass;
        overlayWrapperClassList.toggle(overlayWrapperCssClass, true);
    }
    showOverlay(overlayComponentPromise, overlayWrapperCssClass, exclusive, gridOption) {
        this.setWrapperTypeClass(overlayWrapperCssClass);
        this.destroyActiveOverlay();
        this.elToFocusAfter = null;
        this.activePromise = overlayComponentPromise;
        if (!overlayComponentPromise) {
            return;
        }
        this.setDisplayed(true, { skipAriaHidden: true });
        if (exclusive && this.isGridFocused()) {
            const activeElement = (0, gridOptionsUtils_1._getActiveDomElement)(this.beans);
            if (activeElement && !(0, gridOptionsUtils_1._isNothingFocused)(this.beans)) {
                this.elToFocusAfter = activeElement;
            }
        }
        overlayComponentPromise.then((comp) => {
            if (this.activePromise !== overlayComponentPromise) {
                // Another promise was started, we need to cancel this old operation
                if (this.activeOverlay !== comp) {
                    // We can destroy the component as it will not be used
                    this.destroyBean(comp);
                    comp = null;
                }
                return;
            }
            this.activePromise = null; // Promise completed, so we can reset this
            if (!comp) {
                return; // Error handling
            }
            if (this.activeOverlay !== comp) {
                this.eOverlayWrapper.appendChild(comp.getGui());
                this.activeOverlay = comp;
                if (gridOption) {
                    const component = comp;
                    this.updateListenerDestroyFunc = this.addManagedPropertyListener(gridOption, ({ currentValue }) => {
                        component.refresh?.((0, gridOptionsUtils_1._addGridCommonParams)(this.gos, { ...(currentValue ?? {}) }));
                    });
                }
            }
            if (exclusive && this.isGridFocused()) {
                (0, focus_1._focusInto)(this.eOverlayWrapper);
            }
        });
    }
    updateOverlayWrapperPaddingTop(padding) {
        this.eOverlayWrapper.style.setProperty('padding-top', `${padding}px`);
    }
    destroyActiveOverlay() {
        this.activePromise = null;
        const activeOverlay = this.activeOverlay;
        if (!activeOverlay) {
            return; // Nothing to destroy
        }
        let elementToFocus = this.elToFocusAfter;
        this.activeOverlay = null;
        this.elToFocusAfter = null;
        if (elementToFocus && !this.isGridFocused()) {
            elementToFocus = null;
        }
        const updateListenerDestroyFunc = this.updateListenerDestroyFunc;
        if (updateListenerDestroyFunc) {
            updateListenerDestroyFunc();
            this.updateListenerDestroyFunc = null;
        }
        this.destroyBean(activeOverlay);
        (0, dom_1._clearElement)(this.eOverlayWrapper);
        // Focus the element that was focused before the exclusive overlay was shown
        elementToFocus?.focus?.({ preventScroll: true });
    }
    hideOverlay() {
        this.destroyActiveOverlay();
        this.setDisplayed(false, { skipAriaHidden: true });
    }
    isGridFocused() {
        const activeEl = (0, gridOptionsUtils_1._getActiveDomElement)(this.beans);
        return !!activeEl && this.beans.eGridDiv.contains(activeEl);
    }
    destroy() {
        this.elToFocusAfter = null;
        this.destroyActiveOverlay();
        this.beans.overlays.setOverlayWrapperComp(undefined);
        super.destroy();
    }
}
exports.OverlayWrapperComponent = OverlayWrapperComponent;
exports.OverlayWrapperSelector = {
    selector: 'AG-OVERLAY-WRAPPER',
    component: OverlayWrapperComponent,
};


/***/ }),

/***/ 30094:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCellRendererInstances = exports.getSizesForCurrentTheme = exports.flushAllAnimationFrames = exports.isAnimationFrameQueueEmpty = exports.refreshHeader = exports.refreshCells = exports.setGridAriaProperty = void 0;
const unwrapUserComp_1 = __webpack_require__(54126);
const gridOptionsUtils_1 = __webpack_require__(67274);
const headerUtils_1 = __webpack_require__(1323);
const rowRenderer_1 = __webpack_require__(90557);
function setGridAriaProperty(beans, property, value) {
    if (!property) {
        return;
    }
    const eGrid = beans.ctrlsSvc.getGridBodyCtrl().eGridBody;
    const ariaProperty = `aria-${property}`;
    if (value === null) {
        eGrid.removeAttribute(ariaProperty);
    }
    else {
        eGrid.setAttribute(ariaProperty, value);
    }
}
exports.setGridAriaProperty = setGridAriaProperty;
function refreshCells(beans, params = {}) {
    beans.frameworkOverrides.wrapIncoming(() => beans.rowRenderer.refreshCells(params));
}
exports.refreshCells = refreshCells;
function refreshHeader(beans) {
    beans.frameworkOverrides.wrapIncoming(() => beans.ctrlsSvc.getHeaderRowContainerCtrls().forEach((c) => c.refresh()));
}
exports.refreshHeader = refreshHeader;
function isAnimationFrameQueueEmpty(beans) {
    return beans.animationFrameSvc?.isQueueEmpty() ?? true;
}
exports.isAnimationFrameQueueEmpty = isAnimationFrameQueueEmpty;
function flushAllAnimationFrames(beans) {
    beans.animationFrameSvc?.flushAllFrames();
}
exports.flushAllAnimationFrames = flushAllAnimationFrames;
function getSizesForCurrentTheme(beans) {
    return {
        rowHeight: (0, gridOptionsUtils_1._getRowHeightAsNumber)(beans),
        headerHeight: (0, headerUtils_1.getHeaderHeight)(beans),
    };
}
exports.getSizesForCurrentTheme = getSizesForCurrentTheme;
function getCellRendererInstances(beans, params = {}) {
    const cellRenderers = [];
    beans.rowRenderer.getCellCtrls(params.rowNodes, params.columns).forEach((cellCtrl) => {
        const cellRenderer = cellCtrl.getCellRenderer();
        if (cellRenderer != null) {
            cellRenderers.push((0, unwrapUserComp_1._unwrapUserComp)(cellRenderer));
        }
    });
    if (params.columns?.length) {
        return cellRenderers;
    }
    const fullWidthRenderers = [];
    const rowIdMap = (0, rowRenderer_1.mapRowNodes)(params.rowNodes);
    beans.rowRenderer.getAllRowCtrls().forEach((rowCtrl) => {
        if (rowIdMap && !(0, rowRenderer_1.isRowInMap)(rowCtrl.rowNode, rowIdMap)) {
            return;
        }
        if (!rowCtrl.isFullWidth()) {
            return;
        }
        const renderers = rowCtrl.getFullWidthCellRenderers();
        for (let i = 0; i < renderers.length; i++) {
            const renderer = renderers[i];
            if (renderer != null) {
                fullWidthRenderers.push((0, unwrapUserComp_1._unwrapUserComp)(renderer));
            }
        }
    });
    return [...fullWidthRenderers, ...cellRenderers];
}
exports.getCellRendererInstances = getCellRendererInstances;


/***/ }),

/***/ 66964:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RenderApiModule = void 0;
const version_1 = __webpack_require__(97205);
const renderApi_1 = __webpack_require__(30094);
/**
 * @feature Rendering
 */
exports.RenderApiModule = {
    moduleName: 'RenderApi',
    version: version_1.VERSION,
    apiFunctions: {
        setGridAriaProperty: renderApi_1.setGridAriaProperty,
        refreshCells: renderApi_1.refreshCells,
        refreshHeader: renderApi_1.refreshHeader,
        isAnimationFrameQueueEmpty: renderApi_1.isAnimationFrameQueueEmpty,
        flushAllAnimationFrames: renderApi_1.flushAllAnimationFrames,
        getSizesForCurrentTheme: renderApi_1.getSizesForCurrentTheme,
        getCellRendererInstances: renderApi_1.getCellRendererInstances,
    },
};


/***/ }),

/***/ 4577:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RowAutoHeightModule = void 0;
const version_1 = __webpack_require__(97205);
const rowAutoHeightService_1 = __webpack_require__(86418);
/**
 * @feature Rows -> Row Height
 * @colDef autoHeight
 */
exports.RowAutoHeightModule = {
    moduleName: 'RowAutoHeight',
    version: version_1.VERSION,
    beans: [rowAutoHeightService_1.RowAutoHeightService],
};


/***/ }),

/***/ 86418:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RowAutoHeightService = void 0;
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const dom_1 = __webpack_require__(33507);
const function_1 = __webpack_require__(92043);
class RowAutoHeightService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'rowAutoHeight';
        this.wasEverActive = false;
        this._debouncedCalculateRowHeights = (0, function_1._debounce)(this, this.calculateRowHeights.bind(this), 1);
    }
    /**
     * If row height has been active, request a refresh of the row heights.
     */
    requestCheckAutoHeight() {
        if (!this.wasEverActive) {
            return;
        }
        this._debouncedCalculateRowHeights();
    }
    calculateRowHeights() {
        const { visibleCols, rowModel, rowSpanSvc, pinnedRowModel } = this.beans;
        const displayedAutoHeightCols = visibleCols.autoHeightCols;
        let anyNodeChanged = false;
        const updateDisplayedRowHeights = (row) => {
            const autoHeights = row.__autoHeights;
            let newRowHeight = (0, gridOptionsUtils_1._getRowHeightForNode)(this.beans, row).height;
            for (const col of displayedAutoHeightCols) {
                let cellHeight = autoHeights?.[col.getColId()];
                const spannedCell = rowSpanSvc?.getCellSpan(col, row);
                if (spannedCell) {
                    // only last row gets additional auto height of spanned cell
                    if (spannedCell.getLastNode() !== row) {
                        continue;
                    }
                    cellHeight = rowSpanSvc?.getCellSpan(col, row)?.getLastNodeAutoHeight();
                    // if this is the last row, but no span value, skip this row as auto height not ready
                    if (!cellHeight) {
                        return;
                    }
                }
                // if no cell height, auto height not ready skip row
                if (cellHeight == null) {
                    // if using col span then the cell might be omitted due to being spanned
                    // if so auto height for that cell is not needed
                    if (this.colSpanSkipCell(col, row)) {
                        continue;
                    }
                    return;
                }
                newRowHeight = Math.max(cellHeight, newRowHeight);
            }
            if (newRowHeight !== row.rowHeight) {
                row.setRowHeight(newRowHeight);
                anyNodeChanged = true;
            }
        };
        pinnedRowModel?.forEachPinnedRow?.('top', updateDisplayedRowHeights);
        pinnedRowModel?.forEachPinnedRow?.('bottom', updateDisplayedRowHeights);
        rowModel.forEachDisplayedNode?.(updateDisplayedRowHeights);
        if (anyNodeChanged) {
            rowModel.onRowHeightChanged?.();
        }
    }
    /**
     * Set the cell height into the row node, and request a refresh of the row heights if there's been a change.
     * @param rowNode the node to set the auto height on
     * @param cellHeight the height to set, undefined if the cell has just been destroyed
     * @param column the column of the cell
     */
    setRowAutoHeight(rowNode, cellHeight, column) {
        rowNode.__autoHeights ?? (rowNode.__autoHeights = {});
        // if the cell comp has been unmounted, delete the auto height
        if (cellHeight == undefined) {
            delete rowNode.__autoHeights[column.getId()];
            return;
        }
        const previousCellHeight = rowNode.__autoHeights[column.getId()];
        rowNode.__autoHeights[column.getId()] = cellHeight;
        if (previousCellHeight !== cellHeight) {
            this.requestCheckAutoHeight();
        }
    }
    /**
     * If using col span, then cells which have been spanned over do not need an auto height value
     * @param col the column of the cell
     * @param node the node of the cell
     * @returns whether the row needs auto height value for that column
     */
    colSpanSkipCell(col, node) {
        const { colModel, colViewport, visibleCols } = this.beans;
        if (!colModel.colSpanActive) {
            return false;
        }
        let activeColsForRow = [];
        switch (col.getPinned()) {
            case 'left':
                activeColsForRow = visibleCols.getLeftColsForRow(node);
                break;
            case 'right':
                activeColsForRow = visibleCols.getRightColsForRow(node);
                break;
            case null:
                activeColsForRow = colViewport.getColsWithinViewport(node);
                break;
        }
        return !activeColsForRow.includes(col);
    }
    /**
     * If required, sets up observers to continuously measure changes in the cell height.
     * @param cellCtrl the cellCtrl of the cell
     * @param eCellWrapper the HTMLElement to track the height of
     * @param compBean the component bean to add the destroy/cleanup function to
     * @returns whether or not auto height has been set up on this cell
     */
    setupCellAutoHeight(cellCtrl, eCellWrapper, compBean) {
        if (!cellCtrl.column.isAutoHeight() || !eCellWrapper) {
            return false;
        }
        this.wasEverActive = true;
        const eParentCell = eCellWrapper.parentElement;
        const { rowNode, column } = cellCtrl;
        const beans = this.beans;
        const measureHeight = (timesCalled) => {
            if (this.beans.editSvc?.isEditing(cellCtrl)) {
                return;
            }
            // because of the retry's below, it's possible the retry's go beyond
            // the rows life.
            if (!cellCtrl.isAlive() || !compBean.isAlive()) {
                return;
            }
            const { paddingTop, paddingBottom, borderBottomWidth, borderTopWidth } = (0, dom_1._getElementSize)(eParentCell);
            const extraHeight = paddingTop + paddingBottom + borderBottomWidth + borderTopWidth;
            const wrapperHeight = eCellWrapper.offsetHeight;
            const autoHeight = wrapperHeight + extraHeight;
            if (timesCalled < 5) {
                // if not in doc yet, means framework not yet inserted, so wait for next VM turn,
                // maybe it will be ready next VM turn
                const doc = (0, gridOptionsUtils_1._getDocument)(beans);
                const notYetInDom = !doc || !doc.contains(eCellWrapper);
                // this happens in React, where React hasn't put any content in. we say 'possibly'
                // as a) may not be React and b) the cell could be empty anyway
                const possiblyNoContentYet = autoHeight == 0;
                if (notYetInDom || possiblyNoContentYet) {
                    window.setTimeout(() => measureHeight(timesCalled + 1), 0);
                    return;
                }
            }
            this.setRowAutoHeight(rowNode, autoHeight, column);
        };
        const listener = () => measureHeight(0);
        // do once to set size in case size doesn't change, common when cell is blank
        listener();
        const destroyResizeObserver = (0, dom_1._observeResize)(beans, eCellWrapper, listener);
        compBean.addDestroyFunc(() => {
            destroyResizeObserver();
            this.setRowAutoHeight(rowNode, undefined, column);
        });
        return true;
    }
    setAutoHeightActive(cols) {
        this.active = cols.list.some((col) => col.isVisible() && col.isAutoHeight());
    }
    /**
     * Determines if the row auto height service has cells to grow.
     * @returns true if all of the rendered rows are at least as tall as their rendered cells.
     */
    areRowsMeasured() {
        if (!this.active) {
            return true;
        }
        const rowCtrls = this.beans.rowRenderer.getAllRowCtrls();
        let renderedAutoHeightCols = null;
        for (const { rowNode } of rowCtrls) {
            // if colSpanActive is false, then all rows will have the same cols, so shortcut
            // and avoid filtering the cols for each row
            if (!renderedAutoHeightCols || this.beans.colModel.colSpanActive) {
                const renderedCols = this.beans.colViewport.getColsWithinViewport(rowNode);
                renderedAutoHeightCols = renderedCols.filter((col) => col.isAutoHeight());
            }
            if (renderedAutoHeightCols.length === 0) {
                continue;
            }
            if (!rowNode.__autoHeights) {
                return false;
            }
            for (const col of renderedAutoHeightCols) {
                const cellHeight = rowNode.__autoHeights[col.getColId()];
                if (!cellHeight || rowNode.rowHeight < cellHeight) {
                    return false;
                }
            }
        }
        return true;
    }
}
exports.RowAutoHeightService = RowAutoHeightService;


/***/ }),

/***/ 98430:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RowComp = void 0;
const dom_1 = __webpack_require__(33507);
const component_1 = __webpack_require__(78020);
const cellComp_1 = __webpack_require__(32308);
class RowComp extends component_1.Component {
    constructor(ctrl, beans, containerType) {
        super();
        this.cellComps = new Map();
        this.beans = beans;
        this.rowCtrl = ctrl;
        const rowDiv = (0, dom_1._createElement)({ tag: 'div', role: 'row', attrs: { 'comp-id': `${this.getCompId()}` } });
        this.setInitialStyle(rowDiv, containerType);
        this.setTemplateFromElement(rowDiv);
        const style = rowDiv.style;
        this.domOrder = this.rowCtrl.getDomOrder();
        const compProxy = {
            setDomOrder: (domOrder) => (this.domOrder = domOrder),
            setCellCtrls: (cellCtrls) => this.setCellCtrls(cellCtrls),
            showFullWidth: (compDetails) => this.showFullWidth(compDetails),
            getFullWidthCellRenderer: () => this.fullWidthCellRenderer,
            toggleCss: (name, on) => this.toggleCss(name, on),
            setUserStyles: (styles) => (0, dom_1._addStylesToElement)(rowDiv, styles),
            setTop: (top) => (style.top = top),
            setTransform: (transform) => (style.transform = transform),
            setRowIndex: (rowIndex) => rowDiv.setAttribute('row-index', rowIndex),
            setRowId: (rowId) => rowDiv.setAttribute('row-id', rowId),
            setRowBusinessKey: (businessKey) => rowDiv.setAttribute('row-business-key', businessKey),
            refreshFullWidth: (getUpdatedParams) => this.fullWidthCellRenderer?.refresh?.(getUpdatedParams()) ?? false,
        };
        ctrl.setComp(compProxy, this.getGui(), containerType, undefined);
        this.addDestroyFunc(() => {
            ctrl.unsetComp(containerType);
        });
    }
    setInitialStyle(container, containerType) {
        const transform = this.rowCtrl.getInitialTransform(containerType);
        if (transform) {
            container.style.setProperty('transform', transform);
        }
        else {
            const top = this.rowCtrl.getInitialRowTop(containerType);
            if (top) {
                container.style.setProperty('top', top);
            }
        }
    }
    showFullWidth(compDetails) {
        const callback = (cellRenderer) => {
            if (this.isAlive()) {
                const eGui = cellRenderer.getGui();
                this.getGui().appendChild(eGui);
                this.rowCtrl.setupDetailRowAutoHeight(eGui);
                this.setFullWidthRowComp(cellRenderer);
            }
            else {
                this.beans.context.destroyBean(cellRenderer);
            }
        };
        // if not in cache, create new one
        const res = compDetails.newAgStackInstance();
        res.then(callback);
    }
    setCellCtrls(cellCtrls) {
        const cellsToRemove = new Map(this.cellComps);
        for (const cellCtrl of cellCtrls) {
            const key = cellCtrl.instanceId;
            if (!this.cellComps.has(key)) {
                this.newCellComp(cellCtrl);
            }
            else {
                cellsToRemove.delete(key);
            }
        }
        this.destroyCells(cellsToRemove);
        this.ensureDomOrder(cellCtrls);
    }
    ensureDomOrder(cellCtrls) {
        if (!this.domOrder) {
            return;
        }
        const elementsInOrder = [];
        for (const cellCtrl of cellCtrls) {
            const cellComp = this.cellComps.get(cellCtrl.instanceId);
            if (cellComp) {
                elementsInOrder.push(cellComp.getGui());
            }
        }
        (0, dom_1._setDomChildOrder)(this.getGui(), elementsInOrder);
    }
    newCellComp(cellCtrl) {
        const editing = this.beans.editSvc?.isEditing(cellCtrl, { withOpenEditor: true }) ?? false;
        const cellComp = new cellComp_1.CellComp(this.beans, cellCtrl, this.rowCtrl.printLayout, this.getGui(), editing);
        this.cellComps.set(cellCtrl.instanceId, cellComp);
        this.getGui().appendChild(cellComp.getGui());
    }
    destroy() {
        super.destroy();
        // Destroy all cells
        this.destroyCells(this.cellComps);
    }
    setFullWidthRowComp(fullWidthRowComponent) {
        this.fullWidthCellRenderer = fullWidthRowComponent;
        this.addDestroyFunc(() => {
            this.fullWidthCellRenderer = this.beans.context.destroyBean(this.fullWidthCellRenderer);
        });
    }
    destroyCells(cellComps) {
        for (const cellComp of cellComps.values()) {
            // could be old reference, ie removed cell
            if (!cellComp) {
                return;
            }
            // check cellComp belongs in this container
            const instanceId = cellComp.cellCtrl.instanceId;
            if (this.cellComps.get(instanceId) !== cellComp) {
                return;
            }
            cellComp.detach();
            cellComp.destroy();
            this.cellComps.delete(instanceId);
        }
    }
}
exports.RowComp = RowComp;


/***/ }),

/***/ 7632:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RowCtrl = exports.DOM_DATA_KEY_ROW_CTRL = void 0;
const emptyBean_1 = __webpack_require__(33789);
const userCompUtils_1 = __webpack_require__(12036);
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const rowStyleService_1 = __webpack_require__(27648);
const aria_1 = __webpack_require__(95230);
const browser_1 = __webpack_require__(98667);
const dom_1 = __webpack_require__(33507);
const event_1 = __webpack_require__(92979);
const focus_1 = __webpack_require__(82331);
const function_1 = __webpack_require__(92043);
const generic_1 = __webpack_require__(34422);
const string_1 = __webpack_require__(37766);
const cellCtrl_1 = __webpack_require__(60814);
let instanceIdSequence = 0;
exports.DOM_DATA_KEY_ROW_CTRL = 'renderedRow';
class RowCtrl extends beanStub_1.BeanStub {
    constructor(rowNode, beans, animateIn, useAnimationFrameForCreate, printLayout) {
        super();
        this.rowNode = rowNode;
        this.useAnimationFrameForCreate = useAnimationFrameForCreate;
        this.printLayout = printLayout;
        this.allRowGuis = [];
        this.active = true;
        this.centerCellCtrls = { list: [], map: {} };
        this.leftCellCtrls = { list: [], map: {} };
        this.rightCellCtrls = { list: [], map: {} };
        this.slideInAnimation = {
            left: false,
            center: false,
            right: false,
            fullWidth: false,
        };
        this.fadeInAnimation = {
            left: false,
            center: false,
            right: false,
            fullWidth: false,
        };
        this.rowDragComps = [];
        this.lastMouseDownOnDragger = false;
        this.emptyStyle = {};
        this.updateColumnListsPending = false;
        this.rowId = null;
        /** sanitised */
        this.businessKey = null;
        this.beans = beans;
        this.gos = beans.gos;
        this.paginationPage = beans.pagination?.getCurrentPage() ?? 0;
        this.suppressRowTransform = this.gos.get('suppressRowTransform');
        this.instanceId = (rowNode.id + '-' + instanceIdSequence++);
        this.rowId = (0, string_1._escapeString)(rowNode.id);
        this.initRowBusinessKey();
        this.rowFocused = beans.focusSvc.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned);
        this.rowLevel = (0, rowStyleService_1.calculateRowLevel)(this.rowNode);
        this.setRowType();
        this.setAnimateFlags(animateIn);
        this.rowStyles = this.processStylesFromGridOptions();
        this.rowEditStyleFeature = beans.editSvc?.createRowStyleFeature(this, beans);
        this.addListeners();
    }
    initRowBusinessKey() {
        this.businessKeyForNodeFunc = this.gos.get('getBusinessKeyForNode');
        this.updateRowBusinessKey();
    }
    updateRowBusinessKey() {
        if (typeof this.businessKeyForNodeFunc !== 'function') {
            return;
        }
        const businessKey = this.businessKeyForNodeFunc(this.rowNode);
        this.businessKey = (0, string_1._escapeString)(businessKey);
    }
    updateGui(containerType, gui) {
        if (containerType === 'left') {
            this.leftGui = gui;
        }
        else if (containerType === 'right') {
            this.rightGui = gui;
        }
        else if (containerType === 'fullWidth') {
            this.fullWidthGui = gui;
        }
        else {
            this.centerGui = gui;
        }
    }
    setComp(rowComp, element, containerType, compBean) {
        const { context, focusSvc } = this.beans;
        compBean = (0, emptyBean_1.setupCompBean)(this, context, compBean);
        const gui = { rowComp, element, containerType, compBean };
        this.allRowGuis.push(gui);
        this.updateGui(containerType, gui);
        this.initialiseRowComp(gui);
        const rowNode = this.rowNode;
        const isSsrmLoadingRow = this.rowType === 'FullWidthLoading' || rowNode.stub;
        const isIrmLoadingRow = !rowNode.data && this.beans.rowModel.getType() === 'infinite';
        // pinned rows render before the main grid body in the SSRM, only fire the event after the main body has rendered.
        if (!isSsrmLoadingRow && !isIrmLoadingRow && !rowNode.rowPinned) {
            // this is fired within setComp as we know that the component renderer is now trying to render.
            // linked with the fact the function implementation queues behind requestAnimationFrame should allow
            // us to be certain that all rendering is done by the time the event fires.
            this.beans.rowRenderer.dispatchFirstDataRenderedEvent();
        }
        const focusableElement = this.fullWidthGui?.element;
        if (focusableElement) {
            // when cell is created, if it should be focus the grid should take focus from the focused cell
            const editing = this.beans.editSvc?.isEditing(this);
            if (!editing && focusSvc.isRowFocused(rowNode.rowIndex, rowNode.rowPinned) && focusSvc.shouldTakeFocus()) {
                setTimeout(() => focusableElement.focus({ preventScroll: true }), 0);
            }
        }
    }
    unsetComp(containerType) {
        this.allRowGuis = this.allRowGuis.filter((rowGui) => rowGui.containerType !== containerType);
        this.updateGui(containerType, undefined);
    }
    isCacheable() {
        return this.rowType === 'FullWidthDetail' && this.gos.get('keepDetailRows');
    }
    setCached(cached) {
        const displayValue = cached ? 'none' : '';
        this.allRowGuis.forEach((rg) => (rg.element.style.display = displayValue));
    }
    initialiseRowComp(gui) {
        const gos = this.gos;
        this.onSuppressCellFocusChanged(this.beans.gos.get('suppressCellFocus'));
        this.listenOnDomOrder(gui);
        this.onRowHeightChanged(gui);
        this.updateRowIndexes(gui);
        this.setFocusedClasses(gui);
        this.setStylesFromGridOptions(false, gui); // no need to calculate styles already set in constructor
        if ((0, gridOptionsUtils_1._isRowSelection)(gos) && this.rowNode.selectable) {
            this.onRowSelected(gui);
        }
        this.updateColumnLists(!this.useAnimationFrameForCreate);
        const comp = gui.rowComp;
        const initialRowClasses = this.getInitialRowClasses(gui.containerType);
        initialRowClasses.forEach((name) => comp.toggleCss(name, true));
        this.executeSlideAndFadeAnimations(gui);
        if (this.rowNode.group) {
            (0, aria_1._setAriaExpanded)(gui.element, this.rowNode.expanded == true);
        }
        this.setRowCompRowId(comp);
        this.setRowCompRowBusinessKey(comp);
        // DOM DATA
        (0, gridOptionsUtils_1._setDomData)(gos, gui.element, exports.DOM_DATA_KEY_ROW_CTRL, this);
        gui.compBean.addDestroyFunc(() => (0, gridOptionsUtils_1._setDomData)(gos, gui.element, exports.DOM_DATA_KEY_ROW_CTRL, null));
        // adding hover functionality adds listener to this row, so we
        // do it lazily in an animation frame
        if (this.useAnimationFrameForCreate) {
            this.beans.animationFrameSvc.createTask(this.addHoverFunctionality.bind(this, gui), this.rowNode.rowIndex, 'p2', false);
        }
        else {
            this.addHoverFunctionality(gui);
        }
        if (this.isFullWidth()) {
            this.setupFullWidth(gui);
        }
        if (gos.get('rowDragEntireRow')) {
            this.addRowDraggerToRow(gui);
        }
        if (this.useAnimationFrameForCreate) {
            // the height animation we only want active after the row is alive for 1 second.
            // this stops the row animation working when rows are initially created. otherwise
            // auto-height rows get inserted into the dom and resized immediately, which gives
            // very bad UX (eg 10 rows get inserted, then all 10 expand, look particularly bad
            // when scrolling). so this makes sure when rows are shown for the first time, they
            // are resized immediately without animation.
            this.beans.animationFrameSvc.addDestroyTask(() => {
                if (!this.isAlive()) {
                    return;
                }
                gui.rowComp.toggleCss('ag-after-created', true);
            });
        }
        this.executeProcessRowPostCreateFunc();
    }
    setRowCompRowBusinessKey(comp) {
        if (this.businessKey == null) {
            return;
        }
        comp.setRowBusinessKey(this.businessKey);
    }
    setRowCompRowId(comp) {
        const rowId = (0, string_1._escapeString)(this.rowNode.id);
        this.rowId = rowId;
        if (rowId == null) {
            return;
        }
        comp.setRowId(rowId);
    }
    executeSlideAndFadeAnimations(gui) {
        const { containerType } = gui;
        const shouldSlide = this.slideInAnimation[containerType];
        if (shouldSlide) {
            (0, function_1._batchCall)(() => {
                this.onTopChanged();
            });
            this.slideInAnimation[containerType] = false;
        }
        const shouldFade = this.fadeInAnimation[containerType];
        if (shouldFade) {
            (0, function_1._batchCall)(() => {
                gui.rowComp.toggleCss('ag-opacity-zero', false);
            });
            this.fadeInAnimation[containerType] = false;
        }
    }
    addRowDraggerToRow(gui) {
        const rowDragComp = this.beans.rowDragSvc?.createRowDragCompForRow(this.rowNode, gui.element);
        if (!rowDragComp) {
            return;
        }
        const rowDragBean = this.createBean(rowDragComp, this.beans.context);
        this.rowDragComps.push(rowDragBean);
        gui.compBean.addDestroyFunc(() => {
            this.rowDragComps = this.rowDragComps.filter((r) => r !== rowDragBean);
            this.rowEditStyleFeature = this.destroyBean(this.rowEditStyleFeature, this.beans.context);
            this.destroyBean(rowDragBean, this.beans.context);
        });
    }
    setupFullWidth(gui) {
        const pinned = this.getPinnedForContainer(gui.containerType);
        const compDetails = this.createFullWidthCompDetails(gui.element, pinned);
        gui.rowComp.showFullWidth(compDetails);
    }
    getFullWidthCellRenderers() {
        if (this.gos.get('embedFullWidthRows')) {
            return this.allRowGuis.map((gui) => gui?.rowComp?.getFullWidthCellRenderer());
        }
        return [this.fullWidthGui?.rowComp?.getFullWidthCellRenderer()];
    }
    executeProcessRowPostCreateFunc() {
        const func = this.gos.getCallback('processRowPostCreate');
        if (!func || !this.areAllContainersReady()) {
            return;
        }
        const params = {
            // areAllContainersReady asserts that centerGui is not null
            eRow: this.centerGui.element,
            ePinnedLeftRow: this.leftGui ? this.leftGui.element : undefined,
            ePinnedRightRow: this.rightGui ? this.rightGui.element : undefined,
            node: this.rowNode,
            rowIndex: this.rowNode.rowIndex,
            addRenderedRowListener: this.addEventListener.bind(this),
        };
        func(params);
    }
    areAllContainersReady() {
        const { leftGui, centerGui, rightGui, beans: { visibleCols }, } = this;
        const isLeftReady = !!leftGui || !visibleCols.isPinningLeft();
        const isCenterReady = !!centerGui;
        const isRightReady = !!rightGui || !visibleCols.isPinningRight();
        return isLeftReady && isCenterReady && isRightReady;
    }
    isNodeFullWidthCell() {
        if (this.rowNode.detail) {
            return true;
        }
        const isFullWidthCellFunc = this.beans.gos.getCallback('isFullWidthRow');
        return isFullWidthCellFunc ? isFullWidthCellFunc({ rowNode: this.rowNode }) : false;
    }
    setRowType() {
        // groupHideOpenParents implicitly disables full width loading
        const isStub = this.rowNode.stub &&
            !this.gos.get('suppressServerSideFullWidthLoadingRow') &&
            !this.gos.get('groupHideOpenParents');
        const isFullWidthCell = this.isNodeFullWidthCell();
        const isDetailCell = this.gos.get('masterDetail') && this.rowNode.detail;
        const pivotMode = this.beans.colModel.isPivotMode();
        const isFullWidthGroup = (0, gridOptionsUtils_1._isFullWidthGroupRow)(this.gos, this.rowNode, pivotMode);
        if (isStub) {
            this.rowType = 'FullWidthLoading';
        }
        else if (isDetailCell) {
            this.rowType = 'FullWidthDetail';
        }
        else if (isFullWidthCell) {
            this.rowType = 'FullWidth';
        }
        else if (isFullWidthGroup) {
            this.rowType = 'FullWidthGroup';
        }
        else {
            this.rowType = 'Normal';
        }
    }
    updateColumnLists(suppressAnimationFrame = false, useFlushSync = false) {
        if (this.isFullWidth()) {
            return;
        }
        const { animationFrameSvc } = this.beans;
        const noAnimation = !animationFrameSvc?.active || suppressAnimationFrame || this.printLayout;
        if (noAnimation) {
            this.updateColumnListsImpl(useFlushSync);
            return;
        }
        if (this.updateColumnListsPending) {
            return;
        }
        animationFrameSvc.createTask(() => {
            if (!this.active) {
                return;
            }
            this.updateColumnListsImpl(true);
        }, this.rowNode.rowIndex, 'p1', false);
        this.updateColumnListsPending = true;
    }
    /**
     * Overridden by SpannedRowCtrl
     */
    getNewCellCtrl(col) {
        const isCellSpan = this.beans.rowSpanSvc?.isCellSpanning(col, this.rowNode);
        if (isCellSpan) {
            return undefined;
        }
        return new cellCtrl_1.CellCtrl(col, this.rowNode, this.beans, this);
    }
    /**
     * Overridden by SpannedRowCtrl, if span context changes cell needs rebuilt
     */
    isCorrectCtrlForSpan(cell) {
        return !this.beans.rowSpanSvc?.isCellSpanning(cell.column, this.rowNode);
    }
    createCellCtrls(prev, cols, pinned = null) {
        const res = {
            list: [],
            map: {},
        };
        const addCell = (colInstanceId, cellCtrl, index) => {
            if (index != null) {
                res.list.splice(index, 0, cellCtrl);
            }
            else {
                res.list.push(cellCtrl);
            }
            res.map[colInstanceId] = cellCtrl;
        };
        const colsFromPrev = [];
        for (const col of cols) {
            // we use instanceId's rather than colId as it's possible there is a Column with same Id,
            // but it's referring to a different column instance. Happens a lot with pivot, as pivot col id's are
            // reused eg pivot_0, pivot_1 etc
            const colInstanceId = col.getInstanceId();
            let cellCtrl = prev.map[colInstanceId];
            // for spanned cells, if the span ref has changed, need to hard refresh cell
            if (cellCtrl && !this.isCorrectCtrlForSpan(cellCtrl)) {
                cellCtrl.destroy();
                cellCtrl = undefined;
            }
            if (!cellCtrl) {
                cellCtrl = this.getNewCellCtrl(col);
            }
            if (!cellCtrl) {
                continue;
            }
            addCell(colInstanceId, cellCtrl);
        }
        for (const prevCellCtrl of prev.list) {
            const colInstanceId = prevCellCtrl.column.getInstanceId();
            const cellInResult = res.map[colInstanceId] != null;
            if (cellInResult) {
                continue;
            }
            const keepCell = !this.isCellEligibleToBeRemoved(prevCellCtrl, pinned);
            if (keepCell) {
                colsFromPrev.push([colInstanceId, prevCellCtrl]);
            }
            else {
                prevCellCtrl.destroy();
            }
        }
        if (colsFromPrev.length) {
            for (const [colInstanceId, cellCtrl] of colsFromPrev) {
                const index = res.list.findIndex((ctrl) => ctrl.column.getLeft() > cellCtrl.column.getLeft());
                const normalisedIndex = index === -1 ? undefined : Math.max(index - 1, 0);
                addCell(colInstanceId, cellCtrl, normalisedIndex);
            }
        }
        const { focusSvc, visibleCols } = this.beans;
        const focusedCell = focusSvc.getFocusedCell();
        // if a cell is focused, might need to be force rendered if it belongs to this pinned section
        if (focusedCell && focusedCell.column.getPinned() == pinned) {
            const focusedColInstanceId = focusedCell.column.getInstanceId();
            const focusedCellCtrl = res.map[focusedColInstanceId];
            // if focused col is visible, and there's no cell here for it, try to create one
            if (!focusedCellCtrl && visibleCols.allCols.includes(focusedCell.column)) {
                const cellCtrl = this.createFocusedCellCtrl();
                if (cellCtrl) {
                    const index = res.list.findIndex((ctrl) => ctrl.column.getLeft() > cellCtrl.column.getLeft());
                    const normalisedIndex = index === -1 ? undefined : Math.max(index - 1, 0);
                    addCell(focusedColInstanceId, cellCtrl, normalisedIndex);
                }
            }
        }
        return res;
    }
    /**
     * Creates a new cell ctrl for the focused cell, if this is the correct row ctrl.
     * @returns a CellCtrl for the focused cell, if required.
     */
    createFocusedCellCtrl() {
        const { focusSvc, rowSpanSvc } = this.beans;
        const focusedCell = focusSvc.getFocusedCell();
        if (!focusedCell) {
            return undefined;
        }
        const focusedSpan = rowSpanSvc?.getCellSpan(focusedCell.column, this.rowNode);
        if (focusedSpan) {
            // if span is focused, and the focused row is not the first in this span, don't create ctrl
            if (focusedSpan.firstNode !== this.rowNode || !focusedSpan.doesSpanContain(focusedCell)) {
                return undefined;
            }
        }
        else {
            // if no span, and the focused cell is not in this row, don't create ctrl
            if (!focusSvc.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned)) {
                return undefined;
            }
        }
        return this.getNewCellCtrl(focusedCell.column);
    }
    updateColumnListsImpl(useFlushSync) {
        this.updateColumnListsPending = false;
        this.createAllCellCtrls();
        this.setCellCtrls(useFlushSync);
    }
    setCellCtrls(useFlushSync) {
        this.allRowGuis.forEach((item) => {
            const cellControls = this.getCellCtrlsForContainer(item.containerType);
            item.rowComp.setCellCtrls(cellControls, useFlushSync);
        });
    }
    getCellCtrlsForContainer(containerType) {
        switch (containerType) {
            case 'left':
                return this.leftCellCtrls.list;
            case 'right':
                return this.rightCellCtrls.list;
            case 'fullWidth':
                return [];
            case 'center':
                return this.centerCellCtrls.list;
        }
    }
    createAllCellCtrls() {
        const colViewport = this.beans.colViewport;
        const presentedColsService = this.beans.visibleCols;
        if (this.printLayout) {
            this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, presentedColsService.allCols);
            this.leftCellCtrls = { list: [], map: {} };
            this.rightCellCtrls = { list: [], map: {} };
        }
        else {
            const centerCols = colViewport.getColsWithinViewport(this.rowNode);
            this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, centerCols);
            const leftCols = presentedColsService.getLeftColsForRow(this.rowNode);
            this.leftCellCtrls = this.createCellCtrls(this.leftCellCtrls, leftCols, 'left');
            const rightCols = presentedColsService.getRightColsForRow(this.rowNode);
            this.rightCellCtrls = this.createCellCtrls(this.rightCellCtrls, rightCols, 'right');
        }
    }
    isCellEligibleToBeRemoved(cellCtrl, nextContainerPinned) {
        const REMOVE_CELL = true;
        const KEEP_CELL = false;
        // always remove the cell if it's not rendered or if it's in the wrong pinned location
        const { column } = cellCtrl;
        if (column.getPinned() != nextContainerPinned) {
            return REMOVE_CELL;
        }
        // if cell is in wrong span container, remove it
        if (!this.isCorrectCtrlForSpan(cellCtrl)) {
            return REMOVE_CELL;
        }
        // we want to try and keep editing and focused cells
        const { visibleCols, editSvc } = this.beans;
        const editing = editSvc?.isEditing(cellCtrl);
        const focused = cellCtrl.isCellFocused();
        const mightWantToKeepCell = editing || focused;
        if (mightWantToKeepCell) {
            const displayedColumns = visibleCols.allCols;
            const cellStillDisplayed = displayedColumns.indexOf(column) >= 0;
            return cellStillDisplayed ? KEEP_CELL : REMOVE_CELL;
        }
        return REMOVE_CELL;
    }
    getDomOrder() {
        const isEnsureDomOrder = this.gos.get('ensureDomOrder');
        return isEnsureDomOrder || (0, gridOptionsUtils_1._isDomLayout)(this.gos, 'print');
    }
    listenOnDomOrder(gui) {
        const listener = () => {
            gui.rowComp.setDomOrder(this.getDomOrder());
        };
        gui.compBean.addManagedPropertyListeners(['domLayout', 'ensureDomOrder'], listener);
    }
    setAnimateFlags(animateIn) {
        if (this.rowNode.sticky || !animateIn) {
            return;
        }
        const oldRowTopExists = (0, generic_1._exists)(this.rowNode.oldRowTop);
        const { visibleCols } = this.beans;
        const pinningLeft = visibleCols.isPinningLeft();
        const pinningRight = visibleCols.isPinningRight();
        if (oldRowTopExists) {
            const { slideInAnimation } = this;
            if (this.isFullWidth() && !this.gos.get('embedFullWidthRows')) {
                slideInAnimation.fullWidth = true;
                return;
            }
            // if the row had a previous position, we slide it in
            slideInAnimation.center = true;
            slideInAnimation.left = pinningLeft;
            slideInAnimation.right = pinningRight;
        }
        else {
            const { fadeInAnimation } = this;
            if (this.isFullWidth() && !this.gos.get('embedFullWidthRows')) {
                fadeInAnimation.fullWidth = true;
                return;
            }
            // if the row had no previous position, we fade it in
            fadeInAnimation.center = true;
            fadeInAnimation.left = pinningLeft;
            fadeInAnimation.right = pinningRight;
        }
    }
    isFullWidth() {
        return this.rowType !== 'Normal';
    }
    refreshFullWidth() {
        // returns 'true' if refresh succeeded
        const tryRefresh = (gui, pinned) => {
            if (!gui) {
                return true;
            } // no refresh needed
            return gui.rowComp.refreshFullWidth(() => {
                const compDetails = this.createFullWidthCompDetails(gui.element, pinned);
                return compDetails.params;
            });
        };
        const fullWidthSuccess = tryRefresh(this.fullWidthGui, null);
        const centerSuccess = tryRefresh(this.centerGui, null);
        const leftSuccess = tryRefresh(this.leftGui, 'left');
        const rightSuccess = tryRefresh(this.rightGui, 'right');
        const allFullWidthRowsRefreshed = fullWidthSuccess && centerSuccess && leftSuccess && rightSuccess;
        return allFullWidthRowsRefreshed;
    }
    addListeners() {
        const { beans, gos, rowNode } = this;
        const { expansionSvc, eventSvc, context, rowSpanSvc } = beans;
        this.addManagedListeners(this.rowNode, {
            heightChanged: () => this.onRowHeightChanged(),
            rowSelected: () => this.onRowSelected(),
            rowIndexChanged: this.onRowIndexChanged.bind(this),
            topChanged: this.onTopChanged.bind(this),
            ...(expansionSvc?.getRowExpandedListeners(this) ?? {}),
        });
        if (rowNode.detail) {
            // if the master row node has updated data, we also want to try to refresh the detail row
            this.addManagedListeners(rowNode.parent, { dataChanged: this.onRowNodeDataChanged.bind(this) });
        }
        this.addManagedListeners(rowNode, {
            dataChanged: this.onRowNodeDataChanged.bind(this),
            cellChanged: this.postProcessCss.bind(this),
            rowHighlightChanged: this.onRowNodeHighlightChanged.bind(this),
            draggingChanged: this.postProcessRowDragging.bind(this),
            uiLevelChanged: this.onUiLevelChanged.bind(this),
            rowPinned: this.onRowPinned.bind(this),
        });
        this.addManagedListeners(eventSvc, {
            paginationPixelOffsetChanged: this.onPaginationPixelOffsetChanged.bind(this),
            heightScaleChanged: this.onTopChanged.bind(this),
            displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
            virtualColumnsChanged: this.onVirtualColumnsChanged.bind(this),
            cellFocused: this.onCellFocusChanged.bind(this),
            cellFocusCleared: this.onCellFocusChanged.bind(this),
            paginationChanged: this.onPaginationChanged.bind(this),
            modelUpdated: this.refreshFirstAndLastRowStyles.bind(this),
            columnMoved: () => this.updateColumnLists(),
        });
        if (rowSpanSvc) {
            // when spans change, need to verify that cells are correctly skipped/rendered
            this.addManagedListeners(rowSpanSvc, {
                spannedCellsUpdated: ({ pinned }) => {
                    if (pinned && !rowNode.rowPinned) {
                        return;
                    }
                    this.updateColumnLists();
                },
            });
        }
        this.addDestroyFunc(() => {
            this.rowDragComps = this.destroyBeans(this.rowDragComps, context);
            this.tooltipFeature = this.destroyBean(this.tooltipFeature, context);
            this.rowEditStyleFeature = this.destroyBean(this.rowEditStyleFeature, context);
        });
        this.addManagedPropertyListeners(['rowStyle', 'getRowStyle', 'rowClass', 'getRowClass', 'rowClassRules'], this.postProcessCss.bind(this));
        this.addManagedPropertyListener('rowDragEntireRow', () => {
            const useRowDragEntireRow = gos.get('rowDragEntireRow');
            if (useRowDragEntireRow) {
                this.allRowGuis.forEach((gui) => {
                    this.addRowDraggerToRow(gui);
                });
                return;
            }
            this.rowDragComps = this.destroyBeans(this.rowDragComps, context);
        });
        this.addListenersForCellComps();
    }
    addListenersForCellComps() {
        this.addManagedListeners(this.rowNode, {
            rowIndexChanged: () => this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onRowIndexChanged()),
            cellChanged: (event) => this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onCellChanged(event)),
        });
    }
    /** Should only ever be triggered on source rows (i.e. not on pinned siblings) */
    onRowPinned() {
        for (const gui of this.allRowGuis) {
            gui.rowComp.toggleCss('ag-row-pinned-source', !!this.rowNode.pinnedSibling);
        }
    }
    onRowNodeDataChanged(event) {
        this.refreshRow({
            suppressFlash: !event.update,
            newData: !event.update,
        });
    }
    refreshRow(params) {
        // if the row is rendered incorrectly, as the requirements for whether this is a FW row have changed, we force re-render this row.
        const fullWidthChanged = this.isFullWidth() !== !!this.isNodeFullWidthCell();
        if (fullWidthChanged) {
            this.beans.rowRenderer.redrawRow(this.rowNode);
            return;
        }
        // this bit of logic handles trying to refresh the FW row ctrl, or delegating to removing/recreating it if unsupported.
        if (this.isFullWidth()) {
            const refresh = this.refreshFullWidth();
            if (!refresh) {
                this.beans.rowRenderer.redrawRow(this.rowNode);
            }
            return;
        }
        // if this is an update, we want to refresh, as this will allow the user to put in a transition
        // into the cellRenderer refresh method. otherwise this might be completely new data, in which case
        // we will want to completely replace the cells
        this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.refreshCell(params));
        // as data has changed update the dom row id attributes
        this.allRowGuis.forEach((gui) => {
            this.setRowCompRowId(gui.rowComp);
            this.updateRowBusinessKey();
            this.setRowCompRowBusinessKey(gui.rowComp);
        });
        // check for selected also, as this could be after lazy loading of the row data, in which case
        // the id might of just gotten set inside the row and the row selected state may of changed
        // as a result. this is what happens when selected rows are loaded in virtual pagination.
        // - niall note - since moving to the stub component, this may no longer be true, as replacing
        // the stub component now replaces the entire row
        this.onRowSelected();
        // as data has changed, then the style and class needs to be recomputed
        this.postProcessCss();
    }
    postProcessCss() {
        this.setStylesFromGridOptions(true);
        this.postProcessClassesFromGridOptions();
        this.postProcessRowClassRules();
        this.rowEditStyleFeature?.applyRowStyles();
        this.postProcessRowDragging();
    }
    onRowNodeHighlightChanged() {
        const rowDropHighlightSvc = this.beans.rowDropHighlightSvc;
        const highlighted = rowDropHighlightSvc?.row === this.rowNode ? rowDropHighlightSvc.position : 'none';
        const aboveOn = highlighted === 'above';
        const insideOn = highlighted === 'inside';
        const belowOn = highlighted === 'below';
        const treeData = this.gos.get('treeData');
        const indented = treeData && (belowOn || aboveOn);
        const uiLevel = this.rowNode.uiLevel.toString();
        this.allRowGuis.forEach((gui) => {
            const rowComp = gui.rowComp;
            rowComp.toggleCss('ag-row-highlight-above', aboveOn);
            rowComp.toggleCss('ag-row-highlight-inside', insideOn);
            rowComp.toggleCss('ag-row-highlight-below', belowOn);
            rowComp.toggleCss('ag-row-highlight-indent', indented);
            if (indented) {
                gui.element.style.setProperty('--ag-row-highlight-level', uiLevel);
            }
            else {
                gui.element.style.removeProperty('--ag-row-highlight-level');
            }
        });
    }
    postProcessRowDragging() {
        const dragging = this.rowNode.dragging;
        this.allRowGuis.forEach((gui) => gui.rowComp.toggleCss('ag-row-dragging', dragging));
    }
    onDisplayedColumnsChanged() {
        // we skip animations for onDisplayedColumnChanged, as otherwise the client could remove columns and
        // then set data, and any old valueGetter's (ie from cols that were removed) would still get called.
        this.updateColumnLists(true);
        this.beans.rowAutoHeight?.requestCheckAutoHeight();
    }
    onVirtualColumnsChanged() {
        this.updateColumnLists(false, true);
    }
    getRowPosition() {
        return {
            rowPinned: (0, generic_1._makeNull)(this.rowNode.rowPinned),
            rowIndex: this.rowNode.rowIndex,
        };
    }
    onKeyboardNavigate(keyboardEvent) {
        const groupInfo = this.findFullWidthInfoForEvent(keyboardEvent);
        if (!groupInfo) {
            return;
        }
        const { rowGui, column } = groupInfo;
        const currentFullWidthContainer = rowGui.element;
        const isFullWidthContainerFocused = currentFullWidthContainer === keyboardEvent.target;
        if (!isFullWidthContainerFocused) {
            return;
        }
        const node = this.rowNode;
        const { focusSvc, navigation } = this.beans;
        const lastFocusedCell = focusSvc.getFocusedCell();
        const cellPosition = {
            rowIndex: node.rowIndex,
            rowPinned: node.rowPinned,
            column: lastFocusedCell?.column ?? column,
        };
        navigation?.navigateToNextCell(keyboardEvent, keyboardEvent.key, cellPosition, true);
        keyboardEvent.preventDefault();
    }
    onTabKeyDown(keyboardEvent) {
        if (keyboardEvent.defaultPrevented || (0, event_1._isStopPropagationForAgGrid)(keyboardEvent)) {
            return;
        }
        const currentFullWidthComp = this.allRowGuis.find((c) => c.element.contains(keyboardEvent.target));
        const currentFullWidthContainer = currentFullWidthComp ? currentFullWidthComp.element : null;
        const isFullWidthContainerFocused = currentFullWidthContainer === keyboardEvent.target;
        const activeEl = (0, gridOptionsUtils_1._getActiveDomElement)(this.beans);
        let isDetailGridCellFocused = false;
        if (currentFullWidthContainer && activeEl) {
            isDetailGridCellFocused =
                currentFullWidthContainer.contains(activeEl) && activeEl.classList.contains('ag-cell');
        }
        let nextEl = null;
        if (!isFullWidthContainerFocused && !isDetailGridCellFocused) {
            nextEl = (0, focus_1._findNextFocusableElement)(this.beans, currentFullWidthContainer, false, keyboardEvent.shiftKey);
        }
        if ((this.isFullWidth() && isFullWidthContainerFocused) || !nextEl) {
            this.beans.navigation?.onTabKeyDown(this, keyboardEvent);
        }
    }
    getFullWidthElement() {
        if (this.fullWidthGui) {
            return this.fullWidthGui.element;
        }
        return null;
    }
    getRowYPosition() {
        const displayedEl = this.allRowGuis.find((el) => (0, dom_1._isVisible)(el.element))?.element;
        if (displayedEl) {
            return displayedEl.getBoundingClientRect().top;
        }
        return 0;
    }
    onSuppressCellFocusChanged(suppressCellFocus) {
        const tabIndex = this.isFullWidth() && suppressCellFocus ? undefined : -1;
        this.allRowGuis.forEach((gui) => {
            (0, dom_1._addOrRemoveAttribute)(gui.element, 'tabindex', tabIndex);
        });
    }
    onFullWidthRowFocused(event) {
        const node = this.rowNode;
        const isFocused = !event
            ? false
            : this.isFullWidth() && event.rowIndex === node.rowIndex && event.rowPinned == node.rowPinned;
        let element;
        if (this.fullWidthGui) {
            element = this.fullWidthGui.element;
        }
        else {
            const column = this.beans.colModel.getCol(event?.column);
            const pinned = column?.pinned;
            if (pinned) {
                element = pinned === 'right' ? this.rightGui?.element : this.leftGui?.element;
            }
            else {
                element = this.centerGui?.element;
            }
        }
        if (!element) {
            return;
        } // can happen with react ui, comp not yet ready
        element.classList.toggle('ag-full-width-focus', isFocused);
        if (isFocused && event?.forceBrowserFocus) {
            // we don't scroll normal rows into view when we focus them, so we don't want
            // to scroll Full Width rows either.
            element.focus({ preventScroll: true });
        }
    }
    recreateCell(cellCtrl) {
        this.centerCellCtrls = this.removeCellCtrl(this.centerCellCtrls, cellCtrl);
        this.leftCellCtrls = this.removeCellCtrl(this.leftCellCtrls, cellCtrl);
        this.rightCellCtrls = this.removeCellCtrl(this.rightCellCtrls, cellCtrl);
        cellCtrl.destroy();
        this.updateColumnLists();
    }
    removeCellCtrl(prev, cellCtrlToRemove) {
        const res = {
            list: [],
            map: {},
        };
        prev.list.forEach((cellCtrl) => {
            if (cellCtrl === cellCtrlToRemove) {
                return;
            }
            res.list.push(cellCtrl);
            res.map[cellCtrl.column.getInstanceId()] = cellCtrl;
        });
        return res;
    }
    onMouseEvent(eventName, mouseEvent) {
        switch (eventName) {
            case 'dblclick':
                this.onRowDblClick(mouseEvent);
                break;
            case 'click':
                this.onRowClick(mouseEvent);
                break;
            case 'touchstart':
            case 'mousedown':
                this.onRowMouseDown(mouseEvent);
                break;
        }
    }
    createRowEvent(type, domEvent) {
        const { rowNode } = this;
        return (0, gridOptionsUtils_1._addGridCommonParams)(this.gos, {
            type: type,
            node: rowNode,
            data: rowNode.data,
            rowIndex: rowNode.rowIndex,
            rowPinned: rowNode.rowPinned,
            event: domEvent,
        });
    }
    createRowEventWithSource(type, domEvent) {
        const event = this.createRowEvent(type, domEvent);
        // when first developing this, we included the rowComp in the event.
        // this seems very weird. so when introducing the event types, i left the 'source'
        // out of the type, and just include the source in the two places where this event
        // was fired (rowClicked and rowDoubleClicked). it doesn't make sense for any
        // users to be using this, as the rowComp isn't an object we expose, so would be
        // very surprising if a user was using it.
        event.source = this;
        return event;
    }
    onRowDblClick(mouseEvent) {
        if ((0, event_1._isStopPropagationForAgGrid)(mouseEvent)) {
            return;
        }
        this.beans.eventSvc.dispatchEvent(this.createRowEventWithSource('rowDoubleClicked', mouseEvent));
    }
    findFullWidthInfoForEvent(event) {
        if (!event) {
            return;
        }
        const rowGui = this.findFullWidthRowGui(event.target);
        const column = this.getColumnForFullWidth(rowGui);
        if (!rowGui || !column) {
            return;
        }
        return { rowGui, column };
    }
    findFullWidthRowGui(target) {
        return this.allRowGuis.find((c) => c.element.contains(target));
    }
    getColumnForFullWidth(fullWidthRowGui) {
        const { visibleCols } = this.beans;
        switch (fullWidthRowGui?.containerType) {
            case 'center':
                return visibleCols.centerCols[0];
            case 'left':
                return visibleCols.leftCols[0];
            case 'right':
                return visibleCols.rightCols[0];
            default:
                return visibleCols.allCols[0];
        }
    }
    onRowMouseDown(mouseEvent) {
        this.lastMouseDownOnDragger = (0, dom_1._isElementChildOfClass)(mouseEvent.target, 'ag-row-drag', 3);
        if (!this.isFullWidth()) {
            return;
        }
        const node = this.rowNode;
        const { rangeSvc, focusSvc } = this.beans;
        rangeSvc?.removeAllCellRanges();
        const groupInfo = this.findFullWidthInfoForEvent(mouseEvent);
        if (!groupInfo) {
            return;
        }
        const { rowGui, column } = groupInfo;
        const element = rowGui.element;
        const target = mouseEvent.target;
        let forceBrowserFocus = mouseEvent.defaultPrevented || (0, browser_1._isBrowserSafari)();
        if (element && element.contains(target) && (0, dom_1._isFocusableFormField)(target)) {
            forceBrowserFocus = false;
        }
        focusSvc.setFocusedCell({
            rowIndex: node.rowIndex,
            column,
            rowPinned: node.rowPinned,
            forceBrowserFocus,
        });
    }
    onRowClick(mouseEvent) {
        const stop = (0, event_1._isStopPropagationForAgGrid)(mouseEvent) || this.lastMouseDownOnDragger;
        if (stop) {
            return;
        }
        const { eventSvc, selectionSvc } = this.beans;
        eventSvc.dispatchEvent(this.createRowEventWithSource('rowClicked', mouseEvent));
        selectionSvc?.handleSelectionEvent(mouseEvent, this.rowNode, 'rowClicked');
    }
    setupDetailRowAutoHeight(eDetailGui) {
        if (this.rowType !== 'FullWidthDetail') {
            return;
        }
        this.beans.masterDetailSvc?.setupDetailRowAutoHeight(this, eDetailGui);
    }
    createFullWidthCompDetails(eRow, pinned) {
        const { gos, rowNode } = this;
        const params = (0, gridOptionsUtils_1._addGridCommonParams)(gos, {
            fullWidth: true,
            data: rowNode.data,
            node: rowNode,
            value: rowNode.key,
            valueFormatted: rowNode.key,
            // these need to be taken out, as part of 'afterAttached' now
            eGridCell: eRow,
            eParentOfValue: eRow,
            pinned: pinned,
            addRenderedRowListener: this.addEventListener.bind(this),
            registerRowDragger: (rowDraggerElement, dragStartPixels, value, suppressVisibilityChange) => this.addFullWidthRowDragging(rowDraggerElement, dragStartPixels, value, suppressVisibilityChange),
            setTooltip: (value, shouldDisplayTooltip) => {
                gos.assertModuleRegistered('Tooltip', 3);
                this.setupFullWidthRowTooltip(value, shouldDisplayTooltip);
            },
        });
        const compFactory = this.beans.userCompFactory;
        switch (this.rowType) {
            case 'FullWidthDetail':
                return (0, userCompUtils_1._getFullWidthDetailCellRendererDetails)(compFactory, params);
            case 'FullWidthGroup': {
                const { value, valueFormatted } = this.beans.valueSvc.getValueForDisplay(undefined, this.rowNode, true);
                params.value = value;
                params.valueFormatted = valueFormatted;
                return (0, userCompUtils_1._getFullWidthGroupCellRendererDetails)(compFactory, params);
            }
            case 'FullWidthLoading':
                return (0, userCompUtils_1._getFullWidthLoadingCellRendererDetails)(compFactory, params);
            default:
                return (0, userCompUtils_1._getFullWidthCellRendererDetails)(compFactory, params);
        }
    }
    setupFullWidthRowTooltip(value, shouldDisplayTooltip) {
        if (!this.fullWidthGui) {
            return;
        }
        this.tooltipFeature = this.beans.tooltipSvc?.setupFullWidthRowTooltip(this.tooltipFeature, this, value, shouldDisplayTooltip);
    }
    addFullWidthRowDragging(rowDraggerElement, dragStartPixels, value = '', suppressVisibilityChange) {
        const { rowDragSvc, context } = this.beans;
        if (!rowDragSvc || !this.isFullWidth()) {
            return;
        }
        const rowDragComp = rowDragSvc.createRowDragComp(() => value, this.rowNode, undefined, rowDraggerElement, dragStartPixels, suppressVisibilityChange);
        this.createBean(rowDragComp, context);
        this.addDestroyFunc(() => {
            this.destroyBean(rowDragComp, context);
        });
    }
    onUiLevelChanged() {
        const newLevel = (0, rowStyleService_1.calculateRowLevel)(this.rowNode);
        if (this.rowLevel != newLevel) {
            const classToAdd = 'ag-row-level-' + newLevel;
            const classToRemove = 'ag-row-level-' + this.rowLevel;
            this.allRowGuis.forEach((gui) => {
                gui.rowComp.toggleCss(classToAdd, true);
                gui.rowComp.toggleCss(classToRemove, false);
            });
        }
        this.rowLevel = newLevel;
    }
    isFirstRowOnPage() {
        return this.rowNode.rowIndex === this.beans.pageBounds.getFirstRow();
    }
    isLastRowOnPage() {
        return this.rowNode.rowIndex === this.beans.pageBounds.getLastRow();
    }
    refreshFirstAndLastRowStyles() {
        const newFirst = this.isFirstRowOnPage();
        const newLast = this.isLastRowOnPage();
        if (this.firstRowOnPage !== newFirst) {
            this.firstRowOnPage = newFirst;
            this.allRowGuis.forEach((gui) => gui.rowComp.toggleCss('ag-row-first', newFirst));
        }
        if (this.lastRowOnPage !== newLast) {
            this.lastRowOnPage = newLast;
            this.allRowGuis.forEach((gui) => gui.rowComp.toggleCss('ag-row-last', newLast));
        }
    }
    getAllCellCtrls() {
        if (this.leftCellCtrls.list.length === 0 && this.rightCellCtrls.list.length === 0) {
            return this.centerCellCtrls.list;
        }
        const res = [...this.centerCellCtrls.list, ...this.leftCellCtrls.list, ...this.rightCellCtrls.list];
        return res;
    }
    postProcessClassesFromGridOptions() {
        const cssClasses = [];
        this.beans.rowStyleSvc?.processClassesFromGridOptions(cssClasses, this.rowNode);
        if (!cssClasses.length) {
            return;
        }
        cssClasses.forEach((classStr) => {
            this.allRowGuis.forEach((c) => c.rowComp.toggleCss(classStr, true));
        });
    }
    postProcessRowClassRules() {
        this.beans.rowStyleSvc?.processRowClassRules(this.rowNode, (className) => {
            this.allRowGuis.forEach((gui) => gui.rowComp.toggleCss(className, true));
        }, (className) => {
            this.allRowGuis.forEach((gui) => gui.rowComp.toggleCss(className, false));
        });
    }
    setStylesFromGridOptions(updateStyles, gui) {
        if (updateStyles) {
            this.rowStyles = this.processStylesFromGridOptions();
        }
        this.forEachGui(gui, (gui) => gui.rowComp.setUserStyles(this.rowStyles));
    }
    getPinnedForContainer(rowContainerType) {
        if (rowContainerType === 'left' || rowContainerType === 'right') {
            return rowContainerType;
        }
        return null;
    }
    getInitialRowClasses(rowContainerType) {
        const pinned = this.getPinnedForContainer(rowContainerType);
        const fullWidthRow = this.isFullWidth();
        const { rowNode, beans } = this;
        const classes = [];
        classes.push('ag-row');
        classes.push(this.rowFocused ? 'ag-row-focus' : 'ag-row-no-focus');
        if (this.fadeInAnimation[rowContainerType]) {
            classes.push('ag-opacity-zero');
        }
        classes.push(rowNode.rowIndex % 2 === 0 ? 'ag-row-even' : 'ag-row-odd');
        if (rowNode.isRowPinned()) {
            classes.push('ag-row-pinned');
            if (beans.pinnedRowModel?.isManual()) {
                classes.push('ag-row-pinned-manual');
            }
        }
        // Only the source of the pinned row gets this class
        if (!rowNode.isRowPinned() && rowNode.pinnedSibling) {
            classes.push('ag-row-pinned-source');
        }
        if (rowNode.isSelected()) {
            classes.push('ag-row-selected');
        }
        if (rowNode.footer) {
            classes.push('ag-row-footer');
        }
        classes.push('ag-row-level-' + this.rowLevel);
        if (rowNode.stub) {
            classes.push('ag-row-loading');
        }
        if (fullWidthRow) {
            classes.push('ag-full-width-row');
        }
        beans.expansionSvc?.addExpandedCss(classes, rowNode);
        if (rowNode.dragging) {
            classes.push('ag-row-dragging');
        }
        const { rowStyleSvc } = beans;
        if (rowStyleSvc) {
            rowStyleSvc.processClassesFromGridOptions(classes, rowNode);
            rowStyleSvc.preProcessRowClassRules(classes, rowNode);
        }
        // we use absolute position unless we are doing print layout
        classes.push(this.printLayout ? 'ag-row-position-relative' : 'ag-row-position-absolute');
        if (this.isFirstRowOnPage()) {
            classes.push('ag-row-first');
        }
        if (this.isLastRowOnPage()) {
            classes.push('ag-row-last');
        }
        if (fullWidthRow) {
            if (pinned === 'left') {
                classes.push('ag-cell-last-left-pinned');
            }
            if (pinned === 'right') {
                classes.push('ag-cell-first-right-pinned');
            }
        }
        return classes;
    }
    processStylesFromGridOptions() {
        // Return constant reference for React
        return this.beans.rowStyleSvc?.processStylesFromGridOptions(this.rowNode) ?? this.emptyStyle;
    }
    onRowSelected(gui) {
        this.beans.selectionSvc?.onRowCtrlSelected(this, (gui) => {
            if (gui === this.centerGui || gui === this.fullWidthGui) {
                this.announceDescription();
            }
        }, gui);
    }
    announceDescription() {
        this.beans.selectionSvc?.announceAriaRowSelection(this.rowNode);
    }
    addHoverFunctionality(eGui) {
        // because we use animation frames to do this, it's possible the row no longer exists
        // by the time we get to add it
        if (!this.active) {
            return;
        }
        // because mouseenter and mouseleave do not propagate, we cannot listen on the gridPanel
        // like we do for all the other mouse events.
        // because of the pinning, we cannot simply add / remove the class based on the eRow. we
        // have to check all eRow's (body & pinned). so the trick is if any of the rows gets a
        // mouse hover, it sets such in the rowNode, and then all three reflect the change as
        // all are listening for event on the row node.
        const { element, compBean } = eGui;
        const { rowNode, beans, gos } = this;
        // step 1 - add listener, to set flag on row node
        compBean.addManagedListeners(element, {
            mouseenter: () => rowNode.dispatchRowEvent('mouseEnter'),
            mouseleave: () => rowNode.dispatchRowEvent('mouseLeave'),
        });
        // step 2 - listen for changes on row node (which any element can trigger)
        compBean.addManagedListeners(rowNode, {
            mouseEnter: () => {
                // if hover turned off, we don't add the class. we do this here so that if the application
                // toggles this property mid way, we remove the hover form the last row, but we stop
                // adding hovers from that point onwards. Also, do not highlight while dragging elements around.
                if (!beans.dragSvc?.dragging && !gos.get('suppressRowHoverHighlight')) {
                    element.classList.add('ag-row-hover');
                    rowNode.setHovered(true);
                }
            },
            mouseLeave: () => {
                this.resetHoveredStatus(element);
            },
        });
    }
    resetHoveredStatus(el) {
        const elements = el ? [el] : this.allRowGuis.map((gui) => gui.element);
        for (const element of elements) {
            element.classList.remove('ag-row-hover');
        }
        this.rowNode.setHovered(false);
    }
    // for animation, we don't want to animate entry or exit to a very far away pixel,
    // otherwise the row would move so fast, it would appear to disappear. so this method
    // moves the row closer to the viewport if it is far away, so the row slide in / out
    // at a speed the user can see.
    roundRowTopToBounds(rowTop) {
        const range = this.beans.ctrlsSvc.getScrollFeature().getApproximateVScollPosition();
        const minPixel = this.applyPaginationOffset(range.top, true) - 100;
        const maxPixel = this.applyPaginationOffset(range.bottom, true) + 100;
        return Math.min(Math.max(minPixel, rowTop), maxPixel);
    }
    forEachGui(gui, callback) {
        if (gui) {
            callback(gui);
        }
        else {
            this.allRowGuis.forEach(callback);
        }
    }
    isRowRendered() {
        return this.allRowGuis.length > 0;
    }
    onRowHeightChanged(gui) {
        // check for exists first - if the user is resetting the row height, then
        // it will be null (or undefined) momentarily until the next time the flatten
        // stage is called where the row will then update again with a new height
        if (this.rowNode.rowHeight == null) {
            return;
        }
        const rowHeight = this.rowNode.rowHeight;
        const defaultRowHeight = this.beans.environment.getDefaultRowHeight();
        const isHeightFromFunc = (0, gridOptionsUtils_1._isGetRowHeightFunction)(this.gos);
        const heightFromFunc = isHeightFromFunc ? (0, gridOptionsUtils_1._getRowHeightForNode)(this.beans, this.rowNode).height : undefined;
        const lineHeight = heightFromFunc ? `${Math.min(defaultRowHeight, heightFromFunc) - 2}px` : undefined;
        this.forEachGui(gui, (gui) => {
            gui.element.style.height = `${rowHeight}px`;
            // If the row height is coming from a function, this means some rows can
            // be smaller than the theme had intended. so we set --ag-line-height on
            // the row, which is picked up by the theme CSS and is used in a calc
            // for the CSS line-height property, which makes sure the line-height is
            // not bigger than the row height, otherwise the row text would not fit.
            // We do not use rowNode.rowHeight here, as this could be the result of autoHeight,
            // and we found using the autoHeight result causes a loop, where changing the
            // line-height them impacts the cell height, resulting in a new autoHeight,
            // resulting in a new line-height and so on loop.
            // const heightFromFunc = getRowHeightForNode(this.gos, this.rowNode).height;
            if (lineHeight) {
                gui.element.style.setProperty('--ag-line-height', lineHeight);
            }
        });
    }
    // note - this is NOT called by context, as we don't wire / unwire the CellComp for performance reasons.
    destroyFirstPass(suppressAnimation = false) {
        this.active = false;
        // why do we have this method? shouldn't everything below be added as a destroy func beside
        // the corresponding create logic?
        const { rowNode } = this;
        if (!suppressAnimation && (0, gridOptionsUtils_1._isAnimateRows)(this.gos) && !rowNode.sticky) {
            const rowStillVisibleJustNotInViewport = rowNode.rowTop != null;
            if (rowStillVisibleJustNotInViewport) {
                // if the row is not rendered, but in viewport, it means it has moved,
                // so we animate the row out. if the new location is very far away,
                // the animation will be so fast the row will look like it's just disappeared,
                // so instead we animate to a position just outside the viewport.
                const rowTop = this.roundRowTopToBounds(rowNode.rowTop);
                this.setRowTop(rowTop);
            }
            else {
                this.allRowGuis.forEach((gui) => gui.rowComp.toggleCss('ag-opacity-zero', true));
            }
        }
        // if this was focused; focus will need recovered
        if (this.fullWidthGui?.element.contains((0, gridOptionsUtils_1._getActiveDomElement)(this.beans))) {
            this.beans.focusSvc.attemptToRecoverFocus();
        }
        rowNode.setHovered(false);
        const event = this.createRowEvent('virtualRowRemoved');
        this.dispatchLocalEvent(event);
        this.beans.eventSvc.dispatchEvent(event);
        super.destroy();
    }
    destroySecondPass() {
        this.allRowGuis.length = 0;
        const destroyCellCtrls = (ctrls) => {
            ctrls.list.forEach((c) => c.destroy());
            return { list: [], map: {} };
        };
        this.centerCellCtrls = destroyCellCtrls(this.centerCellCtrls);
        this.leftCellCtrls = destroyCellCtrls(this.leftCellCtrls);
        this.rightCellCtrls = destroyCellCtrls(this.rightCellCtrls);
    }
    setFocusedClasses(gui) {
        this.forEachGui(gui, (gui) => {
            gui.rowComp.toggleCss('ag-row-focus', this.rowFocused);
            gui.rowComp.toggleCss('ag-row-no-focus', !this.rowFocused);
        });
    }
    onCellFocusChanged() {
        const { focusSvc } = this.beans;
        const rowFocused = focusSvc.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned);
        if (rowFocused !== this.rowFocused) {
            this.rowFocused = rowFocused;
            this.setFocusedClasses();
        }
    }
    onPaginationChanged() {
        const currentPage = this.beans.pagination?.getCurrentPage() ?? 0;
        // it is possible this row is in the new page, but the page number has changed, which means
        // it needs to reposition itself relative to the new page
        if (this.paginationPage !== currentPage) {
            this.paginationPage = currentPage;
            this.onTopChanged();
        }
        this.refreshFirstAndLastRowStyles();
    }
    onTopChanged() {
        this.setRowTop(this.rowNode.rowTop);
    }
    onPaginationPixelOffsetChanged() {
        // the pixel offset is used when calculating rowTop to set on the row DIV
        this.onTopChanged();
    }
    // applies pagination offset, eg if on second page, and page height is 500px, then removes
    // 500px from the top position, so a row with rowTop 600px is displayed at location 100px.
    // reverse will take the offset away rather than add.
    applyPaginationOffset(topPx, reverse = false) {
        if (this.rowNode.isRowPinned() || this.rowNode.sticky) {
            return topPx;
        }
        const pixelOffset = this.beans.pageBounds.getPixelOffset();
        const multiplier = reverse ? 1 : -1;
        return topPx + pixelOffset * multiplier;
    }
    setRowTop(pixels) {
        // print layout uses normal flow layout for row positioning
        if (this.printLayout) {
            return;
        }
        // need to make sure rowTop is not null, as this can happen if the node was once
        // visible (ie parent group was expanded) but is now not visible
        if ((0, generic_1._exists)(pixels)) {
            const afterPaginationPixels = this.applyPaginationOffset(pixels);
            const skipScaling = this.rowNode.isRowPinned() || this.rowNode.sticky;
            const afterScalingPixels = skipScaling
                ? afterPaginationPixels
                : this.beans.rowContainerHeight.getRealPixelPosition(afterPaginationPixels);
            const topPx = `${afterScalingPixels}px`;
            this.setRowTopStyle(topPx);
        }
    }
    // the top needs to be set into the DOM element when the element is created, not updated afterwards.
    // otherwise the transition would not work, as it would be transitioning from zero (the unset value).
    // for example, suppose a row that is outside the viewport, then user does a filter to remove other rows
    // and this row now appears in the viewport, and the row moves up (ie it was under the viewport and not rendered,
    // but now is in the viewport) then a new RowComp is created, however it should have it's position initialised
    // to below the viewport, so the row will appear to animate up. if we didn't set the initial position at creation
    // time, the row would animate down (ie from position zero).
    getInitialRowTop(rowContainerType) {
        return this.suppressRowTransform ? this.getInitialRowTopShared(rowContainerType) : undefined;
    }
    getInitialTransform(rowContainerType) {
        return this.suppressRowTransform ? undefined : `translateY(${this.getInitialRowTopShared(rowContainerType)})`;
    }
    getInitialRowTopShared(rowContainerType) {
        // print layout uses normal flow layout for row positioning
        if (this.printLayout) {
            return '';
        }
        const rowNode = this.rowNode;
        let rowTop;
        if (rowNode.sticky) {
            rowTop = rowNode.stickyRowTop;
        }
        else {
            // if sliding in, we take the old row top. otherwise we just set the current row top.
            const pixels = this.slideInAnimation[rowContainerType]
                ? this.roundRowTopToBounds(rowNode.oldRowTop)
                : rowNode.rowTop;
            const afterPaginationPixels = this.applyPaginationOffset(pixels);
            // we don't apply scaling if row is pinned
            rowTop = rowNode.isRowPinned()
                ? afterPaginationPixels
                : this.beans.rowContainerHeight.getRealPixelPosition(afterPaginationPixels);
        }
        return rowTop + 'px';
    }
    setRowTopStyle(topPx) {
        this.allRowGuis.forEach((gui) => this.suppressRowTransform ? gui.rowComp.setTop(topPx) : gui.rowComp.setTransform(`translateY(${topPx})`));
    }
    getCellCtrl(column, skipColSpanSearch = false) {
        // first up, check for cell directly linked to this column
        let res = null;
        this.getAllCellCtrls().forEach((cellCtrl) => {
            if (cellCtrl.column == column) {
                res = cellCtrl;
            }
        });
        if (res != null || skipColSpanSearch) {
            return res;
        }
        // second up, if not found, then check for spanned cols.
        // we do this second (and not at the same time) as this is
        // more expensive, as spanning cols is a
        // infrequently used feature so we don't need to do this most
        // of the time
        this.getAllCellCtrls().forEach((cellCtrl) => {
            if (cellCtrl?.getColSpanningList().indexOf(column) >= 0) {
                res = cellCtrl;
            }
        });
        return res;
    }
    onRowIndexChanged() {
        // we only bother updating if the rowIndex is present. if it is not present, it means this row
        // is child of a group node, and the group node was closed, it's the only way to have no row index.
        // when this happens, row is about to be de-rendered, so we don't care, rowComp is about to die!
        if (this.rowNode.rowIndex != null) {
            this.onCellFocusChanged();
            this.updateRowIndexes();
            this.postProcessCss();
        }
    }
    updateRowIndexes(gui) {
        const rowIndexStr = this.rowNode.getRowIndexString();
        if (rowIndexStr === null) {
            return;
        }
        const headerRowCount = (this.beans.ctrlsSvc.getHeaderRowContainerCtrl()?.getRowCount() ?? 0) +
            (this.beans.filterManager?.getHeaderRowCount() ?? 0);
        const rowIsEven = this.rowNode.rowIndex % 2 === 0;
        const ariaRowIndex = headerRowCount + this.rowNode.rowIndex + 1;
        this.forEachGui(gui, (c) => {
            c.rowComp.setRowIndex(rowIndexStr);
            c.rowComp.toggleCss('ag-row-even', rowIsEven);
            c.rowComp.toggleCss('ag-row-odd', !rowIsEven);
            (0, aria_1._setAriaRowIndex)(c.element, ariaRowIndex);
        });
    }
}
exports.RowCtrl = RowCtrl;


/***/ }),

/***/ 17109:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RowContainerHeightService = void 0;
const beanStub_1 = __webpack_require__(68731);
const browser_1 = __webpack_require__(98667);
const function_1 = __webpack_require__(92043);
/**
 * This class solves the 'max height' problem, where the user might want to show more data than
 * the max div height actually allows.
 */
class RowContainerHeightService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'rowContainerHeight';
        // the scrollY position
        this.scrollY = 0;
        // how tall the body is
        this.uiBodyHeight = 0;
    }
    postConstruct() {
        this.addManagedEventListeners({ bodyHeightChanged: this.updateOffset.bind(this) });
        this.maxDivHeight = (0, browser_1._getMaxDivHeight)();
        (0, function_1._logIfDebug)(this.gos, 'RowContainerHeightService - maxDivHeight = ' + this.maxDivHeight);
    }
    updateOffset() {
        if (!this.stretching) {
            return;
        }
        const newScrollY = this.beans.ctrlsSvc.getScrollFeature().getVScrollPosition().top;
        const newBodyHeight = this.getUiBodyHeight();
        const atLeastOneChanged = newScrollY !== this.scrollY || newBodyHeight !== this.uiBodyHeight;
        if (atLeastOneChanged) {
            this.scrollY = newScrollY;
            this.uiBodyHeight = newBodyHeight;
            this.calculateOffset();
        }
    }
    calculateOffset() {
        this.setUiContainerHeight(this.maxDivHeight);
        this.pixelsToShave = this.modelHeight - this.uiContainerHeight;
        this.maxScrollY = this.uiContainerHeight - this.uiBodyHeight;
        const scrollPercent = this.scrollY / this.maxScrollY;
        const divStretchOffset = scrollPercent * this.pixelsToShave;
        (0, function_1._logIfDebug)(this.gos, `RowContainerHeightService - Div Stretch Offset = ${divStretchOffset} (${this.pixelsToShave} * ${scrollPercent})`);
        this.setDivStretchOffset(divStretchOffset);
    }
    setUiContainerHeight(height) {
        if (height !== this.uiContainerHeight) {
            this.uiContainerHeight = height;
            this.eventSvc.dispatchEvent({ type: 'rowContainerHeightChanged' });
        }
    }
    clearOffset() {
        this.setUiContainerHeight(this.modelHeight);
        this.pixelsToShave = 0;
        this.setDivStretchOffset(0);
    }
    setDivStretchOffset(newOffset) {
        // because we are talking pixels, no point in confusing things with half numbers
        const newOffsetFloor = typeof newOffset === 'number' ? Math.floor(newOffset) : null;
        if (this.divStretchOffset === newOffsetFloor) {
            return;
        }
        this.divStretchOffset = newOffsetFloor;
        this.eventSvc.dispatchEvent({ type: 'heightScaleChanged' });
    }
    setModelHeight(modelHeight) {
        this.modelHeight = modelHeight;
        this.stretching =
            modelHeight != null && // null happens when in print layout
                this.maxDivHeight > 0 &&
                modelHeight > this.maxDivHeight;
        if (this.stretching) {
            this.calculateOffset();
        }
        else {
            this.clearOffset();
        }
    }
    getRealPixelPosition(modelPixel) {
        return modelPixel - this.divStretchOffset;
    }
    getUiBodyHeight() {
        const pos = this.beans.ctrlsSvc.getScrollFeature().getVScrollPosition();
        return pos.bottom - pos.top;
    }
    getScrollPositionForPixel(rowTop) {
        if (this.pixelsToShave <= 0) {
            return rowTop;
        }
        const modelMaxScroll = this.modelHeight - this.getUiBodyHeight();
        const scrollPercent = rowTop / modelMaxScroll;
        const scrollPixel = this.maxScrollY * scrollPercent;
        return scrollPixel;
    }
}
exports.RowContainerHeightService = RowContainerHeightService;


/***/ }),

/***/ 90557:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isRowInMap = exports.mapRowNodes = exports.RowRenderer = void 0;
const beanStub_1 = __webpack_require__(68731);
const positionUtils_1 = __webpack_require__(6257);
const gridOptionsUtils_1 = __webpack_require__(67274);
const headerUtils_1 = __webpack_require__(1323);
const array_1 = __webpack_require__(31502);
const dom_1 = __webpack_require__(33507);
const generic_1 = __webpack_require__(34422);
const logging_1 = __webpack_require__(47764);
const rowCtrl_1 = __webpack_require__(7632);
const ROW_ANIMATION_TIMEOUT = 400;
class RowRenderer extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'rowRenderer';
        this.destroyFuncsForColumnListeners = [];
        // map of row ids to row objects. keeps track of which elements
        // are rendered for which rows in the dom.
        this.rowCtrlsByRowIndex = {};
        this.zombieRowCtrls = {};
        this.allRowCtrls = [];
        this.topRowCtrls = [];
        this.bottomRowCtrls = [];
        // we only allow one refresh at a time, otherwise the internal memory structure here
        // will get messed up. this can happen if the user has a cellRenderer, and inside the
        // renderer they call an API method that results in another pass of the refresh,
        // then it will be trying to draw rows in the middle of a refresh.
        this.refreshInProgress = false;
        this.dataFirstRenderedFired = false;
        this.setupRangeSelectionListeners = () => {
            const onCellSelectionChanged = () => {
                this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onCellSelectionChanged());
            };
            const onColumnMovedPinnedVisible = () => {
                this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.updateRangeBordersIfRangeCount());
            };
            const addCellSelectionListeners = () => {
                this.eventSvc.addEventListener('cellSelectionChanged', onCellSelectionChanged);
                this.eventSvc.addEventListener('columnMoved', onColumnMovedPinnedVisible);
                this.eventSvc.addEventListener('columnPinned', onColumnMovedPinnedVisible);
                this.eventSvc.addEventListener('columnVisible', onColumnMovedPinnedVisible);
            };
            const removeCellSelectionListeners = () => {
                this.eventSvc.removeEventListener('cellSelectionChanged', onCellSelectionChanged);
                this.eventSvc.removeEventListener('columnMoved', onColumnMovedPinnedVisible);
                this.eventSvc.removeEventListener('columnPinned', onColumnMovedPinnedVisible);
                this.eventSvc.removeEventListener('columnVisible', onColumnMovedPinnedVisible);
            };
            this.addDestroyFunc(() => removeCellSelectionListeners());
            this.addManagedPropertyListeners(['enableRangeSelection', 'cellSelection'], () => {
                const isEnabled = (0, gridOptionsUtils_1._isCellSelectionEnabled)(this.gos);
                if (isEnabled) {
                    addCellSelectionListeners();
                }
                else {
                    removeCellSelectionListeners();
                }
            });
            const cellSelectionEnabled = (0, gridOptionsUtils_1._isCellSelectionEnabled)(this.gos);
            if (cellSelectionEnabled) {
                addCellSelectionListeners();
            }
        };
    }
    wireBeans(beans) {
        this.pageBounds = beans.pageBounds;
        this.colModel = beans.colModel;
        this.pinnedRowModel = beans.pinnedRowModel;
        this.rowModel = beans.rowModel;
        this.focusSvc = beans.focusSvc;
        this.rowContainerHeight = beans.rowContainerHeight;
        this.ctrlsSvc = beans.ctrlsSvc;
        this.editSvc = beans.editSvc;
    }
    postConstruct() {
        this.ctrlsSvc.whenReady(this, (p) => {
            this.gridBodyCtrl = p.gridBodyCtrl;
            this.initialise();
        });
    }
    initialise() {
        this.addManagedEventListeners({
            paginationChanged: this.onPageLoaded.bind(this),
            pinnedRowDataChanged: this.onPinnedRowDataChanged.bind(this),
            pinnedRowsChanged: this.onPinnedRowsChanged.bind(this),
            displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
            bodyScroll: this.onBodyScroll.bind(this),
            bodyHeightChanged: this.redraw.bind(this, {}),
        });
        this.addManagedPropertyListeners(['domLayout', 'embedFullWidthRows'], () => this.onDomLayoutChanged());
        this.addManagedPropertyListeners(['suppressMaxRenderedRowRestriction', 'rowBuffer'], () => this.redraw());
        this.addManagedPropertyListener('suppressCellFocus', (e) => this.onSuppressCellFocusChanged(e.currentValue));
        this.addManagedPropertyListeners([
            'groupSuppressBlankHeader',
            'getBusinessKeyForNode',
            'fullWidthCellRenderer',
            'fullWidthCellRendererParams',
            'suppressStickyTotalRow',
            'groupRowRenderer',
            'groupRowRendererParams',
            'loadingCellRenderer',
            'loadingCellRendererParams',
            'detailCellRenderer',
            'detailCellRendererParams',
            'enableRangeSelection',
            'enableCellTextSelection',
        ], () => this.redrawRows());
        this.addManagedPropertyListener('cellSelection', ({ currentValue, previousValue }) => {
            // Only redraw rows if cell selection is enabled or disabled
            if ((!previousValue && currentValue) || (previousValue && !currentValue)) {
                this.redrawRows();
            }
        });
        const { stickyRowSvc, gos, showRowGroupCols } = this.beans;
        if (showRowGroupCols) {
            this.addManagedPropertyListener('showOpenedGroup', () => {
                const columns = showRowGroupCols.getShowRowGroupCols();
                if (columns.length) {
                    this.refreshCells({ columns, force: true });
                }
            });
        }
        if (stickyRowSvc) {
            this.stickyRowFeature = stickyRowSvc.createStickyRowFeature(this, this.createRowCon.bind(this), this.destroyRowCtrls.bind(this));
        }
        else {
            const gridBodyCtrl = this.gridBodyCtrl;
            gridBodyCtrl.setStickyTopHeight(0);
            gridBodyCtrl.setStickyBottomHeight(0);
        }
        this.registerCellEventListeners();
        this.initialiseCache();
        this.printLayout = (0, gridOptionsUtils_1._isDomLayout)(gos, 'print');
        this.embedFullWidthRows = this.printLayout || gos.get('embedFullWidthRows');
        this.redrawAfterModelUpdate();
    }
    initialiseCache() {
        if (this.gos.get('keepDetailRows')) {
            const countProp = this.getKeepDetailRowsCount();
            const count = countProp != null ? countProp : 3;
            this.cachedRowCtrls = new RowCtrlCache(count);
        }
    }
    getKeepDetailRowsCount() {
        return this.gos.get('keepDetailRowsCount');
    }
    getStickyTopRowCtrls() {
        return this.stickyRowFeature?.stickyTopRowCtrls ?? [];
    }
    getStickyBottomRowCtrls() {
        return this.stickyRowFeature?.stickyBottomRowCtrls ?? [];
    }
    updateAllRowCtrls() {
        const liveList = Object.values(this.rowCtrlsByRowIndex);
        const zombieList = Object.values(this.zombieRowCtrls);
        const cachedList = this.cachedRowCtrls?.getEntries() ?? [];
        if (zombieList.length > 0 || cachedList.length > 0) {
            // Only spread if we need to.
            this.allRowCtrls = [...liveList, ...zombieList, ...cachedList];
        }
        else {
            this.allRowCtrls = liveList;
        }
    }
    /**
     * Checks if the cell is rendered or not. Also returns true if row ctrl is present but has not rendered
     * cells yet.
     * @returns true if cellCtrl is present, or if the row is present but has not rendered rows yet
     */
    isCellBeingRendered(rowIndex, column) {
        const rowCtrl = this.rowCtrlsByRowIndex[rowIndex];
        // if no column, simply check for row ctrl, if no rowCtrl then return false
        if (!column || !rowCtrl) {
            return !!rowCtrl;
        }
        if (rowCtrl.isFullWidth()) {
            return true;
        }
        // return true if:
        // - spannedRowRenderer has a cell for this position,
        // - or if the rowCtrl has a cell for this column
        // - or if the row is not rendered yet, as it might try to render it
        const spannedCell = this.beans.spannedRowRenderer?.getCellByPosition({ rowIndex, column, rowPinned: null });
        return !!spannedCell || !!rowCtrl.getCellCtrl(column) || !rowCtrl.isRowRendered();
    }
    /**
     * Notifies all row and cell controls of any change in focused cell.
     * @param event cell focused event
     */
    updateCellFocus(event) {
        this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onCellFocused(event));
        this.getFullWidthRowCtrls().forEach((rowCtrl) => rowCtrl.onFullWidthRowFocused(event));
    }
    /**
     * Called when a new cell is focused in the grid
     * - if the focused cell isn't rendered; re-draw rows to dry to render it
     * - subsequently updates all cell and row controls with the new focused cell
     * @param event cell focused event
     */
    onCellFocusChanged(event) {
        // if the focused cell has not been rendered, need to render cell so focus can be captured.
        if (event && event.rowIndex != null && !event.rowPinned) {
            const col = this.beans.colModel.getCol(event.column) ?? undefined;
            if (!this.isCellBeingRendered(event.rowIndex, col)) {
                this.redraw();
            }
        }
        this.updateCellFocus(event);
    }
    onSuppressCellFocusChanged(suppressCellFocus) {
        this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onSuppressCellFocusChanged(suppressCellFocus));
        this.getFullWidthRowCtrls().forEach((rowCtrl) => rowCtrl.onSuppressCellFocusChanged(suppressCellFocus));
    }
    // in a clean design, each cell would register for each of these events. however when scrolling, all the cells
    // registering and de-registering for events is a performance bottleneck. so we register here once and inform
    // all active cells.
    registerCellEventListeners() {
        this.addManagedEventListeners({
            cellFocused: (event) => this.onCellFocusChanged(event),
            cellFocusCleared: () => this.updateCellFocus(),
            flashCells: (event) => {
                const { cellFlashSvc } = this.beans;
                if (cellFlashSvc) {
                    this.getAllCellCtrls().forEach((cellCtrl) => cellFlashSvc.onFlashCells(cellCtrl, event));
                }
            },
            columnHoverChanged: () => {
                this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onColumnHover());
            },
            displayedColumnsChanged: () => {
                this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onDisplayedColumnsChanged());
            },
            displayedColumnsWidthChanged: () => {
                // only for printLayout - because we are rendering all the cells in the same row, regardless of pinned state,
                // then changing the width of the containers will impact left position. eg the center cols all have their
                // left position adjusted by the width of the left pinned column, so if the pinned left column width changes,
                // all the center cols need to be shifted to accommodate this. when in normal layout, the pinned cols are
                // in different containers so doesn't impact.
                if (this.printLayout) {
                    this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onLeftChanged());
                }
            },
        });
        this.setupRangeSelectionListeners();
        // add listeners to the grid columns
        this.refreshListenersToColumnsForCellComps();
        // if the grid columns change, then refresh the listeners again
        this.addManagedEventListeners({
            gridColumnsChanged: this.refreshListenersToColumnsForCellComps.bind(this),
        });
        this.addDestroyFunc(this.removeGridColumnListeners.bind(this));
    }
    // executes all functions in destroyFuncsForColumnListeners and then clears the list
    removeGridColumnListeners() {
        this.destroyFuncsForColumnListeners.forEach((func) => func());
        this.destroyFuncsForColumnListeners.length = 0;
    }
    // this function adds listeners onto all the grid columns, which are the column that we could have cellComps for.
    // when the grid columns change, we add listeners again. in an ideal design, each CellComp would just register to
    // the column it belongs to on creation, however this was a bottleneck with the number of cells, so do it here
    // once instead.
    refreshListenersToColumnsForCellComps() {
        this.removeGridColumnListeners();
        const cols = this.colModel.getCols();
        cols.forEach((col) => {
            const forEachCellWithThisCol = (callback) => {
                this.getAllCellCtrls().forEach((cellCtrl) => {
                    if (cellCtrl.column === col) {
                        callback(cellCtrl);
                    }
                });
            };
            const leftChangedListener = () => {
                forEachCellWithThisCol((cellCtrl) => cellCtrl.onLeftChanged());
            };
            const widthChangedListener = () => {
                forEachCellWithThisCol((cellCtrl) => cellCtrl.onWidthChanged());
            };
            const firstRightPinnedChangedListener = () => {
                forEachCellWithThisCol((cellCtrl) => cellCtrl.onFirstRightPinnedChanged());
            };
            const lastLeftPinnedChangedListener = () => {
                forEachCellWithThisCol((cellCtrl) => cellCtrl.onLastLeftPinnedChanged());
            };
            const colDefChangedListener = () => {
                forEachCellWithThisCol((cellCtrl) => cellCtrl.onColDefChanged());
            };
            col.__addEventListener('leftChanged', leftChangedListener);
            col.__addEventListener('widthChanged', widthChangedListener);
            col.__addEventListener('firstRightPinnedChanged', firstRightPinnedChangedListener);
            col.__addEventListener('lastLeftPinnedChanged', lastLeftPinnedChangedListener);
            col.__addEventListener('colDefChanged', colDefChangedListener);
            this.destroyFuncsForColumnListeners.push(() => {
                col.__removeEventListener('leftChanged', leftChangedListener);
                col.__removeEventListener('widthChanged', widthChangedListener);
                col.__removeEventListener('firstRightPinnedChanged', firstRightPinnedChangedListener);
                col.__removeEventListener('lastLeftPinnedChanged', lastLeftPinnedChangedListener);
                col.__removeEventListener('colDefChanged', colDefChangedListener);
            });
        });
    }
    onDomLayoutChanged() {
        const printLayout = (0, gridOptionsUtils_1._isDomLayout)(this.gos, 'print');
        const embedFullWidthRows = printLayout || this.gos.get('embedFullWidthRows');
        // if moving towards or away from print layout, means we need to destroy all rows, as rows are not laid
        // out using absolute positioning when doing print layout
        const destroyRows = embedFullWidthRows !== this.embedFullWidthRows || this.printLayout !== printLayout;
        this.printLayout = printLayout;
        this.embedFullWidthRows = embedFullWidthRows;
        if (destroyRows) {
            this.redrawAfterModelUpdate({ domLayoutChanged: true });
        }
    }
    // for row models that have datasources, when we update the datasource, we need to force the rowRenderer
    // to redraw all rows. otherwise the old rows from the old datasource will stay displayed.
    datasourceChanged() {
        this.firstRenderedRow = 0;
        this.lastRenderedRow = -1;
        const rowIndexesToRemove = Object.keys(this.rowCtrlsByRowIndex);
        this.removeRowCtrls(rowIndexesToRemove);
    }
    onPageLoaded(event) {
        const params = {
            recycleRows: event.keepRenderedRows,
            animate: event.animate,
            newData: event.newData,
            newPage: event.newPage,
            // because this is a model updated event (not pinned rows), we
            // can skip updating the pinned rows. this is needed so that if user
            // is doing transaction updates, the pinned rows are not getting constantly
            // trashed - or editing cells in pinned rows are not refreshed and put into read mode
            onlyBody: true,
        };
        this.redrawAfterModelUpdate(params);
    }
    /**
     * @param column AgColumn
     * @returns An array with HTMLElement for every cell of the column passed as param.
     * If the cell is spanning across multiple columns, it only returns the html element
     * if the column passed is the first column of the span (used for auto width calculation).
     */
    getAllCellsNotSpanningForColumn(column) {
        const res = [];
        this.getAllRowCtrls().forEach((rowCtrl) => {
            const eCell = rowCtrl.getCellCtrl(column, true)?.eGui;
            if (eCell) {
                res.push(eCell);
            }
        });
        return res;
    }
    refreshFloatingRowComps(recycleRows = true) {
        this.refreshFloatingRows(this.topRowCtrls, 'top', recycleRows);
        this.refreshFloatingRows(this.bottomRowCtrls, 'bottom', recycleRows);
    }
    /**
     * Determines which row controllers need to be destroyed and re-created vs which ones can
     * be re-used.
     *
     * This is operation is to pinned/floating rows as `this.recycleRows` is to normal/body rows.
     *
     * All `RowCtrl` instances in `rowCtrls` that don't correspond to `RowNode` instances in `rowNodes` are destroyed.
     * All `RowNode` instances in `rowNodes` that don't correspond to `RowCtrl` instances in `rowCtrls` are created.
     * All instances in `rowCtrls` must be in the same order as their corresponding nodes in `rowNodes`.
     *
     * @param rowCtrls The list of existing row controllers
     * @param rowNodes The canonical list of row nodes that should have associated controllers
     */
    refreshFloatingRows(rowCtrls, floating, recycleRows) {
        const { pinnedRowModel, beans, printLayout } = this;
        const rowCtrlMap = Object.fromEntries(rowCtrls.map((ctrl) => [ctrl.rowNode.id, ctrl]));
        pinnedRowModel?.forEachPinnedRow(floating, (node, i) => {
            const rowCtrl = rowCtrls[i];
            const rowCtrlDoesNotExist = rowCtrl && pinnedRowModel.getPinnedRowById(rowCtrl.rowNode.id, floating) === undefined;
            if (rowCtrlDoesNotExist) {
                // ctrl not in new nodes list, destroy
                rowCtrl.destroyFirstPass();
                rowCtrl.destroySecondPass();
            }
            if (node.id in rowCtrlMap && recycleRows) {
                // ctrl exists already, re-use it
                rowCtrls[i] = rowCtrlMap[node.id];
                delete rowCtrlMap[node.id];
            }
            else {
                // ctrl doesn't exist, create it
                rowCtrls[i] = new rowCtrl_1.RowCtrl(node, beans, false, false, printLayout);
            }
        });
        const rowNodeCount = (floating === 'top' ? pinnedRowModel?.getPinnedTopRowCount() : pinnedRowModel?.getPinnedBottomRowCount()) ??
            0;
        // Truncate array if rowCtrls is longer than rowNodes
        rowCtrls.length = rowNodeCount;
    }
    onPinnedRowDataChanged() {
        // recycling rows in order to ensure cell editing is not cancelled
        const params = {
            recycleRows: true,
        };
        this.redrawAfterModelUpdate(params);
    }
    onPinnedRowsChanged() {
        this.redrawAfterModelUpdate({ recycleRows: true });
    }
    redrawRow(rowNode, suppressEvent = false) {
        if (rowNode.sticky) {
            this.stickyRowFeature?.refreshStickyNode(rowNode);
        }
        else if (this.cachedRowCtrls?.has(rowNode)) {
            // delete row from cache if it needs redrawn
            // if it's in the cache no updates need fired, as nothing
            // has been rendered
            this.cachedRowCtrls.removeRow(rowNode);
            return;
        }
        else {
            const destroyAndRecreateCtrl = (dataStruct) => {
                const ctrl = dataStruct[rowNode.rowIndex];
                if (!ctrl) {
                    return;
                }
                if (ctrl.rowNode !== rowNode) {
                    // if the node is in the wrong place, then the row model is responsible for triggering a full refresh.
                    return;
                }
                ctrl.destroyFirstPass();
                ctrl.destroySecondPass();
                dataStruct[rowNode.rowIndex] = this.createRowCon(rowNode, false, false);
            };
            switch (rowNode.rowPinned) {
                case 'top':
                    destroyAndRecreateCtrl(this.topRowCtrls);
                    break;
                case 'bottom':
                    destroyAndRecreateCtrl(this.bottomRowCtrls);
                    break;
                default:
                    destroyAndRecreateCtrl(this.rowCtrlsByRowIndex);
                    this.updateAllRowCtrls();
            }
        }
        if (!suppressEvent) {
            this.dispatchDisplayedRowsChanged(false);
        }
    }
    redrawRows(rowNodes) {
        const { editSvc } = this.beans;
        if (editSvc?.isEditing()) {
            if (editSvc.isBatchEditing()) {
                editSvc.cleanupEditors();
            }
            else {
                editSvc.stopEditing(undefined, { source: 'api' });
            }
        }
        // if no row nodes provided, then refresh everything
        const partialRefresh = rowNodes != null;
        if (partialRefresh) {
            rowNodes?.forEach((node) => this.redrawRow(node, true));
            this.dispatchDisplayedRowsChanged(false);
            return;
        }
        this.redrawAfterModelUpdate();
    }
    // gets called from:
    // +) initialisation (in registerGridComp) params = null
    // +) onDomLayoutChanged, params = null
    // +) onPageLoaded, recycleRows, animate, newData, newPage from event, onlyBody=true
    // +) onPinnedRowDataChanged, recycleRows = true
    // +) redrawRows (from Grid API), recycleRows = true/false
    redrawAfterModelUpdate(params = {}) {
        this.getLockOnRefresh();
        const focusedCell = this.beans.focusSvc?.getFocusCellToUseAfterRefresh();
        this.updateContainerHeights();
        this.scrollToTopIfNewData(params);
        // never recycle rows on layout change as rows could change from normal DOM layout
        // back to the grid's row positioning.
        const recycleRows = !params.domLayoutChanged && !!params.recycleRows;
        const animate = params.animate && (0, gridOptionsUtils_1._isAnimateRows)(this.gos);
        // after modelUpdate, row indexes can change, so we clear out the rowsByIndex map,
        // however we can reuse the rows, so we keep them but index by rowNode.id
        const rowsToRecycle = recycleRows ? this.getRowsToRecycle() : null;
        if (!recycleRows) {
            this.removeAllRowComps();
        }
        this.workOutFirstAndLastRowsToRender();
        const { stickyRowFeature, gos } = this;
        if (stickyRowFeature) {
            stickyRowFeature.checkStickyRows();
            // this is a hack, if sticky rows brings in rows from other pages
            // need to update the model height to include them.
            const extraHeight = stickyRowFeature.extraTopHeight + stickyRowFeature.extraBottomHeight;
            if (extraHeight) {
                this.updateContainerHeights(extraHeight);
            }
        }
        this.recycleRows(rowsToRecycle, animate);
        this.gridBodyCtrl.updateRowCount();
        if (!params.onlyBody) {
            this.refreshFloatingRowComps(gos.get('enableRowPinning') ? recycleRows : undefined);
        }
        this.dispatchDisplayedRowsChanged();
        // if a cell was focused before, ensure focus now.
        if (focusedCell != null) {
            this.restoreFocusedCell(focusedCell);
        }
        this.releaseLockOnRefresh();
    }
    scrollToTopIfNewData(params) {
        const scrollToTop = params.newData || params.newPage;
        const suppressScrollToTop = this.gos.get('suppressScrollOnNewData');
        if (scrollToTop && !suppressScrollToTop) {
            this.gridBodyCtrl.scrollFeature.scrollToTop();
            this.stickyRowFeature?.resetOffsets();
        }
    }
    updateContainerHeights(additionalHeight = 0) {
        const { rowContainerHeight } = this;
        // when doing print layout, we don't explicitly set height on the containers
        if (this.printLayout) {
            rowContainerHeight.setModelHeight(null);
            return;
        }
        let containerHeight = this.pageBounds.getCurrentPageHeight();
        // we need at least 1 pixel for the horizontal scroll to work. so if there are now rows,
        // we still want the scroll to be present, otherwise there would be no way to scroll the header
        // which might be needed us user wants to access columns
        // on the RHS - and if that was where the filter was that cause no rows to be presented, there
        // is no way to remove the filter.
        if (containerHeight === 0) {
            containerHeight = 1;
        }
        rowContainerHeight.setModelHeight(containerHeight + additionalHeight);
    }
    getLockOnRefresh() {
        if (this.refreshInProgress) {
            throw new Error((0, logging_1._errMsg)(252));
        }
        this.refreshInProgress = true;
        this.beans.frameworkOverrides.getLockOnRefresh?.();
    }
    releaseLockOnRefresh() {
        this.refreshInProgress = false;
        this.beans.frameworkOverrides.releaseLockOnRefresh?.();
    }
    isRefreshInProgress() {
        return this.refreshInProgress;
    }
    // sets the focus to the provided cell, if the cell is provided. this way, the user can call refresh without
    // worry about the focus been lost. this is important when the user is using keyboard navigation to do edits
    // and the cellEditor is calling 'refresh' to get other cells to update (as other cells might depend on the
    // edited cell).
    restoreFocusedCell(cellPosition) {
        if (!cellPosition) {
            return;
        }
        const focusSvc = this.beans.focusSvc;
        const cellToFocus = this.findPositionToFocus(cellPosition);
        if (!cellToFocus) {
            focusSvc.focusHeaderPosition({
                headerPosition: {
                    headerRowIndex: (0, headerUtils_1.getFocusHeaderRowCount)(this.beans) - 1,
                    column: cellPosition.column,
                },
            });
            return;
        }
        // if focus has changed (e.g, if row has been removed, so focus moved up) focus new cell
        if (cellPosition.rowIndex !== cellToFocus.rowIndex || cellPosition.rowPinned != cellToFocus.rowPinned) {
            focusSvc.setFocusedCell({
                ...cellToFocus,
                preventScrollOnBrowserFocus: true,
                forceBrowserFocus: true,
            });
            return;
        }
        // if the grid lost focus, we need to try to bring it back
        if (!focusSvc.doesRowOrCellHaveBrowserFocus()) {
            this.updateCellFocus((0, gridOptionsUtils_1._addGridCommonParams)(this.gos, {
                ...cellToFocus,
                forceBrowserFocus: true,
                preventScrollOnBrowserFocus: true,
                type: 'cellFocused',
            }));
        }
    }
    findPositionToFocus(cellPosition) {
        const { pagination, pageBounds } = this.beans;
        let rowPosition = cellPosition;
        // if the provided row isn't on the current page, focus first row of the current page
        if (rowPosition.rowPinned == null &&
            pagination &&
            pageBounds &&
            !pagination.isRowInPage(rowPosition.rowIndex)) {
            rowPosition = { rowPinned: null, rowIndex: pageBounds.getFirstRow() };
        }
        while (rowPosition) {
            // shortcut for pagination
            if (rowPosition.rowPinned == null && pageBounds) {
                // if row is before this page, get row above
                if (rowPosition.rowIndex < pageBounds.getFirstRow()) {
                    rowPosition = (0, positionUtils_1._getRowAbove)(this.beans, { rowPinned: null, rowIndex: 0 });
                    if (!rowPosition) {
                        return null;
                    }
                }
                else if (rowPosition.rowIndex > pageBounds.getLastRow()) {
                    // if row above this page, start from last row of this page
                    rowPosition = { rowPinned: null, rowIndex: pageBounds.getLastRow() };
                }
            }
            const row = this.getRowByPosition(rowPosition);
            if (row?.isAlive()) {
                return { ...row.getRowPosition(), column: cellPosition.column };
            }
            rowPosition = (0, positionUtils_1._getRowAbove)(this.beans, rowPosition);
        }
        return null;
    }
    getAllCellCtrls() {
        const res = [];
        const rowCtrls = this.getAllRowCtrls();
        const rowCtrlsLength = rowCtrls.length;
        for (let i = 0; i < rowCtrlsLength; i++) {
            const cellCtrls = rowCtrls[i].getAllCellCtrls();
            const cellCtrlsLength = cellCtrls.length;
            for (let j = 0; j < cellCtrlsLength; j++) {
                res.push(cellCtrls[j]);
            }
        }
        return res;
    }
    getAllRowCtrls() {
        const { spannedRowRenderer } = this.beans;
        const stickyTopRowCtrls = this.getStickyTopRowCtrls();
        const stickyBottomRowCtrls = this.getStickyBottomRowCtrls();
        const res = [
            ...this.topRowCtrls,
            ...this.bottomRowCtrls,
            ...stickyTopRowCtrls,
            ...stickyBottomRowCtrls,
            ...(spannedRowRenderer?.getCtrls('top') ?? []),
            ...(spannedRowRenderer?.getCtrls('bottom') ?? []),
            ...(spannedRowRenderer?.getCtrls('center') ?? []),
            ...Object.values(this.rowCtrlsByRowIndex),
        ];
        return res;
    }
    addRenderedRowListener(eventName, rowIndex, callback) {
        const rowComp = this.rowCtrlsByRowIndex[rowIndex];
        if (rowComp) {
            rowComp.addEventListener(eventName, callback);
        }
    }
    refreshCells({ rowNodes, columns, force, suppressFlash } = {}) {
        const refreshCellParams = {
            force,
            newData: false,
            suppressFlash,
        };
        for (const cellCtrl of this.getCellCtrls(rowNodes, columns)) {
            cellCtrl.refreshOrDestroyCell(refreshCellParams);
        }
        // refresh the full width rows too
        this.refreshFullWidth(rowNodes);
    }
    refreshRows(params = {}) {
        this.getRowCtrls(params.rowNodes).forEach((rowCtrl) => rowCtrl.refreshRow(params));
        // refresh the full width rows too
        this.refreshFullWidth(params.rowNodes);
    }
    refreshFullWidth(rowNodes) {
        if (!rowNodes) {
            return;
        }
        let rowRedrawn = false;
        for (const rowCtrl of this.getRowCtrls(rowNodes)) {
            if (!rowCtrl.isFullWidth()) {
                continue;
            }
            const refreshed = rowCtrl.refreshFullWidth();
            if (!refreshed) {
                rowRedrawn = true;
                this.redrawRow(rowCtrl.rowNode, true);
            }
        }
        if (rowRedrawn) {
            this.dispatchDisplayedRowsChanged(false);
        }
    }
    /**
     * @param rowNodes if provided, returns the RowCtrls for the provided rowNodes. otherwise returns all RowCtrls.
     */
    getRowCtrls(rowNodes) {
        const rowIdsMap = mapRowNodes(rowNodes);
        const allRowCtrls = this.getAllRowCtrls();
        if (!rowNodes || !rowIdsMap) {
            return allRowCtrls;
        }
        return allRowCtrls.filter((rowCtrl) => {
            const rowNode = rowCtrl.rowNode;
            return isRowInMap(rowNode, rowIdsMap);
        });
    }
    // returns CellCtrl's that match the provided rowNodes and columns. eg if one row node
    // and two columns provided, that identifies 4 cells, so 4 CellCtrl's returned.
    getCellCtrls(rowNodes, columns) {
        let colIdsMap;
        if ((0, generic_1._exists)(columns)) {
            colIdsMap = {};
            columns.forEach((colKey) => {
                const column = this.colModel.getCol(colKey);
                if ((0, generic_1._exists)(column)) {
                    colIdsMap[column.getId()] = true;
                }
            });
        }
        const res = [];
        this.getRowCtrls(rowNodes).forEach((rowCtrl) => {
            rowCtrl.getAllCellCtrls().forEach((cellCtrl) => {
                const colId = cellCtrl.column.getId();
                const excludeColFromRefresh = colIdsMap && !colIdsMap[colId];
                if (excludeColFromRefresh) {
                    return;
                }
                res.push(cellCtrl);
            });
        });
        return res;
    }
    destroy() {
        this.removeAllRowComps(true);
        super.destroy();
    }
    removeAllRowComps(suppressAnimation = false) {
        const rowIndexesToRemove = Object.keys(this.rowCtrlsByRowIndex);
        this.removeRowCtrls(rowIndexesToRemove, suppressAnimation);
        this.stickyRowFeature?.destroyStickyCtrls();
    }
    getRowsToRecycle() {
        // remove all stub nodes, they can't be reused, as no rowNode id
        const stubNodeIndexes = [];
        for (const index of Object.keys(this.rowCtrlsByRowIndex)) {
            const rowCtrl = this.rowCtrlsByRowIndex[index];
            const stubNode = rowCtrl.rowNode.id == null;
            if (stubNode) {
                stubNodeIndexes.push(index);
            }
        }
        this.removeRowCtrls(stubNodeIndexes);
        // then clear out rowCompsByIndex, but before that take a copy, but index by id, not rowIndex
        const ctrlsByIdMap = {};
        for (const rowCtrl of Object.values(this.rowCtrlsByRowIndex)) {
            const rowNode = rowCtrl.rowNode;
            ctrlsByIdMap[rowNode.id] = rowCtrl;
        }
        this.rowCtrlsByRowIndex = {};
        return ctrlsByIdMap;
    }
    // takes array of row indexes
    removeRowCtrls(rowsToRemove, suppressAnimation = false) {
        // if no fromIndex then set to -1, which will refresh everything
        // let realFromIndex = -1;
        rowsToRemove.forEach((indexToRemove) => {
            const rowCtrl = this.rowCtrlsByRowIndex[indexToRemove];
            if (rowCtrl) {
                rowCtrl.destroyFirstPass(suppressAnimation);
                rowCtrl.destroySecondPass();
            }
            delete this.rowCtrlsByRowIndex[indexToRemove];
        });
    }
    onBodyScroll(e) {
        if (e.direction !== 'vertical') {
            return;
        }
        this.redraw({ afterScroll: true });
    }
    // gets called when rows don't change, but viewport does, so after:
    // 1) height of grid body changes, ie number of displayed rows has changed
    // 2) grid scrolled to new position
    // 3) ensure index visible (which is a scroll)
    redraw(params = {}) {
        const { focusSvc, animationFrameSvc } = this.beans;
        const { afterScroll } = params;
        let cellFocused;
        const stickyRowFeature = this.stickyRowFeature;
        // only try to refocus cells shifting in and out of sticky container
        // if the browser supports focus ({ preventScroll })
        if (stickyRowFeature) {
            cellFocused = focusSvc?.getFocusCellToUseAfterRefresh() || undefined;
        }
        const oldFirstRow = this.firstRenderedRow;
        const oldLastRow = this.lastRenderedRow;
        this.workOutFirstAndLastRowsToRender();
        let hasStickyRowChanges = false;
        if (stickyRowFeature) {
            hasStickyRowChanges = stickyRowFeature.checkStickyRows();
            // this is a hack, if sticky rows brings in rows from other pages
            // need to update the model height to include them.
            const extraHeight = stickyRowFeature.extraTopHeight + stickyRowFeature.extraBottomHeight;
            if (extraHeight) {
                this.updateContainerHeights(extraHeight);
            }
        }
        const rangeChanged = this.firstRenderedRow !== oldFirstRow || this.lastRenderedRow !== oldLastRow;
        if (afterScroll && !hasStickyRowChanges && !rangeChanged) {
            return;
        }
        this.getLockOnRefresh();
        this.recycleRows(null, false, afterScroll);
        this.releaseLockOnRefresh();
        // AfterScroll results in flushSync in React but we need to disable flushSync for sticky row group changes to avoid flashing
        this.dispatchDisplayedRowsChanged(afterScroll && !hasStickyRowChanges);
        if (cellFocused != null) {
            const newFocusedCell = focusSvc?.getFocusCellToUseAfterRefresh();
            if (cellFocused != null && newFocusedCell == null) {
                animationFrameSvc?.flushAllFrames();
                this.restoreFocusedCell(cellFocused);
            }
        }
    }
    removeRowCompsNotToDraw(indexesToDraw, suppressAnimation) {
        // for speedy lookup, dump into map
        const indexesToDrawMap = {};
        indexesToDraw.forEach((index) => (indexesToDrawMap[index] = true));
        const existingIndexes = Object.keys(this.rowCtrlsByRowIndex);
        const indexesNotToDraw = existingIndexes.filter((index) => !indexesToDrawMap[index]);
        this.removeRowCtrls(indexesNotToDraw, suppressAnimation);
    }
    calculateIndexesToDraw(rowsToRecycle) {
        // all in all indexes in the viewport
        const indexesToDraw = [];
        for (let i = this.firstRenderedRow; i <= this.lastRenderedRow; i++) {
            indexesToDraw.push(i);
        }
        const pagination = this.beans.pagination;
        // if focus should be on a row, ensure the row is rendered.
        const focusedRowIndex = this.beans.focusSvc?.getFocusedCell()?.rowIndex;
        if (focusedRowIndex != null &&
            (focusedRowIndex < this.firstRenderedRow || focusedRowIndex > this.lastRenderedRow) &&
            (!pagination || pagination.isRowInPage(focusedRowIndex)) &&
            focusedRowIndex < this.rowModel.getRowCount()) {
            indexesToDraw.push(focusedRowIndex);
        }
        const checkRowToDraw = (rowComp) => {
            const index = rowComp.rowNode.rowIndex;
            if (index == null || index === focusedRowIndex) {
                return;
            }
            if (index < this.firstRenderedRow || index > this.lastRenderedRow) {
                if (this.doNotUnVirtualiseRow(rowComp)) {
                    indexesToDraw.push(index);
                }
            }
        };
        // if we are redrawing due to scrolling change, then old rows are in this.rowCompsByIndex
        for (const rowCtrl of Object.values(this.rowCtrlsByRowIndex)) {
            checkRowToDraw(rowCtrl);
        }
        // if we are redrawing due to model update, then old rows are in rowsToRecycle
        if (rowsToRecycle) {
            for (const rowCtrl of Object.values(rowsToRecycle)) {
                checkRowToDraw(rowCtrl);
            }
        }
        indexesToDraw.sort((a, b) => a - b);
        const ret = [];
        for (let i = 0; i < indexesToDraw.length; i++) {
            const currRow = indexesToDraw[i];
            const rowNode = this.rowModel.getRow(currRow);
            if (rowNode && !rowNode.sticky) {
                ret.push(currRow);
            }
        }
        return ret;
    }
    recycleRows(rowsToRecycle, animate = false, afterScroll = false) {
        // the row can already exist and be in the following:
        // rowsToRecycle -> if model change, then the index may be different, however row may
        //                         exist here from previous time (mapped by id).
        // this.rowCompsByIndex -> if just a scroll, then this will contain what is currently in the viewport
        // this is all the indexes we want, including those that already exist, so this method
        // will end up going through each index and drawing only if the row doesn't already exist
        const indexesToDraw = this.calculateIndexesToDraw(rowsToRecycle);
        // never animate when doing print layout - as we want to get things ready to print as quickly as possible,
        // otherwise we risk the printer printing a row that's half faded (half way through fading in)
        // Don't animate rows that have been added or removed as part of scrolling
        if (this.printLayout || afterScroll) {
            animate = false;
        }
        this.removeRowCompsNotToDraw(indexesToDraw, !animate);
        // add in new rows
        const rowCtrls = [];
        indexesToDraw.forEach((rowIndex) => {
            const rowCtrl = this.createOrUpdateRowCtrl(rowIndex, rowsToRecycle, animate, afterScroll);
            if ((0, generic_1._exists)(rowCtrl)) {
                rowCtrls.push(rowCtrl);
            }
        });
        if (rowsToRecycle) {
            const { animationFrameSvc } = this.beans;
            const useAnimationFrame = animationFrameSvc?.active && afterScroll && !this.printLayout;
            if (useAnimationFrame) {
                animationFrameSvc.addDestroyTask(() => {
                    this.destroyRowCtrls(rowsToRecycle, animate);
                    this.updateAllRowCtrls();
                    this.dispatchDisplayedRowsChanged();
                });
            }
            else {
                this.destroyRowCtrls(rowsToRecycle, animate);
            }
        }
        this.updateAllRowCtrls();
    }
    dispatchDisplayedRowsChanged(afterScroll = false) {
        this.eventSvc.dispatchEvent({
            type: 'displayedRowsChanged',
            afterScroll,
        });
    }
    onDisplayedColumnsChanged() {
        const { visibleCols } = this.beans;
        const pinningLeft = visibleCols.isPinningLeft();
        const pinningRight = visibleCols.isPinningRight();
        const atLeastOneChanged = this.pinningLeft !== pinningLeft || pinningRight !== this.pinningRight;
        if (atLeastOneChanged) {
            this.pinningLeft = pinningLeft;
            this.pinningRight = pinningRight;
            if (this.embedFullWidthRows) {
                this.redrawFullWidthEmbeddedRows();
            }
        }
    }
    // when embedding, what gets showed in each section depends on what is pinned. eg if embedding group expand / collapse,
    // then it should go into the pinned left area if pinning left, or the center area if not pinning.
    redrawFullWidthEmbeddedRows() {
        // if either of the pinned panels has shown / hidden, then need to redraw the fullWidth bits when
        // embedded, as what appears in each section depends on whether we are pinned or not
        const rowsToRemove = [];
        this.getFullWidthRowCtrls().forEach((fullWidthCtrl) => {
            const rowIndex = fullWidthCtrl.rowNode.rowIndex;
            rowsToRemove.push(rowIndex.toString());
        });
        this.refreshFloatingRowComps();
        this.removeRowCtrls(rowsToRemove);
        this.redraw({ afterScroll: true });
    }
    getFullWidthRowCtrls(rowNodes) {
        const rowNodesMap = mapRowNodes(rowNodes);
        return this.getAllRowCtrls().filter((rowCtrl) => {
            // include just full width
            if (!rowCtrl.isFullWidth()) {
                return false;
            }
            // if Row Nodes provided, we exclude where Row Node is missing
            const rowNode = rowCtrl.rowNode;
            if (rowNodesMap != null && !isRowInMap(rowNode, rowNodesMap)) {
                return false;
            }
            return true;
        });
    }
    createOrUpdateRowCtrl(rowIndex, rowsToRecycle, animate, afterScroll) {
        let rowNode;
        let rowCtrl = this.rowCtrlsByRowIndex[rowIndex];
        // if no row comp, see if we can get it from the previous rowComps
        if (!rowCtrl) {
            rowNode = this.rowModel.getRow(rowIndex);
            if ((0, generic_1._exists)(rowNode) && (0, generic_1._exists)(rowsToRecycle) && rowsToRecycle[rowNode.id] && rowNode.alreadyRendered) {
                rowCtrl = rowsToRecycle[rowNode.id];
                rowsToRecycle[rowNode.id] = null;
            }
        }
        const creatingNewRowCtrl = !rowCtrl;
        if (creatingNewRowCtrl) {
            // create a new one
            if (!rowNode) {
                rowNode = this.rowModel.getRow(rowIndex);
            }
            if ((0, generic_1._exists)(rowNode)) {
                rowCtrl = this.createRowCon(rowNode, animate, afterScroll);
            }
            else {
                // this should never happen - if somehow we are trying to create
                // a row for a rowNode that does not exist.
                return;
            }
        }
        if (rowNode) {
            // set node as 'alreadyRendered' to ensure we only recycle rowComps that have been rendered, this ensures
            // we don't reuse rowComps that have been removed and then re-added in the same batch transaction.
            rowNode.alreadyRendered = true;
        }
        this.rowCtrlsByRowIndex[rowIndex] = rowCtrl;
        return rowCtrl;
    }
    destroyRowCtrls(rowCtrlsMap, animate) {
        const executeInAWhileFuncs = [];
        if (rowCtrlsMap) {
            for (const rowCtrl of Object.values(rowCtrlsMap)) {
                // if row was used, then it's null
                if (!rowCtrl) {
                    continue;
                }
                if (this.cachedRowCtrls && rowCtrl.isCacheable()) {
                    this.cachedRowCtrls.addRow(rowCtrl);
                    continue;
                }
                rowCtrl.destroyFirstPass(!animate);
                if (animate) {
                    const instanceId = rowCtrl.instanceId;
                    this.zombieRowCtrls[instanceId] = rowCtrl;
                    executeInAWhileFuncs.push(() => {
                        rowCtrl.destroySecondPass();
                        delete this.zombieRowCtrls[instanceId];
                    });
                }
                else {
                    rowCtrl.destroySecondPass();
                }
            }
        }
        if (animate) {
            // this ensures we fire displayedRowsChanged AFTER all the 'executeInAWhileFuncs' get
            // executed, as we added it to the end of the list.
            executeInAWhileFuncs.push(() => {
                this.updateAllRowCtrls();
                this.dispatchDisplayedRowsChanged();
            });
            window.setTimeout(() => executeInAWhileFuncs.forEach((func) => func()), ROW_ANIMATION_TIMEOUT);
        }
    }
    getRowBuffer() {
        return this.gos.get('rowBuffer');
    }
    getRowBufferInPixels() {
        const rowsToBuffer = this.getRowBuffer();
        const defaultRowHeight = (0, gridOptionsUtils_1._getRowHeightAsNumber)(this.beans);
        return rowsToBuffer * defaultRowHeight;
    }
    workOutFirstAndLastRowsToRender() {
        const { rowContainerHeight, pageBounds, rowModel } = this;
        rowContainerHeight.updateOffset();
        let newFirst;
        let newLast;
        if (!rowModel.isRowsToRender()) {
            newFirst = 0;
            newLast = -1; // setting to -1 means nothing in range
        }
        else if (this.printLayout) {
            this.beans.environment.refreshRowHeightVariable();
            newFirst = pageBounds.getFirstRow();
            newLast = pageBounds.getLastRow();
        }
        else {
            const bufferPixels = this.getRowBufferInPixels();
            const scrollFeature = this.ctrlsSvc.getScrollFeature();
            const suppressRowVirtualisation = this.gos.get('suppressRowVirtualisation');
            let rowHeightsChanged = false;
            let firstPixel;
            let lastPixel;
            do {
                const paginationOffset = pageBounds.getPixelOffset();
                const { pageFirstPixel, pageLastPixel } = pageBounds.getCurrentPagePixelRange();
                const divStretchOffset = rowContainerHeight.divStretchOffset;
                const bodyVRange = scrollFeature.getVScrollPosition();
                const bodyTopPixel = bodyVRange.top;
                const bodyBottomPixel = bodyVRange.bottom;
                if (suppressRowVirtualisation) {
                    firstPixel = pageFirstPixel + divStretchOffset;
                    lastPixel = pageLastPixel + divStretchOffset;
                }
                else {
                    firstPixel =
                        Math.max(bodyTopPixel + paginationOffset - bufferPixels, pageFirstPixel) + divStretchOffset;
                    lastPixel =
                        Math.min(bodyBottomPixel + paginationOffset + bufferPixels, pageLastPixel) + divStretchOffset;
                }
                this.firstVisibleVPixel = Math.max(bodyTopPixel + paginationOffset, pageFirstPixel) + divStretchOffset;
                this.lastVisibleVPixel = Math.min(bodyBottomPixel + paginationOffset, pageLastPixel) + divStretchOffset;
                // if the rows we are about to display get their heights changed, then that upsets the calcs from above.
                rowHeightsChanged = this.ensureAllRowsInRangeHaveHeightsCalculated(firstPixel, lastPixel);
            } while (rowHeightsChanged);
            let firstRowIndex = rowModel.getRowIndexAtPixel(firstPixel);
            let lastRowIndex = rowModel.getRowIndexAtPixel(lastPixel);
            const pageFirstRow = pageBounds.getFirstRow();
            const pageLastRow = pageBounds.getLastRow();
            // adjust, in case buffer extended actual size
            if (firstRowIndex < pageFirstRow) {
                firstRowIndex = pageFirstRow;
            }
            if (lastRowIndex > pageLastRow) {
                lastRowIndex = pageLastRow;
            }
            newFirst = firstRowIndex;
            newLast = lastRowIndex;
        }
        // sometimes user doesn't set CSS right and ends up with grid with no height and grid ends up
        // trying to render all the rows, eg 10,000+ rows. this will kill the browser. so instead of
        // killing the browser, we limit the number of rows. just in case some use case we didn't think
        // of, we also have a property to not do this operation.
        const rowLayoutNormal = (0, gridOptionsUtils_1._isDomLayout)(this.gos, 'normal');
        const suppressRowCountRestriction = this.gos.get('suppressMaxRenderedRowRestriction');
        const rowBufferMaxSize = Math.max(this.getRowBuffer(), 500);
        if (rowLayoutNormal && !suppressRowCountRestriction) {
            if (newLast - newFirst > rowBufferMaxSize) {
                newLast = newFirst + rowBufferMaxSize;
            }
        }
        const firstDiffers = newFirst !== this.firstRenderedRow;
        const lastDiffers = newLast !== this.lastRenderedRow;
        if (firstDiffers || lastDiffers) {
            this.firstRenderedRow = newFirst;
            this.lastRenderedRow = newLast;
            this.eventSvc.dispatchEvent({
                type: 'viewportChanged',
                firstRow: newFirst,
                lastRow: newLast,
            });
        }
    }
    /**
     * This event will only be fired once, and is queued until after the browser next renders.
     * This allows us to fire an event during the start of the render cycle, when we first see data being rendered
     * but not execute the event until all of the data has finished being rendered to the dom.
     */
    dispatchFirstDataRenderedEvent() {
        if (this.dataFirstRenderedFired) {
            return;
        }
        this.dataFirstRenderedFired = true;
        // See AG-7018
        (0, dom_1._requestAnimationFrame)(this.beans, () => {
            this.beans.eventSvc.dispatchEvent({
                type: 'firstDataRendered',
                firstRow: this.firstRenderedRow,
                lastRow: this.lastRenderedRow,
            });
        });
    }
    ensureAllRowsInRangeHaveHeightsCalculated(topPixel, bottomPixel) {
        const pinnedRowHeightsChanged = this.pinnedRowModel?.ensureRowHeightsValid();
        // ensure sticky rows heights are all updated
        const stickyHeightsChanged = this.stickyRowFeature?.ensureRowHeightsValid();
        const { pageBounds, rowModel } = this;
        // ensureRowHeightsVisible only works with CSRM, as it's the only row model that allows lazy row height calcs.
        // all the other row models just hard code so the method just returns back false
        const rowModelHeightsChanged = rowModel.ensureRowHeightsValid(topPixel, bottomPixel, pageBounds.getFirstRow(), pageBounds.getLastRow());
        if (rowModelHeightsChanged || stickyHeightsChanged) {
            this.eventSvc.dispatchEvent({
                type: 'recalculateRowBounds',
            });
        }
        if (stickyHeightsChanged || rowModelHeightsChanged || pinnedRowHeightsChanged) {
            this.updateContainerHeights();
            return true;
        }
        return false;
    }
    // check that none of the rows to remove are editing or focused as:
    // a) if editing, we want to keep them, otherwise the user will loose the context of the edit,
    //    eg user starts editing, enters some text, then scrolls down and then up, next time row rendered
    //    the edit is reset - so we want to keep it rendered.
    // b) if focused, we want ot keep keyboard focus, so if user ctrl+c, it goes to clipboard,
    //    otherwise the user can range select and drag (with focus cell going out of the viewport)
    //    and then ctrl+c, nothing will happen if cell is removed from dom.
    // c) if detail record of master detail, as users complained that the context of detail rows
    //    was getting lost when detail row out of view. eg user expands to show detail row,
    //    then manipulates the detail panel (eg sorts the detail grid), then context is lost
    //    after detail panel is scrolled out of / into view.
    doNotUnVirtualiseRow(rowCtrl) {
        const REMOVE_ROW = false;
        const KEEP_ROW = true;
        const rowNode = rowCtrl.rowNode;
        const rowHasFocus = this.focusSvc.isRowFocused(rowNode.rowIndex, rowNode.rowPinned);
        const rowIsEditing = this.editSvc?.isEditing(rowCtrl);
        const rowIsDetail = rowNode.detail;
        const mightWantToKeepRow = rowHasFocus || rowIsEditing || rowIsDetail;
        // if we deffo don't want to keep it,
        if (!mightWantToKeepRow) {
            return REMOVE_ROW;
        }
        // editing row, only remove if it is no longer rendered, eg filtered out or new data set.
        // the reason we want to keep is if user is scrolling up and down, we don't want to loose
        // the context of the editing in process.
        const rowNodePresent = this.isRowPresent(rowNode);
        return rowNodePresent ? KEEP_ROW : REMOVE_ROW;
    }
    isRowPresent(rowNode) {
        if (!this.rowModel.isRowPresent(rowNode)) {
            return false;
        }
        return this.beans.pagination?.isRowInPage(rowNode.rowIndex) ?? true;
    }
    createRowCon(rowNode, animate, afterScroll) {
        const rowCtrlFromCache = this.cachedRowCtrls?.getRow(rowNode) ?? null;
        if (rowCtrlFromCache) {
            return rowCtrlFromCache;
        }
        // we don't use animations frames for printing, so the user can put the grid into print mode
        // and immediately print - otherwise the user would have to wait for the rows to draw in the background
        // (via the animation frames) which is awkward to do from code.
        // we only do the animation frames after scrolling, as this is where we want the smooth user experience.
        // having animation frames for other times makes the grid look 'jumpy'.
        const useAnimationFrameForCreate = afterScroll && !this.printLayout && !!this.beans.animationFrameSvc?.active;
        const res = new rowCtrl_1.RowCtrl(rowNode, this.beans, animate, useAnimationFrameForCreate, this.printLayout);
        return res;
    }
    getRenderedNodes() {
        const viewportRows = Object.values(this.rowCtrlsByRowIndex).map((rowCtrl) => rowCtrl.rowNode);
        const stickyTopRows = this.getStickyTopRowCtrls().map((rowCtrl) => rowCtrl.rowNode);
        const stickyBottomRows = this.getStickyBottomRowCtrls().map((rowCtrl) => rowCtrl.rowNode);
        return [...stickyTopRows, ...viewportRows, ...stickyBottomRows];
    }
    getRowByPosition(rowPosition) {
        let rowCtrl;
        const { rowIndex } = rowPosition;
        switch (rowPosition.rowPinned) {
            case 'top':
                rowCtrl = this.topRowCtrls[rowIndex];
                break;
            case 'bottom':
                rowCtrl = this.bottomRowCtrls[rowIndex];
                break;
            default:
                rowCtrl = this.rowCtrlsByRowIndex[rowIndex];
                if (!rowCtrl) {
                    rowCtrl = this.getStickyTopRowCtrls().find((ctrl) => ctrl.rowNode.rowIndex === rowIndex) || null;
                    if (!rowCtrl) {
                        rowCtrl =
                            this.getStickyBottomRowCtrls().find((ctrl) => ctrl.rowNode.rowIndex === rowIndex) || null;
                    }
                }
                break;
        }
        return rowCtrl;
    }
    // returns true if any row between startIndex and endIndex is rendered. used by
    // SSRM or IRM, as they don't want to purge visible blocks from cache.
    isRangeInRenderedViewport(startIndex, endIndex) {
        // parent closed means the parent node is not expanded, thus these blocks are not visible
        const parentClosed = startIndex == null || endIndex == null;
        if (parentClosed) {
            return false;
        }
        const blockAfterViewport = startIndex > this.lastRenderedRow;
        const blockBeforeViewport = endIndex < this.firstRenderedRow;
        const blockInsideViewport = !blockBeforeViewport && !blockAfterViewport;
        return blockInsideViewport;
    }
}
exports.RowRenderer = RowRenderer;
class RowCtrlCache {
    constructor(maxCount) {
        // map for fast access
        this.entriesMap = {};
        // list for keeping order
        this.entriesList = [];
        this.maxCount = maxCount;
    }
    addRow(rowCtrl) {
        this.entriesMap[rowCtrl.rowNode.id] = rowCtrl;
        this.entriesList.push(rowCtrl);
        rowCtrl.setCached(true);
        if (this.entriesList.length > this.maxCount) {
            const rowCtrlToDestroy = this.entriesList[0];
            rowCtrlToDestroy.destroyFirstPass();
            rowCtrlToDestroy.destroySecondPass();
            this.removeFromCache(rowCtrlToDestroy);
        }
    }
    getRow(rowNode) {
        if (rowNode == null || rowNode.id == null) {
            return null;
        }
        const res = this.entriesMap[rowNode.id];
        if (!res) {
            return null;
        }
        this.removeFromCache(res);
        res.setCached(false);
        // this can happen if user reloads data, and a new RowNode is reusing
        // the same ID as the old one
        const rowNodeMismatch = res.rowNode != rowNode;
        return rowNodeMismatch ? null : res;
    }
    has(rowNode) {
        return this.entriesMap[rowNode.id] != null;
    }
    removeRow(rowNode) {
        const rowNodeId = rowNode.id;
        const ctrl = this.entriesMap[rowNodeId];
        delete this.entriesMap[rowNodeId];
        (0, array_1._removeFromArray)(this.entriesList, ctrl);
    }
    removeFromCache(rowCtrl) {
        const rowNodeId = rowCtrl.rowNode.id;
        delete this.entriesMap[rowNodeId];
        (0, array_1._removeFromArray)(this.entriesList, rowCtrl);
    }
    getEntries() {
        return this.entriesList;
    }
}
function mapRowNodes(rowNodes) {
    if (!rowNodes) {
        return;
    }
    const res = {
        top: {},
        bottom: {},
        normal: {},
    };
    rowNodes.forEach((rowNode) => {
        const id = rowNode.id;
        switch (rowNode.rowPinned) {
            case 'top':
                res.top[id] = rowNode;
                break;
            case 'bottom':
                res.bottom[id] = rowNode;
                break;
            default:
                res.normal[id] = rowNode;
                break;
        }
    });
    return res;
}
exports.mapRowNodes = mapRowNodes;
function isRowInMap(rowNode, rowIdsMap) {
    // skip this row if it is missing from the provided list
    const id = rowNode.id;
    const floating = rowNode.rowPinned;
    switch (floating) {
        case 'top':
            return rowIdsMap.top[id] != null;
        case 'bottom':
            return rowIdsMap.bottom[id] != null;
        default:
            return rowIdsMap.normal[id] != null;
    }
}
exports.isRowInMap = isRowInMap;


/***/ }),

/***/ 4265:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CellSpanModule = void 0;
const version_1 = __webpack_require__(97205);
const rowSpanService_1 = __webpack_require__(24658);
const spannedRowRenderer_1 = __webpack_require__(82991);
exports.CellSpanModule = {
    moduleName: 'CellSpan',
    version: version_1.VERSION,
    beans: [rowSpanService_1.RowSpanService, spannedRowRenderer_1.SpannedRowRenderer],
};


/***/ }),

/***/ 73643:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RowSpanCache = exports.CellSpan = exports._doesColumnSpan = void 0;
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const spannedRowRenderer_1 = __webpack_require__(82991);
const _doesColumnSpan = (column) => {
    // todo replace with new row spanning
    return column.colDef.rowSpan;
};
exports._doesColumnSpan = _doesColumnSpan;
class CellSpan {
    constructor(col, firstNode) {
        this.col = col;
        this.firstNode = firstNode;
        // used for distinguishing between types
        this.cellSpan = true;
        this.spannedNodes = new Set();
        this.addSpannedNode(firstNode);
    }
    /**
     * Reset the span leaving only the head.
     * Head is used as a comparison as this is the row used to render this cell
     * Even if the row data changes, the cell will properly reflect the correct value.
     */
    reset() {
        this.spannedNodes.clear();
        this.addSpannedNode(this.firstNode);
    }
    addSpannedNode(node) {
        this.spannedNodes.add(node);
        this.lastNode = node;
    }
    getLastNode() {
        return this.lastNode;
    }
    getCellHeight() {
        return this.lastNode.rowTop + this.lastNode.rowHeight - this.firstNode.rowTop - 1; // -1 should be border height I think
    }
    doesSpanContain(cellPosition) {
        if (cellPosition.column !== this.col) {
            return false;
        }
        if (cellPosition.rowPinned != this.firstNode.rowPinned) {
            return false;
        }
        return this.firstNode.rowIndex <= cellPosition.rowIndex && cellPosition.rowIndex <= this.lastNode.rowIndex;
    }
    /**
     * Gets the auto height value for last node in the spanned cell.
     * The first node is used to store the auto height for the cell, but the additional height for this cell
     * needs applied to the last row in the span.
     */
    getLastNodeAutoHeight() {
        const autoHeight = this.firstNode.__autoHeights?.[this.col.getColId()];
        if (autoHeight == null) {
            return undefined;
        }
        let allButLastHeights = 0;
        this.spannedNodes.forEach((node) => {
            if (node === this.lastNode)
                return;
            allButLastHeights += node.rowHeight;
        });
        return autoHeight - allButLastHeights;
    }
}
exports.CellSpan = CellSpan;
/**
 * Belongs to a column, when cells are to be rendered they call back to this service with the values.
 * This service determines if the cell should instead be replaced with a spanning cell, in which case the cell is
 * stretched over multiple rows.
 *
 * Only create if spanning is enabled for this column.
 */
class RowSpanCache extends beanStub_1.BeanStub {
    constructor(column) {
        super();
        this.column = column;
    }
    buildCache(pinned) {
        const { column, beans: { gos, pinnedRowModel, rowModel, valueSvc, pagination }, } = this;
        const { colDef } = column;
        const oldMap = this[`${pinned}ValueNodeMap`];
        const newMap = new Map();
        const isFullWidthCellFunc = gos.getCallback('isFullWidthRow');
        const equalsFnc = colDef.equals;
        const customCompare = colDef.spanRows;
        const isCustomCompare = typeof customCompare === 'function';
        let lastNode = null;
        let spanData = null;
        let lastValue;
        const setNewHead = (node, value) => {
            lastNode = node;
            spanData = null;
            lastValue = value;
        };
        // check each node, if the currently open cell span should span, add this node to span, otherwise close the span.
        const checkNodeForCache = (node) => {
            const doesNodeSupportSpanning = !node.isExpandable() &&
                !node.group &&
                !node.detail &&
                (isFullWidthCellFunc ? !isFullWidthCellFunc({ rowNode: node }) : true);
            // fw, hidden, and detail rows cannot be spanned as head, body nor tail. Skip.
            if (node.rowIndex == null || !doesNodeSupportSpanning) {
                setNewHead(null, null);
                return;
            }
            // if level or key is different, cells do not span.
            if (lastNode == null ||
                node.level !== lastNode.level || // no span across groups
                node.footer ||
                (spanData && node.rowIndex - 1 !== spanData?.getLastNode().rowIndex) // no span if rows not contiguous (SSRM)
            ) {
                setNewHead(node, valueSvc.getValue(column, node));
                return;
            }
            // check value is equal, if not, no span
            const value = valueSvc.getValue(column, node);
            if (isCustomCompare) {
                const params = (0, gridOptionsUtils_1._addGridCommonParams)(gos, {
                    valueA: lastValue,
                    nodeA: lastNode,
                    valueB: value,
                    nodeB: node,
                    column,
                    colDef,
                });
                if (!customCompare(params)) {
                    setNewHead(node, value);
                    return;
                }
            }
            else {
                if (equalsFnc ? !equalsFnc(lastValue, value) : lastValue !== value) {
                    setNewHead(node, value);
                    return;
                }
            }
            if (!spanData) {
                const oldSpan = oldMap?.get(lastNode);
                if (oldSpan?.firstNode === lastNode) {
                    oldSpan.reset();
                    spanData = oldSpan;
                }
                else {
                    spanData = new CellSpan(column, lastNode);
                }
                newMap.set(lastNode, spanData);
            }
            spanData.addSpannedNode(node);
            newMap.set(node, spanData);
        };
        switch (pinned) {
            case 'center':
                rowModel.forEachDisplayedNode?.((node) => {
                    const isNodeInPage = !pagination || pagination.isRowInPage(node.rowIndex);
                    if (!isNodeInPage) {
                        return;
                    }
                    checkNodeForCache(node);
                });
                break;
            case 'top':
                pinnedRowModel?.forEachPinnedRow('top', checkNodeForCache);
                break;
            case 'bottom':
                pinnedRowModel?.forEachPinnedRow('bottom', checkNodeForCache);
                break;
        }
        this[`${pinned}ValueNodeMap`] = newMap;
    }
    isCellSpanning(node) {
        return !!this.getCellSpan(node);
    }
    getCellSpan(node) {
        const map = this[`${(0, spannedRowRenderer_1._normalisePinnedValue)(node.rowPinned)}ValueNodeMap`];
        return map.get(node);
    }
}
exports.RowSpanCache = RowSpanCache;


/***/ }),

/***/ 24658:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RowSpanService = void 0;
const beanStub_1 = __webpack_require__(68731);
const function_1 = __webpack_require__(92043);
const rowSpanCache_1 = __webpack_require__(73643);
class RowSpanService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'rowSpanSvc';
        this.spanningColumns = new Map();
        // debounced to allow spannedRowRenderer to run first, removing any old spanned rows
        this.debouncePinnedEvent = (0, function_1._debounce)(this, this.dispatchCellsUpdatedEvent.bind(this, true), 0);
        this.debounceModelEvent = (0, function_1._debounce)(this, this.dispatchCellsUpdatedEvent.bind(this, false), 0);
        this.pinnedTimeout = null;
        this.modelTimeout = null;
    }
    postConstruct() {
        const onRowDataUpdated = this.onRowDataUpdated.bind(this);
        const buildPinnedCaches = this.buildPinnedCaches.bind(this);
        this.addManagedEventListeners({
            paginationChanged: this.buildModelCaches.bind(this),
            pinnedRowDataChanged: buildPinnedCaches,
            pinnedRowsChanged: buildPinnedCaches,
            rowNodeDataChanged: onRowDataUpdated,
            cellValueChanged: onRowDataUpdated,
        });
    }
    /**
     * When a new column is created with spanning (or spanning changes for a column)
     * @param column column that is now spanning
     */
    register(column) {
        const { gos } = this.beans;
        if (!gos.get('enableCellSpan')) {
            return;
        }
        if (this.spanningColumns.has(column)) {
            return;
        }
        const cache = this.createManagedBean(new rowSpanCache_1.RowSpanCache(column));
        this.spanningColumns.set(column, cache);
        // make sure if row model already run we prep this cache
        cache.buildCache('top');
        cache.buildCache('bottom');
        cache.buildCache('center');
        this.debouncePinnedEvent();
        this.debounceModelEvent();
    }
    dispatchCellsUpdatedEvent(pinned) {
        this.dispatchLocalEvent({ type: 'spannedCellsUpdated', pinned });
    }
    /**
     * When a new column is destroyed with spanning (or spanning changes for a column)
     * @param column column that is now spanning
     */
    deregister(column) {
        this.spanningColumns.delete(column);
    }
    // called when data changes, as this could be a hot path it's debounced
    // it uses timeouts instead of debounce so that it can be cancelled by `modelUpdated`
    // which is expected to run immediately (to exec before the rowRenderer)
    onRowDataUpdated({ node }) {
        const { spannedRowRenderer } = this.beans;
        if (node.rowPinned) {
            if (this.pinnedTimeout != null) {
                return;
            }
            this.pinnedTimeout = window.setTimeout(() => {
                this.pinnedTimeout = null;
                this.buildPinnedCaches();
                // normally updated by the rowRenderer, but as this change is
                // caused by data, need to manually update
                spannedRowRenderer?.createCtrls('top');
                spannedRowRenderer?.createCtrls('bottom');
            }, 0);
            return;
        }
        if (this.modelTimeout != null) {
            return;
        }
        this.modelTimeout = window.setTimeout(() => {
            this.modelTimeout = null;
            this.buildModelCaches();
            // normally updated by the rowRenderer, but as this change is
            // caused by data, need to manually update
            spannedRowRenderer?.createCtrls('center');
        }, 0);
    }
    buildModelCaches() {
        if (this.modelTimeout != null) {
            clearTimeout(this.modelTimeout);
        }
        this.spanningColumns.forEach((cache) => cache.buildCache('center'));
        this.debounceModelEvent();
    }
    buildPinnedCaches() {
        if (this.pinnedTimeout != null) {
            clearTimeout(this.pinnedTimeout);
        }
        this.spanningColumns.forEach((cache) => {
            cache.buildCache('top');
            cache.buildCache('bottom');
        });
        this.debouncePinnedEvent();
    }
    isCellSpanning(col, rowNode) {
        const cache = this.spanningColumns.get(col);
        if (!cache) {
            return false;
        }
        return cache.isCellSpanning(rowNode);
    }
    getCellSpanByPosition(position) {
        const { pinnedRowModel, rowModel } = this.beans;
        const col = position.column;
        const index = position.rowIndex;
        const cache = this.spanningColumns.get(col);
        if (!cache) {
            return undefined;
        }
        let node;
        switch (position.rowPinned) {
            case 'top':
                node = pinnedRowModel?.getPinnedTopRow(index);
                break;
            case 'bottom':
                node = pinnedRowModel?.getPinnedBottomRow(index);
                break;
            default:
                node = rowModel.getRow(index);
        }
        if (!node) {
            return undefined;
        }
        return cache.getCellSpan(node);
    }
    getCellStart(position) {
        const span = this.getCellSpanByPosition(position);
        if (!span) {
            return position;
        }
        return { ...position, rowIndex: span.firstNode.rowIndex };
    }
    getCellEnd(position) {
        const span = this.getCellSpanByPosition(position);
        if (!span) {
            return position;
        }
        return { ...position, rowIndex: span.getLastNode().rowIndex };
    }
    /**
     * Look-up a spanned cell given a col and node as position indicators
     *
     * @param col a column to lookup a span at this position
     * @param rowNode a node that may be spanned at this position
     * @returns the CellSpan object if one exists
     */
    getCellSpan(col, rowNode) {
        const cache = this.spanningColumns.get(col);
        if (!cache) {
            return undefined;
        }
        return cache.getCellSpan(rowNode);
    }
    forEachSpannedColumn(rowNode, callback) {
        for (const [col, cache] of this.spanningColumns) {
            if (cache.isCellSpanning(rowNode)) {
                const spanningNode = cache.getCellSpan(rowNode);
                callback(col, spanningNode);
            }
        }
    }
    destroy() {
        super.destroy();
        this.spanningColumns.clear();
    }
}
exports.RowSpanService = RowSpanService;


/***/ }),

/***/ 48411:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SpannedCellCtrl = void 0;
const aria_1 = __webpack_require__(95230);
const focus_1 = __webpack_require__(82331);
const cellCtrl_1 = __webpack_require__(60814);
class SpannedCellCtrl extends cellCtrl_1.CellCtrl {
    constructor(cellSpan, rowCtrl, beans) {
        super(cellSpan.col, cellSpan.firstNode, beans, rowCtrl);
        this.cellSpan = cellSpan;
        this.SPANNED_CELL_CSS_CLASS = 'ag-spanned-cell';
    }
    setComp(comp, eCell, eWrapper, eCellWrapper, printLayout, startEditing, compBean) {
        this.eWrapper = eWrapper;
        super.setComp(comp, eCell, eWrapper, eCellWrapper, printLayout, startEditing, compBean);
        this.setAriaRowSpan();
        this.refreshAriaRowIndex();
    }
    isCellSpanning() {
        return true;
    }
    getCellSpan() {
        return this.cellSpan;
    }
    /**
     * When cell is spanning, ensure row index is also available on the cell
     */
    refreshAriaRowIndex() {
        if (this.rowNode.rowIndex == null) {
            return;
        }
        (0, aria_1._setAriaRowIndex)(this.eGui, this.rowNode.rowIndex);
    }
    /**
     * When cell is spanning, ensure row index is also available on the cell
     */
    setAriaRowSpan() {
        (0, aria_1._setAriaRowSpan)(this.eGui, this.cellSpan.spannedNodes.size);
    }
    // not ideal, for tabbing need to force the focused position
    setFocusedCellPosition(cellPos) {
        this.focusedCellPosition = cellPos;
    }
    getFocusedCellPosition() {
        return this.focusedCellPosition ?? this.cellPosition;
    }
    checkCellFocused() {
        const focusedCell = this.beans.focusSvc.getFocusedCell();
        return !!focusedCell && this.cellSpan.doesSpanContain(focusedCell);
    }
    applyStaticCssClasses() {
        super.applyStaticCssClasses();
        this.comp.toggleCss(this.SPANNED_CELL_CSS_CLASS, true);
    }
    onCellFocused(event) {
        const { beans } = this;
        if ((0, focus_1._isCellFocusSuppressed)(beans)) {
            this.focusedCellPosition = undefined;
            return;
        }
        const cellFocused = this.isCellFocused();
        if (!cellFocused) {
            this.focusedCellPosition = undefined;
        }
        if (event && cellFocused) {
            // when a spanned cell is focused, remember the focused cell position
            this.focusedCellPosition = {
                rowIndex: event.rowIndex,
                rowPinned: event.rowPinned,
                column: event.column, // fix
            };
        }
        super.onCellFocused(event);
    }
    getRootElement() {
        return this.eWrapper;
    }
}
exports.SpannedCellCtrl = SpannedCellCtrl;


/***/ }),

/***/ 86541:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SpannedRowCtrl = void 0;
const rowCtrl_1 = __webpack_require__(7632);
const spannedCellCtrl_1 = __webpack_require__(48411);
class SpannedRowCtrl extends rowCtrl_1.RowCtrl {
    onRowIndexChanged() {
        super.onRowIndexChanged();
        this.getAllCellCtrls().forEach((c) => c.refreshAriaRowIndex());
    }
    getInitialRowClasses(_rowContainerType) {
        return ['ag-spanned-row'];
    }
    getNewCellCtrl(col) {
        // spanned cells, if handled as a spanned cell of another row, ignore this.
        const cellSpan = this.beans.rowSpanSvc?.getCellSpan(col, this.rowNode);
        if (!cellSpan) {
            return;
        }
        // only render cell in first row of span
        const firstRowOfSpan = cellSpan.firstNode !== this.rowNode;
        if (firstRowOfSpan) {
            return;
        }
        return new spannedCellCtrl_1.SpannedCellCtrl(cellSpan, this, this.beans);
    }
    isCorrectCtrlForSpan(cell) {
        // spanned cells, if handled as a spanned cell of another row, ignore this.
        const cellSpan = this.beans.rowSpanSvc?.getCellSpan(cell.column, this.rowNode);
        if (!cellSpan) {
            return false;
        }
        // only render cell in first row of span
        const firstRowOfSpan = cellSpan.firstNode !== this.rowNode;
        if (firstRowOfSpan) {
            return false;
        }
        return cell.getCellSpan() === cellSpan;
    }
    /**
     * Below overrides are explicitly disabling styling and other unwanted behaviours for spannedRowCtrl
     */
    // row height should be 0 in spanned row - they're only included for purpose of aria
    onRowHeightChanged() { }
    // no styling spanned rows
    refreshFirstAndLastRowStyles() { }
    // no hover functionality for spanned rows
    addHoverFunctionality() { }
    resetHoveredStatus() { }
}
exports.SpannedRowCtrl = SpannedRowCtrl;


/***/ }),

/***/ 82991:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._normalisePinnedValue = exports.SpannedRowRenderer = void 0;
const beanStub_1 = __webpack_require__(68731);
const spannedRowCtrl_1 = __webpack_require__(86541);
class SpannedRowRenderer extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'spannedRowRenderer';
        this.topCtrls = new Map();
        this.bottomCtrls = new Map();
        this.centerCtrls = new Map();
    }
    postConstruct() {
        this.addManagedEventListeners({
            displayedRowsChanged: this.createAllCtrls.bind(this),
        });
    }
    createAllCtrls() {
        this.createCtrls('top');
        this.createCtrls('bottom');
        this.createCtrls('center');
    }
    /**
     * When displayed rows or cols change, the spanned cell ctrls need to update
     */
    createCtrls(ctrlsKey) {
        const { rowSpanSvc } = this.beans;
        const ctrlsName = `${ctrlsKey}Ctrls`;
        const previousCtrls = this[ctrlsName];
        const previousCtrlsSize = previousCtrls.size;
        // all currently rendered row ctrls which may have spanned cells
        const rowCtrls = this.getAllRelevantRowControls(ctrlsKey);
        const newRowCtrls = new Map();
        let hasNewSpans = false;
        for (const ctrl of rowCtrls) {
            // skip cells that are animating out.
            if (!ctrl.isAlive()) {
                continue;
            }
            rowSpanSvc?.forEachSpannedColumn(ctrl.rowNode, (col, cellSpan) => {
                // if spanned row ctrl already exists
                if (newRowCtrls.has(cellSpan.firstNode)) {
                    return;
                }
                const existingCtrl = previousCtrls.get(cellSpan.firstNode);
                if (existingCtrl) {
                    newRowCtrls.set(cellSpan.firstNode, existingCtrl);
                    previousCtrls.delete(cellSpan.firstNode);
                    return;
                }
                hasNewSpans = true;
                const newCtrl = new spannedRowCtrl_1.SpannedRowCtrl(cellSpan.firstNode, this.beans, false, false, false);
                newRowCtrls.set(cellSpan.firstNode, newCtrl);
            });
        }
        // set even if no change, as we've deleted out of previousCtrls
        this[ctrlsName] = newRowCtrls;
        // if no new cells, and size is equal can assume no removals either.
        const sameCount = newRowCtrls.size === previousCtrlsSize;
        if (!hasNewSpans && sameCount)
            return;
        for (const oldCtrl of previousCtrls.values()) {
            oldCtrl.destroyFirstPass(true);
            oldCtrl.destroySecondPass();
        }
        this.dispatchLocalEvent({
            type: `spannedRowsUpdated`,
            ctrlsKey,
        });
    }
    // cannot use getAllRowCtrls as it returns this services row ctrls.
    getAllRelevantRowControls(ctrlsKey) {
        const { rowRenderer } = this.beans;
        switch (ctrlsKey) {
            case 'top':
                return rowRenderer.topRowCtrls;
            case 'bottom':
                return rowRenderer.bottomRowCtrls;
            case 'center':
                return rowRenderer.allRowCtrls;
        }
    }
    getCellByPosition(cellPosition) {
        const { rowSpanSvc } = this.beans;
        const cellSpan = rowSpanSvc?.getCellSpanByPosition(cellPosition);
        if (!cellSpan) {
            return undefined;
        }
        const ctrlsName = `${(0, exports._normalisePinnedValue)(cellPosition.rowPinned)}Ctrls`;
        const ctrl = this[ctrlsName].get(cellSpan.firstNode);
        if (!ctrl) {
            return undefined;
        }
        return ctrl.getAllCellCtrls().find((cellCtrl) => cellCtrl.column === cellPosition.column);
    }
    getCtrls(container) {
        const ctrlsName = `${container}Ctrls`;
        return [...this[ctrlsName].values()];
    }
    destroyRowCtrls(container) {
        const ctrlsName = `${container}Ctrls`;
        for (const ctrl of this[ctrlsName].values()) {
            ctrl.destroyFirstPass(true);
            ctrl.destroySecondPass();
        }
        this[ctrlsName] = new Map();
    }
    destroy() {
        super.destroy();
        this.destroyRowCtrls('top');
        this.destroyRowCtrls('bottom');
        this.destroyRowCtrls('center');
    }
}
exports.SpannedRowRenderer = SpannedRowRenderer;
const _normalisePinnedValue = (pinned) => {
    return pinned ?? 'center';
};
exports._normalisePinnedValue = _normalisePinnedValue;


/***/ }),

/***/ 23306:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseSelectionService = void 0;
const columnUtils_1 = __webpack_require__(73146);
const beanStub_1 = __webpack_require__(68731);
const rowNodeUtils_1 = __webpack_require__(9888);
const gridOptionsUtils_1 = __webpack_require__(67274);
const pinnedRowUtils_1 = __webpack_require__(78638);
const aria_1 = __webpack_require__(95230);
const checkboxSelectionComponent_1 = __webpack_require__(95954);
const rowRangeSelectionContext_1 = __webpack_require__(99666);
const selectAllFeature_1 = __webpack_require__(48273);
class BaseSelectionService extends beanStub_1.BeanStub {
    postConstruct() {
        const { gos, beans } = this;
        this.selectionCtx = new rowRangeSelectionContext_1.RowRangeSelectionContext(beans.rowModel, beans.pinnedRowModel);
        this.addManagedPropertyListeners(['isRowSelectable', 'rowSelection'], () => {
            const callback = (0, gridOptionsUtils_1._getIsRowSelectable)(gos);
            if (callback !== this.isRowSelectable) {
                this.isRowSelectable = callback;
                this.updateSelectable();
            }
        });
        this.isRowSelectable = (0, gridOptionsUtils_1._getIsRowSelectable)(gos);
        this.addManagedEventListeners({
            cellValueChanged: (e) => this.updateRowSelectable(e.node),
            rowNodeDataChanged: (e) => this.updateRowSelectable(e.node),
        });
    }
    destroy() {
        super.destroy();
        this.selectionCtx.reset();
    }
    createCheckboxSelectionComponent() {
        return new checkboxSelectionComponent_1.CheckboxSelectionComponent();
    }
    createSelectAllFeature(column) {
        if ((0, selectAllFeature_1.isCheckboxSelection)(this.beans, column)) {
            return new selectAllFeature_1.SelectAllFeature(column);
        }
    }
    isMultiSelect() {
        return (0, gridOptionsUtils_1._isMultiRowSelection)(this.gos);
    }
    onRowCtrlSelected(rowCtrl, hasFocusFunc, gui) {
        // Treat undefined as false, if we pass undefined down it gets treated as toggle class, rather than explicitly
        // setting the required value
        const selected = !!rowCtrl.rowNode.isSelected();
        rowCtrl.forEachGui(gui, (gui) => {
            gui.rowComp.toggleCss('ag-row-selected', selected);
            const element = gui.element;
            (0, aria_1._setAriaSelected)(element, selected);
            const hasFocus = element.contains((0, gridOptionsUtils_1._getActiveDomElement)(this.beans));
            if (hasFocus) {
                hasFocusFunc(gui);
            }
        });
    }
    announceAriaRowSelection(rowNode) {
        if (this.isRowSelectionBlocked(rowNode)) {
            return;
        }
        const selected = rowNode.isSelected();
        if (!rowNode.selectable) {
            return;
        }
        const translate = this.getLocaleTextFunc();
        const label = translate(selected ? 'ariaRowDeselect' : 'ariaRowSelect', `Press SPACE to ${selected ? 'deselect' : 'select'} this row`);
        this.beans.ariaAnnounce?.announceValue(label, 'rowSelection');
    }
    isRowSelectionBlocked(rowNode) {
        return !rowNode.selectable || (rowNode.rowPinned && !(0, pinnedRowUtils_1._isManualPinnedRow)(rowNode)) || !(0, gridOptionsUtils_1._isRowSelection)(this.gos);
    }
    updateRowSelectable(rowNode, suppressSelectionUpdate) {
        const selectable = rowNode.rowPinned && rowNode.pinnedSibling
            ? // If row node is pinned sibling, copy selectable status over from sibling row node
                rowNode.pinnedSibling.selectable
            : // otherwise calculate selectable state directly
                this.isRowSelectable?.(rowNode) ?? true;
        this.setRowSelectable(rowNode, selectable, suppressSelectionUpdate);
        return selectable;
    }
    setRowSelectable(rowNode, newVal, suppressSelectionUpdate) {
        if (rowNode.selectable !== newVal) {
            rowNode.selectable = newVal;
            rowNode.dispatchRowEvent('selectableChanged');
            if (suppressSelectionUpdate) {
                return;
            }
            const isGroupSelectsChildren = (0, gridOptionsUtils_1._getGroupSelectsDescendants)(this.gos);
            if (isGroupSelectsChildren) {
                const selected = this.calculateSelectedFromChildren(rowNode);
                this.setNodesSelected({ nodes: [rowNode], newValue: selected ?? false, source: 'selectableChanged' });
                return;
            }
            // if row is selected but shouldn't be selectable, then deselect.
            if (rowNode.isSelected() && !rowNode.selectable) {
                this.setNodesSelected({ nodes: [rowNode], newValue: false, source: 'selectableChanged' });
            }
        }
    }
    calculateSelectedFromChildren(rowNode) {
        let atLeastOneSelected = false;
        let atLeastOneDeSelected = false;
        if (!rowNode.childrenAfterGroup?.length) {
            return rowNode.selectable ? rowNode.__selected : null;
        }
        for (let i = 0; i < rowNode.childrenAfterGroup.length; i++) {
            const child = rowNode.childrenAfterGroup[i];
            let childState = child.isSelected();
            // non-selectable nodes must be calculated from their children, or ignored if no value results.
            if (!child.selectable) {
                const selectable = this.calculateSelectedFromChildren(child);
                if (selectable === null) {
                    continue;
                }
                childState = selectable;
            }
            switch (childState) {
                case true:
                    atLeastOneSelected = true;
                    break;
                case false:
                    atLeastOneDeSelected = true;
                    break;
                default:
                    return undefined;
            }
        }
        if (atLeastOneSelected && atLeastOneDeSelected) {
            return undefined;
        }
        if (atLeastOneSelected) {
            return true;
        }
        if (atLeastOneDeSelected) {
            return false;
        }
        if (!rowNode.selectable) {
            return null;
        }
        return rowNode.__selected;
    }
    selectRowNode(rowNode, newValue, e, source = 'api') {
        // we only check selectable when newValue=true (ie selecting) to allow unselecting values,
        // as selectable is dynamic, need a way to unselect rows when selectable becomes false.
        const selectionNotAllowed = !rowNode.selectable && newValue;
        const selectionNotChanged = rowNode.__selected === newValue;
        if (selectionNotAllowed || selectionNotChanged) {
            return false;
        }
        rowNode.__selected = newValue;
        rowNode.dispatchRowEvent('rowSelected');
        // in case of root node, sibling may have service while this row may not
        const sibling = rowNode.sibling;
        if (sibling && sibling.footer && sibling.__localEventService) {
            sibling.dispatchRowEvent('rowSelected');
        }
        const pinnedSibling = rowNode.pinnedSibling;
        if (pinnedSibling && pinnedSibling.rowPinned && pinnedSibling.__localEventService) {
            pinnedSibling.dispatchRowEvent('rowSelected');
        }
        this.eventSvc.dispatchEvent({
            ...(0, rowNodeUtils_1._createGlobalRowEvent)(rowNode, this.gos, 'rowSelected'),
            event: e || null,
            source,
        });
        return true;
    }
    isCellCheckboxSelection(column, rowNode) {
        const so = this.gos.get('rowSelection');
        if (so && typeof so !== 'string') {
            const checkbox = (0, columnUtils_1.isColumnSelectionCol)(column) && (0, gridOptionsUtils_1._getCheckboxes)(so);
            return column.isColumnFunc(rowNode, checkbox);
        }
        else {
            return column.isColumnFunc(rowNode, column.colDef.checkboxSelection);
        }
    }
    inferNodeSelections(node, shiftKey, metaKey, source) {
        const { gos, selectionCtx } = this;
        const currentSelection = node.isSelected();
        const groupSelectsDescendants = (0, gridOptionsUtils_1._getGroupSelectsDescendants)(gos);
        const enableClickSelection = (0, gridOptionsUtils_1._getEnableSelection)(gos);
        const enableDeselection = (0, gridOptionsUtils_1._getEnableDeselection)(gos);
        const isMultiSelect = this.isMultiSelect();
        const isRowClicked = source === 'rowClicked';
        if (isRowClicked && !(enableClickSelection || enableDeselection))
            return null;
        if (shiftKey && metaKey && isMultiSelect) {
            // SHIFT+CTRL or SHIFT+CMD is used for bulk deselection, except where the selection root
            // is still selected, in which case we default to normal bulk selection behaviour
            const root = selectionCtx.getRoot();
            if (!root) {
                // do nothing if there's no selection root
                return null;
            }
            else if (!root.isSelected()) {
                // range deselection mode
                const partition = selectionCtx.extend(node, groupSelectsDescendants);
                return {
                    select: [],
                    deselect: partition.keep,
                    reset: false,
                };
            }
            else {
                // default to range selection
                const partition = selectionCtx.isInRange(node)
                    ? selectionCtx.truncate(node)
                    : selectionCtx.extend(node, groupSelectsDescendants);
                return {
                    deselect: partition.discard,
                    select: partition.keep,
                    reset: false,
                };
            }
        }
        else if (shiftKey && isMultiSelect) {
            // SHIFT is used for bulk selection
            // When select-all is active either via UI or API, if there's
            // no actual selection root, we fallback to the first row node (if available)
            const fallback = selectionCtx.selectAll ? this.beans.rowModel.getRow(0) : undefined;
            const root = selectionCtx.getRoot(fallback);
            const partition = selectionCtx.isInRange(node)
                ? selectionCtx.truncate(node)
                : selectionCtx.extend(node, groupSelectsDescendants);
            return {
                select: partition.keep,
                deselect: partition.discard,
                reset: selectionCtx.selectAll || !!(root && !root.isSelected()),
            };
        }
        else if (metaKey) {
            // CTRL is used for deselection of a single node or adding a single node to selection
            if (isRowClicked) {
                const newValue = !currentSelection;
                const selectingWhenDisabled = newValue && !enableClickSelection;
                const deselectingWhenDisabled = !newValue && !enableDeselection;
                if (selectingWhenDisabled || deselectingWhenDisabled)
                    return null;
                selectionCtx.setRoot(node);
                return {
                    node,
                    newValue,
                    clearSelection: false,
                };
            }
            selectionCtx.setRoot(node);
            return {
                node,
                newValue: !currentSelection,
                clearSelection: !isMultiSelect,
            };
        }
        else {
            // Otherwise we just do normal selection of a single node
            selectionCtx.setRoot(node);
            const enableSelectionWithoutKeys = (0, gridOptionsUtils_1._getEnableSelectionWithoutKeys)(gos);
            const groupSelectsFiltered = (0, gridOptionsUtils_1._getGroupSelection)(gos) === 'filteredDescendants';
            const shouldClear = isRowClicked && (!enableSelectionWithoutKeys || !enableClickSelection);
            // Indeterminate states need to be handled differently if `groupSelects: 'filteredDescendants'` in CSRM.
            // Specifically, clicking should toggle them _off_ instead of _on_
            if (groupSelectsFiltered && currentSelection === undefined && (0, gridOptionsUtils_1._isClientSideRowModel)(gos)) {
                return {
                    node,
                    newValue: false,
                    clearSelection: !isMultiSelect || shouldClear,
                };
            }
            if (isRowClicked) {
                const newValue = currentSelection ? !enableSelectionWithoutKeys : enableClickSelection;
                // if selecting, only proceed if not disabled by grid options
                const selectingWhenDisabled = newValue && !enableClickSelection;
                // if deselecting, only proceed if not disabled by grid options
                const deselectingWhenDisabled = !newValue && !enableDeselection;
                // only transistion to same state if we also want to clear other selected nodes
                const wouldStateBeUnchanged = newValue === currentSelection && !shouldClear;
                if (wouldStateBeUnchanged || selectingWhenDisabled || deselectingWhenDisabled)
                    return null;
                return {
                    node,
                    newValue,
                    clearSelection: !isMultiSelect || shouldClear,
                    keepDescendants: node.group && groupSelectsDescendants,
                };
            }
            return {
                node,
                newValue: !currentSelection,
                clearSelection: !isMultiSelect || shouldClear,
            };
        }
    }
}
exports.BaseSelectionService = BaseSelectionService;


/***/ }),

/***/ 95954:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CheckboxSelectionComponent = void 0;
const gridOptionsUtils_1 = __webpack_require__(67274);
const aria_1 = __webpack_require__(95230);
const event_1 = __webpack_require__(92979);
const agCheckbox_1 = __webpack_require__(90066);
const component_1 = __webpack_require__(78020);
const CheckboxSelectionComponentElement = {
    tag: 'div',
    cls: 'ag-selection-checkbox',
    role: 'presentation',
    children: [
        {
            tag: 'ag-checkbox',
            ref: 'eCheckbox',
            role: 'presentation',
        },
    ],
};
class CheckboxSelectionComponent extends component_1.Component {
    constructor() {
        super(CheckboxSelectionComponentElement, [agCheckbox_1.AgCheckboxSelector]);
        this.eCheckbox = component_1.RefPlaceholder;
    }
    postConstruct() {
        this.eCheckbox.setPassive(true);
    }
    getCheckboxId() {
        return this.eCheckbox.getInputElement().id;
    }
    onDataChanged() {
        // when rows are loaded for the second time, this can impact the selection, as a row
        // could be loaded as already selected (if user scrolls down, and then up again).
        this.onSelectionChanged();
    }
    onSelectableChanged() {
        this.showOrHideSelect();
    }
    onSelectionChanged() {
        const translate = this.getLocaleTextFunc();
        const { rowNode, eCheckbox } = this;
        const state = rowNode.isSelected();
        const stateName = (0, aria_1._getAriaCheckboxStateName)(translate, state);
        const [ariaKey, ariaLabel] = rowNode.selectable
            ? ['ariaRowToggleSelection', 'Press Space to toggle row selection']
            : ['ariaRowSelectionDisabled', 'Row Selection is disabled for this row'];
        const translatedLabel = translate(ariaKey, ariaLabel);
        eCheckbox.setValue(state, true);
        eCheckbox.setInputAriaLabel(`${translatedLabel} (${stateName})`);
    }
    init(params) {
        this.rowNode = params.rowNode;
        this.column = params.column;
        this.overrides = params.overrides;
        this.onSelectionChanged();
        this.addManagedListeners(this.eCheckbox.getInputElement(), {
            // we don't want double click on this icon to open a group
            dblclick: event_1._stopPropagationForAgGrid,
            click: (event) => {
                // we don't want the row clicked event to fire when selecting the checkbox, otherwise the row
                // would possibly get selected twice
                (0, event_1._stopPropagationForAgGrid)(event);
                this.beans.selectionSvc?.handleSelectionEvent(event, this.rowNode, 'checkboxSelected');
            },
        });
        this.addManagedListeners(this.rowNode, {
            rowSelected: this.onSelectionChanged.bind(this),
            dataChanged: this.onDataChanged.bind(this),
            selectableChanged: this.onSelectableChanged.bind(this),
        });
        this.addManagedPropertyListener('rowSelection', ({ currentValue, previousValue }) => {
            const curr = typeof currentValue === 'object' ? (0, gridOptionsUtils_1._getHideDisabledCheckboxes)(currentValue) : undefined;
            const prev = typeof previousValue === 'object' ? (0, gridOptionsUtils_1._getHideDisabledCheckboxes)(previousValue) : undefined;
            if (curr !== prev) {
                this.onSelectableChanged();
            }
        });
        const isRowSelectableFunc = (0, gridOptionsUtils_1._getIsRowSelectable)(this.gos);
        const checkboxVisibleIsDynamic = isRowSelectableFunc || typeof this.getIsVisible() === 'function';
        if (checkboxVisibleIsDynamic) {
            const showOrHideSelectListener = this.showOrHideSelect.bind(this);
            this.addManagedEventListeners({ displayedColumnsChanged: showOrHideSelectListener });
            this.addManagedListeners(this.rowNode, {
                dataChanged: showOrHideSelectListener,
                cellChanged: showOrHideSelectListener,
            });
            this.showOrHideSelect();
        }
        this.eCheckbox.getInputElement().setAttribute('tabindex', '-1');
    }
    showOrHideSelect() {
        const { column, rowNode, overrides, gos } = this;
        // if the isRowSelectable() is not provided the row node is selectable by default
        const selectable = rowNode.selectable;
        const isVisible = this.getIsVisible();
        let checkboxes = undefined;
        if (typeof isVisible === 'function') {
            const extraParams = overrides?.callbackParams;
            if (!column) {
                // full width row
                checkboxes = isVisible({ ...extraParams, node: rowNode, data: rowNode.data });
            }
            else {
                const params = column.createColumnFunctionCallbackParams(rowNode);
                checkboxes = isVisible({ ...extraParams, ...params });
            }
        }
        else {
            checkboxes = isVisible ?? false;
        }
        const disabled = (selectable && !checkboxes) || (!selectable && checkboxes);
        const visible = selectable || checkboxes;
        const so = gos.get('rowSelection');
        const showDisabledCheckboxes = so && typeof so !== 'string'
            ? !(0, gridOptionsUtils_1._getHideDisabledCheckboxes)(so)
            : !!column?.getColDef().showDisabledCheckboxes;
        this.setVisible(visible && (disabled ? showDisabledCheckboxes : true));
        this.setDisplayed(visible && (disabled ? showDisabledCheckboxes : true));
        if (visible) {
            this.eCheckbox.setDisabled(disabled);
        }
        if (overrides?.removeHidden) {
            this.setDisplayed(visible);
            return;
        }
    }
    getIsVisible() {
        const overrides = this.overrides;
        if (overrides) {
            return overrides.isVisible;
        }
        const so = this.gos.get('rowSelection');
        if (so && typeof so !== 'string') {
            return (0, gridOptionsUtils_1._getCheckboxes)(so);
        }
        // column will be missing if groupDisplayType = 'groupRows'
        return this.column?.getColDef()?.checkboxSelection;
    }
}
exports.CheckboxSelectionComponent = CheckboxSelectionComponent;


/***/ }),

/***/ 99666:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RowRangeSelectionContext = void 0;
const pinnedRowUtils_1 = __webpack_require__(78638);
/**
 * The context of a row range selection operation.
 *
 * Used to model the stateful range selection behaviour found in things like Excel and
 * various file explorers, in particular Windows File Explorer, where a given cell/row
 * represents the "root" of a selection range, and subsequent selections are based off that root.
 *
 * See AG-9620 for more
 */
class RowRangeSelectionContext {
    constructor(rowModel, pinnedRowModel) {
        this.rowModel = rowModel;
        this.pinnedRowModel = pinnedRowModel;
        /** Whether the user is currently selecting all nodes either via the header checkbox or API */
        this.selectAll = false;
        this.rootId = null;
        /**
         * Note that the "end" `RowNode` may come before or after the "root" `RowNode` in the
         * actual grid.
         */
        this.endId = null;
        this.cachedRange = [];
    }
    reset() {
        this.rootId = null;
        this.endId = null;
        this.cachedRange.length = 0;
    }
    setRoot(node) {
        this.rootId = node.id;
        this.endId = null;
        this.cachedRange.length = 0;
    }
    setEndRange(end) {
        this.endId = end.id;
        this.cachedRange.length = 0;
    }
    getRange() {
        if (this.cachedRange.length === 0) {
            const root = this.getRoot();
            const end = this.getEnd();
            if (root == null || end == null) {
                return this.cachedRange;
            }
            this.cachedRange = this.getNodesInRange(root, end) ?? [];
        }
        return this.cachedRange;
    }
    isInRange(node) {
        if (this.rootId === null) {
            return false;
        }
        return this.getRange().some((nodeInRange) => nodeInRange.id === node.id);
    }
    getRoot(fallback) {
        if (this.rootId) {
            return this.getRowNode(this.rootId);
        }
        if (fallback) {
            this.setRoot(fallback);
            return fallback;
        }
    }
    getEnd() {
        if (this.endId) {
            return this.getRowNode(this.endId);
        }
    }
    getRowNode(id) {
        let node;
        const { rowModel, pinnedRowModel } = this;
        node ?? (node = rowModel.getRowNode(id));
        if (pinnedRowModel?.isManual()) {
            node ?? (node = pinnedRowModel.getPinnedRowById(id, 'top'));
            node ?? (node = pinnedRowModel.getPinnedRowById(id, 'bottom'));
        }
        return node;
    }
    /**
     * Truncates the range to the given node (assumed to be within the current range).
     * Returns nodes that remain in the current range and those that should be removed
     *
     * @param node - Node at which to truncate the range
     * @returns Object of nodes to either keep or discard (i.e. deselect) from the range
     */
    truncate(node) {
        const range = this.getRange();
        if (range.length === 0) {
            return { keep: [], discard: [] };
        }
        // if root is first, then selection range goes "down" the table
        // so we should be unselecting the range _after_ the given `node`
        const discardAfter = range[0].id === this.rootId;
        const idx = range.findIndex((rowNode) => rowNode.id === node.id);
        if (idx > -1) {
            const above = range.slice(0, idx);
            const below = range.slice(idx + 1);
            this.setEndRange(node);
            return discardAfter ? { keep: above, discard: below } : { keep: below, discard: above };
        }
        else {
            return { keep: range, discard: [] };
        }
    }
    /**
     * Extends the range to the given node. Returns nodes that remain in the current range
     * and those that should be removed.
     *
     * @param node - Node marking the new end of the range
     * @returns Object of nodes to either keep or discard (i.e. deselect) from the range
     */
    extend(node, groupSelectsChildren = false) {
        const root = this.getRoot();
        // If the root node is null, we cannot iterate from the root to the given `node`.
        // So we keep the existing selection, plus the given `node`, plus any leaf children.
        if (root == null) {
            const keep = this.getRange().slice();
            if (groupSelectsChildren) {
                node.depthFirstSearch((node) => !node.group && keep.push(node));
            }
            keep.push(node);
            // We now have a node we can use as the root of the selection
            this.setRoot(node);
            return { keep, discard: [] };
        }
        const newRange = this.getNodesInRange(root, node);
        if (!newRange) {
            this.setRoot(node);
            return { keep: [node], discard: [] };
        }
        if (newRange.find((newRangeNode) => newRangeNode.id === this.endId)) {
            // Range between root and given node contains the current "end"
            // so this is an extension of the current range direction
            this.setEndRange(node);
            return { keep: this.getRange(), discard: [] };
        }
        else {
            // otherwise, this is an inversion
            const discard = this.getRange().slice();
            this.setEndRange(node);
            return { keep: this.getRange(), discard };
        }
    }
    getNodesInRange(start, end) {
        const { pinnedRowModel, rowModel } = this;
        // 1. No manual row pinning: just look at row model
        if (!pinnedRowModel?.isManual()) {
            return rowModel.getNodesInRangeForSelection(start, end);
        }
        // 2. start node is pinned top, end node is main view
        if (start.rowPinned === 'top' && !end.rowPinned) {
            const pinnedRange = (0, pinnedRowUtils_1._getNodesInRangeForSelection)(pinnedRowModel, 'top', start, undefined);
            return pinnedRange.concat(rowModel.getNodesInRangeForSelection(rowModel.getRow(0), end) ?? []);
        }
        // 3. start node is pinned bottom, end node is main view
        if (start.rowPinned === 'bottom' && !end.rowPinned) {
            const pinnedRange = (0, pinnedRowUtils_1._getNodesInRangeForSelection)(pinnedRowModel, 'bottom', undefined, start);
            const count = rowModel.getRowCount();
            const lastMain = rowModel.getRow(count - 1);
            return (rowModel.getNodesInRangeForSelection(end, lastMain) ?? []).concat(pinnedRange);
        }
        // 4. start node is main view, end node is main view
        if (!start.rowPinned && !end.rowPinned) {
            return rowModel.getNodesInRangeForSelection(start, end);
        }
        // 5. start node is pinned top, end node is pinned top
        if (start.rowPinned === 'top' && end.rowPinned === 'top') {
            return (0, pinnedRowUtils_1._getNodesInRangeForSelection)(pinnedRowModel, 'top', start, end);
        }
        // 6. start node is pinned bottom, end node is pinned top
        if (start.rowPinned === 'bottom' && end.rowPinned === 'top') {
            const top = (0, pinnedRowUtils_1._getNodesInRangeForSelection)(pinnedRowModel, 'top', end, undefined);
            const bottom = (0, pinnedRowUtils_1._getNodesInRangeForSelection)(pinnedRowModel, 'bottom', undefined, start);
            const first = rowModel.getRow(0);
            const last = rowModel.getRow(rowModel.getRowCount() - 1);
            return top.concat(rowModel.getNodesInRangeForSelection(first, last) ?? []).concat(bottom);
        }
        // 7. start node is main view, end node is pinned top
        if (!start.rowPinned && end.rowPinned === 'top') {
            const pinned = (0, pinnedRowUtils_1._getNodesInRangeForSelection)(pinnedRowModel, 'top', end, undefined);
            return pinned.concat(rowModel.getNodesInRangeForSelection(rowModel.getRow(0), start) ?? []);
        }
        // 8. start node is pinned top, end node is pinned bottom
        if (start.rowPinned === 'top' && end.rowPinned === 'bottom') {
            const top = (0, pinnedRowUtils_1._getNodesInRangeForSelection)(pinnedRowModel, 'top', start, undefined);
            const bottom = (0, pinnedRowUtils_1._getNodesInRangeForSelection)(pinnedRowModel, 'bottom', undefined, end);
            const first = rowModel.getRow(0);
            const last = rowModel.getRow(rowModel.getRowCount() - 1);
            return top.concat(rowModel.getNodesInRangeForSelection(first, last) ?? []).concat(bottom);
        }
        // 9. start node is pinned bottom, end node is pinned bottom
        if (start.rowPinned === 'bottom' && end.rowPinned === 'bottom') {
            return (0, pinnedRowUtils_1._getNodesInRangeForSelection)(pinnedRowModel, 'bottom', start, end);
        }
        // 10. start node is main view, end node is pinned bottom
        if (!start.rowPinned && end.rowPinned === 'bottom') {
            const pinned = (0, pinnedRowUtils_1._getNodesInRangeForSelection)(pinnedRowModel, 'bottom', undefined, end);
            const last = rowModel.getRow(rowModel.getRowCount());
            return (rowModel.getNodesInRangeForSelection(start, last) ?? []).concat(pinned);
        }
        return null;
    }
}
exports.RowRangeSelectionContext = RowRangeSelectionContext;


/***/ }),

/***/ 29770:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSelectedRows = exports.getSelectedNodes = exports.deselectAllOnCurrentPage = exports.selectAllOnCurrentPage = exports.deselectAllFiltered = exports.selectAllFiltered = exports.deselectAll = exports.selectAll = exports.setNodesSelected = void 0;
const pinnedRowUtils_1 = __webpack_require__(78638);
const logging_1 = __webpack_require__(47764);
function setNodesSelected(beans, params) {
    const allNodesValid = params.nodes.every((node) => {
        if (node.rowPinned && !(0, pinnedRowUtils_1._isManualPinnedRow)(node)) {
            (0, logging_1._warn)(59);
            return false;
        }
        if (node.id === undefined) {
            (0, logging_1._warn)(60);
            return false;
        }
        return true;
    });
    if (!allNodesValid) {
        return;
    }
    const { nodes, source, newValue } = params;
    beans.selectionSvc?.setNodesSelected({ nodes: nodes, source: source ?? 'api', newValue });
}
exports.setNodesSelected = setNodesSelected;
function selectAll(beans, selectAll, source = 'apiSelectAll') {
    beans.selectionSvc?.selectAllRowNodes({ source, selectAll });
}
exports.selectAll = selectAll;
function deselectAll(beans, selectAll, source = 'apiSelectAll') {
    beans.selectionSvc?.deselectAllRowNodes({ source, selectAll });
}
exports.deselectAll = deselectAll;
/** @deprecated v33 */
function selectAllFiltered(beans, source = 'apiSelectAllFiltered') {
    beans.selectionSvc?.selectAllRowNodes({ source, selectAll: 'filtered' });
}
exports.selectAllFiltered = selectAllFiltered;
/** @deprecated v33 */
function deselectAllFiltered(beans, source = 'apiSelectAllFiltered') {
    beans.selectionSvc?.deselectAllRowNodes({ source, selectAll: 'filtered' });
}
exports.deselectAllFiltered = deselectAllFiltered;
/** @deprecated v33 */
function selectAllOnCurrentPage(beans, source = 'apiSelectAllCurrentPage') {
    beans.selectionSvc?.selectAllRowNodes({ source, selectAll: 'currentPage' });
}
exports.selectAllOnCurrentPage = selectAllOnCurrentPage;
/** @deprecated v33 */
function deselectAllOnCurrentPage(beans, source = 'apiSelectAllCurrentPage') {
    beans.selectionSvc?.deselectAllRowNodes({ source, selectAll: 'currentPage' });
}
exports.deselectAllOnCurrentPage = deselectAllOnCurrentPage;
function getSelectedNodes(beans) {
    return beans.selectionSvc?.getSelectedNodes() ?? [];
}
exports.getSelectedNodes = getSelectedNodes;
function getSelectedRows(beans) {
    return beans.selectionSvc?.getSelectedRows() ?? [];
}
exports.getSelectedRows = getSelectedRows;


/***/ }),

/***/ 43352:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RowSelectionModule = exports.SharedRowSelectionModule = void 0;
const selectionColService_1 = __webpack_require__(75626);
const version_1 = __webpack_require__(97205);
const rowSelectionApi_1 = __webpack_require__(29770);
const selectionService_1 = __webpack_require__(6603);
/**
 * @internal
 */
exports.SharedRowSelectionModule = {
    moduleName: 'SharedRowSelection',
    version: version_1.VERSION,
    beans: [selectionColService_1.SelectionColService],
    apiFunctions: {
        setNodesSelected: rowSelectionApi_1.setNodesSelected,
        selectAll: rowSelectionApi_1.selectAll,
        deselectAll: rowSelectionApi_1.deselectAll,
        selectAllFiltered: rowSelectionApi_1.selectAllFiltered,
        deselectAllFiltered: rowSelectionApi_1.deselectAllFiltered,
        selectAllOnCurrentPage: rowSelectionApi_1.selectAllOnCurrentPage,
        deselectAllOnCurrentPage: rowSelectionApi_1.deselectAllOnCurrentPage,
        getSelectedNodes: rowSelectionApi_1.getSelectedNodes,
        getSelectedRows: rowSelectionApi_1.getSelectedRows,
    },
};
/**
 * @feature Selection -> Row Selection
 */
exports.RowSelectionModule = {
    moduleName: 'RowSelection',
    version: version_1.VERSION,
    rowModels: ['clientSide', 'infinite', 'viewport'],
    beans: [selectionService_1.SelectionService],
    dependsOn: [exports.SharedRowSelectionModule],
};


/***/ }),

/***/ 48273:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isCheckboxSelection = exports.SelectAllFeature = void 0;
const columnUtils_1 = __webpack_require__(73146);
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const aria_1 = __webpack_require__(95230);
const logging_1 = __webpack_require__(47764);
const agCheckbox_1 = __webpack_require__(90066);
class SelectAllFeature extends beanStub_1.BeanStub {
    constructor(column) {
        super();
        this.column = column;
        this.cbSelectAllVisible = false;
        this.processingEventFromCheckbox = false;
    }
    onSpaceKeyDown(e) {
        const checkbox = this.cbSelectAll;
        if (checkbox.isDisplayed() && !checkbox.getGui().contains((0, gridOptionsUtils_1._getActiveDomElement)(this.beans))) {
            e.preventDefault();
            checkbox.setValue(!checkbox.getValue());
        }
    }
    getCheckboxGui() {
        return this.cbSelectAll.getGui();
    }
    setComp(ctrl) {
        this.headerCellCtrl = ctrl;
        const cbSelectAll = this.createManagedBean(new agCheckbox_1.AgCheckbox());
        this.cbSelectAll = cbSelectAll;
        cbSelectAll.addCss('ag-header-select-all');
        (0, aria_1._setAriaRole)(cbSelectAll.getGui(), 'presentation');
        this.showOrHideSelectAll();
        const updateStateOfCheckbox = this.updateStateOfCheckbox.bind(this);
        this.addManagedEventListeners({
            newColumnsLoaded: () => this.showOrHideSelectAll(),
            displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
            selectionChanged: updateStateOfCheckbox,
            paginationChanged: updateStateOfCheckbox,
            modelUpdated: updateStateOfCheckbox,
        });
        this.addManagedPropertyListener('rowSelection', ({ currentValue, previousValue }) => {
            const getSelectAll = (rowSelection) => typeof rowSelection === 'string' || !rowSelection || rowSelection.mode === 'singleRow'
                ? undefined
                : rowSelection.selectAll;
            if (getSelectAll(currentValue) !== getSelectAll(previousValue)) {
                this.showOrHideSelectAll();
            }
            this.updateStateOfCheckbox();
        });
        this.addManagedListeners(cbSelectAll, { fieldValueChanged: this.onCbSelectAll.bind(this) });
        cbSelectAll.getInputElement().setAttribute('tabindex', '-1');
        this.refreshSelectAllLabel();
    }
    onDisplayedColumnsChanged(e) {
        if (!this.isAlive()) {
            return;
        }
        this.showOrHideSelectAll(e.source === 'uiColumnMoved');
    }
    showOrHideSelectAll(fromColumnMoved = false) {
        const cbSelectAllVisible = this.isCheckboxSelection();
        this.cbSelectAllVisible = cbSelectAllVisible;
        this.cbSelectAll.setDisplayed(cbSelectAllVisible);
        if (cbSelectAllVisible) {
            // in case user is trying this feature with the wrong model type
            this.checkRightRowModelType('selectAllCheckbox');
            // in case user is trying this feature with the wrong model type
            this.checkSelectionType('selectAllCheckbox');
            // make sure checkbox is showing the right state
            this.updateStateOfCheckbox();
        }
        this.refreshSelectAllLabel(fromColumnMoved);
    }
    updateStateOfCheckbox() {
        if (!this.cbSelectAllVisible || this.processingEventFromCheckbox) {
            return;
        }
        this.processingEventFromCheckbox = true;
        const selectAllMode = this.getSelectAllMode();
        const selectionSvc = this.beans.selectionSvc;
        const cbSelectAll = this.cbSelectAll;
        const allSelected = selectionSvc.getSelectAllState(selectAllMode);
        cbSelectAll.setValue(allSelected);
        const hasNodesToSelect = selectionSvc.hasNodesToSelect(selectAllMode);
        cbSelectAll.setDisabled(!hasNodesToSelect);
        this.refreshSelectAllLabel();
        this.processingEventFromCheckbox = false;
    }
    refreshSelectAllLabel(fromColumnMoved = false) {
        const translate = this.getLocaleTextFunc();
        const { headerCellCtrl, cbSelectAll, cbSelectAllVisible } = this;
        const checked = cbSelectAll.getValue();
        const ariaStatus = checked ? translate('ariaChecked', 'checked') : translate('ariaUnchecked', 'unchecked');
        const ariaLabel = translate('ariaRowSelectAll', 'Press Space to toggle all rows selection');
        headerCellCtrl.setAriaDescriptionProperty('selectAll', cbSelectAllVisible ? `${ariaLabel} (${ariaStatus})` : null);
        cbSelectAll.setInputAriaLabel(translate('ariaHeaderSelection', 'Column with Header Selection'));
        // skip repetitive announcements during column move
        if (!fromColumnMoved) {
            headerCellCtrl.announceAriaDescription();
        }
    }
    checkSelectionType(feature) {
        const isMultiSelect = (0, gridOptionsUtils_1._isMultiRowSelection)(this.gos);
        if (!isMultiSelect) {
            (0, logging_1._warn)(128, { feature });
            return false;
        }
        return true;
    }
    checkRightRowModelType(feature) {
        const { gos, rowModel } = this.beans;
        const rowModelMatches = (0, gridOptionsUtils_1._isClientSideRowModel)(gos) || (0, gridOptionsUtils_1._isServerSideRowModel)(gos);
        if (!rowModelMatches) {
            (0, logging_1._warn)(129, { feature, rowModel: rowModel.getType() });
            return false;
        }
        return true;
    }
    onCbSelectAll() {
        if (this.processingEventFromCheckbox) {
            return;
        }
        if (!this.cbSelectAllVisible) {
            return;
        }
        const value = this.cbSelectAll.getValue();
        const selectAll = this.getSelectAllMode();
        let source = 'uiSelectAll';
        if (selectAll === 'currentPage') {
            source = 'uiSelectAllCurrentPage';
        }
        else if (selectAll === 'filtered') {
            source = 'uiSelectAllFiltered';
        }
        const params = { source, selectAll };
        const selectionSvc = this.beans.selectionSvc;
        if (value) {
            selectionSvc.selectAllRowNodes(params);
        }
        else {
            selectionSvc.deselectAllRowNodes(params);
        }
    }
    /**
     * Checkbox is enabled when either the `headerCheckbox` option is enabled in the new selection API
     * or `headerCheckboxSelection` is enabled in the legacy API.
     */
    isCheckboxSelection() {
        const { column, gos, beans } = this;
        const rowSelection = gos.get('rowSelection');
        const newHeaderCheckbox = typeof rowSelection === 'object';
        const featureName = newHeaderCheckbox ? 'headerCheckbox' : 'headerCheckboxSelection';
        return (isCheckboxSelection(beans, column) &&
            this.checkRightRowModelType(featureName) &&
            this.checkSelectionType(featureName));
    }
    getSelectAllMode() {
        const selectAll = (0, gridOptionsUtils_1._getSelectAll)(this.gos, false);
        if (selectAll) {
            return selectAll;
        }
        const { headerCheckboxSelectionCurrentPageOnly, headerCheckboxSelectionFilteredOnly } = this.column.getColDef();
        if (headerCheckboxSelectionCurrentPageOnly) {
            return 'currentPage';
        }
        if (headerCheckboxSelectionFilteredOnly) {
            return 'filtered';
        }
        return 'all';
    }
    destroy() {
        super.destroy();
        this.cbSelectAll = undefined;
        this.headerCellCtrl = undefined;
    }
}
exports.SelectAllFeature = SelectAllFeature;
function isCheckboxSelection({ gos, selectionColSvc }, column) {
    const rowSelection = gos.get('rowSelection');
    const colDef = column.getColDef();
    const { headerCheckboxSelection } = colDef;
    let result = false;
    const newHeaderCheckbox = typeof rowSelection === 'object';
    if (newHeaderCheckbox) {
        // new selection config
        const isSelectionCol = (0, columnUtils_1.isColumnSelectionCol)(column);
        const isAutoCol = (0, columnUtils_1.isColumnGroupAutoCol)(column);
        // default to displaying header checkbox in the selection column
        const location = (0, gridOptionsUtils_1._getCheckboxLocation)(rowSelection);
        if ((location === 'autoGroupColumn' && isAutoCol) ||
            (isSelectionCol && selectionColSvc?.isSelectionColumnEnabled())) {
            result = (0, gridOptionsUtils_1._getHeaderCheckbox)(rowSelection);
        }
    }
    else {
        // legacy selection config
        if (typeof headerCheckboxSelection === 'function') {
            result = headerCheckboxSelection((0, gridOptionsUtils_1._addGridCommonParams)(gos, { column, colDef }));
        }
        else {
            result = !!headerCheckboxSelection;
        }
    }
    return result;
}
exports.isCheckboxSelection = isCheckboxSelection;


/***/ }),

/***/ 6603:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectionService = void 0;
const rowNode_1 = __webpack_require__(3373);
const gridOptionsUtils_1 = __webpack_require__(67274);
const pinnedRowUtils_1 = __webpack_require__(78638);
const changedPath_1 = __webpack_require__(76800);
const logging_1 = __webpack_require__(47764);
const baseSelectionService_1 = __webpack_require__(23306);
class SelectionService extends baseSelectionService_1.BaseSelectionService {
    constructor() {
        super(...arguments);
        this.beanName = 'selectionSvc';
        this.selectedNodes = new Map();
        /** Only used to track detail grid selection state when master/detail is enabled */
        this.detailSelection = new Map();
        this.masterSelectsDetail = false;
    }
    postConstruct() {
        super.postConstruct();
        const { gos } = this;
        this.mode = (0, gridOptionsUtils_1._getRowSelectionMode)(gos);
        this.groupSelectsDescendants = (0, gridOptionsUtils_1._getGroupSelectsDescendants)(gos);
        this.groupSelectsFiltered = (0, gridOptionsUtils_1._getGroupSelection)(gos) === 'filteredDescendants';
        this.masterSelectsDetail = (0, gridOptionsUtils_1._getMasterSelects)(gos) === 'detail';
        this.addManagedPropertyListeners(['groupSelectsChildren', 'groupSelectsFiltered', 'rowSelection'], () => {
            const groupSelectsDescendants = (0, gridOptionsUtils_1._getGroupSelectsDescendants)(gos);
            const selectionMode = (0, gridOptionsUtils_1._getRowSelectionMode)(gos);
            const groupSelectsFiltered = (0, gridOptionsUtils_1._getGroupSelection)(gos) === 'filteredDescendants';
            this.masterSelectsDetail = (0, gridOptionsUtils_1._getMasterSelects)(gos) === 'detail';
            if (groupSelectsDescendants !== this.groupSelectsDescendants ||
                groupSelectsFiltered !== this.groupSelectsFiltered ||
                selectionMode !== this.mode) {
                this.deselectAllRowNodes({ source: 'api' });
                this.groupSelectsDescendants = groupSelectsDescendants;
                this.groupSelectsFiltered = groupSelectsFiltered;
                this.mode = selectionMode;
            }
        });
        this.addManagedEventListeners({ rowSelected: this.onRowSelected.bind(this) });
    }
    destroy() {
        super.destroy();
        this.resetNodes();
    }
    handleSelectionEvent(event, rowNode, source) {
        if (this.isRowSelectionBlocked(rowNode))
            return 0;
        const selection = this.inferNodeSelections(rowNode, event.shiftKey, event.metaKey || event.ctrlKey, source);
        if (selection == null) {
            return 0;
        }
        this.selectionCtx.selectAll = false;
        if ('select' in selection) {
            if (selection.reset) {
                this.resetNodes();
            }
            else {
                this.selectRange(selection.deselect, false, source);
            }
            return this.selectRange(selection.select, true, source);
        }
        else {
            return this.setNodesSelected({
                nodes: [selection.node],
                newValue: selection.newValue,
                clearSelection: selection.clearSelection,
                keepDescendants: selection.keepDescendants,
                event,
                source,
            });
        }
    }
    setNodesSelected({ newValue, clearSelection, suppressFinishActions, nodes, event, source, keepDescendants = false, }) {
        if (!(0, gridOptionsUtils_1._isRowSelection)(this.gos) && newValue) {
            (0, logging_1._warn)(132);
            return 0;
        }
        if (nodes.length === 0)
            return 0;
        if (nodes.length > 1 && !this.isMultiSelect()) {
            (0, logging_1._warn)(130);
            return 0;
        }
        let updatedCount = 0;
        for (let i = 0; i < nodes.length; i++) {
            const rowNode = nodes[i];
            // if node is a footer, we don't do selection, just pass the info
            // to the sibling (the parent of the group)
            const node = _normaliseSiblingRef(rowNode);
            // when groupSelectsFiltered, then this node may end up indeterminate despite
            // trying to set it to true / false. this group will be calculated further on
            // down when we call updateGroupsFromChildrenSelections(). we need to skip it
            // here, otherwise the updatedCount would include it.
            const skipThisNode = this.groupSelectsFiltered && node.group;
            if (node.rowPinned && !(0, pinnedRowUtils_1._isManualPinnedRow)(node)) {
                (0, logging_1._warn)(59);
                continue;
            }
            if (node.id === undefined) {
                (0, logging_1._warn)(60);
                continue;
            }
            if (!skipThisNode) {
                const thisNodeWasSelected = this.selectRowNode(node, newValue, event, source);
                if (thisNodeWasSelected) {
                    this.detailSelection.delete(node.id);
                    updatedCount++;
                }
            }
            if (this.groupSelectsDescendants && node.childrenAfterGroup?.length) {
                updatedCount += this.selectChildren(node, newValue, source);
            }
        }
        // clear other nodes if not doing multi select
        if (!suppressFinishActions) {
            if (nodes.length === 1 && source === 'api') {
                this.selectionCtx.setRoot(_normaliseSiblingRef(nodes[0]));
            }
            const clearOtherNodes = newValue && (clearSelection || !this.isMultiSelect());
            if (clearOtherNodes) {
                updatedCount += this.clearOtherNodes(_normaliseSiblingRef(nodes[0]), keepDescendants, source);
            }
            // only if we selected something, then update groups and fire events
            if (updatedCount > 0) {
                this.updateGroupsFromChildrenSelections(source);
                // this is the very end of the 'action node', so we finished all the updates,
                // including any parent / child changes that this method caused
                this.dispatchSelectionChanged(source);
            }
        }
        return updatedCount;
    }
    // not to be mixed up with 'cell range selection' where you drag the mouse, this is row range selection, by
    // holding down 'shift'.
    selectRange(nodesToSelect, value, source) {
        let updatedCount = 0;
        nodesToSelect.forEach((node) => {
            const rowNode = _normaliseSiblingRef(node);
            if (rowNode.group && this.groupSelectsDescendants) {
                return;
            }
            const nodeWasSelected = this.selectRowNode(rowNode, value, undefined, source);
            if (nodeWasSelected) {
                updatedCount++;
            }
        });
        if (updatedCount > 0) {
            this.updateGroupsFromChildrenSelections(source);
            this.dispatchSelectionChanged(source);
        }
        return updatedCount;
    }
    selectChildren(node, newValue, source) {
        const children = this.groupSelectsFiltered ? node.childrenAfterAggFilter : node.childrenAfterGroup;
        if (!children) {
            return 0;
        }
        return this.setNodesSelected({
            newValue,
            clearSelection: false,
            suppressFinishActions: true,
            source,
            nodes: children,
        });
    }
    getSelectedNodes() {
        return Array.from(this.selectedNodes.values());
    }
    getSelectedRows() {
        const selectedRows = [];
        this.selectedNodes.forEach((rowNode) => selectedRows.push(rowNode.data));
        return selectedRows;
    }
    getSelectionCount() {
        return this.selectedNodes.size;
    }
    /**
     * This method is used by the CSRM to remove groups which are being disposed of,
     * events do not need fired in this case
     */
    filterFromSelection(predicate) {
        const newSelectedNodes = new Map();
        this.selectedNodes.forEach((rowNode, key) => {
            if (predicate(rowNode)) {
                newSelectedNodes.set(key, rowNode);
            }
        });
        this.selectedNodes = newSelectedNodes;
    }
    updateGroupsFromChildrenSelections(source, changedPath) {
        // we only do this when group selection state depends on selected children
        if (!this.groupSelectsDescendants) {
            return false;
        }
        const { gos, rowModel } = this.beans;
        // also only do it if CSRM (code should never allow this anyway)
        if (!(0, gridOptionsUtils_1._isClientSideRowModel)(gos, rowModel)) {
            return false;
        }
        const rootNode = rowModel.rootNode;
        if (!rootNode) {
            return false;
        }
        if (!changedPath) {
            changedPath = new changedPath_1.ChangedPath(true, rootNode);
            changedPath.active = false;
        }
        let selectionChanged = false;
        changedPath.forEachChangedNodeDepthFirst((rowNode) => {
            if (rowNode !== rootNode) {
                const selected = this.calculateSelectedFromChildren(rowNode);
                selectionChanged =
                    this.selectRowNode(rowNode, selected === null ? false : selected, undefined, source) ||
                        selectionChanged;
            }
        });
        return selectionChanged;
    }
    clearOtherNodes(rowNodeToKeepSelected, keepDescendants, source) {
        const groupsToRefresh = new Map();
        let updatedCount = 0;
        this.selectedNodes.forEach((otherRowNode) => {
            const isNodeToKeep = otherRowNode.id == rowNodeToKeepSelected.id;
            const shouldClearDescendant = keepDescendants ? !isDescendantOf(rowNodeToKeepSelected, otherRowNode) : true;
            if (shouldClearDescendant && !isNodeToKeep) {
                const rowNode = this.selectedNodes.get(otherRowNode.id);
                updatedCount += this.setNodesSelected({
                    nodes: [rowNode],
                    newValue: false,
                    clearSelection: false,
                    suppressFinishActions: true,
                    source,
                });
                if (this.groupSelectsDescendants && otherRowNode.parent) {
                    groupsToRefresh.set(otherRowNode.parent.id, otherRowNode.parent);
                }
            }
        });
        groupsToRefresh.forEach((group) => {
            const selected = this.calculateSelectedFromChildren(group);
            this.selectRowNode(group, selected === null ? false : selected, undefined, source);
        });
        return updatedCount;
    }
    onRowSelected(event) {
        const rowNode = event.node;
        // we do not store the group rows when the groups select children
        if (this.groupSelectsDescendants && rowNode.group) {
            return;
        }
        if (rowNode.isSelected()) {
            this.selectedNodes.set(rowNode.id, rowNode);
        }
        else {
            this.selectedNodes.delete(rowNode.id);
        }
    }
    syncInRowNode(rowNode, oldNode) {
        this.syncInOldRowNode(rowNode, oldNode);
        this.syncInNewRowNode(rowNode);
    }
    createDaemonNode(rowNode) {
        if (!rowNode.id) {
            return undefined;
        }
        const oldNode = new rowNode_1.RowNode(this.beans);
        // just copy the id and data, this is enough for the node to be used
        // in the selection service
        oldNode.id = rowNode.id;
        oldNode.data = rowNode.data;
        oldNode.__daemon = true;
        oldNode.__selected = rowNode.__selected;
        oldNode.level = rowNode.level;
        return oldNode;
    }
    // if the id has changed for the node, then this means the rowNode
    // is getting used for a different data item, which breaks
    // our selectedNodes, as the node now is mapped by the old id
    // which is inconsistent. so to keep the old node as selected,
    // we swap in the clone (with the old id and old data). this means
    // the oldNode is effectively a daemon we keep a reference to,
    // so if client calls api.getSelectedNodes(), it gets the daemon
    // in the result. when the client un-selects, the reference to the
    // daemon is removed. the daemon, because it's an oldNode, is not
    // used by the grid for rendering, it's a copy of what the node used
    // to be like before the id was changed.
    syncInOldRowNode(rowNode, oldNode) {
        if (oldNode && rowNode.id !== oldNode.id) {
            const oldNodeSelected = this.selectedNodes.get(oldNode.id) == rowNode;
            if (oldNodeSelected) {
                this.selectedNodes.set(oldNode.id, oldNode);
            }
        }
    }
    syncInNewRowNode(rowNode) {
        if (this.selectedNodes.has(rowNode.id)) {
            rowNode.__selected = true;
            this.selectedNodes.set(rowNode.id, rowNode);
        }
        else {
            rowNode.__selected = false;
        }
    }
    reset(source) {
        const selectionCount = this.getSelectionCount();
        this.resetNodes();
        if (selectionCount) {
            this.dispatchSelectionChanged(source);
        }
    }
    resetNodes() {
        this.selectedNodes.forEach((node) => {
            this.selectRowNode(node, false);
        });
        this.selectedNodes.clear();
    }
    // returns a list of all nodes at 'best cost' - a feature to be used
    // with groups / trees. if a group has all it's children selected,
    // then the group appears in the result, but not the children.
    // Designed for use with 'children' as the group selection type,
    // where groups don't actually appear in the selection normally.
    getBestCostNodeSelection() {
        const { gos, rowModel } = this.beans;
        if (!(0, gridOptionsUtils_1._isClientSideRowModel)(gos, rowModel)) {
            // Error logged as part of gridApi as that is only call point for this method.
            return;
        }
        const topLevelNodes = rowModel.getTopLevelNodes();
        if (topLevelNodes === null) {
            return;
        }
        const result = [];
        // recursive function, to find the selected nodes
        function traverse(nodes) {
            for (let i = 0, l = nodes.length; i < l; i++) {
                const node = nodes[i];
                if (node.isSelected()) {
                    result.push(node);
                }
                else {
                    // if not selected, then if it's a group, and the group
                    // has children, continue to search for selections
                    if (node.group && node.childrenAfterGroup) {
                        traverse(node.childrenAfterGroup);
                    }
                }
            }
        }
        traverse(topLevelNodes);
        return result;
    }
    isEmpty() {
        return this.getSelectionCount() === 0;
    }
    deselectAllRowNodes({ source, selectAll }) {
        const rowModelClientSide = (0, gridOptionsUtils_1._isClientSideRowModel)(this.gos);
        let updatedNodes = false;
        const callback = (rowNode) => {
            const updated = this.selectRowNode(_normaliseSiblingRef(rowNode), false, undefined, source);
            updatedNodes || (updatedNodes = updated);
        };
        if (selectAll === 'currentPage' || selectAll === 'filtered') {
            if (!rowModelClientSide) {
                (0, logging_1._error)(102);
                return;
            }
            this.getNodesToSelect(selectAll).forEach(callback);
        }
        else {
            this.selectedNodes.forEach(callback);
            // this clears down the map (whereas above only sets the items in map to 'undefined')
            this.reset(source);
        }
        this.selectionCtx.selectAll = false;
        // the above does not clean up the parent rows if they are selected
        if (rowModelClientSide && this.groupSelectsDescendants) {
            const updated = this.updateGroupsFromChildrenSelections(source);
            updatedNodes || (updatedNodes = updated);
        }
        if (updatedNodes) {
            this.dispatchSelectionChanged(source);
        }
    }
    getSelectedCounts(selectAll) {
        let selectedCount = 0;
        let notSelectedCount = 0;
        this.getNodesToSelect(selectAll).forEach((node) => {
            if (this.groupSelectsDescendants && node.group) {
                return;
            }
            if (node.isSelected()) {
                selectedCount++;
            }
            else if (node.selectable) {
                // don't count non-selectable nodes!
                notSelectedCount++;
            }
        });
        return { selectedCount, notSelectedCount };
    }
    getSelectAllState(selectAll) {
        const { selectedCount, notSelectedCount } = this.getSelectedCounts(selectAll);
        return _calculateSelectAllState(selectedCount, notSelectedCount) ?? null;
    }
    hasNodesToSelect(selectAll) {
        return this.getNodesToSelect(selectAll).filter((node) => node.selectable).length > 0;
    }
    /**
     * @param selectAll See `MultiRowSelectionOptions.selectAll`
     * @returns all nodes including unselectable nodes which are the target of this selection attempt
     */
    getNodesToSelect(selectAll) {
        if (!this.canSelectAll()) {
            return [];
        }
        const nodes = [];
        const addToResult = (node) => nodes.push(node);
        if (selectAll === 'currentPage') {
            this.forEachNodeOnPage((node) => {
                if (!node.group) {
                    addToResult(node);
                    return;
                }
                if (!node.expanded && !node.footer) {
                    // even with groupSelectsChildren, do this recursively as only the filtered children
                    // are considered as the current page
                    const recursivelyAddChildren = (child) => {
                        addToResult(child);
                        child.childrenAfterFilter?.forEach(recursivelyAddChildren);
                    };
                    recursivelyAddChildren(node);
                    return;
                }
                // if the group node is expanded, the pagination proxy will include the visible nodes to select
                if (!this.groupSelectsDescendants) {
                    addToResult(node);
                }
            });
            return nodes;
        }
        const clientSideRowModel = this.beans.rowModel;
        if (selectAll === 'filtered') {
            clientSideRowModel.forEachNodeAfterFilter(addToResult);
            return nodes;
        }
        clientSideRowModel.forEachNode(addToResult);
        return nodes;
    }
    forEachNodeOnPage(callback) {
        const { pageBounds, rowModel } = this.beans;
        const firstRow = pageBounds.getFirstRow();
        const lastRow = pageBounds.getLastRow();
        for (let i = firstRow; i <= lastRow; i++) {
            const node = rowModel.getRow(i);
            if (node) {
                callback(node);
            }
        }
    }
    selectAllRowNodes(params) {
        const { gos, selectionCtx } = this;
        if (!(0, gridOptionsUtils_1._isRowSelection)(gos)) {
            (0, logging_1._warn)(132);
            return;
        }
        if ((0, gridOptionsUtils_1._isUsingNewRowSelectionAPI)(gos) && !(0, gridOptionsUtils_1._isMultiRowSelection)(gos)) {
            (0, logging_1._warn)(130);
            return;
        }
        if (!this.canSelectAll()) {
            return;
        }
        const { source, selectAll } = params;
        let updatedNodes = false;
        this.getNodesToSelect(selectAll).forEach((rowNode) => {
            const updated = this.selectRowNode(_normaliseSiblingRef(rowNode), true, undefined, source);
            updatedNodes || (updatedNodes = updated);
        });
        selectionCtx.selectAll = true;
        // the above does not clean up the parent rows if they are selected
        if ((0, gridOptionsUtils_1._isClientSideRowModel)(gos) && this.groupSelectsDescendants) {
            const updated = this.updateGroupsFromChildrenSelections(source);
            updatedNodes || (updatedNodes = updated);
        }
        if (updatedNodes) {
            this.dispatchSelectionChanged(source);
        }
    }
    getSelectionState() {
        return this.isEmpty() ? null : Array.from(this.selectedNodes.keys());
    }
    setSelectionState(state, source, clearSelection) {
        if (!state) {
            state = [];
        }
        if (!Array.isArray(state)) {
            (0, logging_1._error)(103);
            return;
        }
        const rowIds = new Set(state);
        const nodes = [];
        this.beans.rowModel.forEachNode((node) => {
            if (rowIds.has(node.id)) {
                nodes.push(node);
            }
        });
        if (clearSelection) {
            this.resetNodes();
        }
        this.setNodesSelected({
            newValue: true,
            nodes,
            source,
        });
    }
    canSelectAll() {
        const { gos } = this.beans;
        if (!(0, gridOptionsUtils_1._isClientSideRowModel)(gos)) {
            return false;
        }
        return true;
    }
    /**
     * Updates the selectable state for a node by invoking isRowSelectable callback.
     * If the node is not selectable, it will be deselected.
     *
     * Callers:
     *  - property isRowSelectable changed
     *  - after grouping / treeData via `updateSelectableAfterGrouping`
     */
    updateSelectable(changedPath) {
        const { gos, rowModel } = this.beans;
        if (!(0, gridOptionsUtils_1._isRowSelection)(gos)) {
            return;
        }
        const source = 'selectableChanged';
        const skipLeafNodes = changedPath !== undefined;
        const isCSRMGroupSelectsDescendants = (0, gridOptionsUtils_1._isClientSideRowModel)(gos) && this.groupSelectsDescendants;
        const nodesToDeselect = [];
        const nodeCallback = (node) => {
            if (skipLeafNodes && !node.group) {
                return;
            }
            // Only in the CSRM, we allow group node selection if a child has a selectable=true when using groupSelectsChildren
            if (isCSRMGroupSelectsDescendants && node.group) {
                const hasSelectableChild = node.childrenAfterGroup?.some((rowNode) => rowNode.selectable) ?? false;
                this.setRowSelectable(node, hasSelectableChild, true);
                return;
            }
            const rowSelectable = this.updateRowSelectable(node, true);
            if (!rowSelectable && node.isSelected()) {
                nodesToDeselect.push(node);
            }
        };
        // Needs to be depth first in this case, so that parents can be updated based on child.
        if (isCSRMGroupSelectsDescendants) {
            if (changedPath === undefined) {
                const rootNode = rowModel.rootNode;
                changedPath = rootNode ? new changedPath_1.ChangedPath(false, rootNode) : undefined;
            }
            changedPath?.forEachChangedNodeDepthFirst(nodeCallback, !skipLeafNodes, !skipLeafNodes);
        }
        else {
            // Normal case, update all rows
            rowModel.forEachNode(nodeCallback);
        }
        if (nodesToDeselect.length) {
            this.setNodesSelected({
                nodes: nodesToDeselect,
                newValue: false,
                source,
            });
        }
        // if csrm and group selects children, update the groups after deselecting leaf nodes.
        if (!skipLeafNodes && isCSRMGroupSelectsDescendants) {
            this.updateGroupsFromChildrenSelections?.(source);
        }
    }
    // only called by CSRM
    updateSelectableAfterGrouping(changedPath) {
        this.updateSelectable(changedPath);
        if (this.groupSelectsDescendants) {
            const selectionChanged = this.updateGroupsFromChildrenSelections?.('rowGroupChanged', changedPath);
            if (selectionChanged) {
                this.dispatchSelectionChanged('rowGroupChanged');
            }
        }
    }
    refreshMasterNodeState(node, e) {
        if (!this.masterSelectsDetail)
            return;
        const detailApi = node.detailNode?.detailGridInfo?.api;
        if (!detailApi)
            return;
        const isSelectAll = _isAllSelected(detailApi);
        const current = node.isSelected();
        if (current !== isSelectAll) {
            const selectionChanged = this.selectRowNode(node, isSelectAll, e, 'masterDetail');
            if (selectionChanged) {
                this.dispatchSelectionChanged('masterDetail');
            }
        }
        if (!isSelectAll) {
            const detailSelected = this.detailSelection.get(node.id) ?? new Set();
            for (const n of detailApi.getSelectedNodes()) {
                detailSelected.add(n.id);
            }
            this.detailSelection.set(node.id, detailSelected);
        }
    }
    setDetailSelectionState(masterNode, detailGridOptions, detailApi) {
        if (!this.masterSelectsDetail)
            return;
        if (!(0, gridOptionsUtils_1._isMultiRowSelection)(detailGridOptions)) {
            (0, logging_1._warn)(269);
            return;
        }
        switch (masterNode.isSelected()) {
            case true: {
                detailApi.selectAll();
                break;
            }
            case false: {
                detailApi.deselectAll();
                break;
            }
            case undefined: {
                const selectedIds = this.detailSelection.get(masterNode.id);
                if (selectedIds) {
                    const nodes = [];
                    for (const id of selectedIds) {
                        const n = detailApi.getRowNode(id);
                        if (n) {
                            nodes.push(n);
                        }
                    }
                    detailApi.setNodesSelected({ nodes, newValue: true, source: 'masterDetail' });
                }
                break;
            }
            default:
                break;
        }
    }
    dispatchSelectionChanged(source) {
        this.eventSvc.dispatchEvent({
            type: 'selectionChanged',
            source,
            selectedNodes: this.getSelectedNodes(),
            serverSideState: null,
        });
    }
}
exports.SelectionService = SelectionService;
/** Selection state of sibling nodes is a clone of their siblings, so always act on sibling rather than footer */
function _normaliseSiblingRef(node) {
    return (0, pinnedRowUtils_1._isManualPinnedRow)(node) ? node.pinnedSibling : node.footer ? node.sibling : node;
}
function _isAllSelected(api) {
    let selectedCount = 0;
    let notSelectedCount = 0;
    api.forEachNode((node) => {
        if (node.isSelected()) {
            selectedCount++;
        }
        else if (node.selectable) {
            // don't count non-selectable nodes!
            notSelectedCount++;
        }
    });
    return _calculateSelectAllState(selectedCount, notSelectedCount);
}
function _calculateSelectAllState(selected, notSelected) {
    // if no rows, always have it unselected
    if (selected === 0 && notSelected === 0) {
        return false;
    }
    // if mix of selected and unselected, this is indeterminate
    if (selected > 0 && notSelected > 0) {
        return;
    }
    // only selected
    return selected > 0;
}
function isDescendantOf(root, child) {
    let parent = child.parent;
    while (parent) {
        if (parent === root)
            return true;
        parent = parent.parent;
    }
    return false;
}


/***/ }),

/***/ 53341:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RowNodeSorter = void 0;
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const generic_1 = __webpack_require__(34422);
// this logic is used by both SSRM and CSRM
class RowNodeSorter extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'rowNodeSorter';
    }
    postConstruct() {
        const { gos } = this;
        this.isAccentedSort = gos.get('accentedSort');
        this.primaryColumnsSortGroups = (0, gridOptionsUtils_1._isColumnsSortingCoupledToGroup)(gos);
        this.addManagedPropertyListener('accentedSort', (propChange) => (this.isAccentedSort = propChange.currentValue));
        this.addManagedPropertyListener('autoGroupColumnDef', () => (this.primaryColumnsSortGroups = (0, gridOptionsUtils_1._isColumnsSortingCoupledToGroup)(gos)));
    }
    doFullSort(rowNodes, sortOptions) {
        const sortedRowNodes = rowNodes.map((rowNode, currentPos) => ({
            currentPos,
            rowNode,
        }));
        sortedRowNodes.sort(this.compareRowNodes.bind(this, sortOptions));
        return sortedRowNodes.map((item) => item.rowNode);
    }
    compareRowNodes(sortOptions, sortedNodeA, sortedNodeB) {
        const nodeA = sortedNodeA.rowNode;
        const nodeB = sortedNodeB.rowNode;
        // Iterate columns, return the first that doesn't match
        for (let i = 0, len = sortOptions.length; i < len; i++) {
            const sortOption = sortOptions[i];
            const isDescending = sortOption.sort === 'desc';
            const valueA = this.getValue(nodeA, sortOption.column);
            const valueB = this.getValue(nodeB, sortOption.column);
            let comparatorResult;
            const providedComparator = this.getComparator(sortOption, nodeA);
            if (providedComparator) {
                //if comparator provided, use it
                comparatorResult = providedComparator(valueA, valueB, nodeA, nodeB, isDescending);
            }
            else {
                //otherwise do our own comparison
                comparatorResult = (0, generic_1._defaultComparator)(valueA, valueB, this.isAccentedSort);
            }
            // user provided comparators can return 'NaN' if they don't correctly handle 'undefined' values, this
            // typically occurs when the comparator is used on a group row
            const validResult = !isNaN(comparatorResult);
            if (validResult && comparatorResult !== 0) {
                return sortOption.sort === 'asc' ? comparatorResult : comparatorResult * -1;
            }
        }
        // All matched, we make is so that the original sort order is kept:
        return sortedNodeA.currentPos - sortedNodeB.currentPos;
    }
    getComparator(sortOption, rowNode) {
        const column = sortOption.column;
        // comparator on col get preference over everything else
        const comparatorOnCol = column.getColDef().comparator;
        if (comparatorOnCol != null) {
            return comparatorOnCol;
        }
        if (!column.getColDef().showRowGroup) {
            return;
        }
        // if a 'field' is supplied on the autoGroupColumnDef we need to use the associated column comparator
        const groupLeafField = !rowNode.group && column.getColDef().field;
        if (!groupLeafField) {
            return;
        }
        const primaryColumn = this.beans.colModel.getColDefCol(groupLeafField);
        if (!primaryColumn) {
            return;
        }
        return primaryColumn.getColDef().comparator;
    }
    getValue(node, column) {
        const { valueSvc, colModel, showRowGroupCols, gos } = this.beans;
        if (!this.primaryColumnsSortGroups) {
            return valueSvc.getValue(column, node, false);
        }
        const isNodeGroupedAtLevel = node.rowGroupColumn === column;
        if (isNodeGroupedAtLevel) {
            const isGroupRows = (0, gridOptionsUtils_1._isGroupUseEntireRow)(gos, colModel.isPivotActive());
            // because they're group rows, no display cols exist, so groupData never populated.
            // instead delegate to getting value from leaf child.
            if (isGroupRows) {
                const leafChild = node.allLeafChildren?.[0];
                if (leafChild) {
                    return valueSvc.getValue(column, leafChild, false);
                }
                return undefined;
            }
            const displayCol = showRowGroupCols?.getShowRowGroupCol(column.getId());
            if (!displayCol) {
                return undefined;
            }
            return node.groupData?.[displayCol.getId()];
        }
        if (node.group && column.getColDef().showRowGroup) {
            return undefined;
        }
        return valueSvc.getValue(column, node, false);
    }
}
exports.RowNodeSorter = RowNodeSorter;


/***/ }),

/***/ 97430:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.onSortChanged = void 0;
function onSortChanged(beans) {
    beans.sortSvc?.onSortChanged('api');
}
exports.onSortChanged = onSortChanged;


/***/ }),

/***/ 67388:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SortIndicatorSelector = exports.SortIndicatorComp = void 0;
const gridOptionsUtils_1 = __webpack_require__(67274);
const dom_1 = __webpack_require__(33507);
const icon_1 = __webpack_require__(59970);
const component_1 = __webpack_require__(78020);
const makeIconParams = (dataRefSuffix, classSuffix) => ({
    tag: 'span',
    ref: `eSort${dataRefSuffix}`,
    cls: `ag-sort-indicator-icon ag-sort-${classSuffix} ag-hidden`,
    attrs: { 'aria-hidden': 'true' },
});
const SortIndicatorElement = {
    tag: 'span',
    cls: 'ag-sort-indicator-container',
    children: [
        makeIconParams('Order', 'order'),
        makeIconParams('Asc', 'ascending-icon'),
        makeIconParams('Desc', 'descending-icon'),
        makeIconParams('Mixed', 'mixed-icon'),
        makeIconParams('None', 'none-icon'),
    ],
};
class SortIndicatorComp extends component_1.Component {
    constructor(skipTemplate) {
        super();
        // Elements might by undefined when the user provides a custom template
        this.eSortOrder = component_1.RefPlaceholder;
        this.eSortAsc = component_1.RefPlaceholder;
        this.eSortDesc = component_1.RefPlaceholder;
        this.eSortMixed = component_1.RefPlaceholder;
        this.eSortNone = component_1.RefPlaceholder;
        if (!skipTemplate) {
            this.setTemplate(SortIndicatorElement);
        }
    }
    attachCustomElements(eSortOrder, eSortAsc, eSortDesc, eSortMixed, eSortNone) {
        this.eSortOrder = eSortOrder;
        this.eSortAsc = eSortAsc;
        this.eSortDesc = eSortDesc;
        this.eSortMixed = eSortMixed;
        this.eSortNone = eSortNone;
    }
    setupSort(column, suppressOrder = false) {
        this.column = column;
        this.suppressOrder = suppressOrder;
        this.setupMultiSortIndicator();
        if (!column.isSortable() && !column.getColDef().showRowGroup) {
            return;
        }
        this.addInIcon('sortAscending', this.eSortAsc, column);
        this.addInIcon('sortDescending', this.eSortDesc, column);
        this.addInIcon('sortUnSort', this.eSortNone, column);
        const updateIcons = this.updateIcons.bind(this);
        const sortUpdated = this.onSortChanged.bind(this);
        this.addManagedPropertyListener('unSortIcon', updateIcons);
        this.addManagedEventListeners({
            newColumnsLoaded: updateIcons,
            // Watch global events, as row group columns can effect their display column.
            sortChanged: sortUpdated,
            // when grouping changes so can sort indexes and icons
            columnRowGroupChanged: sortUpdated,
        });
        this.onSortChanged();
    }
    addInIcon(iconName, eParent, column) {
        if (eParent == null) {
            return;
        }
        const eIcon = (0, icon_1._createIconNoSpan)(iconName, this.beans, column);
        if (eIcon) {
            eParent.appendChild(eIcon);
        }
    }
    onSortChanged() {
        this.updateIcons();
        if (!this.suppressOrder) {
            this.updateSortOrder();
        }
    }
    updateIcons() {
        const { eSortAsc, eSortDesc, eSortNone, column, gos, beans } = this;
        const sortDirection = beans.sortSvc.getDisplaySortForColumn(column);
        if (eSortAsc) {
            const isAscending = sortDirection === 'asc';
            (0, dom_1._setDisplayed)(eSortAsc, isAscending, { skipAriaHidden: true });
        }
        if (eSortDesc) {
            const isDescending = sortDirection === 'desc';
            (0, dom_1._setDisplayed)(eSortDesc, isDescending, { skipAriaHidden: true });
        }
        if (eSortNone) {
            const alwaysHideNoSort = !column.getColDef().unSortIcon && !gos.get('unSortIcon');
            const isNone = sortDirection === null || sortDirection === undefined;
            (0, dom_1._setDisplayed)(eSortNone, !alwaysHideNoSort && isNone, { skipAriaHidden: true });
        }
    }
    setupMultiSortIndicator() {
        const { eSortMixed, column, gos } = this;
        this.addInIcon('sortUnSort', eSortMixed, column);
        const isColumnShowingRowGroup = column.getColDef().showRowGroup;
        const areGroupsCoupled = (0, gridOptionsUtils_1._isColumnsSortingCoupledToGroup)(gos);
        if (areGroupsCoupled && isColumnShowingRowGroup) {
            this.addManagedEventListeners({
                // Watch global events, as row group columns can effect their display column.
                sortChanged: this.updateMultiSortIndicator.bind(this),
                // when grouping changes so can sort indexes and icons
                columnRowGroupChanged: this.updateMultiSortIndicator.bind(this),
            });
            this.updateMultiSortIndicator();
        }
    }
    updateMultiSortIndicator() {
        const { eSortMixed, beans, column } = this;
        if (eSortMixed) {
            const isMixedSort = beans.sortSvc.getDisplaySortForColumn(column) === 'mixed';
            (0, dom_1._setDisplayed)(eSortMixed, isMixedSort, { skipAriaHidden: true });
        }
    }
    // we listen here for global sort events, NOT column sort events, as we want to do this
    // when sorting has been set on all column (if we listened just for our col (where we
    // set the asc / desc icons) then it's possible other cols are yet to get their sorting state.
    updateSortOrder() {
        const { eSortOrder, column, beans: { sortSvc }, } = this;
        if (!eSortOrder) {
            return;
        }
        const allColumnsWithSorting = sortSvc.getColumnsWithSortingOrdered();
        const indexThisCol = sortSvc.getDisplaySortIndexForColumn(column) ?? -1;
        const moreThanOneColSorting = allColumnsWithSorting.some((col) => sortSvc.getDisplaySortIndexForColumn(col) ?? -1 >= 1);
        const showIndex = indexThisCol >= 0 && moreThanOneColSorting;
        (0, dom_1._setDisplayed)(eSortOrder, showIndex, { skipAriaHidden: true });
        if (indexThisCol >= 0) {
            eSortOrder.textContent = (indexThisCol + 1).toString();
        }
        else {
            (0, dom_1._clearElement)(eSortOrder);
        }
    }
}
exports.SortIndicatorComp = SortIndicatorComp;
exports.SortIndicatorSelector = {
    selector: 'AG-SORT-INDICATOR',
    component: SortIndicatorComp,
};


/***/ }),

/***/ 96620:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SortModule = void 0;
const version_1 = __webpack_require__(97205);
const rowNodeSorter_1 = __webpack_require__(53341);
const sortApi_1 = __webpack_require__(97430);
const sortIndicatorComp_1 = __webpack_require__(67388);
const sortService_1 = __webpack_require__(48125);
/**
 * @feature Rows -> Row Sorting
 * @colDef sortable, sort, sortIndex
 */
exports.SortModule = {
    moduleName: 'Sort',
    version: version_1.VERSION,
    beans: [sortService_1.SortService, rowNodeSorter_1.RowNodeSorter],
    apiFunctions: {
        onSortChanged: sortApi_1.onSortChanged,
    },
    userComponents: {
        agSortIndicator: sortIndicatorComp_1.SortIndicatorComp,
    },
    icons: {
        // show on column header when column is sorted ascending
        sortAscending: 'asc',
        // show on column header when column is sorted descending
        sortDescending: 'desc',
        // show on column header when column has no sort, only when enabled with gridOptions.unSortIcon=true
        sortUnSort: 'none',
    },
};


/***/ }),

/***/ 48125:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SortService = exports.DEFAULT_SORTING_ORDER = void 0;
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const sortIndicatorComp_1 = __webpack_require__(67388);
exports.DEFAULT_SORTING_ORDER = ['asc', 'desc', null];
class SortService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'sortSvc';
    }
    progressSort(column, multiSort, source) {
        const nextDirection = this.getNextSortDirection(column);
        this.setSortForColumn(column, nextDirection, multiSort, source);
    }
    progressSortFromEvent(column, event) {
        const sortUsingCtrl = this.gos.get('multiSortKey') === 'ctrl';
        const multiSort = sortUsingCtrl ? event.ctrlKey || event.metaKey : event.shiftKey;
        this.progressSort(column, multiSort, 'uiColumnSorted');
    }
    setSortForColumn(column, sort, multiSort, source) {
        // auto correct - if sort not legal value, then set it to 'no sort' (which is null)
        if (sort !== 'asc' && sort !== 'desc') {
            sort = null;
        }
        const { gos, showRowGroupCols } = this.beans;
        const isColumnsSortingCoupledToGroup = (0, gridOptionsUtils_1._isColumnsSortingCoupledToGroup)(gos);
        let columnsToUpdate = [column];
        if (isColumnsSortingCoupledToGroup) {
            if (column.getColDef().showRowGroup) {
                const rowGroupColumns = showRowGroupCols?.getSourceColumnsForGroupColumn?.(column);
                const sortableRowGroupColumns = rowGroupColumns?.filter((col) => col.isSortable());
                if (sortableRowGroupColumns) {
                    columnsToUpdate = [column, ...sortableRowGroupColumns];
                }
            }
        }
        columnsToUpdate.forEach((col) => this.setColSort(col, sort, source));
        const doingMultiSort = (multiSort || gos.get('alwaysMultiSort')) && !gos.get('suppressMultiSort');
        // clear sort on all columns except those changed, and update the icons
        const updatedColumns = [];
        if (!doingMultiSort) {
            const clearedColumns = this.clearSortBarTheseColumns(columnsToUpdate, source);
            updatedColumns.push(...clearedColumns);
        }
        // sortIndex used for knowing order of cols when multi-col sort
        this.updateSortIndex(column);
        updatedColumns.push(...columnsToUpdate);
        this.dispatchSortChangedEvents(source, updatedColumns);
    }
    updateSortIndex(lastColToChange) {
        const { gos, colModel, showRowGroupCols } = this.beans;
        const isCoupled = (0, gridOptionsUtils_1._isColumnsSortingCoupledToGroup)(gos);
        const groupParent = showRowGroupCols?.getShowRowGroupCol(lastColToChange.getId());
        const lastSortIndexCol = isCoupled ? groupParent || lastColToChange : lastColToChange;
        const allSortedCols = this.getColumnsWithSortingOrdered();
        // reset sort index on everything
        colModel.forAllCols((col) => this.setColSortIndex(col, null));
        const allSortedColsWithoutChangesOrGroups = allSortedCols.filter((col) => {
            if (isCoupled && col.getColDef().showRowGroup) {
                return false;
            }
            return col !== lastSortIndexCol;
        });
        const sortedColsWithIndices = lastSortIndexCol.getSort()
            ? [...allSortedColsWithoutChangesOrGroups, lastSortIndexCol]
            : allSortedColsWithoutChangesOrGroups;
        sortedColsWithIndices.forEach((col, idx) => this.setColSortIndex(col, idx));
    }
    // gets called by API, so if data changes, use can call this, which will end up
    // working out the sort order again of the rows.
    onSortChanged(source, columns) {
        this.dispatchSortChangedEvents(source, columns);
    }
    isSortActive() {
        // pull out all the columns that have sorting set
        let isSorting = false;
        this.beans.colModel.forAllCols((col) => {
            if (col.getSort()) {
                isSorting = true;
            }
        });
        return isSorting;
    }
    dispatchSortChangedEvents(source, columns) {
        const event = {
            type: 'sortChanged',
            source,
        };
        if (columns) {
            event.columns = columns;
        }
        this.eventSvc.dispatchEvent(event);
    }
    clearSortBarTheseColumns(columnsToSkip, source) {
        const clearedColumns = [];
        this.beans.colModel.forAllCols((columnToClear) => {
            // Do not clear if either holding shift, or if column in question was clicked
            if (!columnsToSkip.includes(columnToClear)) {
                // add to list of cleared cols when sort direction is set
                if (columnToClear.getSort()) {
                    clearedColumns.push(columnToClear);
                }
                // setting to 'undefined' as null means 'none' rather than cleared, otherwise issue will arise
                // if sort order is: ['desc', null , 'asc'], as it will start at null rather than 'desc'.
                this.setColSort(columnToClear, undefined, source);
            }
        });
        return clearedColumns;
    }
    getNextSortDirection(column) {
        const sortingOrder = column.getColDef().sortingOrder ?? this.gos.get('sortingOrder') ?? exports.DEFAULT_SORTING_ORDER;
        const currentIndex = sortingOrder.indexOf(column.getSort());
        const notInArray = currentIndex < 0;
        const lastItemInArray = currentIndex == sortingOrder.length - 1;
        return notInArray || lastItemInArray ? sortingOrder[0] : sortingOrder[currentIndex + 1];
    }
    /**
     * @returns a map of sort indexes for every sorted column, if groups sort primaries then they will have equivalent indices
     */
    getIndexedSortMap() {
        const { gos, colModel, showRowGroupCols, rowGroupColsSvc } = this.beans;
        // pull out all the columns that have sorting set
        let allSortedCols = [];
        colModel.forAllCols((col) => {
            if (col.getSort()) {
                allSortedCols.push(col);
            }
        });
        if (colModel.isPivotMode()) {
            const isSortingLinked = (0, gridOptionsUtils_1._isColumnsSortingCoupledToGroup)(gos);
            allSortedCols = allSortedCols.filter((col) => {
                const isAggregated = !!col.getAggFunc();
                const isSecondary = !col.isPrimary();
                const isGroup = isSortingLinked
                    ? showRowGroupCols?.getShowRowGroupCol(col.getId())
                    : col.getColDef().showRowGroup;
                return isAggregated || isSecondary || isGroup;
            });
        }
        const sortedRowGroupCols = rowGroupColsSvc?.columns.filter((col) => !!col.getSort()) ?? [];
        // when both cols are missing sortIndex, we use the position of the col in all cols list.
        // this means if colDefs only have sort, but no sortIndex, we deterministically pick which
        // cols is sorted by first.
        const allColsIndexes = {};
        allSortedCols.forEach((col, index) => (allColsIndexes[col.getId()] = index));
        // put the columns in order of which one got sorted first
        allSortedCols.sort((a, b) => {
            const iA = a.getSortIndex();
            const iB = b.getSortIndex();
            if (iA != null && iB != null) {
                return iA - iB; // both present, normal comparison
            }
            else if (iA == null && iB == null) {
                // both missing, compare using column positions
                const posA = allColsIndexes[a.getId()];
                const posB = allColsIndexes[b.getId()];
                return posA > posB ? 1 : -1;
            }
            else if (iB == null) {
                return -1; // iB missing
            }
            else {
                return 1; // iA missing
            }
        });
        const isSortLinked = (0, gridOptionsUtils_1._isColumnsSortingCoupledToGroup)(gos) && !!sortedRowGroupCols.length;
        if (isSortLinked) {
            allSortedCols = [
                ...new Set(
                // if linked sorting, replace all columns with the display group column for index purposes, and ensure uniqueness
                allSortedCols.map((col) => showRowGroupCols?.getShowRowGroupCol(col.getId()) ?? col)),
            ];
        }
        const indexMap = new Map();
        allSortedCols.forEach((col, idx) => indexMap.set(col, idx));
        // add the row group cols back
        if (isSortLinked) {
            sortedRowGroupCols.forEach((col) => {
                const groupDisplayCol = showRowGroupCols.getShowRowGroupCol(col.getId());
                indexMap.set(col, indexMap.get(groupDisplayCol));
            });
        }
        return indexMap;
    }
    getColumnsWithSortingOrdered() {
        // pull out all the columns that have sorting set
        return [...this.getIndexedSortMap().entries()].sort(([, idx1], [, idx2]) => idx1 - idx2).map(([col]) => col);
    }
    // used by server side row models, to sent sort to server
    getSortModel() {
        return this.getColumnsWithSortingOrdered()
            .filter((column) => column.getSort())
            .map((column) => ({
            sort: column.getSort(),
            colId: column.getId(),
        }));
    }
    getSortOptions() {
        return this.getColumnsWithSortingOrdered()
            .filter((column) => column.getSort())
            .map((column) => ({
            sort: column.getSort(),
            column,
        }));
    }
    canColumnDisplayMixedSort(column) {
        const isColumnSortCouplingActive = (0, gridOptionsUtils_1._isColumnsSortingCoupledToGroup)(this.gos);
        const isGroupDisplayColumn = !!column.getColDef().showRowGroup;
        return isColumnSortCouplingActive && isGroupDisplayColumn;
    }
    getDisplaySortForColumn(column) {
        const linkedColumns = this.beans.showRowGroupCols?.getSourceColumnsForGroupColumn(column);
        if (!this.canColumnDisplayMixedSort(column) || !linkedColumns?.length) {
            return column.getSort();
        }
        // if column has unique data, its sorting is independent - but can still be mixed
        const columnHasUniqueData = column.getColDef().field != null || !!column.getColDef().valueGetter;
        const sortableColumns = columnHasUniqueData ? [column, ...linkedColumns] : linkedColumns;
        const firstSort = sortableColumns[0].getSort();
        // the == is intentional, as null and undefined both represent no sort, which means they are equivalent
        const allMatch = sortableColumns.every((col) => col.getSort() == firstSort);
        if (!allMatch) {
            return 'mixed';
        }
        return firstSort;
    }
    getDisplaySortIndexForColumn(column) {
        return this.getIndexedSortMap().get(column);
    }
    setupHeader(comp, column, clickElement) {
        let lastMovingChanged = 0;
        // keep track of last time the moving changed flag was set
        comp.addManagedListeners(column, {
            movingChanged: () => {
                lastMovingChanged = Date.now();
            },
        });
        // add the event on the header, so when clicked, we do sorting
        if (clickElement) {
            comp.addManagedElementListeners(clickElement, {
                click: (event) => {
                    // sometimes when moving a column via dragging, this was also firing a clicked event.
                    // here is issue raised by user: https://ag-grid.zendesk.com/agent/tickets/1076
                    // this check stops sort if a) column is moving or b) column moved less than 200ms ago (so caters for race condition)
                    const moving = column.isMoving();
                    const nowTime = Date.now();
                    // typically there is <2ms if moving flag was set recently, as it would be done in same VM turn
                    const movedRecently = nowTime - lastMovingChanged < 50;
                    const columnMoving = moving || movedRecently;
                    if (!columnMoving) {
                        this.progressSortFromEvent(column, event);
                    }
                },
            });
        }
        const onSortingChanged = () => {
            const sort = column.getSort();
            comp.toggleCss('ag-header-cell-sorted-asc', sort === 'asc');
            comp.toggleCss('ag-header-cell-sorted-desc', sort === 'desc');
            comp.toggleCss('ag-header-cell-sorted-none', !sort);
            if (column.getColDef().showRowGroup) {
                const sourceColumns = this.beans.showRowGroupCols?.getSourceColumnsForGroupColumn(column);
                // this == is intentional, as it allows null and undefined to match, which are both unsorted states
                const sortDirectionsMatch = sourceColumns?.every((sourceCol) => column.getSort() == sourceCol.getSort());
                const isMultiSorting = !sortDirectionsMatch;
                comp.toggleCss('ag-header-cell-sorted-mixed', isMultiSorting);
            }
        };
        comp.addManagedEventListeners({
            sortChanged: onSortingChanged,
            columnRowGroupChanged: onSortingChanged,
        });
    }
    initCol(column) {
        const { sort, initialSort, sortIndex, initialSortIndex } = column.colDef;
        if (sort !== undefined) {
            if (sort === 'asc' || sort === 'desc') {
                column.sort = sort;
            }
        }
        else {
            if (initialSort === 'asc' || initialSort === 'desc') {
                column.sort = initialSort;
            }
        }
        if (sortIndex !== undefined) {
            if (sortIndex !== null) {
                column.sortIndex = sortIndex;
            }
        }
        else {
            if (initialSortIndex !== null) {
                column.sortIndex = initialSortIndex;
            }
        }
    }
    updateColSort(column, sort, source) {
        if (sort !== undefined) {
            if (sort === 'desc' || sort === 'asc') {
                this.setColSort(column, sort, source);
            }
            else {
                this.setColSort(column, undefined, source);
            }
        }
    }
    setColSort(column, sort, source) {
        if (column.sort !== sort) {
            column.sort = sort;
            column.dispatchColEvent('sortChanged', source);
        }
        column.dispatchStateUpdatedEvent('sort');
    }
    setColSortIndex(column, sortOrder) {
        column.sortIndex = sortOrder;
        column.dispatchStateUpdatedEvent('sortIndex');
    }
    createSortIndicator(skipTemplate) {
        return new sortIndicatorComp_1.SortIndicatorComp(skipTemplate);
    }
    getSortIndicatorSelector() {
        return sortIndicatorComp_1.SortIndicatorSelector;
    }
}
exports.SortService = SortService;


/***/ }),

/***/ 52760:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CellCustomStyleFeature = void 0;
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const stylingUtils_1 = __webpack_require__(88729);
class CellCustomStyleFeature extends beanStub_1.BeanStub {
    constructor(cellCtrl, beans) {
        super();
        this.cellCtrl = cellCtrl;
        this.staticClasses = [];
        this.beans = beans;
        this.column = cellCtrl.column;
    }
    setComp(comp) {
        this.cellComp = comp;
        this.applyUserStyles();
        this.applyCellClassRules();
        this.applyClassesFromColDef();
    }
    applyCellClassRules() {
        const { column, cellComp } = this;
        const colDef = column.colDef;
        const cellClassRules = colDef.cellClassRules;
        const cellClassParams = this.getCellClassParams(column, colDef);
        (0, stylingUtils_1.processClassRules)(this.beans.expressionSvc, 
        // if current was previous, skip
        cellClassRules === this.cellClassRules ? undefined : this.cellClassRules, cellClassRules, cellClassParams, (className) => cellComp.toggleCss(className, true), (className) => cellComp.toggleCss(className, false));
        this.cellClassRules = cellClassRules;
    }
    applyUserStyles() {
        const column = this.column;
        const colDef = column.colDef;
        const cellStyle = colDef.cellStyle;
        if (!cellStyle) {
            return;
        }
        let styles;
        if (typeof cellStyle === 'function') {
            const cellStyleParams = this.getCellClassParams(column, colDef);
            styles = cellStyle(cellStyleParams);
        }
        else {
            styles = cellStyle;
        }
        if (styles) {
            this.cellComp.setUserStyles(styles);
        }
    }
    applyClassesFromColDef() {
        const { column, cellComp } = this;
        const colDef = column.colDef;
        const cellClassParams = this.getCellClassParams(column, colDef);
        this.staticClasses.forEach((className) => cellComp.toggleCss(className, false));
        const newStaticClasses = this.beans.cellStyles.getStaticCellClasses(colDef, cellClassParams);
        this.staticClasses = newStaticClasses;
        newStaticClasses.forEach((className) => cellComp.toggleCss(className, true));
    }
    getCellClassParams(column, colDef) {
        const { value, rowNode } = this.cellCtrl;
        return (0, gridOptionsUtils_1._addGridCommonParams)(this.beans.gos, {
            value,
            data: rowNode.data,
            node: rowNode,
            colDef,
            column,
            rowIndex: rowNode.rowIndex,
        });
    }
}
exports.CellCustomStyleFeature = CellCustomStyleFeature;


/***/ }),

/***/ 89330:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CellStyleService = void 0;
const beanStub_1 = __webpack_require__(68731);
const cellCustomStyleFeature_1 = __webpack_require__(52760);
const stylingUtils_1 = __webpack_require__(88729);
class CellStyleService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'cellStyles';
    }
    processAllCellClasses(colDef, params, onApplicableClass, onNotApplicableClass) {
        (0, stylingUtils_1.processClassRules)(this.beans.expressionSvc, undefined, colDef.cellClassRules, params, onApplicableClass, onNotApplicableClass);
        this.processStaticCellClasses(colDef, params, onApplicableClass);
    }
    getStaticCellClasses(colDef, params) {
        const { cellClass } = colDef;
        if (!cellClass) {
            return [];
        }
        let classOrClasses;
        if (typeof cellClass === 'function') {
            const cellClassFunc = cellClass;
            classOrClasses = cellClassFunc(params);
        }
        else {
            classOrClasses = cellClass;
        }
        if (typeof classOrClasses === 'string') {
            classOrClasses = [classOrClasses];
        }
        return classOrClasses || [];
    }
    createCellCustomStyleFeature(ctrl, beans) {
        return new cellCustomStyleFeature_1.CellCustomStyleFeature(ctrl, beans);
    }
    processStaticCellClasses(colDef, params, onApplicableClass) {
        const classOrClasses = this.getStaticCellClasses(colDef, params);
        classOrClasses.forEach((cssClassItem) => {
            onApplicableClass(cssClassItem);
        });
    }
}
exports.CellStyleService = CellStyleService;


/***/ }),

/***/ 59360:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LayoutFeature = exports.LayoutCssClasses = void 0;
const beanStub_1 = __webpack_require__(68731);
exports.LayoutCssClasses = {
    AUTO_HEIGHT: 'ag-layout-auto-height',
    NORMAL: 'ag-layout-normal',
    PRINT: 'ag-layout-print',
};
class LayoutFeature extends beanStub_1.BeanStub {
    constructor(view) {
        super();
        this.view = view;
    }
    postConstruct() {
        this.addManagedPropertyListener('domLayout', this.updateLayoutClasses.bind(this));
        this.updateLayoutClasses();
    }
    updateLayoutClasses() {
        const domLayout = this.gos.get('domLayout');
        const params = {
            autoHeight: domLayout === 'autoHeight',
            normal: domLayout === 'normal',
            print: domLayout === 'print',
        };
        const cssClass = params.autoHeight
            ? exports.LayoutCssClasses.AUTO_HEIGHT
            : params.print
                ? exports.LayoutCssClasses.PRINT
                : exports.LayoutCssClasses.NORMAL;
        this.view.updateLayoutClasses(cssClass, params);
    }
}
exports.LayoutFeature = LayoutFeature;


/***/ }),

/***/ 27648:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RowStyleService = exports.calculateRowLevel = void 0;
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const stylingUtils_1 = __webpack_require__(88729);
function calculateRowLevel(rowNode) {
    if (rowNode.group) {
        return rowNode.level;
    }
    const parent = rowNode.parent;
    // if a leaf, and a parent exists, put a level of the parent, else put level of 0 for top level item
    return parent ? parent.level + 1 : 0;
}
exports.calculateRowLevel = calculateRowLevel;
class RowStyleService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'rowStyleSvc';
    }
    processClassesFromGridOptions(classes, rowNode) {
        const gos = this.gos;
        const process = (rowCls) => {
            if (typeof rowCls === 'string') {
                classes.push(rowCls);
            }
            else if (Array.isArray(rowCls)) {
                rowCls.forEach((e) => classes.push(e));
            }
        };
        // part 1 - rowClass
        const rowClass = gos.get('rowClass');
        if (rowClass) {
            process(rowClass);
        }
        // part 2 - rowClassFunc
        const rowClassFunc = gos.getCallback('getRowClass');
        if (rowClassFunc) {
            const params = {
                data: rowNode.data,
                node: rowNode,
                rowIndex: rowNode.rowIndex,
            };
            const rowClassFuncResult = rowClassFunc(params);
            process(rowClassFuncResult);
        }
    }
    preProcessRowClassRules(classes, rowNode) {
        this.processRowClassRules(rowNode, (className) => {
            classes.push(className);
        }, () => {
            // not catered for, if creating, no need
            // to remove class as it was never there
        });
    }
    processRowClassRules(rowNode, onApplicableClass, onNotApplicableClass) {
        const { gos, expressionSvc } = this.beans;
        const rowClassParams = (0, gridOptionsUtils_1._addGridCommonParams)(gos, {
            data: rowNode.data,
            node: rowNode,
            rowIndex: rowNode.rowIndex,
        });
        (0, stylingUtils_1.processClassRules)(expressionSvc, undefined, gos.get('rowClassRules'), rowClassParams, onApplicableClass, onNotApplicableClass);
    }
    processStylesFromGridOptions(rowNode) {
        const gos = this.gos;
        // part 1 - rowStyle
        const rowStyle = gos.get('rowStyle');
        // part 1 - rowStyleFunc
        const rowStyleFunc = gos.getCallback('getRowStyle');
        let rowStyleFuncResult;
        if (rowStyleFunc) {
            const params = {
                data: rowNode.data,
                node: rowNode,
                rowIndex: rowNode.rowIndex,
            };
            rowStyleFuncResult = rowStyleFunc(params);
        }
        if (rowStyleFuncResult || rowStyle) {
            return Object.assign({}, rowStyle, rowStyleFuncResult);
        }
        return undefined;
    }
}
exports.RowStyleService = RowStyleService;


/***/ }),

/***/ 68594:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RowStyleModule = exports.CellStyleModule = void 0;
const version_1 = __webpack_require__(97205);
const cellStyleService_1 = __webpack_require__(89330);
const rowStyleService_1 = __webpack_require__(27648);
/**
 * @feature Cells -> Styling Cells
 * @colDef cellStyle, cellClass, cellClassRules
 */
exports.CellStyleModule = {
    moduleName: 'CellStyle',
    version: version_1.VERSION,
    beans: [cellStyleService_1.CellStyleService],
};
/**
 * @feature Rows -> Styling Rows
 * @gridOption rowStyle, getRowStyle, rowClass, getRowClass, rowClassRules
 */
exports.RowStyleModule = {
    moduleName: 'RowStyle',
    version: version_1.VERSION,
    beans: [rowStyleService_1.RowStyleService],
};


/***/ }),

/***/ 88729:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.processClassRules = void 0;
function processClassRules(expressionSvc, previousClassRules, classRules, params, onApplicableClass, onNotApplicableClass) {
    if (classRules == null && previousClassRules == null) {
        return;
    }
    const classesToApply = {};
    const classesToRemove = {};
    const forEachSingleClass = (className, callback) => {
        // in case className = 'my-class1 my-class2', we need to split into individual class names
        className.split(' ').forEach((singleClass) => {
            if (singleClass.trim() == '')
                return;
            callback(singleClass);
        });
    };
    if (classRules) {
        const classNames = Object.keys(classRules);
        for (let i = 0; i < classNames.length; i++) {
            const className = classNames[i];
            const rule = classRules[className];
            let resultOfRule;
            if (typeof rule === 'string') {
                resultOfRule = expressionSvc ? expressionSvc.evaluate(rule, params) : true;
            }
            else if (typeof rule === 'function') {
                resultOfRule = rule(params);
            }
            forEachSingleClass(className, (singleClass) => {
                resultOfRule ? (classesToApply[singleClass] = true) : (classesToRemove[singleClass] = true);
            });
        }
    }
    if (previousClassRules && onNotApplicableClass) {
        Object.keys(previousClassRules).forEach((className) => forEachSingleClass(className, (singleClass) => {
            if (!classesToApply[singleClass]) {
                // if we're not applying a previous class now, make sure we remove it
                classesToRemove[singleClass] = true;
            }
        }));
    }
    // we remove all classes first, then add all classes second,
    // in case a class appears in more than one rule, this means it will be added
    // if appears in at least one truthy rule
    if (onNotApplicableClass) {
        Object.keys(classesToRemove).forEach(onNotApplicableClass);
    }
    Object.keys(classesToApply).forEach(onApplicableClass);
}
exports.processClassRules = processClassRules;


/***/ }),

/***/ 7711:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyncService = void 0;
const columnUtils_1 = __webpack_require__(73146);
const beanStub_1 = __webpack_require__(68731);
const function_1 = __webpack_require__(92043);
class SyncService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'syncSvc';
        this.waitingForColumns = false;
    }
    postConstruct() {
        this.addManagedPropertyListener('columnDefs', (event) => this.setColumnDefs(event));
    }
    start() {
        // we wait until the UI has finished initialising before setting in columns and rows
        this.beans.ctrlsSvc.whenReady(this, () => {
            const columnDefs = this.gos.get('columnDefs');
            if (columnDefs) {
                this.setColumnsAndData(columnDefs);
            }
            else {
                this.waitingForColumns = true;
            }
            this.gridReady();
        });
    }
    setColumnsAndData(columnDefs) {
        const { colModel, rowModel } = this.beans;
        colModel.setColumnDefs(columnDefs ?? [], 'gridInitializing');
        rowModel.start();
    }
    gridReady() {
        const { eventSvc, gos } = this;
        eventSvc.dispatchEvent({
            type: 'gridReady',
        });
        (0, function_1._logIfDebug)(gos, `initialised successfully, enterprise = ${gos.isModuleRegistered('EnterpriseCore')}`);
    }
    setColumnDefs(event) {
        const columnDefs = this.gos.get('columnDefs');
        if (!columnDefs) {
            return;
        }
        if (this.waitingForColumns) {
            this.waitingForColumns = false;
            this.setColumnsAndData(columnDefs);
            return;
        }
        this.beans.colModel.setColumnDefs(columnDefs, (0, columnUtils_1._convertColumnEventSourceType)(event.source));
    }
}
exports.SyncService = SyncService;


/***/ }),

/***/ 86607:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PartImpl = exports.defaultModeName = exports.createPart = void 0;
const inject_1 = __webpack_require__(68951);
/**
 * Create a new empty part.
 *
 * @param feature an The part feature, e.g. 'iconSet'. Adding a part to a theme will remove any existing part with the same feature.
 * @param variant an optional identifier for debugging, if omitted one will be generated
 */
const createPart = (args) => {
    /*#__PURE__*/
    return new PartImpl(args);
};
exports.createPart = createPart;
exports.defaultModeName = '$default';
let partCounter = 0;
class PartImpl {
    constructor({ feature, params, modeParams = {}, css, cssImports }) {
        this.feature = feature;
        this.css = css;
        this.cssImports = cssImports;
        this.modeParams = {
            // NOTE: it's important that default is defined first, putting it
            // first in iteration order, because when merging params the default
            // params override any prior modal params, so modal params in this
            // part need to come after default params to prevent them from being
            // immediately overridden.
            [exports.defaultModeName]: {
                ...(modeParams[exports.defaultModeName] ?? {}),
                ...(params ?? {}),
            },
            ...modeParams,
        };
    }
    use(styleContainer, layer, nonce) {
        let inject = this._inject;
        if (inject == null) {
            let { css } = this;
            if (css) {
                const className = `ag-theme-${this.feature ?? 'part'}-${++partCounter}`;
                if (typeof css === 'function')
                    css = css();
                css = `:where(.${className}) {\n${css}\n}\n`;
                for (const cssImport of this.cssImports ?? []) {
                    css = `@import url(${JSON.stringify(cssImport)});\n${css}`;
                }
                inject = { css, class: className };
            }
            else {
                inject = false;
            }
            this._inject = inject;
        }
        if (inject && styleContainer) {
            (0, inject_1._injectGlobalCSS)(inject.css, styleContainer, inject.class, layer, 1, nonce);
        }
        return inject ? inject.class : false;
    }
}
exports.PartImpl = PartImpl;


/***/ }),

/***/ 39621:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ThemeImpl = exports.createTheme = exports._asThemeImpl = exports.FORCE_LEGACY_THEMES = void 0;
const logging_1 = __webpack_require__(47764);
const Part_1 = __webpack_require__(86607);
const core_css_1 = __webpack_require__(405);
const inject_1 = __webpack_require__(68951);
const batch_edit_styles_1 = __webpack_require__(51017);
const button_styles_1 = __webpack_require__(82475);
const column_drop_styles_1 = __webpack_require__(21697);
const theme_types_1 = __webpack_require__(50113);
const theme_utils_1 = __webpack_require__(77845);
// For testing, if true, only Vanilla examples will work and they will use legacy themes.
exports.FORCE_LEGACY_THEMES = false;
const _asThemeImpl = (theme) => {
    if (!(theme instanceof ThemeImpl)) {
        throw new Error('theme is not an object created by createTheme');
    }
    return theme;
};
exports._asThemeImpl = _asThemeImpl;
/**
 * Create a custom theme containing core grid styles but no parts.
 */
// TODO button and column drop styles were split out into a part in 33.1 and
// must be bundled by default to avoid a breaking change for people using
// createTheme(). In v34 the withPart calls can be removed.
const createTheme = () => new ThemeImpl().withPart(button_styles_1.buttonStyleQuartz).withPart(column_drop_styles_1.columnDropStyleBordered).withPart(batch_edit_styles_1.batchEditStyleBase);
exports.createTheme = createTheme;
class ThemeImpl {
    constructor(parts = []) {
        this.parts = parts;
    }
    withPart(part) {
        if (typeof part === 'function')
            part = part();
        if (!(part instanceof Part_1.PartImpl)) {
            // Can't use validation service as this is API is designed to be used before modules are registered
            (0, logging_1._logPreInitErr)(259, { part }, 'Invalid part');
            return this;
        }
        return new ThemeImpl([...this.parts, part]);
    }
    withoutPart(feature) {
        return this.withPart((0, Part_1.createPart)({ feature }));
    }
    withParams(params, mode = Part_1.defaultModeName) {
        return this.withPart((0, Part_1.createPart)({
            modeParams: { [mode]: params },
        }));
    }
    /**
     * Called by a grid instance when it starts using the theme. This installs
     * the theme's parts into document head, or the shadow DOM if the provided
     * container is within a shadow root.
     */
    _startUse({ styleContainer, cssLayer, nonce, loadThemeGoogleFonts }) {
        if (inject_1.IS_SSR)
            return;
        if (exports.FORCE_LEGACY_THEMES)
            return;
        uninstallLegacyCSS();
        (0, inject_1._injectCoreAndModuleCSS)(styleContainer, cssLayer, nonce);
        const googleFontsUsed = getGoogleFontsUsed(this);
        if (googleFontsUsed.length > 0) {
            for (const googleFont of googleFontsUsed) {
                if (loadThemeGoogleFonts) {
                    loadGoogleFont(googleFont, nonce);
                }
            }
        }
        for (const part of this.parts) {
            part.use(styleContainer, cssLayer, nonce);
        }
    }
    /**
     * Return CSS that that applies the params of this theme to elements with
     * the provided class name
     */
    _getCssClass() {
        if (exports.FORCE_LEGACY_THEMES)
            return 'ag-theme-quartz';
        return (this._cssClassCache ?? (this._cssClassCache = deduplicatePartsByFeature(this.parts)
            .map((part) => part.use(undefined, undefined, undefined))
            .filter(Boolean)
            .join(' ')));
    }
    _getModeParams() {
        let paramsCache = this._paramsCache;
        if (!paramsCache) {
            const mergedModeParams = {
                // NOTE: defining the default mode here is important, it ensures
                // that the default mode is first in iteration order, which puts
                // it first in outputted CSS, allowing other modes to override it
                [Part_1.defaultModeName]: { ...core_css_1.coreDefaults },
            };
            for (const part of deduplicatePartsByFeature(this.parts)) {
                for (const partMode of Object.keys(part.modeParams)) {
                    const partParams = part.modeParams[partMode];
                    if (partParams) {
                        const mergedParams = (mergedModeParams[partMode] ?? (mergedModeParams[partMode] = {}));
                        const partParamNames = new Set();
                        for (const partParamName of Object.keys(partParams)) {
                            const partParamValue = partParams[partParamName];
                            if (partParamValue !== undefined) {
                                mergedParams[partParamName] = partParamValue;
                                partParamNames.add(partParamName);
                            }
                        }
                        // If a later part has added default mode params, remove any non-default mode
                        // values for the same param. We need to do this because the last value set
                        // for a param should always take precedence. Consider this:
                        // const redInDarkMode = themeQuartz.withParams({accentColor: 'red'}, 'dark');
                        // const alwaysBlue = redInDarkMode.withParams({accentColor: 'blue'});
                        // Setting theme.withParams({accentColor: 'blue'}) is expected to produce a theme
                        // whose accent color is always blue, end of story. So we remove the accentColor
                        // value from the `dark` mode params otherwise it would override the default
                        // accent color.
                        if (partMode === Part_1.defaultModeName) {
                            for (const mergedMode of Object.keys(mergedModeParams)) {
                                const mergedParams = mergedModeParams[mergedMode];
                                if (mergedMode !== Part_1.defaultModeName) {
                                    for (const partParamName of partParamNames) {
                                        delete mergedParams[partParamName];
                                    }
                                }
                            }
                        }
                    }
                }
            }
            this._paramsCache = paramsCache = mergedModeParams;
        }
        return paramsCache;
    }
    /**
     * Return the CSS chunk that is inserted into the grid DOM, and will
     * therefore be removed automatically when the grid is destroyed or it
     * starts to use a new theme.
     *
     * @param className a unique class name on the grid wrapper used to scope the returned CSS to the grid instance
     */
    _getPerGridCss(className) {
        const selectorPlaceholder = '##SELECTOR##';
        let innerParamsCss = this._paramsCssCache;
        if (!innerParamsCss) {
            // Ensure that every variable has a value set on root elements ("root"
            // elements are those containing grid UI, e.g. ag-root-wrapper and
            // ag-popup)
            //
            // Simply setting .ag-root-wrapper { --ag-foo: default-value } is not
            // appropriate because it will override any values set on parent
            // elements. An application should be able to set `--ag-spacing: 4px`
            // on the document body and have it picked up by all grids on the page.
            //
            // To allow this we capture the application-provided value of --ag-foo
            // into --ag-inherited-foo on the *parent* element of the root, and then
            // use --ag-inherited-foo as the value for --ag-foo on the root element,
            // applying our own default if it is unset.
            let variablesCss = '';
            let inheritanceCss = '';
            const modeParams = this._getModeParams();
            for (const mode of Object.keys(modeParams)) {
                const params = modeParams[mode];
                if (mode !== Part_1.defaultModeName) {
                    const escapedMode = typeof CSS === 'object' ? CSS.escape(mode) : mode; // check for CSS global in case we're running in tests
                    const wrapPrefix = `:where([data-ag-theme-mode="${escapedMode}"]) & {\n`;
                    variablesCss += wrapPrefix;
                    inheritanceCss += wrapPrefix;
                }
                for (const key of Object.keys(params).sort()) {
                    const value = params[key];
                    const cssValue = (0, theme_types_1.paramValueToCss)(key, value);
                    if (cssValue === false) {
                        (0, logging_1._error)(107, { key, value });
                    }
                    else {
                        const cssName = (0, theme_utils_1.paramToVariableName)(key);
                        const inheritedName = cssName.replace('--ag-', '--ag-inherited-');
                        variablesCss += `\t${cssName}: var(${inheritedName}, ${cssValue});\n`;
                        inheritanceCss += `\t${inheritedName}: var(${cssName});\n`;
                    }
                }
                if (mode !== Part_1.defaultModeName) {
                    variablesCss += '}\n';
                    inheritanceCss += '}\n';
                }
            }
            let css = `${selectorPlaceholder} {\n${variablesCss}}\n`;
            // Create --ag-inherited-foo variable values on the parent element, unless
            // the parent is itself a root (which can happen if popupParent is
            // ag-root-wrapper)
            css += `:has(> ${selectorPlaceholder}):not(${selectorPlaceholder}) {\n${inheritanceCss}}\n`;
            this._paramsCssCache = innerParamsCss = css;
        }
        return innerParamsCss.replaceAll(selectorPlaceholder, `:where(.${className})`);
    }
}
exports.ThemeImpl = ThemeImpl;
// Remove parts with the same feature, keeping only the last one
const deduplicatePartsByFeature = (parts) => {
    const lastPartByFeature = new Map();
    for (const part of parts) {
        lastPartByFeature.set(part.feature, part);
    }
    const result = [];
    for (const part of parts) {
        if (!part.feature || lastPartByFeature.get(part.feature) === part) {
            result.push(part);
        }
    }
    return result;
};
const getGoogleFontsUsed = (theme) => {
    const googleFontsUsed = new Set();
    const visitParamValue = (paramValue) => {
        // font value can be a font object or array of font objects
        if (Array.isArray(paramValue)) {
            paramValue.forEach(visitParamValue);
        }
        else {
            const googleFont = paramValue?.googleFont;
            if (typeof googleFont === 'string') {
                googleFontsUsed.add(googleFont);
            }
        }
    };
    const allModeValues = Object.values(theme._getModeParams());
    const allValues = allModeValues.flatMap((mv) => Object.values(mv));
    allValues.forEach(visitParamValue);
    return Array.from(googleFontsUsed).sort();
};
let uninstalledLegacyCSS = false;
// Remove the CSS from @ag-grid-community/styles that is automatically injected
// by the UMD bundle
const uninstallLegacyCSS = () => {
    if (uninstalledLegacyCSS)
        return;
    uninstalledLegacyCSS = true;
    for (const style of Array.from(document.head.querySelectorAll('style[data-ag-scope="legacy"]'))) {
        style.remove();
    }
};
const googleFontsLoaded = new Set();
const loadGoogleFont = async (font, nonce) => {
    googleFontsLoaded.add(font);
    const css = `@import url('https://${googleFontsDomain}/css2?family=${encodeURIComponent(font)}:wght@100;200;300;400;500;600;700;800;900&display=swap');\n`;
    // fonts are always installed in the document head, they are inherited in
    // shadow DOM without the need for separate installation
    (0, inject_1._injectGlobalCSS)(css, document.head, `googleFont:${font}`, undefined, 0, nonce);
};
const googleFontsDomain = 'fonts.googleapis.com';


/***/ }),

/***/ 405:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.coreDefaults = exports.defaultLightColorSchemeParams = exports.coreCSS = void 0;
const theme_utils_1 = __webpack_require__(77845);
var core_css_GENERATED_1 = __webpack_require__(99550);
Object.defineProperty(exports, "coreCSS", ({ enumerable: true, get: function () { return core_css_GENERATED_1.coreCSS; } }));
exports.defaultLightColorSchemeParams = {
    backgroundColor: '#fff',
    foregroundColor: '#181d1f',
    borderColor: (0, theme_utils_1.foregroundMix)(0.15),
    chromeBackgroundColor: (0, theme_utils_1.foregroundBackgroundMix)(0.02),
    browserColorScheme: 'light',
};
exports.coreDefaults = {
    ...exports.defaultLightColorSchemeParams,
    textColor: theme_utils_1.foregroundColor,
    accentColor: '#2196f3',
    invalidColor: '#e02525',
    wrapperBorder: true,
    rowBorder: true,
    headerRowBorder: true,
    footerRowBorder: {
        ref: 'rowBorder',
    },
    columnBorder: {
        style: 'solid',
        width: 1,
        color: 'transparent',
    },
    headerColumnBorder: false,
    headerColumnBorderHeight: '100%',
    pinnedColumnBorder: true,
    pinnedRowBorder: true,
    sidePanelBorder: true,
    sideBarPanelWidth: 250,
    sideBarBackgroundColor: {
        ref: 'chromeBackgroundColor',
    },
    sideButtonBarBackgroundColor: {
        ref: 'sideBarBackgroundColor',
    },
    sideButtonBarTopPadding: 0,
    sideButtonSelectedUnderlineWidth: 2,
    sideButtonSelectedUnderlineColor: 'transparent',
    sideButtonSelectedUnderlineTransitionDuration: 0,
    sideButtonBackgroundColor: 'transparent',
    sideButtonTextColor: { ref: 'textColor' },
    sideButtonHoverBackgroundColor: { ref: 'sideButtonBackgroundColor' },
    sideButtonHoverTextColor: { ref: 'sideButtonTextColor' },
    sideButtonSelectedBackgroundColor: theme_utils_1.backgroundColor,
    sideButtonSelectedTextColor: { ref: 'sideButtonTextColor' },
    sideButtonBorder: 'solid 1px transparent',
    sideButtonSelectedBorder: true,
    sideButtonLeftPadding: { ref: 'spacing' },
    sideButtonRightPadding: { ref: 'spacing' },
    sideButtonVerticalPadding: { calc: 'spacing * 3' },
    fontFamily: [
        '-apple-system',
        'BlinkMacSystemFont',
        'Segoe UI',
        'Roboto',
        'Oxygen-Sans',
        'Ubuntu',
        'Cantarell',
        'Helvetica Neue',
        'sans-serif',
    ],
    headerBackgroundColor: {
        ref: 'chromeBackgroundColor',
    },
    headerFontFamily: {
        ref: 'fontFamily',
    },
    cellFontFamily: {
        ref: 'fontFamily',
    },
    headerFontWeight: 500,
    headerFontSize: {
        ref: 'fontSize',
    },
    dataFontSize: {
        ref: 'fontSize',
    },
    headerTextColor: {
        ref: 'textColor',
    },
    headerCellHoverBackgroundColor: 'transparent',
    headerCellMovingBackgroundColor: { ref: 'headerCellHoverBackgroundColor' },
    headerCellBackgroundTransitionDuration: '0.2s',
    cellTextColor: {
        ref: 'textColor',
    },
    subtleTextColor: {
        ref: 'textColor',
        mix: 0.5,
    },
    rangeSelectionBorderStyle: 'solid',
    rangeSelectionBorderColor: theme_utils_1.accentColor,
    rangeSelectionBackgroundColor: (0, theme_utils_1.accentMix)(0.2),
    rangeSelectionChartBackgroundColor: '#0058FF1A',
    rangeSelectionChartCategoryBackgroundColor: '#00FF841A',
    rangeSelectionHighlightColor: (0, theme_utils_1.accentMix)(0.5),
    rangeHeaderHighlightColor: (0, theme_utils_1.foregroundHeaderBackgroundMix)(0.08),
    rowNumbersSelectedColor: (0, theme_utils_1.accentMix)(0.5),
    rowHoverColor: (0, theme_utils_1.accentMix)(0.08),
    columnHoverColor: (0, theme_utils_1.accentMix)(0.05),
    selectedRowBackgroundColor: (0, theme_utils_1.accentMix)(0.12),
    modalOverlayBackgroundColor: {
        ref: 'backgroundColor',
        mix: 0.66,
    },
    oddRowBackgroundColor: theme_utils_1.backgroundColor,
    borderWidth: 1,
    borderRadius: 4,
    wrapperBorderRadius: 8,
    cellHorizontalPadding: {
        calc: 'spacing * 2 * cellHorizontalPaddingScale',
    },
    cellWidgetSpacing: {
        calc: 'spacing * 1.5',
    },
    cellHorizontalPaddingScale: 1,
    rowGroupIndentSize: {
        calc: 'cellWidgetSpacing + iconSize',
    },
    valueChangeDeltaUpColor: '#43a047',
    valueChangeDeltaDownColor: '#e53935',
    valueChangeValueHighlightBackgroundColor: '#16a08580',
    spacing: 8,
    fontSize: 14,
    rowHeight: {
        calc: 'max(iconSize, dataFontSize) + spacing * 3.25 * rowVerticalPaddingScale',
    },
    rowVerticalPaddingScale: 1,
    headerHeight: {
        calc: 'max(iconSize, dataFontSize) + spacing * 4 * headerVerticalPaddingScale',
    },
    headerVerticalPaddingScale: 1,
    paginationPanelHeight: {
        ref: 'rowHeight',
        calc: 'max(rowHeight, 22px)',
    },
    popupShadow: '0 0 16px #00000026',
    cardShadow: '0 1px 4px 1px #00000018',
    dropdownShadow: { ref: 'cardShadow' },
    dragAndDropImageBackgroundColor: theme_utils_1.backgroundColor,
    dragAndDropImageBorder: true,
    dragAndDropImageShadow: {
        ref: 'popupShadow',
    },
    dragHandleColor: (0, theme_utils_1.foregroundMix)(0.7),
    focusShadow: {
        spread: 3,
        color: (0, theme_utils_1.accentMix)(0.5),
    },
    focusErrorShadow: {
        spread: 3,
        color: {
            ref: 'invalidColor',
            onto: 'backgroundColor',
            mix: 0.5,
        },
    },
    headerColumnResizeHandleHeight: '30%',
    headerColumnResizeHandleWidth: 2,
    headerColumnResizeHandleColor: {
        ref: 'borderColor',
    },
    widgetContainerHorizontalPadding: {
        calc: 'spacing * 1.5',
    },
    widgetContainerVerticalPadding: {
        calc: 'spacing * 1.5',
    },
    widgetHorizontalSpacing: {
        calc: 'spacing * 1.5',
    },
    widgetVerticalSpacing: {
        ref: 'spacing',
    },
    listItemHeight: {
        calc: 'max(iconSize, dataFontSize) + widgetVerticalSpacing',
    },
    iconSize: 16,
    iconColor: 'inherit',
    iconButtonColor: { ref: 'iconColor' },
    iconButtonBackgroundColor: 'transparent',
    iconButtonBackgroundSpread: 4,
    iconButtonBorderRadius: 1,
    iconButtonHoverColor: { ref: 'iconButtonColor' },
    iconButtonHoverBackgroundColor: (0, theme_utils_1.foregroundMix)(0.1),
    iconButtonActiveColor: theme_utils_1.accentColor,
    iconButtonActiveBackgroundColor: (0, theme_utils_1.accentMix)(0.28),
    iconButtonActiveIndicatorColor: theme_utils_1.accentColor,
    toggleButtonWidth: 28,
    toggleButtonHeight: 18,
    toggleButtonOnBackgroundColor: theme_utils_1.accentColor,
    toggleButtonOffBackgroundColor: (0, theme_utils_1.foregroundBackgroundMix)(0.3),
    toggleButtonSwitchBackgroundColor: theme_utils_1.backgroundColor,
    toggleButtonSwitchInset: 2,
    menuBorder: {
        color: (0, theme_utils_1.foregroundMix)(0.2),
    },
    menuBackgroundColor: (0, theme_utils_1.foregroundBackgroundMix)(0.03),
    menuTextColor: (0, theme_utils_1.foregroundBackgroundMix)(0.95),
    menuShadow: {
        ref: 'popupShadow',
    },
    menuSeparatorColor: {
        ref: 'borderColor',
    },
    setFilterIndentSize: {
        ref: 'iconSize',
    },
    chartMenuPanelWidth: 260,
    chartMenuLabelColor: (0, theme_utils_1.foregroundMix)(0.8),
    dialogShadow: {
        ref: 'popupShadow',
    },
    cellEditingBorder: {
        color: theme_utils_1.accentColor,
    },
    cellEditingShadow: { ref: 'cardShadow' },
    fullRowEditInvalidBackgroundColor: {
        ref: 'invalidColor',
        onto: 'backgroundColor',
        mix: 0.25,
    },
    dialogBorder: {
        color: (0, theme_utils_1.foregroundMix)(0.2),
    },
    panelBackgroundColor: theme_utils_1.backgroundColor,
    panelTitleBarBackgroundColor: {
        ref: 'headerBackgroundColor',
    },
    panelTitleBarIconColor: {
        ref: 'headerTextColor',
    },
    panelTitleBarTextColor: {
        ref: 'headerTextColor',
    },
    panelTitleBarFontWeight: {
        ref: 'headerFontWeight',
    },
    panelTitleBarBorder: true,
    columnSelectIndentSize: {
        ref: 'iconSize',
    },
    toolPanelSeparatorBorder: true,
    tooltipBackgroundColor: {
        ref: 'chromeBackgroundColor',
    },
    tooltipErrorBackgroundColor: {
        ref: 'invalidColor',
        onto: 'backgroundColor',
        mix: 0.1,
    },
    tooltipTextColor: {
        ref: 'textColor',
    },
    tooltipErrorTextColor: {
        ref: 'invalidColor',
    },
    tooltipBorder: true,
    tooltipErrorBorder: {
        color: {
            ref: 'invalidColor',
            onto: 'backgroundColor',
            mix: 0.25,
        },
    },
    columnDropCellBackgroundColor: (0, theme_utils_1.foregroundMix)(0.07),
    columnDropCellTextColor: {
        ref: 'textColor',
    },
    columnDropCellDragHandleColor: {
        ref: 'textColor',
    },
    columnDropCellBorder: {
        color: (0, theme_utils_1.foregroundMix)(0.13),
    },
    selectCellBackgroundColor: (0, theme_utils_1.foregroundMix)(0.07),
    selectCellBorder: {
        color: (0, theme_utils_1.foregroundMix)(0.13),
    },
    advancedFilterBuilderButtonBarBorder: true,
    advancedFilterBuilderIndentSize: {
        calc: 'spacing * 2 + iconSize',
    },
    advancedFilterBuilderJoinPillColor: '#f08e8d',
    advancedFilterBuilderColumnPillColor: '#a6e194',
    advancedFilterBuilderOptionPillColor: '#f3c08b',
    advancedFilterBuilderValuePillColor: '#85c0e4',
    filterPanelApplyButtonColor: theme_utils_1.backgroundColor,
    filterPanelApplyButtonBackgroundColor: theme_utils_1.accentColor,
    filterPanelCardSubtleColor: {
        ref: 'textColor',
        mix: 0.7,
    },
    filterPanelCardSubtleHoverColor: { ref: 'textColor' },
    findMatchColor: theme_utils_1.foregroundColor,
    findMatchBackgroundColor: '#ffff00',
    findActiveMatchColor: theme_utils_1.foregroundColor,
    findActiveMatchBackgroundColor: '#ffa500',
    filterToolPanelGroupIndent: {
        ref: 'spacing',
    },
    rowLoadingSkeletonEffectColor: (0, theme_utils_1.foregroundMix)(0.15),
    statusBarLabelColor: theme_utils_1.foregroundColor,
    statusBarLabelFontWeight: 500,
    statusBarValueColor: theme_utils_1.foregroundColor,
    statusBarValueFontWeight: 500,
    pinnedSourceRowTextColor: {
        ref: 'textColor',
    },
    pinnedSourceRowBackgroundColor: {
        ref: 'backgroundColor',
    },
    pinnedSourceRowFontWeight: 600,
    pinnedRowFontWeight: 600,
    pinnedRowBackgroundColor: {
        ref: 'backgroundColor',
    },
    pinnedRowTextColor: {
        ref: 'textColor',
    },
};


/***/ }),

/***/ 99550:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.coreCSS = void 0;
exports.coreCSS = `:where(.ag-root-wrapper,.ag-popup,.ag-dnd-ghost,.ag-chart),:where(.ag-root-wrapper,.ag-popup,.ag-dnd-ghost,.ag-chart) :where([class^=ag-]){box-sizing:border-box;&:after,&:before{box-sizing:border-box}&:where(div,span,label):focus-visible{box-shadow:inset var(--ag-focus-shadow);outline:none;&.invalid{box-shadow:inset var(--ag-focus-error-shadow)}}&:where(button){color:inherit}}:where(.ag-root-wrapper,.ag-popup,.ag-dnd-ghost,.ag-chart) :where([class^=ag-]) ::-ms-clear{display:none}.ag-aria-description-container{border:0;z-index:9999;clip:rect(1px,1px,1px,1px);height:1px;overflow:hidden;padding:0;position:absolute;white-space:nowrap;width:1px}.ag-hidden{display:none!important}.ag-invisible{visibility:hidden!important}.ag-unselectable{-webkit-user-select:none;-moz-user-select:none;user-select:none}.ag-selectable{-webkit-user-select:text;-moz-user-select:text;user-select:text}.ag-tab-guard{display:block;height:0;position:absolute;width:0}:where(.ag-virtual-list-viewport) .ag-tab-guard{position:sticky}.ag-tab-guard-top{top:1px}.ag-tab-guard-bottom{bottom:1px}.ag-shake-left-to-right{animation-direction:alternate;animation-duration:.2s;animation-iteration-count:infinite;animation-name:ag-shake-left-to-right}@keyframes ag-shake-left-to-right{0%{padding-left:6px;padding-right:2px}to{padding-left:2px;padding-right:6px}}.ag-body-horizontal-scroll-viewport,.ag-body-vertical-scroll-viewport,.ag-body-viewport,.ag-center-cols-viewport,.ag-floating-bottom-viewport,.ag-floating-top-viewport,.ag-header-viewport,.ag-sticky-bottom-viewport,.ag-sticky-top-viewport,.ag-virtual-list-viewport{flex:1 1 auto;height:100%;min-width:0;overflow:hidden;position:relative}.ag-viewport{position:relative}.ag-spanning-container{position:absolute;top:0;z-index:1}.ag-body-viewport,.ag-center-cols-viewport,.ag-floating-bottom-viewport,.ag-floating-top-viewport,.ag-header-viewport,.ag-sticky-bottom-viewport,.ag-sticky-top-viewport{overflow-x:auto;-ms-overflow-style:none!important;scrollbar-width:none!important;&::-webkit-scrollbar{display:none!important}}.ag-body-viewport{display:flex;overflow-x:hidden;&:where(.ag-layout-normal){overflow-y:auto;-webkit-overflow-scrolling:touch}}.ag-floating-bottom-container,.ag-floating-top-container,.ag-sticky-bottom-container,.ag-sticky-top-container{min-height:1px}.ag-center-cols-viewport{min-height:100%;width:100%}.ag-body-horizontal-scroll-viewport{overflow-x:scroll}.ag-body-vertical-scroll-viewport{overflow-y:scroll}.ag-virtual-list-viewport{overflow:auto;width:100%}.ag-body-container,.ag-body-horizontal-scroll-container,.ag-body-vertical-scroll-container,.ag-center-cols-container,.ag-floating-bottom-container,.ag-floating-bottom-full-width-container,.ag-floating-top-container,.ag-full-width-container,.ag-header-container,.ag-pinned-left-cols-container,.ag-pinned-right-cols-container,.ag-sticky-bottom-container,.ag-sticky-top-container,.ag-virtual-list-container{position:relative}.ag-floating-bottom-container,.ag-floating-top-container,.ag-header-container,.ag-pinned-left-floating-bottom,.ag-pinned-left-floating-top,.ag-pinned-right-floating-bottom,.ag-pinned-right-floating-top,.ag-sticky-bottom-container,.ag-sticky-top-container{height:100%;white-space:nowrap}.ag-center-cols-container,.ag-pinned-right-cols-container{display:block}.ag-body-horizontal-scroll-container{height:100%}.ag-body-vertical-scroll-container{width:100%}.ag-floating-bottom-full-width-container,.ag-floating-top-full-width-container,.ag-full-width-container,.ag-sticky-bottom-full-width-container,.ag-sticky-top-full-width-container{pointer-events:none;position:absolute;top:0}:where(.ag-ltr) .ag-floating-bottom-full-width-container,:where(.ag-ltr) .ag-floating-top-full-width-container,:where(.ag-ltr) .ag-full-width-container,:where(.ag-ltr) .ag-sticky-bottom-full-width-container,:where(.ag-ltr) .ag-sticky-top-full-width-container{left:0}:where(.ag-rtl) .ag-floating-bottom-full-width-container,:where(.ag-rtl) .ag-floating-top-full-width-container,:where(.ag-rtl) .ag-full-width-container,:where(.ag-rtl) .ag-sticky-bottom-full-width-container,:where(.ag-rtl) .ag-sticky-top-full-width-container{right:0}.ag-full-width-container{width:100%}.ag-floating-bottom-full-width-container,.ag-floating-top-full-width-container{display:inline-block;height:100%;overflow:hidden;width:100%}.ag-virtual-list-container{overflow:hidden}.ag-body{display:flex;flex:1 1 auto;flex-direction:row!important;min-height:0;position:relative}.ag-body-horizontal-scroll,.ag-body-vertical-scroll{display:flex;min-height:0;min-width:0;position:relative;&:where(.ag-scrollbar-invisible){bottom:0;position:absolute;&:where(.ag-apple-scrollbar){opacity:0;transition:opacity .4s;visibility:hidden;&:where(.ag-scrollbar-scrolling,.ag-scrollbar-active){opacity:1;visibility:visible}}}}.ag-body-horizontal-scroll{width:100%;&:where(.ag-scrollbar-invisible){left:0;right:0}}.ag-body-vertical-scroll{height:100%;&:where(.ag-scrollbar-invisible){top:0;z-index:10}}:where(.ag-ltr) .ag-body-vertical-scroll{&:where(.ag-scrollbar-invisible){right:0}}:where(.ag-rtl) .ag-body-vertical-scroll{&:where(.ag-scrollbar-invisible){left:0}}.ag-force-vertical-scroll{overflow-y:scroll!important}.ag-horizontal-left-spacer,.ag-horizontal-right-spacer{height:100%;min-width:0;overflow-x:scroll;&:where(.ag-scroller-corner){overflow-x:hidden}}:where(.ag-row-animation) .ag-row{transition:transform .4s,top .4s,opacity .2s;&:where(.ag-after-created){transition:transform .4s,top .4s,height .4s,opacity .2s}}:where(.ag-row-animation.ag-prevent-animation) .ag-row{transition:none!important;&:where(.ag-row.ag-after-created){transition:none!important}}:where(.ag-row-no-animation) .ag-row{transition:none}.ag-row-loading{align-items:center;display:flex}.ag-row-position-absolute{position:absolute}.ag-row-position-relative{position:relative}.ag-full-width-row{overflow:hidden;pointer-events:all}.ag-row-inline-editing{z-index:1}.ag-row-dragging{z-index:2}.ag-stub-cell{align-items:center;display:flex}.ag-cell{display:inline-block;height:100%;position:absolute;white-space:nowrap;&:focus-visible{box-shadow:none}}.ag-cell-value{flex:1 1 auto}.ag-cell-value,.ag-group-value{overflow:hidden;text-overflow:ellipsis}.ag-cell-wrap-text{white-space:normal;word-break:break-word}:where(.ag-cell) .ag-icon{display:inline-block;vertical-align:middle}.ag-floating-top{display:flex;overflow:hidden;position:relative;white-space:nowrap;width:100%}:where(.ag-floating-top:not(.ag-invisible)){border-bottom:var(--ag-pinned-row-border)}.ag-floating-bottom{display:flex;overflow:hidden;position:relative;white-space:nowrap;width:100%}:where(.ag-floating-bottom:not(.ag-invisible)){border-top:var(--ag-pinned-row-border)}.ag-sticky-bottom,.ag-sticky-top{background-color:var(--ag-background-color);display:flex;height:0;overflow:hidden;position:absolute;width:100%;z-index:1}.ag-opacity-zero{opacity:0!important}.ag-cell-label-container{align-items:center;display:flex;flex-direction:row-reverse;height:100%;justify-content:space-between;width:100%}:where(.ag-right-aligned-header){.ag-cell-label-container{flex-direction:row}.ag-header-cell-text{text-align:end}}.ag-column-group-icons{display:block;>*{cursor:pointer}}:where(.ag-ltr){direction:ltr;.ag-body,.ag-body-horizontal-scroll,.ag-body-viewport,.ag-floating-bottom,.ag-floating-top,.ag-header,.ag-sticky-bottom,.ag-sticky-top{flex-direction:row}}:where(.ag-rtl){direction:rtl;text-align:right;.ag-body,.ag-body-horizontal-scroll,.ag-body-viewport,.ag-floating-bottom,.ag-floating-top,.ag-header,.ag-sticky-bottom,.ag-sticky-top{flex-direction:row-reverse}.ag-icon-contracted,.ag-icon-expanded,.ag-icon-tree-closed{display:block}}:where(.ag-rtl){.ag-icon-contracted,.ag-icon-expanded,.ag-icon-tree-closed{transform:rotate(180deg)}}:where(.ag-rtl){.ag-icon-contracted,.ag-icon-expanded,.ag-icon-tree-closed{transform:rotate(-180deg)}}.ag-measurement-container{height:0;overflow:hidden;visibility:hidden;width:0}.ag-measurement-element-border{display:inline-block;&:before{border-left:var(--ag-internal-measurement-border);content:"";display:block}}.ag-group{position:relative;width:100%}.ag-group-title-bar{align-items:center;display:flex;padding:var(--ag-spacing)}.ag-group-title{display:inline;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}:where(.ag-group-title-bar) .ag-group-title{cursor:default}.ag-group-toolbar{align-items:center;display:flex;padding:var(--ag-spacing)}.ag-group-container{display:flex}.ag-disabled .ag-group-container{pointer-events:none}.ag-disabled-group-container,.ag-disabled-group-title-bar{opacity:.5}.ag-group-container-horizontal{flex-flow:row wrap}.ag-group-container-vertical{flex-direction:column}.ag-group-title-bar-icon{cursor:pointer;flex:none}:where(.ag-ltr) .ag-group-title-bar-icon{margin-right:var(--ag-spacing)}:where(.ag-rtl) .ag-group-title-bar-icon{margin-left:var(--ag-spacing)}:where(.ag-group-item-alignment-stretch) .ag-group-item{align-items:stretch}:where(.ag-group-item-alignment-start) .ag-group-item{align-items:flex-start}:where(.ag-group-item-alignment-end) .ag-group-item{align-items:flex-end}.ag-popup-child{top:0;z-index:5;&:where(:not(.ag-tooltip-custom)){box-shadow:var(--ag-popup-shadow)}}.ag-popup-editor{position:absolute;-webkit-user-select:none;-moz-user-select:none;user-select:none}.ag-large-text-input{display:block}:where(.ag-ltr) .ag-row:not(.ag-row-level-0) .ag-pivot-leaf-group{margin-left:var(--ag-row-group-indent-size)}:where(.ag-rtl) .ag-row:not(.ag-row-level-0) .ag-pivot-leaf-group{margin-right:var(--ag-row-group-indent-size)}:where(.ag-ltr) .ag-row-group-leaf-indent{margin-left:calc(var(--ag-cell-widget-spacing) + var(--ag-icon-size))}:where(.ag-rtl) .ag-row-group-leaf-indent{margin-right:calc(var(--ag-cell-widget-spacing) + var(--ag-icon-size))}.ag-value-change-delta{padding:0 2px}.ag-value-change-delta-up{color:var(--ag-value-change-delta-up-color)}.ag-value-change-delta-down{color:var(--ag-value-change-delta-down-color)}.ag-value-change-value{background-color:transparent;border-radius:1px;padding-left:1px;padding-right:1px;transition:background-color 1s}.ag-value-change-value-highlight{background-color:var(--ag-value-change-value-highlight-background-color);transition:background-color .1s}.ag-cell-data-changed{background-color:var(--ag-value-change-value-highlight-background-color)!important}.ag-cell-data-changed-animation{background-color:transparent}.ag-cell-highlight{background-color:var(--ag-range-selection-highlight-color)!important}.ag-row,.ag-spanned-row{color:var(--ag-cell-text-color);font-family:var(--ag-cell-font-family);font-size:var(--ag-data-font-size);white-space:nowrap;--ag-internal-content-line-height:calc(min(var(--ag-row-height), var(--ag-line-height, 1000px)) - var(--ag-internal-row-border-width, 1px) - 2px)}.ag-row{background-color:var(--ag-background-color);border-bottom:var(--ag-row-border);height:var(--ag-row-height);width:100%;&.ag-row-editing-invalid{background-color:var(--ag-full-row-edit-invalid-background-color)}}:where(.ag-body-vertical-content-no-gap>div>div>div,.ag-body-vertical-content-no-gap>div>div>div>div)>.ag-row-last{border-bottom-color:transparent}.ag-sticky-bottom{border-top:var(--ag-row-border);box-sizing:content-box!important}.ag-group-contracted,.ag-group-expanded{cursor:pointer}.ag-cell,.ag-full-width-row .ag-cell-wrapper.ag-row-group{border:1px solid transparent;line-height:var(--ag-internal-content-line-height);-webkit-font-smoothing:subpixel-antialiased}:where(.ag-ltr) .ag-cell{border-right:var(--ag-column-border)}:where(.ag-rtl) .ag-cell{border-left:var(--ag-column-border)}.ag-spanned-cell-wrapper{background-color:var(--ag-background-color);position:absolute}.ag-spanned-cell-wrapper>.ag-spanned-cell{display:block;position:relative}:where(.ag-ltr) :where(.ag-body-horizontal-content-no-gap) .ag-column-last{border-right-color:transparent}:where(.ag-rtl) :where(.ag-body-horizontal-content-no-gap) .ag-column-last{border-left-color:transparent}.ag-cell-wrapper{align-items:center;display:flex;>:where(:not(.ag-cell-value,.ag-group-value)){align-items:center;display:flex;height:var(--ag-internal-content-line-height)}&:where(.ag-row-group){align-items:flex-start}:where(.ag-full-width-row) &:where(.ag-row-group){align-items:center;height:100%}}:where(.ag-ltr) .ag-cell-wrapper{padding-left:calc(var(--ag-indentation-level)*var(--ag-row-group-indent-size))}:where(.ag-rtl) .ag-cell-wrapper{padding-right:calc(var(--ag-indentation-level)*var(--ag-row-group-indent-size))}:where(.ag-cell-wrap-text:not(.ag-cell-auto-height)) .ag-cell-wrapper{align-items:normal;height:100%;:where(.ag-cell-value){height:100%}}:where(.ag-ltr) .ag-row>.ag-cell-wrapper.ag-row-group{padding-left:calc(var(--ag-cell-horizontal-padding) + var(--ag-row-group-indent-size)*var(--ag-indentation-level))}:where(.ag-rtl) .ag-row>.ag-cell-wrapper.ag-row-group{padding-right:calc(var(--ag-cell-horizontal-padding) + var(--ag-row-group-indent-size)*var(--ag-indentation-level))}.ag-cell-focus:not(.ag-cell-range-selected):focus-within,.ag-cell-range-single-cell,.ag-cell-range-single-cell.ag-cell-range-handle,.ag-context-menu-open .ag-cell-focus:not(.ag-cell-range-selected),.ag-context-menu-open .ag-full-width-row.ag-row-focus .ag-cell-wrapper.ag-row-group,.ag-full-width-row.ag-row-focus:focus .ag-cell-wrapper.ag-row-group{border:1px solid;border-color:var(--ag-range-selection-border-color);border-style:var(--ag-range-selection-border-style);outline:initial}.ag-full-width-row.ag-row-focus:focus{box-shadow:none}:where(.ag-ltr) .ag-group-contracted,:where(.ag-ltr) .ag-group-expanded,:where(.ag-ltr) .ag-row-drag,:where(.ag-ltr) .ag-selection-checkbox{margin-right:var(--ag-cell-widget-spacing)}:where(.ag-rtl) .ag-group-contracted,:where(.ag-rtl) .ag-group-expanded,:where(.ag-rtl) .ag-row-drag,:where(.ag-rtl) .ag-selection-checkbox{margin-left:var(--ag-cell-widget-spacing)}:where(.ag-ltr) .ag-group-child-count{margin-left:3px}:where(.ag-rtl) .ag-group-child-count{margin-right:3px}.ag-row-highlight-above:after,.ag-row-highlight-below:after,.ag-row-highlight-inside:after{background-color:var(--ag-range-selection-border-color);content:"";height:1px;pointer-events:none;position:absolute;width:calc(100% - 1px)}:where(.ag-ltr) .ag-row-highlight-above:after,:where(.ag-ltr) .ag-row-highlight-below:after,:where(.ag-ltr) .ag-row-highlight-inside:after{left:1px}:where(.ag-rtl) .ag-row-highlight-above:after,:where(.ag-rtl) .ag-row-highlight-below:after,:where(.ag-rtl) .ag-row-highlight-inside:after{right:1px}.ag-row-highlight-above:after{top:0}.ag-row-highlight-below:after{bottom:0}.ag-row-highlight-indent:after{display:block;width:auto}:where(.ag-ltr) .ag-row-highlight-indent:after{left:calc((var(--ag-cell-widget-spacing) + var(--ag-icon-size))*2 + var(--ag-cell-horizontal-padding) + var(--ag-row-highlight-level)*var(--ag-row-group-indent-size));right:1px}:where(.ag-rtl) .ag-row-highlight-indent:after{left:1px;right:calc((var(--ag-cell-widget-spacing) + var(--ag-icon-size))*2 + var(--ag-cell-horizontal-padding) + var(--ag-row-highlight-level)*var(--ag-row-group-indent-size))}.ag-row-highlight-inside:after{background-color:var(--ag-selected-row-background-color);border:1px solid var(--ag-range-selection-border-color);display:block;height:auto;inset:0;width:auto}.ag-row-odd{background-color:var(--ag-odd-row-background-color)}.ag-row-selected:before{background-color:var(--ag-selected-row-background-color);content:"";display:block;inset:0;pointer-events:none;position:absolute}.ag-row-hover.ag-full-width-row.ag-row-group:before,.ag-row-hover:not(.ag-full-width-row):before{background-color:var(--ag-row-hover-color);content:"";display:block;inset:0;pointer-events:none;position:absolute}.ag-row-hover.ag-row-selected:before{background-color:var(--ag-row-hover-color);background-image:linear-gradient(var(--ag-selected-row-background-color),var(--ag-selected-row-background-color))}.ag-row.ag-full-width-row.ag-row-group>*{position:relative}.ag-column-hover{background-color:var(--ag-column-hover-color)}.ag-header-range-highlight{background-color:var(--ag-range-header-highlight-color)}.ag-right-aligned-cell{font-variant-numeric:tabular-nums}:where(.ag-ltr) .ag-right-aligned-cell{text-align:right}:where(.ag-rtl) .ag-right-aligned-cell{text-align:left}.ag-right-aligned-cell .ag-cell-value,.ag-right-aligned-cell .ag-group-value{margin-left:auto}:where(.ag-ltr) .ag-cell:not(.ag-cell-inline-editing),:where(.ag-ltr) .ag-full-width-row .ag-cell-wrapper.ag-row-group{padding-left:calc(var(--ag-cell-horizontal-padding) - 1px + var(--ag-row-group-indent-size)*var(--ag-indentation-level));padding-right:calc(var(--ag-cell-horizontal-padding) - 1px)}:where(.ag-rtl) .ag-cell:not(.ag-cell-inline-editing),:where(.ag-rtl) .ag-full-width-row .ag-cell-wrapper.ag-row-group{padding-left:calc(var(--ag-cell-horizontal-padding) - 1px);padding-right:calc(var(--ag-cell-horizontal-padding) - 1px + var(--ag-row-group-indent-size)*var(--ag-indentation-level))}.ag-row>.ag-cell-wrapper{padding-left:calc(var(--ag-cell-horizontal-padding) - 1px);padding-right:calc(var(--ag-cell-horizontal-padding) - 1px)}.ag-row-dragging{cursor:move;opacity:.5}.ag-details-row{background-color:var(--ag-background-color);padding:calc(var(--ag-spacing)*3.75)}.ag-layout-auto-height,.ag-layout-print{.ag-center-cols-container,.ag-center-cols-viewport{min-height:150px}}.ag-overlay-loading-wrapper{background-color:var(--ag-modal-overlay-background-color)}.ag-skeleton-container{align-content:center;height:100%;width:100%}.ag-skeleton-effect{animation:ag-skeleton-loading 1.5s ease-in-out .5s infinite;background-color:var(--ag-row-loading-skeleton-effect-color);border-radius:.25rem;height:1em;width:100%}:where(.ag-ltr) .ag-right-aligned-cell .ag-skeleton-effect{margin-left:auto}:where(.ag-rtl) .ag-right-aligned-cell .ag-skeleton-effect{margin-right:auto}@keyframes ag-skeleton-loading{0%{opacity:1}50%{opacity:.4}to{opacity:1}}.ag-loading{align-items:center;display:flex;height:100%}:where(.ag-ltr) .ag-loading{padding-left:var(--ag-cell-horizontal-padding)}:where(.ag-rtl) .ag-loading{padding-right:var(--ag-cell-horizontal-padding)}:where(.ag-ltr) .ag-loading-icon{padding-right:var(--ag-cell-widget-spacing)}:where(.ag-rtl) .ag-loading-icon{padding-left:var(--ag-cell-widget-spacing)}.ag-icon-loading{animation-duration:1s;animation-iteration-count:infinite;animation-name:spin;animation-timing-function:linear}@keyframes spin{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}.ag-input-wrapper,.ag-picker-field-wrapper{align-items:center;display:flex;flex:1 1 auto;line-height:normal;position:relative}.ag-input-field{align-items:center;display:flex;flex-direction:row}.ag-input-field-input:where(:not([type=checkbox],[type=radio])){flex:1 1 auto;min-width:0;width:100%}.ag-header{background-color:var(--ag-header-background-color);border-bottom:var(--ag-header-row-border);color:var(--ag-header-text-color);display:flex;font-family:var(--ag-header-font-family);font-size:var(--ag-header-font-size);font-weight:var(--ag-header-font-weight);overflow:hidden;white-space:nowrap;width:100%}.ag-header-row{height:var(--ag-header-height);position:absolute}.ag-floating-filter-button-button,.ag-header-cell-filter-button,.ag-header-cell-menu-button,.ag-header-expand-icon,.ag-panel-title-bar-button,:where(.ag-header-cell-sortable) .ag-header-cell-label{cursor:pointer}:where(.ag-ltr) .ag-header-expand-icon{margin-left:4px}:where(.ag-rtl) .ag-header-expand-icon{margin-right:4px}.ag-header-row:where(:not(:first-child)){:where(.ag-header-cell:not(.ag-header-span-height.ag-header-span-total,.ag-header-parent-hidden),.ag-header-group-cell.ag-header-group-cell-with-group){border-top:var(--ag-header-row-border)}}.ag-header-row:where(:not(.ag-header-row-column-group)){overflow:hidden}:where(.ag-header.ag-header-allow-overflow) .ag-header-row{overflow:visible}.ag-header-cell{display:inline-flex;overflow:hidden}.ag-header-group-cell{contain:paint;display:flex}.ag-header-cell,.ag-header-group-cell{align-items:center;gap:var(--ag-cell-widget-spacing);height:100%;padding:0 var(--ag-cell-horizontal-padding);position:absolute}@property --ag-internal-moving-color{syntax:"<color>";inherits:false;initial-value:transparent}@property --ag-internal-hover-color{syntax:"<color>";inherits:false;initial-value:transparent}.ag-header-cell:where(:not(.ag-floating-filter)),.ag-header-group-cell{&:before{background-image:linear-gradient(var(--ag-internal-hover-color),var(--ag-internal-hover-color)),linear-gradient(var(--ag-internal-moving-color),var(--ag-internal-moving-color));content:"";inset:0;position:absolute;--ag-internal-moving-color:transparent;--ag-internal-hover-color:transparent;transition:--ag-internal-moving-color var(--ag-header-cell-background-transition-duration),--ag-internal-hover-color var(--ag-header-cell-background-transition-duration)}&:where(:hover):before{--ag-internal-hover-color:var(--ag-header-cell-hover-background-color)}&:where(.ag-header-cell-moving):before{--ag-internal-moving-color:var(--ag-header-cell-moving-background-color);--ag-internal-hover-color:var(--ag-header-cell-hover-background-color)}}:where(.ag-header-cell:not(.ag-floating-filter) *,.ag-header-group-cell *){position:relative;z-index:1}.ag-header-cell-menu-button:where(:not(.ag-header-menu-always-show)){opacity:0;transition:opacity .2s}.ag-header-cell-filter-button,:where(.ag-header-cell.ag-header-active) .ag-header-cell-menu-button{opacity:1}.ag-header-cell-label,.ag-header-group-cell-label{align-items:center;align-self:stretch;display:flex;flex:1 1 auto;overflow:hidden;padding:5px 0}:where(.ag-ltr) .ag-sort-indicator-icon{padding-left:var(--ag-spacing)}:where(.ag-rtl) .ag-sort-indicator-icon{padding-right:var(--ag-spacing)}.ag-header-cell-label{text-overflow:ellipsis}.ag-header-group-cell-label.ag-sticky-label{flex:none;max-width:100%;overflow:visible;position:sticky}:where(.ag-ltr) .ag-header-group-cell-label.ag-sticky-label{left:var(--ag-cell-horizontal-padding)}:where(.ag-rtl) .ag-header-group-cell-label.ag-sticky-label{right:var(--ag-cell-horizontal-padding)}.ag-header-cell-text,.ag-header-group-text{overflow:hidden;text-overflow:ellipsis}.ag-header-cell-text{word-break:break-word}.ag-header-cell-comp-wrapper{width:100%}:where(.ag-header-group-cell) .ag-header-cell-comp-wrapper{display:flex}:where(.ag-header-cell:not(.ag-header-cell-auto-height)) .ag-header-cell-comp-wrapper{align-items:center;display:flex;height:100%}.ag-header-cell-wrap-text .ag-header-cell-comp-wrapper{white-space:normal}.ag-header-cell-comp-wrapper-limited-height>*{overflow:hidden}:where(.ag-right-aligned-header) .ag-header-cell-label{flex-direction:row-reverse}:where(.ag-ltr) :where(.ag-header-cell:not(.ag-right-aligned-header)){.ag-header-label-icon,.ag-header-menu-icon{margin-left:var(--ag-spacing)}}:where(.ag-rtl) :where(.ag-header-cell:not(.ag-right-aligned-header)){.ag-header-label-icon,.ag-header-menu-icon{margin-right:var(--ag-spacing)}}:where(.ag-ltr) :where(.ag-header-cell.ag-right-aligned-header){.ag-header-label-icon,.ag-header-menu-icon{margin-right:var(--ag-spacing)}}:where(.ag-rtl) :where(.ag-header-cell.ag-right-aligned-header){.ag-header-label-icon,.ag-header-menu-icon{margin-left:var(--ag-spacing)}}.ag-header-cell:after,.ag-header-group-cell:where(:not(.ag-header-span-height.ag-header-group-cell-no-group)):after{content:"";height:var(--ag-header-column-border-height);position:absolute;top:calc(50% - var(--ag-header-column-border-height)*.5);z-index:1}:where(.ag-ltr) .ag-header-cell:after,:where(.ag-ltr) .ag-header-group-cell:where(:not(.ag-header-span-height.ag-header-group-cell-no-group)):after{border-right:var(--ag-header-column-border);right:0}:where(.ag-rtl) .ag-header-cell:after,:where(.ag-rtl) .ag-header-group-cell:where(:not(.ag-header-span-height.ag-header-group-cell-no-group)):after{border-left:var(--ag-header-column-border);left:0}.ag-header-highlight-after:after,.ag-header-highlight-before:after{background-color:var(--ag-accent-color);content:"";height:100%;position:absolute;width:1px}:where(.ag-ltr) .ag-header-highlight-before:after{left:0}:where(.ag-rtl) .ag-header-highlight-before:after{right:0}:where(.ag-ltr) .ag-header-highlight-after:after{right:0;:where(.ag-pinned-left-header) &{right:1px}}:where(.ag-rtl) .ag-header-highlight-after:after{left:0;:where(.ag-pinned-left-header) &{left:1px}}.ag-header-cell-resize{align-items:center;cursor:ew-resize;display:flex;height:100%;position:absolute;top:0;width:8px;z-index:2;&:after{background-color:var(--ag-header-column-resize-handle-color);content:"";height:var(--ag-header-column-resize-handle-height);position:absolute;top:calc(50% - var(--ag-header-column-resize-handle-height)*.5);width:var(--ag-header-column-resize-handle-width);z-index:1}}:where(.ag-ltr) .ag-header-cell-resize{right:-3px;&:after{left:calc(50% - var(--ag-header-column-resize-handle-width))}}:where(.ag-rtl) .ag-header-cell-resize{left:-3px;&:after{right:calc(50% - var(--ag-header-column-resize-handle-width))}}:where(.ag-header-cell.ag-header-span-height) .ag-header-cell-resize:after{height:calc(100% - var(--ag-spacing)*4);top:calc(var(--ag-spacing)*2)}.ag-header-group-cell-no-group:where(.ag-header-span-height){display:none}.ag-sort-indicator-container{display:flex;gap:var(--ag-spacing)}.ag-layout-print{&.ag-body{display:block;height:unset}&.ag-root-wrapper{display:inline-block}.ag-body-horizontal-scroll,.ag-body-vertical-scroll{display:none}&.ag-force-vertical-scroll{overflow-y:visible!important}}@media print{.ag-root-wrapper.ag-layout-print{display:table;.ag-body-horizontal-scroll-viewport,.ag-body-viewport,.ag-center-cols-container,.ag-center-cols-viewport,.ag-root,.ag-root-wrapper-body,.ag-virtual-list-viewport{display:block!important;height:auto!important;overflow:hidden!important}.ag-cell,.ag-row{-moz-column-break-inside:avoid;break-inside:avoid}}}ag-grid,ag-grid-angular{display:block}.ag-chart,.ag-dnd-ghost,.ag-popup,.ag-root-wrapper{cursor:default;line-height:normal;white-space:normal;-webkit-font-smoothing:antialiased;background-color:var(--ag-background-color);color:var(--ag-text-color);color-scheme:var(--ag-browser-color-scheme);font-family:var(--ag-font-family);font-size:var(--ag-font-size);--ag-indentation-level:0}.ag-root-wrapper{border:var(--ag-wrapper-border);border-radius:var(--ag-wrapper-border-radius);display:flex;flex-direction:column;overflow:hidden;position:relative;&.ag-layout-normal{height:100%}}.ag-root-wrapper-body{display:flex;flex-direction:row;&.ag-layout-normal{flex:1 1 auto;height:0;min-height:0}}.ag-root{display:flex;flex-direction:column;position:relative;&.ag-layout-auto-height,&.ag-layout-normal{flex:1 1 auto;overflow:hidden;width:0}&.ag-layout-normal{height:100%}}.ag-drag-handle{color:var(--ag-drag-handle-color);cursor:grab}.ag-list-item,.ag-virtual-list-item{height:var(--ag-list-item-height)}.ag-virtual-list-item{position:absolute;width:100%}.ag-select-list{background-color:var(--ag-picker-list-background-color);border:var(--ag-picker-list-border);border-radius:var(--ag-border-radius);box-shadow:var(--ag-dropdown-shadow);overflow:hidden auto}.ag-list-item{align-items:center;display:flex;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;&.ag-active-item{background-color:var(--ag-row-hover-color)}}.ag-select-list-item{cursor:default;-webkit-user-select:none;-moz-user-select:none;user-select:none;:where(span){overflow:hidden;text-overflow:ellipsis;white-space:nowrap}}:where(.ag-ltr) .ag-select-list-item{padding-left:calc(var(--ag-cell-horizontal-padding)/2)}:where(.ag-rtl) .ag-select-list-item{padding-right:calc(var(--ag-cell-horizontal-padding)/2)}.ag-list-item-hovered:after{background-color:var(--ag-accent-color);content:"";height:1px;left:0;position:absolute;right:0}.ag-item-highlight-top:after{top:0}.ag-item-highlight-bottom:after{bottom:0}:where(.ag-icon):before{align-items:center;background-color:currentcolor;color:inherit;content:"";display:flex;font-family:inherit;font-size:var(--ag-icon-size);font-style:normal;font-variant:normal;height:var(--ag-icon-size);justify-content:center;line-height:var(--ag-icon-size);-webkit-mask-size:contain;mask-size:contain;text-transform:none;width:var(--ag-icon-size)}.ag-icon{background-position:50%;background-repeat:no-repeat;background-size:contain;color:var(--ag-icon-color);display:block;height:var(--ag-icon-size);position:relative;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:var(--ag-icon-size)}.ag-column-select-column-group-readonly,.ag-column-select-column-readonly,.ag-disabled,[disabled]{.ag-icon{opacity:.5}&.ag-icon-grip{opacity:.35}}.ag-column-select-column-readonly{&.ag-icon-grip,.ag-icon-grip{opacity:.35}}.ag-chart-menu-icon,.ag-chart-settings-next,.ag-chart-settings-prev,.ag-column-group-icons,.ag-column-select-header-icon,.ag-filter-toolpanel-expand,.ag-floating-filter-button-button,.ag-group-title-bar-icon,.ag-header-cell-filter-button,.ag-header-cell-menu-button,.ag-header-expand-icon,.ag-panel-title-bar-button,.ag-panel-title-bar-button-icon,.ag-set-filter-group-icons,:where(.ag-group-contracted) .ag-icon,:where(.ag-group-expanded) .ag-icon{background-color:var(--ag-icon-button-background-color);border-radius:var(--ag-icon-button-border-radius);box-shadow:0 0 0 var(--ag-icon-button-background-spread) var(--ag-icon-button-background-color);color:var(--ag-icon-button-color);&:hover{background-color:var(--ag-icon-button-hover-background-color);box-shadow:0 0 0 var(--ag-icon-button-background-spread) var(--ag-icon-button-hover-background-color);color:var(--ag-icon-button-hover-color)}}.ag-filter-active{background-image:linear-gradient(var(--ag-icon-button-active-background-color),var(--ag-icon-button-active-background-color));border-radius:1px;outline:solid var(--ag-icon-button-background-spread) var(--ag-icon-button-active-background-color);position:relative;&:after{background-color:var(--ag-accent-color);border-radius:50%;content:"";height:6px;position:absolute;top:-1px;width:6px}:where(.ag-icon-filter){clip-path:path("M8,0C8,4.415 11.585,8 16,8L16,16L0,16L0,0L8,0Z");color:var(--ag-icon-button-active-color)}}:where(.ag-ltr) .ag-filter-active{&:after{right:-1px}}:where(.ag-rtl) .ag-filter-active{&:after{left:-1px}}.ag-menu{background-color:var(--ag-menu-background-color);border:var(--ag-menu-border);border-radius:var(--ag-border-radius);box-shadow:var(--ag-menu-shadow);color:var(--ag-menu-text-color);max-height:100%;overflow-y:auto}.ag-menu,.ag-resizer{position:absolute;-webkit-user-select:none;-moz-user-select:none;user-select:none}.ag-resizer{pointer-events:none;z-index:1}:where(.ag-resizer){&.ag-resizer-topLeft{cursor:nwse-resize;height:5px;left:0;top:0;width:5px}&.ag-resizer-top{cursor:ns-resize;height:5px;left:5px;right:5px;top:0}&.ag-resizer-topRight{cursor:nesw-resize;height:5px;right:0;top:0;width:5px}&.ag-resizer-right{bottom:5px;cursor:ew-resize;right:0;top:5px;width:5px}&.ag-resizer-bottomRight{bottom:0;cursor:nwse-resize;height:5px;right:0;width:5px}&.ag-resizer-bottom{bottom:0;cursor:ns-resize;height:5px;left:5px;right:5px}&.ag-resizer-bottomLeft{bottom:0;cursor:nesw-resize;height:5px;left:0;width:5px}&.ag-resizer-left{bottom:5px;cursor:ew-resize;left:0;top:5px;width:5px}}`;


/***/ }),

/***/ 68951:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._unregisterGridUsingThemingAPI = exports._registerGridUsingThemingAPI = exports._injectCoreAndModuleCSS = exports._injectGlobalCSS = exports.IS_SSR = void 0;
const moduleRegistry_1 = __webpack_require__(2132);
const Theme_1 = __webpack_require__(39621);
const core_css_GENERATED_1 = __webpack_require__(99550);
exports.IS_SSR = typeof window !== 'object' || !window?.document?.fonts?.forEach;
const _injectGlobalCSS = (css, styleContainer, debugId, layer, priority, nonce) => {
    if (exports.IS_SSR)
        return;
    if (Theme_1.FORCE_LEGACY_THEMES)
        return;
    if (layer) {
        css = `@layer ${CSS.escape(layer)} { ${css} }`;
    }
    let injections = injectionState.map.get(styleContainer);
    if (!injections) {
        injections = [];
        injectionState.map.set(styleContainer, injections);
    }
    if (injections.find((i) => i.css === css))
        return;
    const el = document.createElement('style');
    if (nonce) {
        el.setAttribute('nonce', nonce);
    }
    el.dataset.agGlobalCss = debugId;
    el.textContent = css;
    const newInjection = { css, el, priority };
    let insertAfter;
    for (const injection of injections) {
        if (injection.priority > priority)
            break;
        insertAfter = injection;
    }
    if (insertAfter) {
        insertAfter.el.insertAdjacentElement('afterend', el);
        const index = injections.indexOf(insertAfter);
        injections.splice(index + 1, 0, newInjection);
    }
    else {
        styleContainer.insertBefore(el, styleContainer.querySelector(':not(title, meta)'));
        injections.push(newInjection);
    }
};
exports._injectGlobalCSS = _injectGlobalCSS;
const _injectCoreAndModuleCSS = (styleContainer, layer, nonce) => {
    (0, exports._injectGlobalCSS)(core_css_GENERATED_1.coreCSS, styleContainer, 'core', layer, 0, nonce);
    Array.from((0, moduleRegistry_1._getAllRegisteredModules)())
        .sort((a, b) => a.moduleName.localeCompare(b.moduleName))
        .forEach((module) => module.css?.forEach((css) => (0, exports._injectGlobalCSS)(css, styleContainer, `module-${module.moduleName}`, layer, 0, nonce)));
};
exports._injectCoreAndModuleCSS = _injectCoreAndModuleCSS;
const _registerGridUsingThemingAPI = (environment) => {
    injectionState.grids.add(environment);
};
exports._registerGridUsingThemingAPI = _registerGridUsingThemingAPI;
const _unregisterGridUsingThemingAPI = (environment) => {
    injectionState.grids.delete(environment);
    if (injectionState.grids.size === 0) {
        injectionState.map = new WeakMap();
        for (const style of document.head.querySelectorAll('style[data-ag-global-css]')) {
            style.remove();
        }
    }
};
exports._unregisterGridUsingThemingAPI = _unregisterGridUsingThemingAPI;
// AG-14716 - for customers using module federation, there may be many
// instances of this module, but we want to ensure that there is only
// one instance of the container to injection map per window otherwise
// unmounting any grid instance will clear all styles from the page
// resulting in unstyled grids
const injectionState = ((_a = (typeof window === 'object'
    ? window
    : {})).agStyleInjectionState ?? (_a.agStyleInjectionState = {
    map: new WeakMap(),
    grids: new Set(),
}));


/***/ }),

/***/ 40847:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.batchEditStyleDefaultCSS = void 0;
exports.batchEditStyleDefaultCSS = `.ag-cell-batch-edit{background-color:var(--ag-cell-batch-edit-background-color);color:var(--ag-cell-batch-edit-text-color);display:inherit}.ag-row-batch-edit{background-color:var(--ag-row-batch-edit-background-color);color:var(--ag-row-batch-edit-text-color)}`;


/***/ }),

/***/ 51017:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.darkBatchEditStyleBase = exports.batchEditStyleBase = exports.baseDarkBatchEditParams = void 0;
const Part_1 = __webpack_require__(86607);
const batch_edit_style_default_css_GENERATED_1 = __webpack_require__(40847);
const baseParams = {
    cellBatchEditBackgroundColor: 'rgba(220 181 139 / 16%)',
    cellBatchEditTextColor: '#422f00',
    rowBatchEditBackgroundColor: {
        ref: 'cellBatchEditBackgroundColor',
    },
    rowBatchEditTextColor: {
        ref: 'cellBatchEditTextColor',
    },
};
exports.baseDarkBatchEditParams = {
    ...baseParams,
    cellBatchEditTextColor: '#f3d0b3',
};
const makeBatchEditStyleBaseTreeShakeable = () => (0, Part_1.createPart)({
    feature: 'batchEditStyle',
    params: baseParams,
    css: batch_edit_style_default_css_GENERATED_1.batchEditStyleDefaultCSS,
});
exports.batchEditStyleBase = makeBatchEditStyleBaseTreeShakeable();
const makeDarkBatchEditStyleBaseTreeShakeable = () => (0, Part_1.createPart)({
    feature: 'batchEditStyle',
    params: exports.baseDarkBatchEditParams,
    css: batch_edit_style_default_css_GENERATED_1.batchEditStyleDefaultCSS,
});
exports.darkBatchEditStyleBase = 
/*#__PURE__*/ makeDarkBatchEditStyleBaseTreeShakeable();


/***/ }),

/***/ 57753:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buttonStyleBaseCSS = void 0;
exports.buttonStyleBaseCSS = `:where(.ag-button){background:none;border:none;color:inherit;cursor:pointer;font-family:inherit;font-size:inherit;font-weight:inherit;letter-spacing:inherit;line-height:inherit;margin:0;padding:0;text-indent:inherit;text-shadow:inherit;text-transform:inherit;word-spacing:inherit;&:disabled{cursor:default}&:focus-visible{box-shadow:var(--ag-focus-shadow);outline:none}}.ag-standard-button{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:var(--ag-button-background-color);border:var(--ag-button-border);border-radius:var(--ag-button-border-radius);color:var(--ag-button-text-color);cursor:pointer;font-weight:var(--ag-button-font-weight);padding:var(--ag-button-vertical-padding) var(--ag-button-horizontal-padding);&:hover{background-color:var(--ag-button-hover-background-color);border:var(--ag-button-hover-border);color:var(--ag-button-hover-text-color)}&:active{background-color:var(--ag-button-active-background-color);border:var(--ag-button-active-border);color:var(--ag-button-active-text-color)}&:disabled{background-color:var(--ag-button-disabled-background-color);border:var(--ag-button-disabled-border);color:var(--ag-button-disabled-text-color)}}`;


/***/ }),

/***/ 82475:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buttonStyleBalham = exports.buttonStyleAlpine = exports.buttonStyleQuartz = exports.buttonStyleBase = void 0;
const Part_1 = __webpack_require__(86607);
const theme_utils_1 = __webpack_require__(77845);
const button_style_base_css_GENERATED_1 = __webpack_require__(57753);
const baseParams = {
    buttonTextColor: 'inherit',
    buttonFontWeight: 'normal',
    buttonBackgroundColor: 'transparent',
    buttonBorder: false,
    buttonBorderRadius: { ref: 'borderRadius' },
    buttonHorizontalPadding: { calc: 'spacing * 2' },
    buttonVerticalPadding: { ref: 'spacing' },
    buttonHoverTextColor: { ref: 'buttonTextColor' },
    buttonHoverBackgroundColor: { ref: 'buttonBackgroundColor' },
    buttonHoverBorder: { ref: 'buttonBorder' },
    buttonActiveTextColor: { ref: 'buttonHoverTextColor' },
    buttonActiveBackgroundColor: { ref: 'buttonHoverBackgroundColor' },
    buttonActiveBorder: { ref: 'buttonHoverBorder' },
    buttonDisabledTextColor: { ref: 'inputDisabledTextColor' },
    buttonDisabledBackgroundColor: { ref: 'inputDisabledBackgroundColor' },
    buttonDisabledBorder: { ref: 'inputDisabledBorder' },
};
const makeButtonStyleBaseTreeShakeable = () => (0, Part_1.createPart)({
    feature: 'buttonStyle',
    params: baseParams,
    css: button_style_base_css_GENERATED_1.buttonStyleBaseCSS,
});
exports.buttonStyleBase = makeButtonStyleBaseTreeShakeable();
const makeButtonStyleQuartzTreeShakeable = () => (0, Part_1.createPart)({
    feature: 'buttonStyle',
    params: {
        ...baseParams,
        buttonBackgroundColor: theme_utils_1.backgroundColor,
        buttonBorder: true,
        buttonHoverBackgroundColor: { ref: 'rowHoverColor' },
        buttonActiveBorder: { color: theme_utils_1.accentColor },
    },
    css: button_style_base_css_GENERATED_1.buttonStyleBaseCSS,
});
exports.buttonStyleQuartz = makeButtonStyleQuartzTreeShakeable();
const makeButtonStyleAlpineTreeShakeable = () => (0, Part_1.createPart)({
    feature: 'buttonStyle',
    params: {
        ...baseParams,
        buttonBackgroundColor: theme_utils_1.backgroundColor,
        buttonBorder: { color: theme_utils_1.accentColor },
        buttonFontWeight: 600,
        buttonTextColor: theme_utils_1.accentColor,
        buttonHoverBackgroundColor: { ref: 'rowHoverColor' },
        buttonActiveBackgroundColor: theme_utils_1.accentColor,
        buttonActiveTextColor: theme_utils_1.backgroundColor,
    },
    css: button_style_base_css_GENERATED_1.buttonStyleBaseCSS,
});
exports.buttonStyleAlpine = makeButtonStyleAlpineTreeShakeable();
const makeButtonStyleBalhamTreeShakeable = () => (0, Part_1.createPart)({
    feature: 'buttonStyle',
    params: {
        ...baseParams,
        buttonBorder: { color: theme_utils_1.foregroundColor, width: 2, style: 'outset' },
        buttonActiveBorder: { color: theme_utils_1.foregroundColor, width: 2, style: 'inset' },
        buttonBackgroundColor: (0, theme_utils_1.foregroundBackgroundMix)(0.07),
        buttonHoverBackgroundColor: theme_utils_1.backgroundColor,
        buttonVerticalPadding: { calc: 'spacing * 0.5' },
    },
    css: button_style_base_css_GENERATED_1.buttonStyleBaseCSS,
});
exports.buttonStyleBalham = makeButtonStyleBalhamTreeShakeable();


/***/ }),

/***/ 63071:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkboxStyleDefaultCSS = void 0;
exports.checkboxStyleDefaultCSS = `.ag-checkbox-input-wrapper,.ag-radio-button-input-wrapper{background-color:var(--ag-checkbox-unchecked-background-color);border:solid var(--ag-checkbox-border-width) var(--ag-checkbox-unchecked-border-color);flex:none;height:var(--ag-icon-size);position:relative;width:var(--ag-icon-size);:where(input){-webkit-appearance:none;-moz-appearance:none;appearance:none;cursor:pointer;display:block;height:var(--ag-icon-size);margin:0;opacity:0;width:var(--ag-icon-size)}&:after{content:"";display:block;inset:0;-webkit-mask-position:center;mask-position:center;-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;pointer-events:none;position:absolute}&:where(.ag-checked){background-color:var(--ag-checkbox-checked-background-color);border-color:var(--ag-checkbox-checked-border-color);&:after{background-color:var(--ag-checkbox-checked-shape-color)}}&:where(:focus-within,:active){box-shadow:var(--ag-focus-shadow)}&:where(.ag-disabled){filter:grayscale();opacity:.5}}.ag-checkbox-input-wrapper{border-radius:var(--ag-checkbox-border-radius);&:where(.ag-checked):after{-webkit-mask-image:var(--ag-checkbox-checked-shape-image);mask-image:var(--ag-checkbox-checked-shape-image)}&:where(.ag-indeterminate){background-color:var(--ag-checkbox-indeterminate-background-color);border-color:var(--ag-checkbox-indeterminate-border-color);&:after{background-color:var(--ag-checkbox-indeterminate-shape-color);-webkit-mask-image:var(--ag-checkbox-indeterminate-shape-image);mask-image:var(--ag-checkbox-indeterminate-shape-image)}}}.ag-cell-editing-error .ag-checkbox-input-wrapper:focus-within{box-shadow:var(--ag-focus-error-shadow)}.ag-radio-button-input-wrapper{border-radius:100%;&:where(.ag-checked):after{-webkit-mask-image:var(--ag-radio-checked-shape-image);mask-image:var(--ag-radio-checked-shape-image)}}`;


/***/ }),

/***/ 98265:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkboxStyleDefault = void 0;
const Part_1 = __webpack_require__(86607);
const theme_utils_1 = __webpack_require__(77845);
const checkbox_style_default_css_GENERATED_1 = __webpack_require__(63071);
const makeCheckboxStyleDefaultTreeShakeable = () => (0, Part_1.createPart)({
    feature: 'checkboxStyle',
    params: {
        checkboxBorderWidth: 1,
        checkboxBorderRadius: {
            ref: 'borderRadius',
        },
        checkboxUncheckedBackgroundColor: theme_utils_1.backgroundColor,
        checkboxUncheckedBorderColor: (0, theme_utils_1.foregroundBackgroundMix)(0.3),
        checkboxCheckedBackgroundColor: theme_utils_1.accentColor,
        checkboxCheckedBorderColor: { ref: 'checkboxCheckedBackgroundColor' },
        checkboxCheckedShapeImage: {
            svg: '<svg xmlns="http://www.w3.org/2000/svg" width="10" height="7" fill="none"><path stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.75" d="M1 3.5 3.5 6l5-5"/></svg>',
        },
        checkboxCheckedShapeColor: theme_utils_1.backgroundColor,
        checkboxIndeterminateBackgroundColor: (0, theme_utils_1.foregroundBackgroundMix)(0.3),
        checkboxIndeterminateBorderColor: { ref: 'checkboxIndeterminateBackgroundColor' },
        checkboxIndeterminateShapeImage: {
            svg: '<svg xmlns="http://www.w3.org/2000/svg" width="10" height="2" fill="none"><rect width="10" height="2" fill="#000" rx="1"/></svg>',
        },
        checkboxIndeterminateShapeColor: theme_utils_1.backgroundColor,
        radioCheckedShapeImage: {
            svg: '<svg xmlns="http://www.w3.org/2000/svg" width="6" height="6" fill="none"><circle cx="3" cy="3" r="3" fill="#000"/></svg>',
        },
    },
    css: checkbox_style_default_css_GENERATED_1.checkboxStyleDefaultCSS,
});
exports.checkboxStyleDefault = makeCheckboxStyleDefaultTreeShakeable();


/***/ }),

/***/ 38689:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.colorSchemeVariable = exports.colorSchemeDarkBlue = exports.colorSchemeDarkWarm = exports.colorSchemeDark = exports.colorSchemeLightCold = exports.colorSchemeLightWarm = exports.colorSchemeLight = void 0;
const Part_1 = __webpack_require__(86607);
const core_css_1 = __webpack_require__(405);
const theme_utils_1 = __webpack_require__(77845);
const batch_edit_styles_1 = __webpack_require__(51017);
const makeColorSchemeLightTreeShakeable = () => (0, Part_1.createPart)({
    feature: 'colorScheme',
    params: core_css_1.defaultLightColorSchemeParams,
});
exports.colorSchemeLight = makeColorSchemeLightTreeShakeable();
const makeColorSchemeLightWarmTreeShakeable = () => (0, Part_1.createPart)({
    feature: 'colorScheme',
    params: {
        ...core_css_1.defaultLightColorSchemeParams,
        foregroundColor: '#000000de',
        borderColor: '#60300026',
        chromeBackgroundColor: '#60300005',
    },
});
exports.colorSchemeLightWarm = makeColorSchemeLightWarmTreeShakeable();
const makeColorSchemeLightColdTreeShakeable = () => (0, Part_1.createPart)({
    feature: 'colorScheme',
    params: {
        ...core_css_1.defaultLightColorSchemeParams,
        foregroundColor: '#000',
        chromeBackgroundColor: '#f3f8f8',
    },
});
exports.colorSchemeLightCold = makeColorSchemeLightColdTreeShakeable();
const darkParams = () => ({
    ...core_css_1.defaultLightColorSchemeParams,
    ...batch_edit_styles_1.baseDarkBatchEditParams,
    backgroundColor: 'hsl(217, 0%, 17%)',
    foregroundColor: '#FFF',
    chromeBackgroundColor: (0, theme_utils_1.foregroundBackgroundMix)(0.05),
    rowHoverColor: (0, theme_utils_1.accentMix)(0.15),
    selectedRowBackgroundColor: (0, theme_utils_1.accentMix)(0.2),
    menuBackgroundColor: (0, theme_utils_1.foregroundBackgroundMix)(0.1),
    browserColorScheme: 'dark',
    popupShadow: '0 0px 20px #000A',
    cardShadow: '0 1px 4px 1px #000A',
    advancedFilterBuilderJoinPillColor: '#7a3a37',
    advancedFilterBuilderColumnPillColor: '#355f2d',
    advancedFilterBuilderOptionPillColor: '#5a3168',
    advancedFilterBuilderValuePillColor: '#374c86',
    filterPanelApplyButtonColor: theme_utils_1.foregroundColor,
    findMatchColor: theme_utils_1.backgroundColor,
    findActiveMatchColor: theme_utils_1.backgroundColor,
    checkboxUncheckedBorderColor: (0, theme_utils_1.foregroundBackgroundMix)(0.4),
    toggleButtonOffBackgroundColor: (0, theme_utils_1.foregroundBackgroundMix)(0.4),
    rowBatchEditBackgroundColor: (0, theme_utils_1.foregroundBackgroundMix)(0.1),
});
const makeColorSchemeDarkTreeShakeable = () => (0, Part_1.createPart)({
    feature: 'colorScheme',
    params: darkParams(),
});
exports.colorSchemeDark = makeColorSchemeDarkTreeShakeable();
const makeColorSchemeDarkWarmTreeShakeable = () => (0, Part_1.createPart)({
    feature: 'colorScheme',
    params: {
        backgroundColor: 'hsl(29, 10%, 17%)',
        foregroundColor: '#FFF',
        browserColorScheme: 'dark',
    },
});
const darkBlueParams = () => ({
    ...darkParams(),
    backgroundColor: '#1f2836',
});
exports.colorSchemeDarkWarm = makeColorSchemeDarkWarmTreeShakeable();
const makeColorSchemeDarkBlueTreeShakeable = () => (0, Part_1.createPart)({
    feature: 'colorScheme',
    params: darkBlueParams(),
});
exports.colorSchemeDarkBlue = makeColorSchemeDarkBlueTreeShakeable();
const makeColorSchemeVariableTreeShakeable = () => (0, Part_1.createPart)({
    feature: 'colorScheme',
    params: core_css_1.defaultLightColorSchemeParams,
    modeParams: {
        light: core_css_1.defaultLightColorSchemeParams,
        dark: darkParams(),
        'dark-blue': darkBlueParams(),
    },
});
exports.colorSchemeVariable = makeColorSchemeVariableTreeShakeable();


/***/ }),

/***/ 27941:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.columnDropStyleBorderedCSS = void 0;
exports.columnDropStyleBorderedCSS = `.ag-column-drop-vertical-empty-message{align-items:center;border:dashed var(--ag-border-width);border-color:var(--ag-border-color);display:flex;inset:0;justify-content:center;margin:calc(var(--ag-spacing)*1.5) calc(var(--ag-spacing)*2);overflow:hidden;padding:calc(var(--ag-spacing)*2);position:absolute}`;


/***/ }),

/***/ 75350:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.columnDropStylePlainCSS = void 0;
exports.columnDropStylePlainCSS = `.ag-column-drop-vertical-empty-message{color:var(--ag-subtle-text-color);font-size:calc(var(--ag-font-size) - 1px);font-weight:600;padding-top:var(--ag-spacing)}:where(.ag-ltr) .ag-column-drop-vertical-empty-message{padding-left:calc(var(--ag-icon-size) + var(--ag-spacing) + var(--ag-widget-horizontal-spacing));padding-right:var(--ag-spacing)}:where(.ag-rtl) .ag-column-drop-vertical-empty-message{padding-left:var(--ag-spacing);padding-right:calc(var(--ag-icon-size) + var(--ag-spacing) + var(--ag-widget-horizontal-spacing))}`;


/***/ }),

/***/ 21697:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.columnDropStylePlain = exports.columnDropStyleBordered = void 0;
const Part_1 = __webpack_require__(86607);
const column_drop_style_bordered_css_GENERATED_1 = __webpack_require__(27941);
const column_drop_style_plain_css_GENERATED_1 = __webpack_require__(75350);
const makeColumnDropStyleBorderedTreeShakeable = () => {
    return (0, Part_1.createPart)({
        feature: 'columnDropStyle',
        css: column_drop_style_bordered_css_GENERATED_1.columnDropStyleBorderedCSS,
    });
};
exports.columnDropStyleBordered = makeColumnDropStyleBorderedTreeShakeable();
const makeColumnDropStylePlainTreeShakeable = () => {
    return (0, Part_1.createPart)({
        feature: 'columnDropStyle',
        css: column_drop_style_plain_css_GENERATED_1.columnDropStylePlainCSS,
    });
};
exports.columnDropStylePlain = makeColumnDropStylePlainTreeShakeable();


/***/ }),

/***/ 38897:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.iconSetAlpineCSS = void 0;
exports.iconSetAlpineCSS = `.ag-icon-aggregation:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M24 6H8v2l8 8-8 8v2h16v-2H11l8-8-8-8h13z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-arrows:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M7.515 11.171 2.687 16l4.828 4.829-1.414 1.414L-.142 16l6.243-6.243zm16.97 0 1.414-1.414L32.142 16l-6.243 6.243-1.414-1.414L29.313 16zM16.028 13.2l2.829 2.828-2.829 2.829-2.828-2.829zm-4.857 11.285L16 29.313l4.829-4.828 1.414 1.414L16 32.142l-6.243-6.243zm0-16.97L9.757 6.101 16-.142l6.243 6.243-1.414 1.414L16 2.687z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-asc:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m5.333 16 1.88 1.88 7.453-7.44v16.227h2.667V10.44l7.44 7.453L26.666 16 15.999 5.333 5.332 16z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-cancel:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M16 2.667A13.32 13.32 0 0 0 2.667 16c0 7.373 5.96 13.333 13.333 13.333S29.333 23.373 29.333 16 23.373 2.667 16 2.667m6.667 18.12-1.88 1.88L16 17.88l-4.787 4.787-1.88-1.88L14.12 16l-4.787-4.787 1.88-1.88L16 14.12l4.787-4.787 1.88 1.88L17.88 16z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-chart:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Echart%3C/title%3E%3Cg fill='%23000' fill-rule='nonzero'%3E%3Cpath d='M14 7h4v18h-4zM8 17h4v8H8zM20 13h4v12h-4z'/%3E%3C/g%3E%3C/svg%3E")}.ag-icon-color-picker:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M23.907 17.587 10.574 4.254l-1.88 1.88 3.173 3.173-8.28 8.28 10.16 10.16zm-16.547 0 6.387-6.387 6.387 6.387zm18.387 2s-2.667 2.893-2.667 4.667c0 1.467 1.2 2.667 2.667 2.667s2.667-1.2 2.667-2.667c0-1.773-2.667-4.667-2.667-4.667' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-columns:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M26 25H6V7h20zM12 11H8v12h4zm6 0h-4v12h4zm6 12V11h-4v12z' style='fill-rule:nonzero' transform='translate(0 -1)'/%3E%3C/svg%3E")}.ag-icon-contracted:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m12 6 10 10-10 10-2-2 8-8-8-8z'/%3E%3C/svg%3E")}.ag-icon-copy:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M22 1.333H6A2.675 2.675 0 0 0 3.333 4v18.667H6V4h16zm4 5.334H11.333a2.675 2.675 0 0 0-2.667 2.667v18.667c0 1.467 1.2 2.667 2.667 2.667H26c1.467 0 2.667-1.2 2.667-2.667V9.334c0-1.467-1.2-2.667-2.667-2.667M26 28H11.333V9.333H26z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-cross:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M15.984 13.894 27.05 2.828l2.122 2.122-11.066 11.066 11.066 11.066-2.122 2.12-11.066-11.066L4.918 29.202l-2.12-2.12 11.066-11.066L2.798 4.95l2.12-2.122z'/%3E%3C/svg%3E")}.ag-icon-csv:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M384 131.9c-7.753-8.433-110.425-128.473-114.9-133L48-.1C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48zm-35.9 2.1H257V27.9zM30 479V27h200l1 105c0 13.3-1.3 29 12 29h111l1 318z' style='fill-rule:nonzero' transform='matrix(.06285 0 0 .06285 3.934 -.054)'/%3E%3Cpath d='M.688-.226a.2.2 0 0 1-.017.074.28.28 0 0 1-.145.14.412.412 0 0 1-.234.013.28.28 0 0 1-.202-.168.468.468 0 0 1-.04-.19q0-.086.025-.155a.319.319 0 0 1 .182-.191.4.4 0 0 1 .134-.025q.087 0 .155.035a.3.3 0 0 1 .104.085.17.17 0 0 1 .036.097.06.06 0 0 1-.018.044.06.06 0 0 1-.042.019.06.06 0 0 1-.042-.013.2.2 0 0 1-.031-.046.2.2 0 0 0-.066-.079.16.16 0 0 0-.095-.027.17.17 0 0 0-.142.068.3.3 0 0 0-.053.193.4.4 0 0 0 .023.139.2.2 0 0 0 .067.083.2.2 0 0 0 .1.027q.063 0 .106-.031a.2.2 0 0 0 .065-.091.2.2 0 0 1 .023-.046q.014-.018.044-.018a.06.06 0 0 1 .044.018.06.06 0 0 1 .019.045' style='fill-rule:nonzero' transform='matrix(8.39799 0 0 12.455 7.122 25.977)'/%3E%3Cpath d='M.622-.215a.2.2 0 0 1-.033.117.23.23 0 0 1-.098.081.4.4 0 0 1-.153.029.34.34 0 0 1-.175-.04.23.23 0 0 1-.079-.077.17.17 0 0 1-.031-.093q0-.027.019-.045a.06.06 0 0 1 .046-.019.06.06 0 0 1 .039.014.1.1 0 0 1 .027.044.3.3 0 0 0 .03.057q.015.023.044.038.03.015.076.015.065 0 .105-.03a.09.09 0 0 0 .04-.075.08.08 0 0 0-.022-.058.14.14 0 0 0-.056-.034 1 1 0 0 0-.092-.025.7.7 0 0 1-.129-.042.2.2 0 0 1-.083-.066.17.17 0 0 1-.03-.104q0-.058.032-.105a.2.2 0 0 1 .093-.07.4.4 0 0 1 .144-.025q.066 0 .114.016a.3.3 0 0 1 .08.044.2.2 0 0 1 .046.057q.015.03.015.058a.07.07 0 0 1-.018.046.06.06 0 0 1-.046.021q-.025 0-.038-.012a.2.2 0 0 1-.028-.041.2.2 0 0 0-.047-.063Q.387-.625.326-.625a.15.15 0 0 0-.09.025q-.035.024-.035.059 0 .021.012.037a.1.1 0 0 0 .032.027.4.4 0 0 0 .111.036q.06.015.11.031.048.018.083.042a.2.2 0 0 1 .054.062.2.2 0 0 1 .019.091' style='fill-rule:nonzero' transform='matrix(8.39799 0 0 12.455 13.339 25.977)'/%3E%3Cpath d='m.184-.633.162.48.163-.483q.013-.038.019-.053a.062.062 0 0 1 .061-.039q.018 0 .034.009a.1.1 0 0 1 .025.025q.009.015.009.031L.654-.64l-.007.025-.009.024-.173.468-.019.051a.2.2 0 0 1-.021.042.1.1 0 0 1-.033.03.1.1 0 0 1-.049.012.1.1 0 0 1-.05-.011A.1.1 0 0 1 .26-.03a.2.2 0 0 1-.021-.042L.22-.123.05-.587.041-.612.033-.638.03-.662q0-.025.02-.046a.07.07 0 0 1 .05-.02q.037 0 .053.023.015.023.031.072' style='fill-rule:nonzero' transform='matrix(8.39799 0 0 12.455 18.94 25.977)'/%3E%3C/svg%3E")}.ag-icon-cut:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M13.775 15.198 3.835 2.945a1.501 1.501 0 0 1 2.33-1.89l14.997 18.488A6.003 6.003 0 0 1 29.657 25c0 3.311-2.688 6-6 6s-6-2.689-6-6c0-1.335.437-2.569 1.176-3.566l-3.127-3.855-3.001 3.7A5.97 5.97 0 0 1 14 25c0 3.311-2.689 6-6 6s-6-2.689-6-6a6.003 6.003 0 0 1 8.315-5.536zm9.882 6.702a3.1 3.1 0 0 0-3.1 3.1c0 1.711 1.389 3.1 3.1 3.1s3.1-1.389 3.1-3.1-1.389-3.1-3.1-3.1M8 21.95a3.05 3.05 0 1 0 .001 6.101A3.05 3.05 0 0 0 8 21.95m9.63-11.505 1.932 2.381 8.015-9.881a1.5 1.5 0 0 0-2.329-1.89z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-desc:before,.ag-icon-down:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m26.667 16-1.88-1.88-7.453 7.44V5.333h-2.667V21.56l-7.44-7.453L5.334 16l10.667 10.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-excel:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M384 131.9c-7.753-8.433-110.425-128.473-114.9-133L48-.1C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48zm-35.9 2.1H257V27.9zM30 479V27h200l1 105c0 13.3-1.3 29 12 29h111l1 318z' style='fill-rule:nonzero' transform='matrix(.06285 0 0 .06285 3.934 -.054)'/%3E%3Cpath d='m.052-.139.16-.234-.135-.208a.4.4 0 0 1-.028-.052.1.1 0 0 1-.01-.042.05.05 0 0 1 .018-.037.07.07 0 0 1 .045-.016q.03 0 .047.018a1 1 0 0 1 .047.066l.107.174.115-.174.024-.038.019-.026.021-.015a.1.1 0 0 1 .027-.005.06.06 0 0 1 .044.016.05.05 0 0 1 .018.039q0 .033-.038.089l-.141.211.152.234a.3.3 0 0 1 .03.051.1.1 0 0 1 .009.038.1.1 0 0 1-.008.031.1.1 0 0 1-.024.023.1.1 0 0 1-.034.008.1.1 0 0 1-.035-.008.1.1 0 0 1-.023-.022L.427-.067.301-.265l-.134.204-.022.034-.016.019a.1.1 0 0 1-.022.015.1.1 0 0 1-.03.005.06.06 0 0 1-.044-.016.06.06 0 0 1-.017-.047q0-.036.036-.088' style='fill-rule:nonzero' transform='matrix(17.82892 0 0 16.50777 10.371 25.928)'/%3E%3C/svg%3E")}.ag-icon-expanded:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M20 26 10 16 20 6l2 2-8 8 8 8z'/%3E%3C/svg%3E")}.ag-icon-eye-slash:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Eeye-slash%3C/title%3E%3Cpath fill='%23000' fill-rule='nonzero' d='M8.95 10.364 7 8.414 8.414 7l2.32 2.32A13.2 13.2 0 0 1 16.5 8c5.608 0 10.542 3.515 12.381 8.667L29 17l-.119.333a13 13 0 0 1-4.255 5.879l1.466 1.466-1.414 1.414-1.754-1.753A13.2 13.2 0 0 1 16.5 26c-5.608 0-10.542-3.515-12.381-8.667L4 17l.119-.333a13 13 0 0 1 4.83-6.303m1.445 1.445A11.02 11.02 0 0 0 6.148 17c1.646 4.177 5.728 7 10.352 7 1.76 0 3.441-.409 4.94-1.146l-1.878-1.878A5.06 5.06 0 0 1 16.5 22c-2.789 0-5.05-2.239-5.05-5 0-1.158.398-2.223 1.065-3.07zm1.855-.974 1.794 1.795A5.07 5.07 0 0 1 16.5 12c2.789 0 5.05 2.239 5.05 5 0 .9-.24 1.745-.661 2.474l2.305 2.306A11 11 0 0 0 26.852 17c-1.646-4.177-5.728-7-10.352-7-1.495 0-2.933.295-4.25.835'/%3E%3C/svg%3E")}.ag-icon-eye:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M16.5 23c4.624 0 8.706-2.823 10.352-7-1.646-4.177-5.728-7-10.352-7s-8.706 2.823-10.352 7c1.646 4.177 5.728 7 10.352 7M4.119 15.667C5.958 10.515 10.892 7 16.5 7s10.542 3.515 12.381 8.667L29 16l-.119.333C27.042 21.485 22.108 25 16.5 25S5.958 21.485 4.119 16.333L4 16zM16.5 21c2.789 0 5.049-2.239 5.049-5s-2.26-5-5.049-5-5.049 2.239-5.049 5 2.26 5 5.049 5' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-filter:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m28 8-8 8v5l-6 6V16L6 8V6h22zM9 8l7 7v7l2-2v-5l7-7z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-first:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M24.273 22.12 18.153 16l6.12-6.12L22.393 8l-8 8 8 8zM7.727 8h2.667v16H7.727z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-group:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M14 7v1H9V7zm0-3v1H5.001V4zm-7 7H5v-1h2zm0-3H5V7h2zM3 5H1V4h2zm11 5v1H9v-1zm-7 4H5v-1h2zm7-1v1H9v-1z' style='fill-rule:nonzero' transform='matrix(2 0 0 2 0 -2)'/%3E%3C/svg%3E")}.ag-icon-last:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m7.727 9.88 6.12 6.12-6.12 6.12L9.607 24l8-8-8-8zM21.607 8h2.667v16h-2.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-left:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M26.667 14.667H10.44l7.453-7.453L16 5.334 5.333 16.001 16 26.668l1.88-1.88-7.44-7.453h16.227z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-linked:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M5.2 16a4.136 4.136 0 0 1 4.133-4.133h5.333V9.334H9.333a6.67 6.67 0 0 0-6.667 6.667 6.67 6.67 0 0 0 6.667 6.667h5.333v-2.533H9.333A4.136 4.136 0 0 1 5.2 16.002zm5.467 1.333h10.667v-2.667H10.667zm12-8h-5.333v2.533h5.333a4.136 4.136 0 0 1 4.133 4.133 4.136 4.136 0 0 1-4.133 4.133h-5.333v2.533h5.333a6.67 6.67 0 0 0 6.667-6.667 6.67 6.67 0 0 0-6.667-6.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-loading:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M17 29h-2v-8h2zm-3.586-9L7 26.414 5.586 25 12 18.586zm13 5L25 26.414 18.586 20 20 18.586zM29 17h-8v-2h8zm-18 0H3v-2h8zm2.414-5L12 13.414 5.586 7 7 5.586zm13-5L20 13.414 18.586 12 25 5.586zM17 11h-2V3h2z' style='fill-rule:nonzero' transform='translate(-3.692 -3.692)scale(1.23077)'/%3E%3C/svg%3E")}.ag-icon-maximize:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M14 30H2V18h2.828v7.05l8.254-8.252 2.12 2.12-8.252 8.254H14zm4-28h12v12h-2.828V6.95l-8.254 8.252-2.12-2.12 8.252-8.254H18z'/%3E%3C/svg%3E")}.ag-icon-menu:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M20 13H0v-2h20zm0-6H0V5h20zm0-6H0v-2h20z' style='fill-rule:nonzero' transform='translate(6 9)'/%3E%3C/svg%3E")}.ag-icon-menu-alt:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='%23000' d='M16 19a3 3 0 1 0 0-6 3 3 0 0 0 0 6M16 11a3 3 0 1 0 0-6 3 3 0 0 0 0 6M16 27a3 3 0 1 0 0-6 3 3 0 0 0 0 6'/%3E%3C/svg%3E")}.ag-icon-minimize:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M2 18h12v12h-2.828v-7.05l-8.254 8.252-2.12-2.12 8.252-8.254H2zm28-4H18V2h2.828v7.05L29.082.798l2.12 2.12-8.252 8.254H30z'/%3E%3C/svg%3E")}.ag-icon-minus:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M6.572 6.572a13.32 13.32 0 0 0 0 18.856 13.32 13.32 0 0 0 18.856 0 13.32 13.32 0 0 0 0-18.856 13.32 13.32 0 0 0-18.856 0m17.527 8.099v2.658H7.901v-2.658z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-next:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M10.94 6 9.06 7.88 17.167 16 9.06 24.12 10.94 26l10-10z' style='fill-rule:nonzero' transform='translate(1)'/%3E%3C/svg%3E")}.ag-icon-none:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Enone%3C/title%3E%3Cg fill='%23000' fill-rule='nonzero'%3E%3Cpath d='M23.708 14.645 16 6.939l-7.708 7.706 1.416 1.416L16 9.767l6.292 6.294zM23.708 20.355 16 28.061l-7.708-7.706 1.416-1.416L16 25.233l6.292-6.294z'/%3E%3C/g%3E%3C/svg%3E")}.ag-icon-not-allowed:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M16 2.667C8.64 2.667 2.667 8.64 2.667 16S8.64 29.333 16 29.333 29.333 23.36 29.333 16 23.36 2.667 16 2.667M5.333 16c0-5.893 4.773-10.667 10.667-10.667 2.467 0 4.733.84 6.533 2.253L7.586 22.533A10.54 10.54 0 0 1 5.333 16M16 26.667c-2.467 0-4.733-.84-6.533-2.253L24.414 9.467A10.54 10.54 0 0 1 26.667 16c0 5.893-4.773 10.667-10.667 10.667' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-paste:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M25.334 4H19.76C19.2 2.453 17.733 1.333 16 1.333S12.8 2.453 12.24 4H6.667A2.675 2.675 0 0 0 4 6.667V28c0 1.467 1.2 2.667 2.667 2.667h18.667c1.467 0 2.667-1.2 2.667-2.667V6.667C28.001 5.2 26.801 4 25.334 4M16 4c.733 0 1.333.6 1.333 1.333s-.6 1.333-1.333 1.333-1.333-.6-1.333-1.333S15.267 4 16 4m9.333 24H6.666V6.667h2.667v4h13.333v-4h2.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-pin:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m10.78 19.777-4.668-4.666s.032-1 .67-1.87c1.366-1.86 4.052-1.96 6.056-1.572l3.158-3.108c-.7-2.342 3.352-5.046 3.352-5.046l9.166 9.168q-.334.447-.67.894c-1.074 1.426-2.538 2.63-4.272 2.338l-3.32 3.218c.046.344.042.03.118 1.152.144 2.13-.64 4.324-2.632 5.34l-.746.364-4.798-4.798-7.292 7.294-1.416-1.416zm8.24-13.672c-.688.568-1.416 1.45-1.024 2.072l.49.722-4.986 4.988c-1.988-.506-4.346-.636-5.156.614l9.02 9.032q.14-.099.272-.21c1.226-1.08.764-3.04.498-4.9l4.79-4.79s1.47.938 2.936-.776l-6.79-6.79q-.026.019-.05.038' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-pivot:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M25.128 2.002c2.56.096 4.772 2.292 4.87 4.87a712 712 0 0 1 0 18.256c-.096 2.56-2.292 4.772-4.87 4.87a712 712 0 0 1-18.256 0c-2.558-.096-4.772-2.29-4.87-4.87a712 712 0 0 1 0-18.256c.096-2.56 2.292-4.772 4.87-4.87a712 712 0 0 1 18.256 0m2.966 7.954H9.892v18.136c5.086.13 10.18.098 15.264-.096 1.48-.094 2.746-1.35 2.84-2.84.192-5.064.226-10.134.098-15.2M3.968 24.1q.015.528.036 1.056c.094 1.484 1.354 2.746 2.84 2.84l1.012.036V24.1zM22 15.414l-.292.294-1.416-1.416L23 11.586l2.708 2.706-1.416 1.416-.292-.294v3.592c-.032 2.604-2.246 4.892-4.872 4.992L15.414 24l.294.292-1.416 1.416L11.586 23l2.706-2.708 1.416 1.416-.322.32c3.372.03 6.578-.164 6.614-3.034zM3.88 18.038c.002 1.346.012 2.694.038 4.04h3.938v-4.04zm.05-6.062a681 681 0 0 0-.044 4.042h3.97v-4.042zm5.962-7.99Q8.449 3.999 7.006 4c-1.57.02-2.946 1.348-3.004 2.922q-.02 1.517-.042 3.034h3.896v-2.02h2.036zm14.244-.016v3.966h3.898q-.017-.546-.038-1.092c-.094-1.48-1.35-2.746-2.84-2.84q-.51-.019-1.02-.034m-8.14-.054q-2.035.022-4.07.048v3.972h4.07zm6.106.008a213 213 0 0 0-4.07-.022v4.034h4.07z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-plus:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M6.572 6.572a13.32 13.32 0 0 0 0 18.856 13.32 13.32 0 0 0 18.856 0 13.32 13.32 0 0 0 0-18.856 13.32 13.32 0 0 0-18.856 0m17.527 8.099v2.658h-6.77v6.77h-2.658v-6.77h-6.77v-2.658h6.77v-6.77h2.658v6.77z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-previous:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M21.94 7.88 20.06 6l-10 10 10 10 1.88-1.88L13.833 16z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-right:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m16 5.333-1.88 1.88 7.44 7.453H5.333v2.667H21.56l-7.44 7.453 1.88 1.88 10.667-10.667L16 5.332z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-save:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M15.708 2.355 8 10.061.292 2.355 1.708.939 8 7.233 14.292.939z' style='fill-rule:nonzero' transform='translate(8 14)'/%3E%3Cpath d='M5 26h22v2H5zM15 4h2v18h-2z'/%3E%3C/svg%3E")}.ag-icon-small-down:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M7.334 10.667 16 21.334l8.667-10.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-small-left:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M21.333 7.334 10.666 16l10.667 8.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-small-right:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M10.667 24.666 21.334 16 10.667 7.333z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-small-up:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M7.334 21.333 16 10.666l8.667 10.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-tick:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M11.586 22.96 27.718 6.828 29.84 8.95 11.586 27.202 2.4 18.016l2.12-2.122z'/%3E%3C/svg%3E")}.ag-icon-tree-closed:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m11.94 6-1.88 1.88L18.167 16l-8.107 8.12L11.94 26l10-10z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-tree-indeterminate:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M6 13.5h20v3H6z'/%3E%3C/svg%3E")}.ag-icon-tree-open:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M24.12 9.06 16 17.167 7.88 9.06 6 10.94l10 10 10-10z' style='fill-rule:nonzero' transform='translate(0 1)'/%3E%3C/svg%3E")}.ag-icon-unlinked:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M22.667 9.333h-5.333v2.533h5.333a4.136 4.136 0 0 1 4.133 4.133c0 1.907-1.307 3.507-3.08 3.973l1.947 1.947c2.173-1.107 3.667-3.32 3.667-5.92a6.67 6.67 0 0 0-6.667-6.667zm-1.334 5.334h-2.92l2.667 2.667h.253zM2.667 5.693 6.814 9.84A6.65 6.65 0 0 0 2.667 16a6.67 6.67 0 0 0 6.667 6.667h5.333v-2.533H9.334a4.136 4.136 0 0 1-4.133-4.133c0-2.12 1.613-3.867 3.68-4.093l2.76 2.76h-.973v2.667h3.64l3.027 3.027v2.307h2.307l5.347 5.333 1.68-1.68L4.362 4.002 2.669 5.695z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-up:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m5.333 16 1.88 1.88 7.453-7.44v16.227h2.667V10.44l7.44 7.453L26.666 16 15.999 5.333 5.332 16z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-grip:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M8 24H6v-4h2zm6 0h-2v-4h2zm6 0h-2v-4h2zm6 0h-2v-4h2zM8 18H6v-4h2zm6 0h-2v-4h2zm6 0h-2v-4h2zm6 0h-2v-4h2zM8 12H6V8h2zm6 0h-2V8h2zm6 0h-2V8h2zm6 0h-2V8h2z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-settings:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='%23000' d='M30 8h-4.1c-.5-2.3-2.5-4-4.9-4s-4.4 1.7-4.9 4H2v2h14.1c.5 2.3 2.5 4 4.9 4s4.4-1.7 4.9-4H30zm-9 4c-1.7 0-3-1.3-3-3s1.3-3 3-3 3 1.3 3 3-1.3 3-3 3M2 24h4.1c.5 2.3 2.5 4 4.9 4s4.4-1.7 4.9-4H30v-2H15.9c-.5-2.3-2.5-4-4.9-4s-4.4 1.7-4.9 4H2zm9-4c1.7 0 3 1.3 3 3s-1.3 3-3 3-3-1.3-3-3 1.3-3 3-3'/%3E%3C/svg%3E")}.ag-icon-column-arrow:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='currentColor' fill-rule='evenodd' d='M11 4a1 1 0 0 1 1 1v22a1 1 0 1 1-2 0V5a1 1 0 0 1 1-1' clip-rule='evenodd'/%3E%3Cpath fill='currentColor' fill-rule='evenodd' d='M2 13a1 1 0 0 1 1-1h23.5a1 1 0 1 1 0 2H3a1 1 0 0 1-1-1' clip-rule='evenodd'/%3E%3Cpath fill='currentColor' fill-rule='evenodd' d='M2 4h18v24H2zm2 2v20h14V6zM26.793 13 23 9.207l1.414-1.414L29.621 13l-5.207 5.207L23 16.793z' clip-rule='evenodd'/%3E%3C/svg%3E")}.ag-icon-un-pin:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='currentColor' fill-rule='evenodd' d='m6.112 15.111 3.272 3.271 1.436-1.402-2.476-2.479c.81-1.25 3.168-1.12 5.156-.614l4.986-4.988-.49-.722c-.392-.622.336-1.504 1.024-2.072l.008-.007.01-.006.032-.025 1.447 1.447 1.432-1.397-2.601-2.602s-4.052 2.704-3.352 5.046l-3.158 3.108c-2.004-.388-4.69-.288-6.056 1.572-.638.87-.67 1.87-.67 1.87m.581 11.582.014.014 5.502-5.501 4.783 4.783.746-.364c1.992-1.016 2.776-3.21 2.632-5.34-.055-.805-.068-.87-.088-.97-.008-.04-.017-.085-.03-.182l3.32-3.218c1.734.292 3.198-.912 4.272-2.338q.337-.447.67-.894l-.001-.001-.007-.007-.007-.007-.007-.007-3.87-3.87 1.585-1.584-1.414-1.414-14.381 14.38-1.237 1.209-5.69 5.687 1.417 1.416zM23.21 10.206l2.65 2.651c-1.465 1.714-2.935.776-2.935.776l-4.79 4.79q.041.291.087.583c.257 1.676.513 3.35-.585 4.317a4 4 0 0 1-.272.21l-3.739-3.744z' clip-rule='evenodd'/%3E%3C/svg%3E")}.ag-icon-pinned-top:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='currentColor' d='m16.708 10.878 8.708 8.706L24 21l-6.292-6.294V27h-2V14.706L9.416 21 8 19.584q4.348-4.344 8.691-8.69zM25 6H8v2h17z'/%3E%3C/svg%3E")}.ag-icon-pinned-bottom:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='currentColor' d='M16.708 22.122 8 13.416 9.416 12l6.292 6.294V6h2v12.294L24 12l1.416 1.416-8.691 8.69zM7.416 28h17v-2h-17z'/%3E%3C/svg%3E")}.ag-icon-chevron-up:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='none' viewBox='0 0 16 16'%3E%3Cpath fill='currentColor' fill-rule='evenodd' d='M3.479 10.521a.75.75 0 0 1 0-1.06l4-4a.75.75 0 0 1 1.06 0l4 4a.75.75 0 0 1-1.06 1.06l-3.47-3.47-3.47 3.47a.75.75 0 0 1-1.06 0' clip-rule='evenodd'/%3E%3C/svg%3E")}.ag-icon-chevron-down:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='none' viewBox='0 0 16 16'%3E%3Cpath fill='currentColor' fill-rule='evenodd' d='M12.521 5.461a.75.75 0 0 1 0 1.06l-4 4a.75.75 0 0 1-1.06 0l-4-4a.75.75 0 0 1 1.06-1.06l3.47 3.47 3.47-3.47a.75.75 0 0 1 1.06 0' clip-rule='evenodd'/%3E%3C/svg%3E")}.ag-icon-chevron-left:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='none' viewBox='0 0 16 16'%3E%3Cpath fill='currentColor' fill-rule='evenodd' d='M10.53 12.512a.75.75 0 0 1-1.06 0l-4-4a.75.75 0 0 1 0-1.06l4-4a.75.75 0 0 1 1.06 1.06l-3.47 3.47 3.47 3.47a.75.75 0 0 1 0 1.06' clip-rule='evenodd'/%3E%3C/svg%3E")}.ag-icon-chevron-right:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='none' viewBox='0 0 16 16'%3E%3Cpath fill='currentColor' fill-rule='evenodd' d='M5.47 3.47a.75.75 0 0 1 1.06 0l4 4a.75.75 0 0 1 0 1.06l-4 4a.75.75 0 0 1-1.06-1.06L8.94 8 5.47 4.53a.75.75 0 0 1 0-1.06' clip-rule='evenodd'/%3E%3C/svg%3E")}.ag-icon-filter-add:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='currentColor' d='M19.834 8H8c0 .304.06.612.258.842 2.716 2.854 6.682 5.548 6.742 7.974V21l2-1.5v-2.684c.056-2.267 2.968-4.417 5.49-6.75v3.087c-1.081.974-2.245 1.968-3.232 3.005a1.05 1.05 0 0 0-.258.682v3.66L13 25c0-2.74.066-5.482-.002-8.222a1.05 1.05 0 0 0-.256-.62C10.026 13.304 6.06 10.61 6 8.184V6h13.834z'/%3E%3Cpath fill='currentColor' d='M26 6h2.946v2.002H26v3.313h-2.002V8.002h-2.946V6h2.946V3.04H26z'/%3E%3C/svg%3E")}.ag-icon-edit:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='currentColor' d='M6.222 25.778h1.611l14.834-14.811-1.611-1.611-14.834 14.81zM4 28v-4.733L22.644 4.656a2.26 2.26 0 0 1 1.567-.634q.423 0 .833.167.412.166.734.478l1.589 1.6q.333.322.483.733t.15.822q0 .423-.161.839-.162.416-.472.728L8.733 28zm17.856-17.833-.8-.811 1.61 1.61z'/%3E%3C/svg%3E")}`;


/***/ }),

/***/ 89580:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.iconSetAlpine = void 0;
const Part_1 = __webpack_require__(86607);
const icon_set_alpine_css_GENERATED_1 = __webpack_require__(38897);
exports.iconSetAlpine = (0, Part_1.createPart)({
    feature: 'iconSet',
    css: icon_set_alpine_css_GENERATED_1.iconSetAlpineCSS,
});


/***/ }),

/***/ 33817:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.iconSetBalhamCSS = void 0;
exports.iconSetBalhamCSS = `.ag-icon-aggregation:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Eaggregation%3C/title%3E%3Cpath d='M25.128 2.002c2.56.096 4.772 2.292 4.87 4.87a712 712 0 0 1 0 18.256c-.096 2.56-2.292 4.772-4.87 4.87a712 712 0 0 1-18.256 0c-2.558-.096-4.772-2.29-4.87-4.87a712 712 0 0 1 0-18.256c.096-2.56 2.292-4.772 4.87-4.87a712 712 0 0 1 18.256 0M7.006 4c-1.57.02-2.946 1.348-3.004 2.922-.078 6.078-.23 12.16.002 18.234.094 1.484 1.354 2.746 2.84 2.84 6.1.232 12.212.232 18.312 0 1.48-.094 2.746-1.35 2.84-2.84.232-6.1.232-12.212 0-18.312-.094-1.48-1.35-2.746-2.84-2.84C19.11 3.774 13.056 4 7.006 4M22 12h-2v-2h-8v.092c.056 1.352 3.426 2.598 4.472 4.404.682 1.174.438 2.754-.572 3.72C14.29 19.618 12 20.924 12 22h8v-2h2v4H10c0-1.586-.098-3.304 1.016-4.314 1.904-1.632 4.89-3.108 3.54-4.42-1.918-1.68-4.464-2.936-4.554-5.12L10 8h12z'/%3E%3C/svg%3E")}.ag-icon-arrows:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Earrows%3C/title%3E%3Cpath d='m6.414 17 2.294 2.292-1.416 1.416L2.586 16l4.706-4.708 1.416 1.416L6.414 15H15V6.414l-2.292 2.294-1.416-1.416L16 2.586l4.708 4.706-1.416 1.416L17 6.414V15h8.586l-2.294-2.292 1.416-1.416L29.414 16l-4.706 4.708-1.416-1.416L25.586 17H17v8.586l2.292-2.294 1.416 1.416L16 29.414l-4.708-4.706 1.416-1.416L15 25.586V17z'/%3E%3C/svg%3E")}.ag-icon-asc:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Easc%3C/title%3E%3Cpath d='m15 10.621-4.292 4.294-1.416-1.416L16 6.793l6.708 6.706-1.416 1.416L17 10.621v14.586h-2z'/%3E%3C/svg%3E")}.ag-icon-cancel:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Ecancel%3C/title%3E%3Cpath d='M16 4C9.378 4 4 9.378 4 16s5.378 12 12 12 12-5.378 12-12S22.622 4 16 4m0 2c5.52 0 10 4.48 10 10s-4.48 10-10 10S6 21.52 6 16 10.48 6 16 6m0 8.586 5.292-5.294 1.416 1.416L17.414 16l5.294 5.292-1.416 1.416L16 17.414l-5.292 5.294-1.416-1.416L14.586 16l-5.294-5.292 1.416-1.416z'/%3E%3C/svg%3E")}.ag-icon-chart:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Echart%3C/title%3E%3Cpath d='M6.667 12.267h4v13.067h-4zm7.466-5.6h3.733v18.667h-3.733zM21.6 17.333h3.733v8H21.6z'/%3E%3C/svg%3E")}.ag-icon-color-picker:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Ecolor-picker%3C/title%3E%3Cpath d='M23.907 17.587 10.574 4.254l-1.88 1.88 3.173 3.173-8.28 8.28 10.16 10.16zm-16.547 0 6.387-6.387 6.387 6.387H7.361zm18.387 2s-2.667 2.893-2.667 4.667c0 1.467 1.2 2.667 2.667 2.667s2.667-1.2 2.667-2.667c0-1.773-2.667-4.667-2.667-4.667'/%3E%3C/svg%3E")}.ag-icon-columns:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Ecolumns%3C/title%3E%3Cpath d='M14 25h-2V7h2zm6 0h-2V7h2zm6 0h-2V7h2zM8 25H6V7h2z'/%3E%3C/svg%3E")}.ag-icon-contracted:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Econtracted%3C/title%3E%3Cpath d='m21.061 16-8.706 8.708-1.416-1.416L18.233 16l-7.294-7.292 1.416-1.416z'/%3E%3C/svg%3E")}.ag-icon-copy:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Ecopy%3C/title%3E%3Cpath d='M21.929 27.999h-7.828a5.09 5.09 0 0 1-5.086-5.086v-9.812a5.087 5.087 0 0 1 5.086-5.086h7.828a5.09 5.09 0 0 1 5.086 5.086v9.812a5.087 5.087 0 0 1-5.086 5.086m.16-17.984h-8.088a2.94 2.94 0 0 0-2.938 2.938v10.132a2.94 2.94 0 0 0 2.938 2.938h8.088a2.94 2.94 0 0 0 2.936-2.938V12.953a2.94 2.94 0 0 0-2.936-2.938M7.041 26.013h-2.05a4 4 0 0 1-.006-.228V9.065a5.07 5.07 0 0 1 5.064-5.064h12.812q.069 0 .134.002v2.012H9.915a2.876 2.876 0 0 0-2.874 2.874z'/%3E%3C/svg%3E")}.ag-icon-cross:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='4 4 24 24'%3E%3Ctitle%3Ecross%3C/title%3E%3Cpath d='m16 14.586 5.292-5.294 1.416 1.416L17.414 16l5.294 5.292-1.416 1.416L16 17.414l-5.292 5.294-1.416-1.416L14.586 16l-5.294-5.292 1.416-1.416z'/%3E%3C/svg%3E")}.ag-icon-csv:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M384 131.9c-7.753-8.433-110.425-128.473-114.9-133L48-.1C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48zm-35.9 2.1H257V27.9zM30 479V27h200l1 105c0 13.3-1.3 29 12 29h111l1 318z' style='fill-rule:nonzero' transform='matrix(.06285 0 0 .06285 3.934 -.054)'/%3E%3Cpath d='M.688-.226a.2.2 0 0 1-.017.074.28.28 0 0 1-.145.14.412.412 0 0 1-.234.013.28.28 0 0 1-.202-.168.468.468 0 0 1-.04-.19q0-.086.025-.155a.319.319 0 0 1 .182-.191.4.4 0 0 1 .134-.025q.087 0 .155.035a.3.3 0 0 1 .104.085.17.17 0 0 1 .036.097.06.06 0 0 1-.018.044.06.06 0 0 1-.042.019.06.06 0 0 1-.042-.013.2.2 0 0 1-.031-.046.2.2 0 0 0-.066-.079.16.16 0 0 0-.095-.027.17.17 0 0 0-.142.068.3.3 0 0 0-.053.193.4.4 0 0 0 .023.139.2.2 0 0 0 .067.083.2.2 0 0 0 .1.027q.063 0 .106-.031a.2.2 0 0 0 .065-.091.2.2 0 0 1 .023-.046q.014-.018.044-.018a.06.06 0 0 1 .044.018.06.06 0 0 1 .019.045' style='fill-rule:nonzero' transform='matrix(8.39799 0 0 12.455 7.122 25.977)'/%3E%3Cpath d='M.622-.215a.2.2 0 0 1-.033.117.23.23 0 0 1-.098.081.4.4 0 0 1-.153.029.34.34 0 0 1-.175-.04.23.23 0 0 1-.079-.077.17.17 0 0 1-.031-.093q0-.027.019-.045a.06.06 0 0 1 .046-.019.06.06 0 0 1 .039.014.1.1 0 0 1 .027.044.3.3 0 0 0 .03.057q.015.023.044.038.03.015.076.015.065 0 .105-.03a.09.09 0 0 0 .04-.075.08.08 0 0 0-.022-.058.14.14 0 0 0-.056-.034 1 1 0 0 0-.092-.025.7.7 0 0 1-.129-.042.2.2 0 0 1-.083-.066.17.17 0 0 1-.03-.104q0-.058.032-.105a.2.2 0 0 1 .093-.07.4.4 0 0 1 .144-.025q.066 0 .114.016a.3.3 0 0 1 .08.044.2.2 0 0 1 .046.057q.015.03.015.058a.07.07 0 0 1-.018.046.06.06 0 0 1-.046.021q-.025 0-.038-.012a.2.2 0 0 1-.028-.041.2.2 0 0 0-.047-.063Q.387-.625.326-.625a.15.15 0 0 0-.09.025q-.035.024-.035.059 0 .021.012.037a.1.1 0 0 0 .032.027.4.4 0 0 0 .111.036q.06.015.11.031.048.018.083.042a.2.2 0 0 1 .054.062.2.2 0 0 1 .019.091' style='fill-rule:nonzero' transform='matrix(8.39799 0 0 12.455 13.339 25.977)'/%3E%3Cpath d='m.184-.633.162.48.163-.483q.013-.038.019-.053a.062.062 0 0 1 .061-.039q.018 0 .034.009a.1.1 0 0 1 .025.025q.009.015.009.031L.654-.64l-.007.025-.009.024-.173.468-.019.051a.2.2 0 0 1-.021.042.1.1 0 0 1-.033.03.1.1 0 0 1-.049.012.1.1 0 0 1-.05-.011A.1.1 0 0 1 .26-.03a.2.2 0 0 1-.021-.042L.22-.123.05-.587.041-.612.033-.638.03-.662q0-.025.02-.046a.07.07 0 0 1 .05-.02q.037 0 .053.023.015.023.031.072' style='fill-rule:nonzero' transform='matrix(8.39799 0 0 12.455 18.94 25.977)'/%3E%3C/svg%3E")}.ag-icon-cut:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M14.703 15.096 6.215 4.719a1 1 0 1 1 1.548-1.267l13.058 15.965A5.001 5.001 0 0 1 28 23.916a5 5 0 0 1-4.999 4.999 5 5 0 0 1-4.999-4.999 4.98 4.98 0 0 1 1.23-3.283l-3.238-3.958-3.272 4.001a4.98 4.98 0 0 1 1.265 3.323 5 5 0 0 1-4.999 4.999 5 5 0 0 1-4.999-4.999 5 5 0 0 1 7.13-4.522zM8.991 20.8a3.1 3.1 0 0 0-3.1 3.1c0 1.711 1.389 3.1 3.1 3.1s3.1-1.389 3.1-3.1-1.389-3.1-3.1-3.1M23 20.8a3.1 3.1 0 0 0-3.1 3.1c0 1.711 1.389 3.1 3.1 3.1s3.1-1.389 3.1-3.1-1.389-3.1-3.1-3.1m-5.723-8.852 1.292 1.579 7.205-8.808a1 1 0 0 0-1.548-1.267z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-desc:before,.ag-icon-down:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Edesc%3C/title%3E%3Cpath d='m17 21.379 4.292-4.294 1.416 1.416L16 25.207l-6.708-6.706 1.416-1.416L15 21.379V6.793h2z'/%3E%3C/svg%3E")}.ag-icon-excel:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M384 131.9c-7.753-8.433-110.425-128.473-114.9-133L48-.1C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48zm-35.9 2.1H257V27.9zM30 479V27h200l1 105c0 13.3-1.3 29 12 29h111l1 318z' style='fill-rule:nonzero' transform='matrix(.06285 0 0 .06285 3.934 -.054)'/%3E%3Cpath d='m.052-.139.16-.234-.135-.208a.4.4 0 0 1-.028-.052.1.1 0 0 1-.01-.042.05.05 0 0 1 .018-.037.07.07 0 0 1 .045-.016q.03 0 .047.018a1 1 0 0 1 .047.066l.107.174.115-.174.024-.038.019-.026.021-.015a.1.1 0 0 1 .027-.005.06.06 0 0 1 .044.016.05.05 0 0 1 .018.039q0 .033-.038.089l-.141.211.152.234a.3.3 0 0 1 .03.051.1.1 0 0 1 .009.038.1.1 0 0 1-.008.031.1.1 0 0 1-.024.023.1.1 0 0 1-.034.008.1.1 0 0 1-.035-.008.1.1 0 0 1-.023-.022L.427-.067.301-.265l-.134.204-.022.034-.016.019a.1.1 0 0 1-.022.015.1.1 0 0 1-.03.005.06.06 0 0 1-.044-.016.06.06 0 0 1-.017-.047q0-.036.036-.088' style='fill-rule:nonzero' transform='matrix(17.82892 0 0 16.50777 10.371 25.928)'/%3E%3C/svg%3E")}.ag-icon-expanded:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Eexpanded%3C/title%3E%3Cpath d='M21.061 8.708 13.767 16l7.294 7.292-1.416 1.416L10.939 16l8.706-8.708z'/%3E%3C/svg%3E")}.ag-icon-eye-slash:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Eeye-slash%3C/title%3E%3Cpath d='M9.304 7.89a15.2 15.2 0 0 1 6.404-1.638c.294-.002.292-.002.584 0 5.956.174 11.328 4.088 13.62 9.748 0 0-1.318 3.178-3.224 5.174a13.6 13.6 0 0 1-2.226 1.874L26.414 25 25 26.414l-2.336-2.336C17.866 26.396 11.776 26.15 7.36 22.96a14.9 14.9 0 0 1-4.168-4.612c-.41-.71-.694-1.336-1.104-2.348 0 0 .898-2.218 2.002-3.718a14.6 14.6 0 0 1 3.442-3.334L5.586 7 7 5.586zm-.3 2.528c-2.038 1.344-3.708 3.246-4.724 5.508L4.248 16c2.46 5.762 9.622 9.064 15.63 7.15q.688-.219 1.342-.516l-.912-.912a6.96 6.96 0 0 1-4.19 1.394c-3.862 0-7-3.136-7-7 0-1.57.52-3.022 1.394-4.19zm14.032 11.204a13.25 13.25 0 0 0 4.684-5.548l.032-.074c-1.984-4.646-6.834-7.798-12.006-7.748-1.712.05-3.386.458-4.922 1.158l1.102 1.102a6.97 6.97 0 0 1 4.192-1.396 7.003 7.003 0 0 1 5.606 11.192zm-11.09-8.262a5.003 5.003 0 0 0 6.928 6.928zm8.342 5.514a5.002 5.002 0 0 0-6.928-6.928z'/%3E%3C/svg%3E")}.ag-icon-eye:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Eeye%3C/title%3E%3Cpath d='M16.292 6.32c5.956.174 11.328 4.086 13.62 9.746 0 0-1.318 3.18-3.224 5.176-4.862 5.088-13.534 5.97-19.328 1.784a14.9 14.9 0 0 1-4.168-4.612c-.41-.71-.694-1.336-1.104-2.348 0 0 .898-2.216 2.002-3.716 2.678-3.64 7.03-5.896 11.618-6.03.294-.004.292-.004.584 0m-.546 2c-4.896.142-9.458 3.202-11.466 7.672l-.032.074c2.46 5.762 9.622 9.066 15.63 7.152 3.458-1.102 6.342-3.738 7.842-7.076l.032-.076C25.768 11.42 20.918 8.27 15.746 8.32m.254.946c3.754 0 6.8 3.048 6.8 6.8 0 3.754-3.046 6.8-6.8 6.8s-6.8-3.046-6.8-6.8c0-3.752 3.046-6.8 6.8-6.8m5 6.768V16c0-2.76-2.24-5-5-5s-5 2.24-5 5v.066c0 2.76 2.24 5 5 5s5-2.24 5-5z'/%3E%3C/svg%3E")}.ag-icon-filter:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Efilter%3C/title%3E%3Cpath d='M26 8.184c-.066 2.658-4.058 5.154-6.742 7.974a1.05 1.05 0 0 0-.258.682v3.66L13 25c0-2.74.066-5.482-.002-8.222a1.05 1.05 0 0 0-.256-.62C10.026 13.304 6.06 10.61 6 8.184V6h20zM8 8c0 .304.06.612.258.842 2.716 2.854 6.682 5.548 6.742 7.974V21l2-1.5v-2.684c.066-2.658 4.058-5.154 6.742-7.974.198-.23.258-.538.258-.842z'/%3E%3C/svg%3E")}.ag-icon-first:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Efirst%3C/title%3E%3Cpath d='M24.354 8.708 17.06 16l7.294 7.292-1.416 1.416L14.232 16l8.706-8.708zM9.646 8v16h-2V8z'/%3E%3C/svg%3E")}.ag-icon-group:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Egroup%3C/title%3E%3Cpath d='M25.128 2.002c2.56.096 4.772 2.292 4.87 4.87a712 712 0 0 1 0 18.256c-.096 2.56-2.292 4.772-4.87 4.87a712 712 0 0 1-18.256 0c-2.558-.096-4.772-2.29-4.87-4.87a712 712 0 0 1 0-18.256c.096-2.56 2.292-4.772 4.87-4.87a712 712 0 0 1 18.256 0M7.006 4c-1.57.02-2.946 1.348-3.004 2.922-.078 6.078-.23 12.16.002 18.234.094 1.484 1.354 2.746 2.84 2.84 6.1.232 12.212.232 18.312 0 1.48-.094 2.746-1.35 2.84-2.84.232-6.1.232-12.212 0-18.312-.094-1.48-1.35-2.746-2.84-2.84C19.11 3.774 13.056 4 7.006 4M14 21h-4v-2h4zm12 0H16v-2h10zm-12-4h-4v-2h4zm12 0H16v-2h10zm-16-4H6v-2h4zm16 0H12v-2h14z'/%3E%3C/svg%3E")}.ag-icon-last:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Elast%3C/title%3E%3Cpath d='m17.768 16-8.706 8.708-1.416-1.416L14.94 16 7.646 8.708l1.416-1.416zm6.586 8h-2V8h2z'/%3E%3C/svg%3E")}.ag-icon-left:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Eleft%3C/title%3E%3Cpath d='m17.621 11-2 2h12.586v6H15.621l2 2-4.414 4.414L3.793 16l9.414-9.414zm-11 5 6.586 6.586L14.793 21l-4-4h15.414v-2H10.793l4-4-1.586-1.586z'/%3E%3C/svg%3E")}.ag-icon-linked:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Elinked%3C/title%3E%3Cpath d='M17.138 13.418a1.03 1.03 0 0 0-.298.658s.125.096.226.178c1.372 1.114 2.033 3.039 1.582 4.796a4.7 4.7 0 0 1-1.205 2.123c-1.145 1.151-2.296 2.294-3.445 3.441-1.241 1.232-3.185 1.691-4.864 1.105-1.546-.54-2.756-1.938-3.048-3.572-.267-1.496.246-3.108 1.319-4.186l.578-.578-.03-.092a10.5 10.5 0 0 1-.452-2.3v-.005c-.776.775-1.621 1.489-2.275 2.396-1.817 2.522-1.643 6.323.706 8.669 1.813 1.811 4.708 2.462 7.171 1.517a6.75 6.75 0 0 0 2.336-1.518l3.427-3.424c1.939-1.954 2.533-5.126 1.294-7.674a6.8 6.8 0 0 0-2.071-2.481l-.003-.002zM21.265 4a6.8 6.8 0 0 0-4.734 1.964l-3.427 3.424c-1.961 1.977-2.52 5.092-1.32 7.619a6.8 6.8 0 0 0 2.098 2.537l.003.002c.32-.32.643-.637.96-.96.167-.172.27-.401.286-.64l-.204-.167c-1.603-1.287-2.215-3.68-1.316-5.616a4.7 4.7 0 0 1 .918-1.32c1.145-1.151 2.296-2.294 3.445-3.441 1.239-1.23 3.178-1.694 4.864-1.105 1.83.639 3.16 2.498 3.12 4.493a4.8 4.8 0 0 1-1.391 3.265l-.578.578.03.092c.235.743.387 1.519.452 2.3v.005c.732-.731 1.521-1.406 2.162-2.244 1.192-1.559 1.643-3.651 1.204-5.575a6.8 6.8 0 0 0-3.98-4.703 6.8 6.8 0 0 0-2.529-.506h-.061z'/%3E%3C/svg%3E")}.ag-icon-loading:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Eloading%3C/title%3E%3Cpath d='M17 29h-2v-8h2zm-3.586-9L7 26.414 5.586 25 12 18.586zm13 5L25 26.414 18.586 20 20 18.586zM29 17h-8v-2h8zm-18 0H3v-2h8zm2.414-5L12 13.414 5.586 7 7 5.586zm13-5L20 13.414 18.586 12 25 5.586zM17 11h-2V3h2z'/%3E%3C/svg%3E")}.ag-icon-maximize:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='3 3 26 26'%3E%3Ctitle%3Emaximize%3C/title%3E%3Cpath d='m7.54 17.4.1 6.98 6.96.1-2.24-2.24L16 18.6 13.4 16l-3.64 3.64zm16.92-2.8-.1-6.98-6.96-.1 2.24 2.24L16 13.4l2.6 2.6 3.64-3.64z'/%3E%3C/svg%3E")}.ag-icon-menu:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Emenu%3C/title%3E%3Cpath d='M26 23H6v-2h20zm0-6H6v-2h20zm0-6H6V9h20z'/%3E%3C/svg%3E")}.ag-icon-menu-alt:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' fill='none'%3E%3Cpath fill='%23000' d='M16 18a2 2 0 1 0 0-4 2 2 0 0 0 0 4m0-7a2 2 0 1 0 0-4 2 2 0 0 0 0 4m0 14a2 2 0 1 0 0-4 2 2 0 0 0 0 4'/%3E%3C/svg%3E")}.ag-icon-minimize:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='3 3 26 26'%3E%3Ctitle%3Eminimize%3C/title%3E%3Cpath d='m14.8 24.26-.1-6.96-6.96-.1 2.24 2.24-3.64 3.64 2.6 2.6 3.64-3.64zm2.4-16.52.1 6.96 6.96.1-2.24-2.24 3.64-3.64-2.6-2.6-3.64 3.64z'/%3E%3C/svg%3E")}.ag-icon-minus:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M7.515 7.515c-4.683 4.682-4.683 12.288 0 16.97 4.682 4.683 12.288 4.683 16.97 0 4.683-4.682 4.683-12.288 0-16.97-4.682-4.683-12.288-4.683-16.97 0m1.414 1.414c3.903-3.903 10.239-3.903 14.142 0s3.903 10.239 0 14.142-10.239 3.903-14.142 0-3.903-10.239 0-14.142m-1.414 6.07h16.97v2.002H7.515z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-next:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Enext%3C/title%3E%3Cpath d='m21.061 16-8.706 8.708-1.416-1.416L18.233 16l-7.294-7.292 1.416-1.416z'/%3E%3C/svg%3E")}.ag-icon-none:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Enone%3C/title%3E%3Cpath d='m10.044 21.258 4.478-4.198L16 18.444 9 25l-7-6.556 1.478-1.384 4.478 4.198V7h2.088zm14 3.742h-2.088V10.742l-4.478 4.198L16 13.556 23 7q3.5 3.28 7 6.556l-1.478 1.384-4.478-4.198z'/%3E%3C/svg%3E")}.ag-icon-not-allowed:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Enot-allowed%3C/title%3E%3Cpath d='M16.186 3.646c8.188.154 14.898 9.796 11.17 17.78-3.298 7.066-13.932 9.374-19.848 3.87-3.9-3.632-5.076-9.896-2.684-14.708 2.082-4.19 6.588-6.974 11.362-6.942m-.298 1.998c-6.922.132-12.578 8.308-9.33 15.052 3.342 6.934 15.246 7.646 18.932 0 3.076-6.386-1.988-15.1-9.602-15.052m7.596 6.422c2.864 5.33-1.744 13.186-8.306 12.536a8.6 8.6 0 0 1-3.232-.998l-1.266-.706L22.778 10.8q.351.633.706 1.266m-9.422 10.276c3.296 1.028 7.246-1.006 8.216-4.418a6.6 6.6 0 0 0-.056-3.742zm2.104-14.696a8.8 8.8 0 0 1 3.936 1.038l1.266.706L9.27 21.488c-3.018-5.41-.99-13.37 6.318-13.834q.289-.01.578-.008m-.31 2c-4.06.154-7.23 4.614-6.03 8.46l8.16-8.16a6.8 6.8 0 0 0-2.13-.3'/%3E%3C/svg%3E")}.ag-icon-paste:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Epaste%3C/title%3E%3Cpath d='M20 6.5c0-1-1-3-4-3s-4 2-4 3H8c-2.21 0-4 1.79-4 4v14c0 2.21 1.79 4 4 4h16c2.21 0 4-1.79 4-4v-14c0-2.21-1.79-4-4-4zm-4 .546c.734 0 1.334.572 1.334 1.272S16.734 9.59 16 9.59s-1.334-.572-1.334-1.272.6-1.272 1.334-1.272M24 26.5H8a2 2 0 0 1-2-2v-14a2 2 0 0 1 2-2h2v4h12v-4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2'/%3E%3C/svg%3E")}.ag-icon-pin:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Epin%3C/title%3E%3Cpath d='m10.78 19.777-4.668-4.666s.032-1 .67-1.87c1.366-1.86 4.052-1.96 6.056-1.572l3.158-3.108c-.7-2.342 3.352-5.046 3.352-5.046l9.166 9.168q-.334.447-.67.894c-1.074 1.426-2.538 2.63-4.272 2.338l-3.32 3.218c.046.344.042.03.118 1.152.144 2.13-.64 4.324-2.632 5.34l-.746.364-4.798-4.798-7.292 7.294-1.416-1.416zm8.24-13.672c-.688.568-1.416 1.45-1.024 2.072l.49.722-4.986 4.988c-1.988-.506-4.346-.636-5.156.614l9.02 9.032q.14-.099.272-.21c1.226-1.08.764-3.04.498-4.9l4.79-4.79s1.47.938 2.936-.776l-6.79-6.79q-.026.019-.05.038'/%3E%3C/svg%3E")}.ag-icon-pivot:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Epivot%3C/title%3E%3Cpath d='M25.128 2.002c2.56.096 4.772 2.292 4.87 4.87a712 712 0 0 1 0 18.256c-.096 2.56-2.292 4.772-4.87 4.87a712 712 0 0 1-18.256 0c-2.558-.096-4.772-2.29-4.87-4.87a712 712 0 0 1 0-18.256c.096-2.56 2.292-4.772 4.87-4.87a712 712 0 0 1 18.256 0m2.966 7.954H9.892v18.136c5.086.13 10.18.098 15.264-.096 1.48-.094 2.746-1.35 2.84-2.84.192-5.064.226-10.134.098-15.2M3.968 24.1q.015.528.036 1.056c.094 1.484 1.354 2.746 2.84 2.84l1.012.036V24.1zM22 15.414l-.292.294-1.416-1.416L23 11.586l2.708 2.706-1.416 1.416-.292-.294v3.592c-.032 2.604-2.246 4.892-4.872 4.992L15.414 24l.294.292-1.416 1.416L11.586 23l2.706-2.708 1.416 1.416-.322.32c3.372.03 6.578-.164 6.614-3.034zM3.88 18.038c.002 1.346.012 2.694.038 4.04h3.938v-4.04zm.05-6.062a681 681 0 0 0-.044 4.042h3.97v-4.042zm5.962-7.99Q8.449 3.999 7.006 4c-1.57.02-2.946 1.348-3.004 2.922q-.02 1.517-.042 3.034h3.896v-2.02h2.036zm14.244-.016v3.966h3.898q-.017-.546-.038-1.092c-.094-1.48-1.35-2.746-2.84-2.84q-.51-.019-1.02-.034m-8.14-.054q-2.035.022-4.07.048v3.972h4.07zm6.106.008c-1.358-.022-2.714-.026-4.07-.022v4.034h4.07z'/%3E%3C/svg%3E")}.ag-icon-plus:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M7.515 7.515c-4.683 4.682-4.683 12.288 0 16.97 4.682 4.683 12.288 4.683 16.97 0 4.683-4.682 4.683-12.288 0-16.97-4.682-4.683-12.288-4.683-16.97 0m1.414 1.414c3.903-3.903 10.239-3.903 14.142 0s3.903 10.239 0 14.142-10.239 3.903-14.142 0-3.903-10.239 0-14.142M15 15l-.001-7.485h2.002L17 15l7.485-.001v2.002L17 17l.001 7.485h-2.002L15 17l-7.485.001v-2.002z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-previous:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Eprevious%3C/title%3E%3Cpath d='M21.061 8.708 13.767 16l7.294 7.292-1.416 1.416L10.939 16l8.706-8.708z'/%3E%3C/svg%3E")}.ag-icon-right:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Eright%3C/title%3E%3Cpath d='m28.207 16-9.414 9.414L14.379 21l2-2H3.793v-6h12.586l-2-2 4.414-4.414zm-11-5 4 4H5.793v2h15.414l-4 4 1.586 1.586L25.379 16l-6.586-6.586z'/%3E%3C/svg%3E")}.ag-icon-save:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Esave%3C/title%3E%3Cpath d='M25.333 16v9.333H6.666V16H3.999v9.333C3.999 26.8 5.199 28 6.666 28h18.667C26.8 28 28 26.8 28 25.333V16zm-8 .893 3.453-3.44 1.88 1.88L15.999 22l-6.667-6.667 1.88-1.88 3.453 3.44V4h2.667v12.893z'/%3E%3C/svg%3E")}.ag-icon-small-down:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Esmall-down%3C/title%3E%3Cpath d='M24.708 12.355 16 21.061l-8.708-8.706 1.416-1.416L16 18.233l7.292-7.294z'/%3E%3C/svg%3E")}.ag-icon-small-left:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Esmall-left%3C/title%3E%3Cpath d='M21.061 8.708 13.767 16l7.294 7.292-1.416 1.416L10.939 16l8.706-8.708z'/%3E%3C/svg%3E")}.ag-icon-small-right:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Esmall-right%3C/title%3E%3Cpath d='m21.061 16-8.706 8.708-1.416-1.416L18.233 16l-7.294-7.292 1.416-1.416z'/%3E%3C/svg%3E")}.ag-icon-small-up:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Esmall-up%3C/title%3E%3Cpath d='m24.708 19.645-1.416 1.416L16 13.767l-7.292 7.294-1.416-1.416L16 10.939z'/%3E%3C/svg%3E")}.ag-icon-tick:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Etick%3C/title%3E%3Cpath d='M24.708 10.855 13 22.561l-5.708-5.706 1.416-1.416L13 19.733 23.292 9.439z'/%3E%3C/svg%3E")}.ag-icon-tree-closed:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Etree-closed%3C/title%3E%3Cpath d='m21.061 16-8.706 8.708-1.416-1.416L18.233 16l-7.294-7.292 1.416-1.416z'/%3E%3C/svg%3E")}.ag-icon-tree-indeterminate:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Etree-indeterminate%3C/title%3E%3Cpath d='M6 15h20v2H6z'/%3E%3C/svg%3E")}.ag-icon-tree-open:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Etree-open%3C/title%3E%3Cpath d='M24.708 12.355 16 21.061l-8.708-8.706 1.416-1.416L16 18.233l7.292-7.294z'/%3E%3C/svg%3E")}.ag-icon-unlinked:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Eunlinked%3C/title%3E%3Cpath d='M5.35 3.999a.2.2 0 0 0-.14.058c-.388.38-.768.768-1.152 1.152a.21.21 0 0 0-.002.288c7.459 7.506 14.965 14.965 22.447 22.447a.21.21 0 0 0 .288.002q.576-.574 1.151-1.151a.21.21 0 0 0 .002-.288C20.484 19.002 12.979 11.542 5.497 4.06a.2.2 0 0 0-.146-.061zm.611 12.548c-1.933 1.939-2.538 5.119-1.289 7.688a6.79 6.79 0 0 0 4.891 3.672 6.82 6.82 0 0 0 5.893-1.866l1.984-1.984-1.438-1.438-1.986 1.986c-1.486 1.476-3.993 1.81-5.834.629a4.73 4.73 0 0 1-2.024-2.853 4.76 4.76 0 0 1 1.241-4.393l1.986-1.986-1.438-1.438-1.984 1.984zM21.273 3.999a6.78 6.78 0 0 0-4.727 1.963l-1.984 1.984L16 9.384l1.985-1.985a4.74 4.74 0 0 1 2.776-1.338c1.974-.224 4.045.926 4.845 2.834.712 1.699.329 3.778-1.004 5.12L22.616 16l1.439 1.438q1-1 2-2c2.012-2.031 2.557-5.368 1.112-7.982-1.144-2.07-3.432-3.441-5.834-3.459h-.061z'/%3E%3C/svg%3E")}.ag-icon-up:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Easc%3C/title%3E%3Cpath d='m15 10.621-4.292 4.294-1.416-1.416L16 6.793l6.708 6.706-1.416 1.416L17 10.621v14.586h-2z'/%3E%3C/svg%3E")}.ag-icon-grip:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Egrip%3C/title%3E%3Cpath d='M8 24H6v-4h2zm6 0h-2v-4h2zm6 0h-2v-4h2zm6 0h-2v-4h2zM8 18H6v-4h2zm6 0h-2v-4h2zm6 0h-2v-4h2zm6 0h-2v-4h2zM8 12H6V8h2zm6 0h-2V8h2zm6 0h-2V8h2zm6 0h-2V8h2z'/%3E%3C/svg%3E")}.ag-icon-settings:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='%23000' d='M30 8h-4.1c-.5-2.3-2.5-4-4.9-4s-4.4 1.7-4.9 4H2v2h14.1c.5 2.3 2.5 4 4.9 4s4.4-1.7 4.9-4H30zm-9 4c-1.7 0-3-1.3-3-3s1.3-3 3-3 3 1.3 3 3-1.3 3-3 3M2 24h4.1c.5 2.3 2.5 4 4.9 4s4.4-1.7 4.9-4H30v-2H15.9c-.5-2.3-2.5-4-4.9-4s-4.4 1.7-4.9 4H2zm9-4c1.7 0 3 1.3 3 3s-1.3 3-3 3-3-1.3-3-3 1.3-3 3-3'/%3E%3C/svg%3E")}.ag-icon-column-arrow:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='currentColor' fill-rule='evenodd' d='M11 4a1 1 0 0 1 1 1v22a1 1 0 1 1-2 0V5a1 1 0 0 1 1-1' clip-rule='evenodd'/%3E%3Cpath fill='currentColor' fill-rule='evenodd' d='M2 13a1 1 0 0 1 1-1h23.5a1 1 0 1 1 0 2H3a1 1 0 0 1-1-1' clip-rule='evenodd'/%3E%3Cpath fill='currentColor' fill-rule='evenodd' d='M2 4h18v24H2zm2 2v20h14V6zM26.793 13 23 9.207l1.414-1.414L29.621 13l-5.207 5.207L23 16.793z' clip-rule='evenodd'/%3E%3C/svg%3E")}.ag-icon-un-pin:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='currentColor' fill-rule='evenodd' d='m6.112 15.111 3.272 3.271 1.436-1.402-2.476-2.479c.81-1.25 3.168-1.12 5.156-.614l4.986-4.988-.49-.722c-.392-.622.336-1.504 1.024-2.072l.008-.007.01-.006.032-.025 1.447 1.447 1.432-1.397-2.601-2.602s-4.052 2.704-3.352 5.046l-3.158 3.108c-2.004-.388-4.69-.288-6.056 1.572-.638.87-.67 1.87-.67 1.87m.581 11.582.014.014 5.502-5.501 4.783 4.783.746-.364c1.992-1.016 2.776-3.21 2.632-5.34-.055-.805-.068-.87-.088-.97-.008-.04-.017-.085-.03-.182l3.32-3.218c1.734.292 3.198-.912 4.272-2.338q.337-.447.67-.894l-.001-.001-.007-.007-.007-.007-.007-.007-3.87-3.87 1.585-1.584-1.414-1.414-14.381 14.38-1.237 1.209-5.69 5.687 1.417 1.416zM23.21 10.206l2.65 2.651c-1.465 1.714-2.935.776-2.935.776l-4.79 4.79q.041.291.087.583c.257 1.676.513 3.35-.585 4.317a4 4 0 0 1-.272.21l-3.739-3.744z' clip-rule='evenodd'/%3E%3C/svg%3E")}.ag-icon-pinned-top:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='currentColor' d='m16.708 10.878 8.708 8.706L24 21l-6.292-6.294V27h-2V14.706L9.416 21 8 19.584q4.348-4.344 8.691-8.69zM25 6H8v2h17z'/%3E%3C/svg%3E")}.ag-icon-pinned-bottom:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='currentColor' d='M16.708 22.122 8 13.416 9.416 12l6.292 6.294V6h2v12.294L24 12l1.416 1.416-8.691 8.69zM7.416 28h17v-2h-17z'/%3E%3C/svg%3E")}.ag-icon-chevron-up:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='none' viewBox='0 0 16 16'%3E%3Cpath fill='currentColor' fill-rule='evenodd' d='M3.479 10.521a.75.75 0 0 1 0-1.06l4-4a.75.75 0 0 1 1.06 0l4 4a.75.75 0 0 1-1.06 1.06l-3.47-3.47-3.47 3.47a.75.75 0 0 1-1.06 0' clip-rule='evenodd'/%3E%3C/svg%3E")}.ag-icon-chevron-down:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='none' viewBox='0 0 16 16'%3E%3Cpath fill='currentColor' fill-rule='evenodd' d='M12.521 5.461a.75.75 0 0 1 0 1.06l-4 4a.75.75 0 0 1-1.06 0l-4-4a.75.75 0 0 1 1.06-1.06l3.47 3.47 3.47-3.47a.75.75 0 0 1 1.06 0' clip-rule='evenodd'/%3E%3C/svg%3E")}.ag-icon-chevron-left:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='none' viewBox='0 0 16 16'%3E%3Cpath fill='currentColor' fill-rule='evenodd' d='M10.53 12.512a.75.75 0 0 1-1.06 0l-4-4a.75.75 0 0 1 0-1.06l4-4a.75.75 0 0 1 1.06 1.06l-3.47 3.47 3.47 3.47a.75.75 0 0 1 0 1.06' clip-rule='evenodd'/%3E%3C/svg%3E")}.ag-icon-chevron-right:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='none' viewBox='0 0 16 16'%3E%3Cpath fill='currentColor' fill-rule='evenodd' d='M5.47 3.47a.75.75 0 0 1 1.06 0l4 4a.75.75 0 0 1 0 1.06l-4 4a.75.75 0 0 1-1.06-1.06L8.94 8 5.47 4.53a.75.75 0 0 1 0-1.06' clip-rule='evenodd'/%3E%3C/svg%3E")}.ag-icon-filter-add:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='currentColor' d='M19.834 8H8c0 .304.06.612.258.842 2.716 2.854 6.682 5.548 6.742 7.974V21l2-1.5v-2.684c.056-2.267 2.968-4.417 5.49-6.75v3.087c-1.081.974-2.245 1.968-3.232 3.005a1.05 1.05 0 0 0-.258.682v3.66L13 25c0-2.74.066-5.482-.002-8.222a1.05 1.05 0 0 0-.256-.62C10.026 13.304 6.06 10.61 6 8.184V6h13.834z'/%3E%3Cpath fill='currentColor' d='M26 6h2.946v2.002H26v3.313h-2.002V8.002h-2.946V6h2.946V3.04H26z'/%3E%3C/svg%3E")}.ag-icon-edit:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='currentColor' d='M23.182 5a3.82 3.82 0 0 1 2.83 6.383l-.131.137-2.09 2.088a1 1 0 0 1-.084.099 1 1 0 0 1-.098.084L12.533 24.869a3 3 0 0 1-1.245.746l-4.353 1.32-.003.002a1.5 1.5 0 0 1-1.87-1.867l.003-.004 1.32-4.352v-.003l.06-.174c.13-.344.321-.661.565-.936l.126-.135L18.209 8.39a1 1 0 0 1 .18-.181l2.092-2.09.137-.132A3.82 3.82 0 0 1 23.182 5M8.548 20.883a1 1 0 0 0-.25.415l-1.049 3.451 3.457-1.048.114-.042q.17-.076.301-.206l10.458-10.46-2.572-2.572zM23.182 7c-.482 0-.946.19-1.287.531v.001l-1.474 1.475 2.572 2.572 1.474-1.474.121-.133A1.82 1.82 0 0 0 23.182 7'/%3E%3C/svg%3E")}`;


/***/ }),

/***/ 65572:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.iconSetBalham = void 0;
const Part_1 = __webpack_require__(86607);
const icon_set_balham_css_GENERATED_1 = __webpack_require__(33817);
exports.iconSetBalham = (0, Part_1.createPart)({
    feature: 'iconSet',
    css: icon_set_balham_css_GENERATED_1.iconSetBalhamCSS,
});


/***/ }),

/***/ 26407:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.iconSetQuartzRegular = exports.iconSetQuartzLight = exports.iconSetQuartzBold = exports.iconSetQuartz = exports.iconOverrides = exports.iconSetMaterial = exports.iconSetAlpine = void 0;
var icon_set_alpine_1 = __webpack_require__(89580);
Object.defineProperty(exports, "iconSetAlpine", ({ enumerable: true, get: function () { return icon_set_alpine_1.iconSetAlpine; } }));
var icon_set_material_1 = __webpack_require__(98900);
Object.defineProperty(exports, "iconSetMaterial", ({ enumerable: true, get: function () { return icon_set_material_1.iconSetMaterial; } }));
var icon_overrides_1 = __webpack_require__(95867);
Object.defineProperty(exports, "iconOverrides", ({ enumerable: true, get: function () { return icon_overrides_1.iconOverrides; } }));
var icon_set_quartz_1 = __webpack_require__(53692);
Object.defineProperty(exports, "iconSetQuartz", ({ enumerable: true, get: function () { return icon_set_quartz_1.iconSetQuartz; } }));
Object.defineProperty(exports, "iconSetQuartzBold", ({ enumerable: true, get: function () { return icon_set_quartz_1.iconSetQuartzBold; } }));
Object.defineProperty(exports, "iconSetQuartzLight", ({ enumerable: true, get: function () { return icon_set_quartz_1.iconSetQuartzLight; } }));
Object.defineProperty(exports, "iconSetQuartzRegular", ({ enumerable: true, get: function () { return icon_set_quartz_1.iconSetQuartzRegular; } }));


/***/ }),

/***/ 77545:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.iconSetMaterialCSS = void 0;
exports.iconSetMaterialCSS = `.ag-icon-aggregation:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Eaggregation%3C/title%3E%3Cpath d='M24 5.333H8V8l8.667 8L8 24v2.667h16v-4h-9.333L21.334 16l-6.667-6.667H24z'/%3E%3C/svg%3E")}.ag-icon-arrows:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Earrows%3C/title%3E%3Cpath d='M13.333 11.556h5.333V8h3.556L16 1.778 9.778 8h3.556zm-1.777 1.777H8V9.777l-6.222 6.222L8 22.221v-3.556h3.556zM30.222 16 24 9.778v3.556h-3.556v5.333H24v3.556l6.222-6.222zm-11.555 4.444h-5.333V24H9.778L16 30.222 22.222 24h-3.556z'/%3E%3C/svg%3E")}.ag-icon-asc:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Easc%3C/title%3E%3Cpath d='m5.333 16 1.88 1.88 7.453-7.44v16.227h2.667V10.44l7.44 7.453L26.666 16 15.999 5.333z'/%3E%3C/svg%3E")}.ag-icon-cancel:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Ecancel%3C/title%3E%3Cpath d='M16 2.667C8.627 2.667 2.667 8.627 2.667 16S8.627 29.333 16 29.333 29.333 23.373 29.333 16 23.373 2.667 16 2.667m6.667 18.12-1.88 1.88L16 17.88l-4.787 4.787-1.88-1.88L14.12 16l-4.787-4.787 1.88-1.88L16 14.12l4.787-4.787 1.88 1.88L17.88 16z'/%3E%3C/svg%3E")}.ag-icon-chart:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Echart%3C/title%3E%3Cpath d='M6.667 12.267h4v13.067h-4zm7.466-5.6h3.733v18.667h-3.733zM21.6 17.333h3.733v8H21.6z'/%3E%3C/svg%3E")}.ag-icon-color-picker:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Ecolor-picker%3C/title%3E%3Cpath d='M23.907 17.587 10.574 4.254l-1.88 1.88 3.173 3.173-8.28 8.28 10.16 10.16zm-16.547 0 6.387-6.387 6.387 6.387H7.361zm18.387 2s-2.667 2.893-2.667 4.667c0 1.467 1.2 2.667 2.667 2.667s2.667-1.2 2.667-2.667c0-1.773-2.667-4.667-2.667-4.667'/%3E%3C/svg%3E")}.ag-icon-columns:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Ecolumns%3C/title%3E%3Cpath d='M5.333 10.667h5.333V5.334H5.333zm8 16h5.333v-5.333h-5.333zm-8 0h5.333v-5.333H5.333zm0-8h5.333v-5.333H5.333zm8 0h5.333v-5.333h-5.333zm8-13.334v5.333h5.333V5.333zm-8 5.334h5.333V5.334h-5.333zm8 8h5.333v-5.333h-5.333zm0 8h5.333v-5.333h-5.333z'/%3E%3C/svg%3E")}.ag-icon-contracted:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Econtracted%3C/title%3E%3Cpath d='m12.94 8-1.88 1.88L17.167 16l-6.107 6.12L12.94 24l8-8z'/%3E%3C/svg%3E")}.ag-icon-copy:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Ecopy%3C/title%3E%3Cpath d='M22 1.333H6A2.675 2.675 0 0 0 3.333 4v18.667H6V4h16zm4 5.334H11.333a2.675 2.675 0 0 0-2.667 2.667v18.667c0 1.467 1.2 2.667 2.667 2.667H26c1.467 0 2.667-1.2 2.667-2.667V9.334c0-1.467-1.2-2.667-2.667-2.667M26 28H11.333V9.333H26z'/%3E%3C/svg%3E")}.ag-icon-cross:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Ecross%3C/title%3E%3Cpath d='m25.333 8.547-1.88-1.88L16 14.12 8.547 6.667l-1.88 1.88L14.12 16l-7.453 7.453 1.88 1.88L16 17.88l7.453 7.453 1.88-1.88L17.88 16z'/%3E%3C/svg%3E")}.ag-icon-csv:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M384 131.9c-7.753-8.433-110.425-128.473-114.9-133L48-.1C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48zm-35.9 2.1H257V27.9zM30 479V27h200l1 105c0 13.3-1.3 29 12 29h111l1 318z' style='fill-rule:nonzero' transform='matrix(.06285 0 0 .06285 3.934 -.054)'/%3E%3Cpath d='M.688-.226a.2.2 0 0 1-.017.074.28.28 0 0 1-.145.14.412.412 0 0 1-.234.013.28.28 0 0 1-.202-.168.468.468 0 0 1-.04-.19q0-.086.025-.155a.319.319 0 0 1 .182-.191.4.4 0 0 1 .134-.025q.087 0 .155.035a.3.3 0 0 1 .104.085.17.17 0 0 1 .036.097.06.06 0 0 1-.018.044.06.06 0 0 1-.042.019.06.06 0 0 1-.042-.013.2.2 0 0 1-.031-.046.2.2 0 0 0-.066-.079.16.16 0 0 0-.095-.027.17.17 0 0 0-.142.068.3.3 0 0 0-.053.193.4.4 0 0 0 .023.139.2.2 0 0 0 .067.083.2.2 0 0 0 .1.027q.063 0 .106-.031a.2.2 0 0 0 .065-.091.2.2 0 0 1 .023-.046q.014-.018.044-.018a.06.06 0 0 1 .044.018.06.06 0 0 1 .019.045' style='fill-rule:nonzero' transform='matrix(8.39799 0 0 12.455 7.122 25.977)'/%3E%3Cpath d='M.622-.215a.2.2 0 0 1-.033.117.23.23 0 0 1-.098.081.4.4 0 0 1-.153.029.34.34 0 0 1-.175-.04.23.23 0 0 1-.079-.077.17.17 0 0 1-.031-.093q0-.027.019-.045a.06.06 0 0 1 .046-.019.06.06 0 0 1 .039.014.1.1 0 0 1 .027.044.3.3 0 0 0 .03.057q.015.023.044.038.03.015.076.015.065 0 .105-.03a.09.09 0 0 0 .04-.075.08.08 0 0 0-.022-.058.14.14 0 0 0-.056-.034 1 1 0 0 0-.092-.025.7.7 0 0 1-.129-.042.2.2 0 0 1-.083-.066.17.17 0 0 1-.03-.104q0-.058.032-.105a.2.2 0 0 1 .093-.07.4.4 0 0 1 .144-.025q.066 0 .114.016a.3.3 0 0 1 .08.044.2.2 0 0 1 .046.057q.015.03.015.058a.07.07 0 0 1-.018.046.06.06 0 0 1-.046.021q-.025 0-.038-.012a.2.2 0 0 1-.028-.041.2.2 0 0 0-.047-.063Q.387-.625.326-.625a.15.15 0 0 0-.09.025q-.035.024-.035.059 0 .021.012.037a.1.1 0 0 0 .032.027.4.4 0 0 0 .111.036q.06.015.11.031.048.018.083.042a.2.2 0 0 1 .054.062.2.2 0 0 1 .019.091' style='fill-rule:nonzero' transform='matrix(8.39799 0 0 12.455 13.339 25.977)'/%3E%3Cpath d='m.184-.633.162.48.163-.483q.013-.038.019-.053a.062.062 0 0 1 .061-.039q.018 0 .034.009a.1.1 0 0 1 .025.025q.009.015.009.031L.654-.64l-.007.025-.009.024-.173.468-.019.051a.2.2 0 0 1-.021.042.1.1 0 0 1-.033.03.1.1 0 0 1-.049.012.1.1 0 0 1-.05-.011A.1.1 0 0 1 .26-.03a.2.2 0 0 1-.021-.042L.22-.123.05-.587.041-.612.033-.638.03-.662q0-.025.02-.046a.07.07 0 0 1 .05-.02q.037 0 .053.023.015.023.031.072' style='fill-rule:nonzero' transform='matrix(8.39799 0 0 12.455 18.94 25.977)'/%3E%3C/svg%3E")}.ag-icon-cut:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m19 3-6 6 2 2 7-7V3m-10 9.5a.503.503 0 0 1-.5-.5c0-.274.226-.5.5-.5s.5.226.5.5-.226.5-.5.5M6 20c-1.097 0-2-.903-2-2a2 2 0 0 1 2-2c1.097 0 2 .903 2 2a2 2 0 0 1-2 2M6 8c-1.097 0-2-.903-2-2a2 2 0 0 1 2-2c1.097 0 2 .903 2 2a2 2 0 0 1-2 2m3.64-.36c.23-.5.36-1.05.36-1.64 0-2.194-1.806-4-4-4S2 3.806 2 6s1.806 4 4 4c.59 0 1.14-.13 1.64-.36L10 12l-2.36 2.36C7.14 14.13 6.59 14 6 14c-2.194 0-4 1.806-4 4s1.806 4 4 4 4-1.806 4-4c0-.59-.13-1.14-.36-1.64L12 14l7 7h3v-1z' style='fill-rule:nonzero' transform='translate(4 4)'/%3E%3C/svg%3E")}.ag-icon-desc:before,.ag-icon-down:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Edesc%3C/title%3E%3Cpath d='m26.667 16-1.88-1.88-7.453 7.44V5.333h-2.667V21.56l-7.44-7.453L5.334 16l10.667 10.667L26.668 16z'/%3E%3C/svg%3E")}.ag-icon-excel:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M384 131.9c-7.753-8.433-110.425-128.473-114.9-133L48-.1C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48zm-35.9 2.1H257V27.9zM30 479V27h200l1 105c0 13.3-1.3 29 12 29h111l1 318z' style='fill-rule:nonzero' transform='matrix(.06285 0 0 .06285 3.934 -.054)'/%3E%3Cpath d='m.052-.139.16-.234-.135-.208a.4.4 0 0 1-.028-.052.1.1 0 0 1-.01-.042.05.05 0 0 1 .018-.037.07.07 0 0 1 .045-.016q.03 0 .047.018a1 1 0 0 1 .047.066l.107.174.115-.174.024-.038.019-.026.021-.015a.1.1 0 0 1 .027-.005.06.06 0 0 1 .044.016.05.05 0 0 1 .018.039q0 .033-.038.089l-.141.211.152.234a.3.3 0 0 1 .03.051.1.1 0 0 1 .009.038.1.1 0 0 1-.008.031.1.1 0 0 1-.024.023.1.1 0 0 1-.034.008.1.1 0 0 1-.035-.008.1.1 0 0 1-.023-.022L.427-.067.301-.265l-.134.204-.022.034-.016.019a.1.1 0 0 1-.022.015.1.1 0 0 1-.03.005.06.06 0 0 1-.044-.016.06.06 0 0 1-.017-.047q0-.036.036-.088' style='fill-rule:nonzero' transform='matrix(17.82892 0 0 16.50777 10.371 25.928)'/%3E%3C/svg%3E")}.ag-icon-expanded:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Eexpanded%3C/title%3E%3Cpath d='M20.94 9.88 19.06 8l-8 8 8 8 1.88-1.88L14.833 16z'/%3E%3C/svg%3E")}.ag-icon-eye-slash:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Eeye-slash%3C/title%3E%3Cpath d='M21.106 15.088A5.19 5.19 0 0 0 16 10.814a5.17 5.17 0 0 0-3.668 1.522L9.866 9.868a12.2 12.2 0 0 1 6.133-1.646c5.186 0 9.614 3.225 11.408 7.778a12.34 12.34 0 0 1-5.276 6.133l-2.468-2.466a5.17 5.17 0 0 0 1.449-2.802h-2.123c-.148.508-.42.964-.782 1.33l-1.33-1.33h-2.514l2.196 2.196q-.272.049-.56.05a3.11 3.11 0 0 1-2.99-2.245h-2.123a5.19 5.19 0 0 0 7.3 3.836l2.247 2.247a12.2 12.2 0 0 1-4.434.828c-5.186 0-9.614-3.225-11.408-7.778a12.3 12.3 0 0 1 3.781-5.111l2.924 2.924a5.1 5.1 0 0 0-.404 1.275h4.206l-1.296-1.296a3.1 3.1 0 0 1 2.196-.903c1.404 0 2.587.924 2.976 2.199h2.13z'/%3E%3C/svg%3E")}.ag-icon-eye:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Eeye%3C/title%3E%3Cpath d='M16 8.222c-5.186 0-9.614 3.225-11.408 7.778 1.794 4.553 6.222 7.778 11.408 7.778S25.614 20.553 27.408 16C25.614 11.447 21.186 8.222 16 8.222m0 12.964c-2.862 0-5.186-2.324-5.186-5.186s2.324-5.186 5.186-5.186 5.186 2.324 5.186 5.186-2.324 5.186-5.186 5.186m0-8.297c-1.721 0-3.111 1.39-3.111 3.111s1.39 3.111 3.111 3.111 3.111-1.39 3.111-3.111-1.39-3.111-3.111-3.111'/%3E%3C/svg%3E")}.ag-icon-filter:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Efilter%3C/title%3E%3Cpath d='M13.333 24h5.333v-2.667h-5.333zM4 8v2.667h24V8zm4 9.333h16v-2.667H8z'/%3E%3C/svg%3E")}.ag-icon-first:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Efirst%3C/title%3E%3Cpath d='M24.273 22.12 18.153 16l6.12-6.12L22.393 8l-8 8 8 8zM7.727 8h2.667v16H7.727z'/%3E%3C/svg%3E")}.ag-icon-group:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Egroup%3C/title%3E%3Cpath d='M18.667 21.333h8.889A3.555 3.555 0 0 1 24 24.889h-5.333zm8.888-7.111v3.556h-8.889v-3.556zM24 7.111a3.555 3.555 0 0 1 3.556 3.556h-16V7.111zm-8.889 17.778h-3.556v-3.556h3.556zm0-7.111h-3.556v-3.556h3.556zM8 10.667H4.444A3.555 3.555 0 0 1 8 7.111z'/%3E%3C/svg%3E")}.ag-icon-last:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Elast%3C/title%3E%3Cpath d='m7.727 9.88 6.12 6.12-6.12 6.12L9.607 24l8-8-8-8zM21.607 8h2.667v16h-2.667z'/%3E%3C/svg%3E")}.ag-icon-left:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Eleft%3C/title%3E%3Cpath d='M26.667 14.667H10.44l7.453-7.453L16 5.334 5.333 16.001 16 26.668l1.88-1.88-7.44-7.453h16.227v-2.667z'/%3E%3C/svg%3E")}.ag-icon-linked:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Elinked%3C/title%3E%3Cpath d='M5.2 16a4.136 4.136 0 0 1 4.133-4.133h5.333V9.334H9.333c-3.68 0-6.667 2.987-6.667 6.667s2.987 6.667 6.667 6.667h5.333v-2.533H9.333A4.136 4.136 0 0 1 5.2 16.002zm5.467 1.333h10.667v-2.667H10.667zm12-8h-5.333v2.533h5.333c2.28 0 4.133 1.853 4.133 4.133s-1.853 4.133-4.133 4.133h-5.333v2.533h5.333c3.68 0 6.667-2.987 6.667-6.667s-2.987-6.667-6.667-6.667z'/%3E%3C/svg%3E")}.ag-icon-loading:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Eloading%3C/title%3E%3Cpath d='m17.778 11.708 3.25-3.251 2.516 2.516-3.251 3.25h4.597v3.556h-4.597l3.251 3.25-2.516 2.516-3.25-3.251v4.597h-3.556v-4.597l-3.25 3.251-2.516-2.516 3.251-3.25H7.11v-3.556h4.597l-3.251-3.25 2.516-2.516 3.25 3.251V7.111h3.556zm-3.251 7.847h2.944l2.084-2.084v-2.944l-2.084-2.084h-2.944l-2.084 2.084v2.944z'/%3E%3C/svg%3E")}.ag-icon-maximize:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Emaximize%3C/title%3E%3Cpath d='M4 4h24v2.667H4z'/%3E%3C/svg%3E")}.ag-icon-menu:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Emenu%3C/title%3E%3Cpath d='M4 24h24v-2.667H4zm0-6.667h24v-2.667H4zM4 8v2.667h24V8z'/%3E%3C/svg%3E")}.ag-icon-menu-alt:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='%23000' d='M16 26.667a2.57 2.57 0 0 1-1.883-.784A2.57 2.57 0 0 1 13.333 24q0-1.1.784-1.883A2.57 2.57 0 0 1 16 21.333q1.1 0 1.883.784.784.783.784 1.883t-.784 1.883a2.57 2.57 0 0 1-1.883.784m0-8a2.57 2.57 0 0 1-1.883-.784A2.57 2.57 0 0 1 13.333 16q0-1.1.784-1.883A2.57 2.57 0 0 1 16 13.333q1.1 0 1.883.784.784.783.784 1.883t-.784 1.883a2.57 2.57 0 0 1-1.883.784m0-8a2.57 2.57 0 0 1-1.883-.784A2.57 2.57 0 0 1 13.333 8q0-1.1.784-1.883A2.57 2.57 0 0 1 16 5.333q1.1 0 1.883.784.784.783.784 1.883t-.784 1.883a2.57 2.57 0 0 1-1.883.784'/%3E%3C/svg%3E")}.ag-icon-minimize:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Eminimize%3C/title%3E%3Cpath d='M8 25.333h16V28H8z'/%3E%3C/svg%3E")}.ag-icon-minus:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M6.572 6.572a13.32 13.32 0 0 0 0 18.856 13.32 13.32 0 0 0 18.856 0 13.32 13.32 0 0 0 0-18.856 13.32 13.32 0 0 0-18.856 0m17.527 8.099v2.658H7.901v-2.658z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-next:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Enext%3C/title%3E%3Cpath d='m12.94 8-1.88 1.88L17.167 16l-6.107 6.12L12.94 24l8-8z'/%3E%3C/svg%3E")}.ag-icon-none:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Enone%3C/title%3E%3Cpath d='M4 24h16v-2.667H4zM4 8v2.667h24V8zm0 9.333h24v-2.667H4z'/%3E%3C/svg%3E")}.ag-icon-not-allowed:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Enot-allowed%3C/title%3E%3Cpath d='M16 2.667C8.64 2.667 2.667 8.64 2.667 16S8.64 29.333 16 29.333 29.333 23.36 29.333 16 23.36 2.667 16 2.667M5.333 16c0-5.893 4.773-10.667 10.667-10.667 2.467 0 4.733.84 6.533 2.253L7.586 22.533A10.54 10.54 0 0 1 5.333 16M16 26.667c-2.467 0-4.733-.84-6.533-2.253L24.414 9.467A10.54 10.54 0 0 1 26.667 16c0 5.893-4.773 10.667-10.667 10.667'/%3E%3C/svg%3E")}.ag-icon-paste:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Epaste%3C/title%3E%3Cpath d='M25.333 4H19.76C19.2 2.453 17.733 1.333 16 1.333S12.8 2.453 12.24 4H6.667A2.675 2.675 0 0 0 4 6.667V28c0 1.467 1.2 2.667 2.667 2.667h18.667c1.467 0 2.667-1.2 2.667-2.667V6.667C28.001 5.2 26.801 4 25.334 4zM16 4c.733 0 1.333.6 1.333 1.333s-.6 1.333-1.333 1.333-1.333-.6-1.333-1.333S15.267 4 16 4m9.333 24H6.666V6.667h2.667v4h13.333v-4h2.667z'/%3E%3C/svg%3E")}.ag-icon-pin:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Epin%3C/title%3E%3Cpath d='m11.106 22.093-4.444 4.444-1.259-1.259 4.444-4.444zm5.872-16.63 9.618 9.62-.962.962-.962-.962-7.694 3.847 1.924 1.924-2.74 2.74-7.696-7.696 2.741-2.74 1.924 1.925 3.847-7.696-.962-.962z'/%3E%3C/svg%3E")}.ag-icon-pivot:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Epivot%3C/title%3E%3Cpath d='M26.667 30.223H5.334a3.556 3.556 0 0 1-3.556-3.556V5.334a3.556 3.556 0 0 1 3.556-3.556h21.333a3.556 3.556 0 0 1 3.556 3.556v21.333a3.556 3.556 0 0 1-3.556 3.556m-16-8.89H5.334v5.333h5.333zm16-7.11H12.444v12.444h14.223zm-9.15 6.85-2.039 2.037 2.039 2.039-1.257 1.257-3.295-3.296 3.295-3.295q.63.628 1.257 1.257zm-6.85-6.85H5.334v5.333h5.333zm15.74 3.816-1.257 1.256-2.039-2.037-2.037 2.037-1.257-1.256 3.295-3.296zM10.667 5.333H5.334v5.333h5.333zm8.889 0h-7.112v5.333h7.112zm7.111 0h-5.333v5.333h5.333z'/%3E%3C/svg%3E")}.ag-icon-plus:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M6.572 6.572a13.32 13.32 0 0 0 0 18.856 13.32 13.32 0 0 0 18.856 0 13.32 13.32 0 0 0 0-18.856 13.32 13.32 0 0 0-18.856 0m17.527 8.099v2.658h-6.77v6.77h-2.658v-6.77h-6.77v-2.658h6.77v-6.77h2.658v6.77z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-previous:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Eprevious%3C/title%3E%3Cpath d='M20.94 9.88 19.06 8l-8 8 8 8 1.88-1.88L14.833 16z'/%3E%3C/svg%3E")}.ag-icon-right:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Eright%3C/title%3E%3Cpath d='m16 5.333-1.88 1.88 7.44 7.453H5.333v2.667H21.56l-7.44 7.453 1.88 1.88 10.667-10.667L16 5.332z'/%3E%3C/svg%3E")}.ag-icon-save:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Esave%3C/title%3E%3Cpath d='M25.333 16v9.333H6.666V16H3.999v9.333C3.999 26.8 5.199 28 6.666 28h18.667C26.8 28 28 26.8 28 25.333V16zm-8 .893 3.453-3.44 1.88 1.88L15.999 22l-6.667-6.667 1.88-1.88 3.453 3.44V4h2.667v12.893z'/%3E%3C/svg%3E")}.ag-icon-small-down:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Esmall-down%3C/title%3E%3Cpath d='M9.333 12.667 16 19.334l6.667-6.667H9.334z'/%3E%3C/svg%3E")}.ag-icon-small-left:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Esmall-left%3C/title%3E%3Cpath d='M19.333 9.333 12.666 16l6.667 6.667V9.334z'/%3E%3C/svg%3E")}.ag-icon-small-right:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Esmall-right%3C/title%3E%3Cpath d='M12.667 22.667 19.334 16l-6.667-6.667v13.333z'/%3E%3C/svg%3E")}.ag-icon-small-up:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Esmall-up%3C/title%3E%3Cpath d='M9.333 19.333 16 12.666l6.667 6.667H9.334z'/%3E%3C/svg%3E")}.ag-icon-tick:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Etick%3C/title%3E%3Cpath d='m11.727 21.167-5.56-5.56-1.893 1.88 7.453 7.453 16-16-1.88-1.88z'/%3E%3C/svg%3E")}.ag-icon-tree-closed:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Etree-closed%3C/title%3E%3Cpath d='m12.94 8-1.88 1.88L17.167 16l-6.107 6.12L12.94 24l8-8z'/%3E%3C/svg%3E")}.ag-icon-tree-indeterminate:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Etree-indeterminate%3C/title%3E%3Cpath d='M6.667 14.667h18.667v2.667H6.667z'/%3E%3C/svg%3E")}.ag-icon-tree-open:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Etree-open%3C/title%3E%3Cpath d='M22.12 11.06 16 17.167 9.88 11.06 8 12.94l8 8 8-8z'/%3E%3C/svg%3E")}.ag-icon-unlinked:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Eunlinked%3C/title%3E%3Cpath d='M22.667 9.333h-5.333v2.533h5.333a4.136 4.136 0 0 1 4.133 4.133c0 1.907-1.307 3.507-3.08 3.973l1.947 1.947c2.173-1.107 3.667-3.32 3.667-5.92a6.67 6.67 0 0 0-6.667-6.667zm-1.334 5.334h-2.92l2.667 2.667h.253zM2.667 5.693 6.814 9.84A6.65 6.65 0 0 0 2.667 16a6.67 6.67 0 0 0 6.667 6.667h5.333v-2.533H9.334a4.136 4.136 0 0 1-4.133-4.133c0-2.12 1.613-3.867 3.68-4.093l2.76 2.76h-.973v2.667h3.64l3.027 3.027v2.307h2.307l5.347 5.333 1.68-1.68L4.362 4.002 2.669 5.695z'/%3E%3C/svg%3E")}.ag-icon-up:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Easc%3C/title%3E%3Cpath d='m5.333 16 1.88 1.88 7.453-7.44v16.227h2.667V10.44l7.44 7.453L26.666 16 15.999 5.333z'/%3E%3C/svg%3E")}.ag-icon-grip:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Egrip%3C/title%3E%3Cpath d='M26.667 12H5.334v2.667h21.333zM5.333 20h21.333v-2.667H5.333z'/%3E%3C/svg%3E")}.ag-icon-settings:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='%23000' d='M30 8h-4.1c-.5-2.3-2.5-4-4.9-4s-4.4 1.7-4.9 4H2v2h14.1c.5 2.3 2.5 4 4.9 4s4.4-1.7 4.9-4H30zm-9 4c-1.7 0-3-1.3-3-3s1.3-3 3-3 3 1.3 3 3-1.3 3-3 3M2 24h4.1c.5 2.3 2.5 4 4.9 4s4.4-1.7 4.9-4H30v-2H15.9c-.5-2.3-2.5-4-4.9-4s-4.4 1.7-4.9 4H2zm9-4c1.7 0 3 1.3 3 3s-1.3 3-3 3-3-1.3-3-3 1.3-3 3-3'/%3E%3C/svg%3E")}.ag-icon-column-arrow:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='currentColor' fill-rule='evenodd' d='M11 4a1 1 0 0 1 1 1v22a1 1 0 1 1-2 0V5a1 1 0 0 1 1-1' clip-rule='evenodd'/%3E%3Cpath fill='currentColor' fill-rule='evenodd' d='M2 13a1 1 0 0 1 1-1h23.5a1 1 0 1 1 0 2H3a1 1 0 0 1-1-1' clip-rule='evenodd'/%3E%3Cpath fill='currentColor' fill-rule='evenodd' d='M2 4h18v24H2zm2 2v20h14V6zM26.793 13 23 9.207l1.414-1.414L29.621 13l-5.207 5.207L23 16.793z' clip-rule='evenodd'/%3E%3C/svg%3E")}.ag-icon-un-pin:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='none' viewBox='0 0 16 16'%3E%3Cpath fill='currentColor' d='M8 11a.75.75 0 0 0-.75.75v3.333a.75.75 0 1 0 1.5 0V11.75A.75.75 0 0 0 8 11'/%3E%3Cpath fill='currentColor' d='M13.11 1.436a.75.75 0 0 0-1.22-.872l-10 14a.75.75 0 1 0 1.22.872L5.207 12.5h7.376a.75.75 0 0 0 .75-.75v-1.174a2.08 2.08 0 0 0-1.153-1.863l-1.185-.599-.005-.002a.58.58 0 0 1-.323-.522V5.165a2.083 2.083 0 0 0 1.854-2.904zm-3.943 5.52v.634a2.08 2.08 0 0 0 1.153 1.863l1.185.6.005.002a.58.58 0 0 1 .323.522V11H6.28zM9.277 1H5.25a2.084 2.084 0 0 0-.083 4.165v1.676l1.5-2.132v-.292a.75.75 0 0 0-.75-.75H5.25a.584.584 0 0 1 0-1.167h2.972z'/%3E%3C/svg%3E")}.ag-icon-pinned-top:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='none' viewBox='0 0 16 16'%3E%3Cpath fill='currentColor' d='M12.53 3.72A.75.75 0 0 1 12 5H4a.75.75 0 0 1 0-1.5h8a.75.75 0 0 1 .53.22M3.269 10.744a.75.75 0 0 1 .2-.524l4-4a.75.75 0 0 1 1.06 0l4 4a.75.75 0 1 1-1.06 1.06L8.75 8.56V14a.75.75 0 0 1-1.5 0V8.56l-2.72 2.72a.75.75 0 0 1-1.26-.536'/%3E%3C/svg%3E")}.ag-icon-pinned-bottom:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='none' viewBox='0 0 16 16'%3E%3Cpath fill='currentColor' d='M3.47 12.28A.75.75 0 0 1 4 11h8a.75.75 0 0 1 0 1.5H4a.75.75 0 0 1-.53-.22M12.731 5.256a.75.75 0 0 1-.2.524l-4 4a.75.75 0 0 1-1.06 0l-4-4a.75.75 0 1 1 1.06-1.06l2.72 2.72V2a.75.75 0 0 1 1.5 0v5.44l2.72-2.72a.75.75 0 0 1 1.26.536'/%3E%3C/svg%3E")}.ag-icon-chevron-up:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='none' viewBox='0 0 16 16'%3E%3Cpath fill='currentColor' fill-rule='evenodd' d='M3.479 10.521a.75.75 0 0 1 0-1.06l4-4a.75.75 0 0 1 1.06 0l4 4a.75.75 0 0 1-1.06 1.06l-3.47-3.47-3.47 3.47a.75.75 0 0 1-1.06 0' clip-rule='evenodd'/%3E%3C/svg%3E")}.ag-icon-chevron-down:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='none' viewBox='0 0 16 16'%3E%3Cpath fill='currentColor' fill-rule='evenodd' d='M12.521 5.461a.75.75 0 0 1 0 1.06l-4 4a.75.75 0 0 1-1.06 0l-4-4a.75.75 0 0 1 1.06-1.06l3.47 3.47 3.47-3.47a.75.75 0 0 1 1.06 0' clip-rule='evenodd'/%3E%3C/svg%3E")}.ag-icon-chevron-left:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='none' viewBox='0 0 16 16'%3E%3Cpath fill='currentColor' fill-rule='evenodd' d='M10.53 12.512a.75.75 0 0 1-1.06 0l-4-4a.75.75 0 0 1 0-1.06l4-4a.75.75 0 0 1 1.06 1.06l-3.47 3.47 3.47 3.47a.75.75 0 0 1 0 1.06' clip-rule='evenodd'/%3E%3C/svg%3E")}.ag-icon-chevron-right:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='none' viewBox='0 0 16 16'%3E%3Cpath fill='currentColor' fill-rule='evenodd' d='M5.47 3.47a.75.75 0 0 1 1.06 0l4 4a.75.75 0 0 1 0 1.06l-4 4a.75.75 0 0 1-1.06-1.06L8.94 8 5.47 4.53a.75.75 0 0 1 0-1.06' clip-rule='evenodd'/%3E%3C/svg%3E")}.ag-icon-filter-add:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='currentColor' d='M18.666 24h-5.333v-2.667h5.333zM24 17.333H8v-2.667h16zm3.59-9.344h3.221v2.657h-3.22v3.22h-2.656v-3.22h-3.221V7.989h3.22V4.77h2.657zm-8.582 2.678H4V8h15.008z'/%3E%3C/svg%3E")}.ag-icon-edit:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='currentColor' d='M6.222 25.778h1.611l14.834-14.811-1.611-1.611-14.834 14.81zM4 28v-4.733L22.644 4.656a2.26 2.26 0 0 1 1.567-.634q.423 0 .833.167.412.166.734.478l1.589 1.6q.333.322.483.733t.15.822q0 .423-.161.839-.162.416-.472.728L8.733 28zm17.856-17.833-.8-.811 1.61 1.61z'/%3E%3C/svg%3E")}`;


/***/ }),

/***/ 98900:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.iconSetMaterial = void 0;
const Part_1 = __webpack_require__(86607);
const icon_set_material_css_GENERATED_1 = __webpack_require__(77545);
exports.iconSetMaterial = (0, Part_1.createPart)({
    feature: 'iconSet',
    css: icon_set_material_css_GENERATED_1.iconSetMaterialCSS,
});


/***/ }),

/***/ 95867:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.iconOverrides = void 0;
const Part_1 = __webpack_require__(86607);
const theme_types_1 = __webpack_require__(50113);
const iconOverrides = (args) => {
    const cssParts = [];
    if (args.type === 'image') {
        const { icons, mask } = args;
        for (const key of Object.keys(icons)) {
            const imageCssValue = (0, theme_types_1.imageValueToCss)(icons[key]);
            if (mask) {
                cssParts.push(`.ag-icon-${key}::before { mask-image: ${imageCssValue}; }`);
            }
            else {
                cssParts.push(`.ag-icon-${key}::before { background-image: ${imageCssValue}; ${unsetMaskIcon} }`);
            }
        }
    }
    if (args.type === 'font') {
        const { family, weight, color, icons } = args;
        let properties = unsetMaskIcon;
        if (family) {
            properties += ` font-family: ${(0, theme_types_1.fontFamilyValueToCss)(family)};`;
        }
        if (weight) {
            properties += ` font-weight: ${(0, theme_types_1.fontWeightValueToCss)(weight)};`;
        }
        if (color) {
            properties += ` color: ${(0, theme_types_1.colorValueToCss)(color)};`;
        }
        for (const key of Object.keys(icons)) {
            cssParts.push(`.ag-icon-${key}::before { content: ${JSON.stringify(icons[key])}; ${properties} }`);
        }
    }
    return (0, Part_1.createPart)({
        css: cssParts.join(';\n'),
        cssImports: args.cssImports,
    });
};
exports.iconOverrides = iconOverrides;
const unsetMaskIcon = `background-color: unset; mask-image: unset; -webkit-mask-image: unset;`;


/***/ }),

/***/ 53692:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.iconSetQuartzBold = exports.iconSetQuartzRegular = exports.iconSetQuartzLight = exports.iconSetQuartz = void 0;
const Part_1 = __webpack_require__(86607);
const quartz_icon_data_1 = __webpack_require__(21368);
const iconSetQuartz = (args = {}) => {
    return (0, Part_1.createPart)({
        feature: 'iconSet',
        css: () => (0, quartz_icon_data_1.getQuartzIconsCss)(args),
    });
};
exports.iconSetQuartz = iconSetQuartz;
exports.iconSetQuartzLight = (0, exports.iconSetQuartz)({ strokeWidth: 1 });
exports.iconSetQuartzRegular = (0, exports.iconSetQuartz)();
exports.iconSetQuartzBold = (0, exports.iconSetQuartz)({ strokeWidth: 2 });


/***/ }),

/***/ 21368:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getQuartzIconsCss = void 0;
const iconNameToSvgFragment = {
    aggregation: '<path d="M18 7V4H6l6 8-6 8h12v-3"/>',
    arrows: '<polyline points="5 9 2 12 5 15"/><polyline points="9 5 12 2 15 5"/><polyline points="15 19 12 22 9 19"/><polyline points="19 9 22 12 19 15"/><line x1="2" x2="22" y1="12" y2="12"/><line x1="12" x2="12" y1="2" y2="22"/>',
    asc: '<path d="m5 12 7-7 7 7"/><path d="M12 19V5"/>',
    cancel: '<path d="m18 6-12 12"/><path d="m6 6 12 12"/>',
    chart: '<line x1="18" x2="18" y1="20" y2="10"/><line x1="12" x2="12" y1="20" y2="4"/><line x1="6" x2="6" y1="20" y2="14"/>',
    'color-picker': '<path d="m19 11-8-8-8.6 8.6a2 2 0 0 0 0 2.8l5.2 5.2c.8.8 2 .8 2.8 0L19 11Z"/><path d="m5 2 5 5"/><path d="M2 13h15"/><path d="M22 20a2 2 0 1 1-4 0c0-1.6 1.7-2.4 2-4 .3 1.6 2 2.4 2 4Z"/>',
    columns: '<path d="M9 3H5a2 2 0 0 0-2 2v4m6-6h10a2 2 0 0 1 2 2v4M9 3v18m0 0h10a2 2 0 0 0 2-2V9M9 21H5a2 2 0 0 1-2-2V9m0 0h18"/>',
    contracted: '<path d="m9 18 6-6-6-6"/>',
    copy: '<rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/>',
    cross: '<path d="M18 6 6 18"/><path d="m6 6 12 12"/>',
    csv: '<path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><path d="M8 13h2"/><path d="M8 17h2"/><path d="M14 13h2"/><path d="M14 17h2"/>',
    cut: '<circle cx="6" cy="6" r="3"/><path d="M8.12 8.12 12 12"/><path d="M20 4 8.12 15.88"/><circle cx="6" cy="18" r="3"/><path d="M14.8 14.8 20 20"/>',
    desc: '<path d="M12 5v14"/><path d="m19 12-7 7-7-7"/>',
    down: '<path d="M12 5v14"/><path d="m19 12-7 7-7-7"/>',
    excel: '<path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><path d="M8 13h2"/><path d="M8 17h2"/><path d="M14 13h2"/><path d="M14 17h2"/>',
    expanded: '<path d="m15 18-6-6 6-6"/>',
    'eye-slash': '<path d="M9.88 9.88a3 3 0 1 0 4.24 4.24"/><path d="M10.73 5.08A10.43 10.43 0 0 1 12 5c7 0 10 7 10 7a13.16 13.16 0 0 1-1.67 2.68"/><path d="M6.61 6.61A13.526 13.526 0 0 0 2 12s3 7 10 7a9.74 9.74 0 0 0 5.39-1.61"/><line x1="2" x2="22" y1="2" y2="22"/>',
    eye: '<path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/>',
    filter: '<path d="M3 6h18"/><path d="M7 12h10"/><path d="M10 18h4"/>',
    first: '<path d="m17 18-6-6 6-6"/><path d="M7 6v12"/>',
    group: '<path d="M16 12H3"/><path d="M16 18H3"/><path d="M10 6H3"/><path d="M21 18V8a2 2 0 0 0-2-2h-5"/><path d="m16 8-2-2 2-2"/>',
    last: '<path d="m7 18 6-6-6-6"/><path d="M17 6v12"/>',
    left: '<path d="m12 19-7-7 7-7"/><path d="M19 12H5"/>',
    linked: '<path d="M9 17H7A5 5 0 0 1 7 7h2"/><path d="M15 7h2a5 5 0 1 1 0 10h-2"/><line x1="8" x2="16" y1="12" y2="12"/>',
    loading: '<line x1="12" x2="12" y1="2" y2="6"/><line x1="12" x2="12" y1="18" y2="22"/><line x1="4.93" x2="7.76" y1="4.93" y2="7.76"/><line x1="16.24" x2="19.07" y1="16.24" y2="19.07"/><line x1="2" x2="6" y1="12" y2="12"/><line x1="18" x2="22" y1="12" y2="12"/><line x1="4.93" x2="7.76" y1="19.07" y2="16.24"/><line x1="16.24" x2="19.07" y1="7.76" y2="4.93"/>',
    maximize: '<polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><line x1="21" x2="14" y1="3" y2="10"/><line x1="3" x2="10" y1="21" y2="14"/>',
    menu: '<line x1="4" x2="20" y1="12" y2="12"/><line x1="4" x2="20" y1="6" y2="6"/><line x1="4" x2="20" y1="18" y2="18"/>',
    'menu-alt': '<circle cx="12" cy="5" r="0.75" fill="#D9D9D9"/><circle cx="12" cy="12" r="0.75" fill="#D9D9D9"/><circle cx="12" cy="19" r="0.75" fill="#D9D9D9"/>',
    minimize: '<polyline points="4 14 10 14 10 20"/><polyline points="20 10 14 10 14 4"/><line x1="14" x2="21" y1="10" y2="3"/><line x1="3" x2="10" y1="21" y2="14"/>',
    minus: '<circle cx="12" cy="12" r="10"/><path d="M8 12h8"/>',
    next: '<path d="m9 18 6-6-6-6"/>',
    none: '<path d="m7 15 5 5 5-5"/><path d="m7 9 5-5 5 5"/>',
    'not-allowed': '<circle cx="12" cy="12" r="10"/><path d="m4.9 4.9 14.2 14.2"/>',
    paste: '<path d="M15 2H9a1 1 0 0 0-1 1v2c0 .6.4 1 1 1h6c.6 0 1-.4 1-1V3c0-.6-.4-1-1-1Z"/><path d="M8 4H6a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2M16 4h2a2 2 0 0 1 2 2v2M11 14h10"/><path d="m17 10 4 4-4 4"/>',
    pin: '<line x1="12" x2="12" y1="17" y2="22"/><path d="M5 17h14v-1.76a2 2 0 0 0-1.11-1.79l-1.78-.9A2 2 0 0 1 15 10.76V6h1a2 2 0 0 0 0-4H8a2 2 0 0 0 0 4h1v4.76a2 2 0 0 1-1.11 1.79l-1.78.9A2 2 0 0 0 5 15.24Z"/>',
    pivot: '<path d="M15 3v18"/><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M21 9H3"/><path d="M21 15H3"/>',
    plus: '<circle cx="12" cy="12" r="10"/><path d="M8 12h8"/><path d="M12 8v8"/>',
    previous: '<path d="m15 18-6-6 6-6"/>',
    right: '<path d="M5 12h14"/><path d="m12 5 7 7-7 7"/>',
    save: '<path d="M12 17V3"/><path d="m6 11 6 6 6-6"/><path d="M19 21H5"/>',
    'small-left': '<path d="m15 18-6-6 6-6"/>',
    'small-right': '<path d="m9 18 6-6-6-6"/>',
    tick: '<path d="M20 6 9 17l-5-5"/>',
    'tree-closed': '<path d="m9 18 6-6-6-6"/>',
    'tree-indeterminate': '<path d="M5 12h14"/>',
    'tree-open': '<path d="m6 9 6 6 6-6"/>',
    unlinked: '<path d="M9 17H7A5 5 0 0 1 7 7"/><path d="M15 7h2a5 5 0 0 1 4 8"/><line x1="8" x2="12" y1="12" y2="12"/><line x1="2" x2="22" y1="2" y2="22"/>',
    up: '<path d="m5 12 7-7 7 7"/><path d="M12 19V5"/>',
    grip: '<circle cx="5" cy="8" r="0.5"/><circle cx="12" cy="8" r="0.5"/><circle cx="19" cy="8" r="0.5"/><circle cx="5" cy="16" r="0.5"/><circle cx="12" cy="16" r="0.5"/><circle cx="19" cy="16" r="0.5"/>' +
        '<g stroke="none" fill="currentColor"><circle cx="5" cy="8" r="1"/><circle cx="12" cy="8" r="1"/><circle cx="19" cy="8" r="1"/><circle cx="5" cy="16" r="1"/><circle cx="12" cy="16" r="1"/><circle cx="19" cy="16" r="1"/></g>',
    settings: '<path d="M20 7h-9"/><path d="M14 17H5"/><circle cx="17" cy="17" r="3"/><circle cx="7" cy="7" r="3"/>',
};
const iconNameToFullSvg = {
    'column-arrow': '<svg xmlns="http://www.w3.org/2000/svg" class="ag-icon" fill="none" viewBox="0 0 32 32"><path fill-rule="evenodd" clip-rule="evenodd" d="M0 26C0 28.2092 1.79086 30 4 30H14C16.2091 30 18 28.2092 18 26V15H25.8786L24.4394 16.4393C23.8536 17.0251 23.8536 17.9749 24.4394 18.5607C25.0252 19.1464 25.9748 19.1464 26.5606 18.5607L30.5606 14.5607C31.1464 13.9749 31.1464 13.0251 30.5606 12.4393L26.5606 8.43934C25.9748 7.85356 25.0252 7.85356 24.4394 8.43934C23.8536 9.02512 23.8536 9.97488 24.4394 10.5607L25.8786 12H18V6C18 3.79086 16.2091 2 14 2H4C1.79086 2 0 3.79086 0 6V26ZM14 5H10.5V12H15V6C15 5.44772 14.5523 5 14 5ZM4 5H7.5V12H3V6C3 5.44772 3.44772 5 4 5ZM10.5 15H15V26C15 26.5522 14.5523 27 14 27H10.5V15ZM4 27H7.5V15H3V26C3 26.5522 3.44772 27 4 27Z" fill="currentColor"/></svg>',
    'small-down': '<svg xmlns="http://www.w3.org/2000/svg" class="ag-icon" fill="black" stroke="none" viewBox="0 0 32 32"><path d="M7.334 10.667 16 21.334l8.667-10.667H7.334Z"/></svg>',
    'small-up': '<svg xmlns="http://www.w3.org/2000/svg" class="ag-icon" fill="black" stroke="none" viewBox="0 0 32 32"><path d="M7.334 21.333 16 10.666l8.667 10.667H7.334Z"/></svg>',
    'pinned-top': '<svg xmlns="http://www.w3.org/2000/svg" class="ag-icon" fill="none" viewBox="0 0 16 16"><path fill="currentColor" d="M12.53 3.72A.75.75 0 0 1 12 5H4a.75.75 0 0 1 0-1.5h8a.75.75 0 0 1 .53.22ZM3.269 10.744a.75.75 0 0 1 .2-.524l4-4a.75.75 0 0 1 1.06 0l4 4a.75.75 0 1 1-1.06 1.06L8.75 8.56V14a.75.75 0 0 1-1.5 0V8.56l-2.72 2.72a.75.75 0 0 1-1.26-.536Z"/></svg>',
    'pinned-bottom': '<svg xmlns="http://www.w3.org/2000/svg" fill="none" class="ag-icon" viewBox="0 0 16 16"><path fill="currentColor" d="M3.47 12.28A.75.75 0 0 1 4 11h8a.75.75 0 0 1 0 1.5H4a.75.75 0 0 1-.53-.22ZM12.731 5.256a.75.75 0 0 1-.2.524l-4 4a.75.75 0 0 1-1.06 0l-4-4a.75.75 0 1 1 1.06-1.06l2.72 2.72V2a.75.75 0 0 1 1.5 0v5.44l2.72-2.72a.75.75 0 0 1 1.26.536Z"/></svg>',
    'un-pin': '<svg xmlns="http://www.w3.org/2000/svg" fill="none" class="ag-icon" viewBox="0 0 16 16"><path fill="currentColor" d="M8 11a.75.75 0 0 0-.75.75v3.333a.75.75 0 1 0 1.5 0V11.75A.75.75 0 0 0 8 11Z"/><path fill="currentColor" d="M13.11 1.436a.75.75 0 0 0-1.22-.872l-10 14a.75.75 0 1 0 1.22.872L5.207 12.5h7.376a.75.75 0 0 0 .75-.75v-1.174a2.08 2.08 0 0 0-1.153-1.863l-1.185-.599-.005-.002a.58.58 0 0 1-.323-.522V5.165a2.083 2.083 0 0 0 1.854-2.904l.589-.825Zm-3.943 5.52v.634a2.08 2.08 0 0 0 1.153 1.863l1.185.6.005.002a.58.58 0 0 1 .323.522V11H6.28l2.887-4.044ZM9.277 1H5.25a2.084 2.084 0 0 0-.083 4.165v1.676l1.5-2.132v-.292a.75.75 0 0 0-.75-.75H5.25a.584.584 0 0 1 0-1.167h2.972L9.277 1Z"/></svg>',
    'chevron-down': '<svg width="16" height="16" viewBox="0 0 16 16" class="ag-icon" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 6L8 10L4 6" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>',
    'chevron-up': '<svg width="16" height="16" viewBox="0 0 16 16" class="ag-icon" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4 10L8 6L12 10" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>',
    'chevron-left': '<svg width="16" height="16" viewBox="0 0 16 16" class="ag-icon" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10 12L6 8L10 4" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>',
    'chevron-right': '<svg width="16" height="16" viewBox="0 0 16 16" class="ag-icon" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6 12L10 8L6 4" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>',
    'filter-add': '<svg width="16" height="16" viewBox="0 0 16 16" class="ag-icon" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5.12126 7.75L10.8517 7.75" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/><path d="M6.65934 11.748L9.32778 11.748" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/><path d="M12.2943 1.04872V6.19184M14.9886 3.74341H9.68478" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/><path d="M8.25488 3C8.04799 3.18323 7.91706 3.45099 7.91699 3.74902C7.91713 4.04868 8.04988 4.31681 8.25879 4.5H2C1.58579 4.5 1.25 4.16421 1.25 3.75C1.25 3.33579 1.58579 3 2 3H8.25488Z" fill="currentColor"/></svg>',
    edit: '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.5 10.6262V12.5012H5.375L10.905 6.97122L9.03 5.09622L3.5 10.6262ZM12.355 5.52122C12.4014 5.47497 12.4381 5.42002 12.4632 5.35953C12.4883 5.29905 12.5012 5.23421 12.5012 5.16872C12.5012 5.10324 12.4883 5.0384 12.4632 4.97791C12.4381 4.91742 12.4014 4.86248 12.355 4.81622L11.185 3.64622C11.1387 3.59987 11.0838 3.5631 11.0233 3.53801C10.9628 3.51291 10.898 3.5 10.8325 3.5C10.767 3.5 10.7022 3.51291 10.6417 3.53801C10.5812 3.5631 10.5263 3.59987 10.48 3.64622L9.565 4.56122L11.44 6.43622L12.355 5.52122Z" fill="currentColor"/></svg>',
};
const getQuartzIconsCss = (args = {}) => {
    let result = '';
    for (const iconName of [...Object.keys(iconNameToSvgFragment), ...Object.keys(iconNameToFullSvg)]) {
        const iconSvg = quartzIconSvg(iconName, args.strokeWidth);
        result += `.ag-icon-${iconName}::before { mask-image: url('data:image/svg+xml,${encodeURIComponent(iconSvg)}'); }\n`;
    }
    return result;
};
exports.getQuartzIconsCss = getQuartzIconsCss;
const quartzIconSvg = (name, strokeWidth = 1.5) => {
    const fullSVG = iconNameToFullSvg[name];
    if (fullSVG)
        return fullSVG;
    const svgFragment = iconNameToSvgFragment[name];
    if (!svgFragment)
        throw new Error(`Missing icon data for ${name}`);
    return (`<svg xmlns="http://www.w3.org/2000/svg" class="ag-icon" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke="black" stroke-width="${strokeWidth}" viewBox="0 0 24 24">` +
        '<style>* { vector-effect: non-scaling-stroke; }</style>' +
        svgFragment +
        '</svg>');
};


/***/ }),

/***/ 62543:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.inputStyleBaseCSS = void 0;
exports.inputStyleBaseCSS = `:where(.ag-input-field-input[type=number]:not(.ag-number-field-input-stepper)){-webkit-appearance:textfield;-moz-appearance:textfield;appearance:textfield;&::-webkit-inner-spin-button,&::-webkit-outer-spin-button{-webkit-appearance:none;appearance:none;margin:0}}.ag-input-field-input:where(input:not([type]),input[type=text],input[type=number],input[type=tel],input[type=date],input[type=datetime-local],textarea){background-color:var(--ag-input-background-color);border:var(--ag-input-border);border-radius:var(--ag-input-border-radius);color:var(--ag-input-text-color);font-family:inherit;font-size:inherit;line-height:inherit;margin:0;min-height:var(--ag-input-height);padding:0;&:where(:disabled){background-color:var(--ag-input-disabled-background-color);border:var(--ag-input-disabled-border);color:var(--ag-input-disabled-text-color)}&:where(:focus){background-color:var(--ag-input-focus-background-color);border:var(--ag-input-focus-border);box-shadow:var(--ag-input-focus-shadow);color:var(--ag-input-focus-text-color);outline:none}&:where(:invalid){background-color:var(--ag-input-invalid-background-color);border:var(--ag-input-invalid-border);color:var(--ag-input-invalid-text-color)}&:where(.invalid){background-color:var(--ag-input-invalid-background-color);border:var(--ag-input-invalid-border);color:var(--ag-input-invalid-text-color)}&::-moz-placeholder{color:var(--ag-input-placeholder-text-color)}&::placeholder{color:var(--ag-input-placeholder-text-color)}}:where(.ag-ltr) .ag-input-field-input:where(input:not([type]),input[type=text],input[type=number],input[type=tel],input[type=date],input[type=datetime-local],textarea){padding-left:var(--ag-input-padding-start)}:where(.ag-rtl) .ag-input-field-input:where(input:not([type]),input[type=text],input[type=number],input[type=tel],input[type=date],input[type=datetime-local],textarea){padding-right:var(--ag-input-padding-start)}:where(.ag-column-select-header-filter-wrapper,.ag-filter-toolpanel-search,.ag-mini-filter,.ag-filter-filter,.ag-filter-add-select){.ag-input-wrapper:before{background-color:currentcolor;color:var(--ag-input-icon-color);content:"";display:block;height:12px;-webkit-mask-image:url("data:image/svg+xml;charset=utf-8;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMiIgaGVpZ2h0PSIxMiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMS41Ij48cGF0aCBkPSJNNS4zIDlhMy43IDMuNyAwIDEgMCAwLTcuNSAzLjcgMy43IDAgMCAwIDAgNy41Wk0xMC41IDEwLjUgOC4zIDguMiIvPjwvc3ZnPg==");mask-image:url("data:image/svg+xml;charset=utf-8;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMiIgaGVpZ2h0PSIxMiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMS41Ij48cGF0aCBkPSJNNS4zIDlhMy43IDMuNyAwIDEgMCAwLTcuNSAzLjcgMy43IDAgMCAwIDAgNy41Wk0xMC41IDEwLjUgOC4zIDguMiIvPjwvc3ZnPg==");-webkit-mask-position:center;mask-position:center;-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;opacity:.5;position:absolute;width:12px}}:where(.ag-ltr) :where(.ag-column-select-header-filter-wrapper,.ag-filter-toolpanel-search,.ag-mini-filter,.ag-filter-filter,.ag-filter-add-select){.ag-input-wrapper:before{margin-left:var(--ag-spacing)}.ag-number-field-input,.ag-text-field-input{padding-left:calc(var(--ag-spacing)*1.5 + 12px)}}:where(.ag-rtl) :where(.ag-column-select-header-filter-wrapper,.ag-filter-toolpanel-search,.ag-mini-filter,.ag-filter-filter,.ag-filter-add-select){.ag-input-wrapper:before{margin-right:var(--ag-spacing)}.ag-number-field-input,.ag-text-field-input{padding-right:calc(var(--ag-spacing)*1.5 + 12px)}}`;


/***/ }),

/***/ 37389:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.inputStyleBorderedCSS = void 0;
exports.inputStyleBorderedCSS = `.ag-input-field-input:where(input:not([type]),input[type=text],input[type=number],input[type=tel],input[type=date],input[type=datetime-local],textarea){&:focus{box-shadow:var(--ag-focus-shadow);&:where(.invalid),&:where(:invalid){box-shadow:var(--ag-focus-error-shadow)}}}`;


/***/ }),

/***/ 33054:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.inputStyleUnderlinedCSS = void 0;
exports.inputStyleUnderlinedCSS = `.ag-input-field-input:where(input:not([type]),input[type=text],input[type=number],input[type=tel],input[type=date],input[type=datetime-local],textarea){border-left:none;border-right:none;border-top:none}`;


/***/ }),

/***/ 87161:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.inputStyleUnderlined = exports.inputStyleBordered = exports.inputStyleBase = void 0;
const Part_1 = __webpack_require__(86607);
const theme_utils_1 = __webpack_require__(77845);
const input_style_base_css_GENERATED_1 = __webpack_require__(62543);
const input_style_bordered_css_GENERATED_1 = __webpack_require__(37389);
const input_style_underlined_css_GENERATED_1 = __webpack_require__(33054);
const baseParams = {
    inputBackgroundColor: 'transparent',
    inputBorder: false,
    inputBorderRadius: 0,
    inputTextColor: {
        ref: 'textColor',
    },
    inputPlaceholderTextColor: {
        ref: 'inputTextColor',
        mix: 0.5,
    },
    inputPaddingStart: 0,
    inputHeight: {
        calc: 'max(iconSize, fontSize) + spacing * 2',
    },
    inputFocusBackgroundColor: {
        ref: 'inputBackgroundColor',
    },
    inputFocusBorder: {
        ref: 'inputBorder',
    },
    inputFocusShadow: 'none',
    inputFocusTextColor: {
        ref: 'inputTextColor',
    },
    inputDisabledBackgroundColor: {
        ref: 'inputBackgroundColor',
    },
    inputDisabledBorder: {
        ref: 'inputBorder',
    },
    inputDisabledTextColor: {
        ref: 'inputTextColor',
    },
    inputInvalidBackgroundColor: {
        ref: 'inputBackgroundColor',
    },
    inputInvalidBorder: {
        ref: 'inputBorder',
    },
    inputInvalidTextColor: {
        ref: 'inputTextColor',
    },
    inputIconColor: {
        ref: 'inputTextColor',
    },
    pickerButtonBorder: false,
    pickerButtonFocusBorder: { ref: 'inputFocusBorder' },
    pickerButtonBackgroundColor: { ref: 'backgroundColor' },
    pickerButtonFocusBackgroundColor: { ref: 'backgroundColor' },
    pickerListBorder: false,
    pickerListBackgroundColor: { ref: 'backgroundColor' },
};
const makeInputStyleBaseTreeShakeable = () => (0, Part_1.createPart)({
    feature: 'inputStyle',
    params: baseParams,
    css: input_style_base_css_GENERATED_1.inputStyleBaseCSS,
});
exports.inputStyleBase = makeInputStyleBaseTreeShakeable();
const makeInputStyleBorderedTreeShakeable = () => (0, Part_1.createPart)({
    feature: 'inputStyle',
    params: {
        ...baseParams,
        inputBackgroundColor: theme_utils_1.backgroundColor,
        inputBorder: true,
        inputBorderRadius: {
            ref: 'borderRadius',
        },
        inputPaddingStart: {
            ref: 'spacing',
        },
        inputFocusBorder: {
            color: theme_utils_1.accentColor,
        },
        inputFocusShadow: {
            ref: 'focusShadow',
        },
        inputDisabledBackgroundColor: (0, theme_utils_1.foregroundBackgroundMix)(0.06),
        inputDisabledTextColor: {
            ref: 'textColor',
            mix: 0.5,
        },
        inputInvalidBorder: {
            color: { ref: 'invalidColor' },
        },
        pickerButtonBorder: true,
        pickerListBorder: true,
    },
    css: () => input_style_base_css_GENERATED_1.inputStyleBaseCSS + input_style_bordered_css_GENERATED_1.inputStyleBorderedCSS,
});
exports.inputStyleBordered = makeInputStyleBorderedTreeShakeable();
const makeInputStyleUnderlinedTreeShakeable = () => (0, Part_1.createPart)({
    feature: 'inputStyle',
    params: {
        ...baseParams,
        inputBackgroundColor: 'transparent',
        inputBorder: {
            width: 2,
            color: (0, theme_utils_1.foregroundMix)(0.3),
        },
        inputPaddingStart: {
            ref: 'spacing',
        },
        inputFocusBorder: 'solid 2px var(--ag-accent-color)',
        inputDisabledTextColor: {
            ref: 'textColor',
            mix: 0.5,
        },
        inputDisabledBorder: 'solid 1px var(--ag-border-color)',
        inputInvalidBorder: {
            width: 2,
            color: {
                ref: 'invalidColor',
                mix: 0.3,
            },
        },
    },
    css: () => input_style_base_css_GENERATED_1.inputStyleBaseCSS + input_style_underlined_css_GENERATED_1.inputStyleUnderlinedCSS,
});
exports.inputStyleUnderlined = makeInputStyleUnderlinedTreeShakeable();


/***/ }),

/***/ 54907:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.tabStyleBaseCSS = void 0;
exports.tabStyleBaseCSS = `.ag-tabs-header{background-color:var(--ag-tab-bar-background-color);border-bottom:var(--ag-tab-bar-border);display:flex;flex:1;gap:var(--ag-tab-spacing);padding:var(--ag-tab-bar-top-padding) var(--ag-tab-bar-horizontal-padding) 0}.ag-tabs-header-wrapper{display:flex}.ag-tabs-close-button-wrapper{align-items:center;border:0;display:flex;padding:var(--ag-spacing)}:where(.ag-ltr) .ag-tabs-close-button-wrapper{border-right:solid var(--ag-border-width) var(--ag-border-color)}:where(.ag-rtl) .ag-tabs-close-button-wrapper{border-left:solid var(--ag-border-width) var(--ag-border-color)}.ag-tabs-close-button{background-color:unset;border:0;cursor:pointer;padding:0}.ag-tab{align-items:center;background-color:var(--ag-tab-background-color);border-left:var(--ag-tab-selected-border-width) solid transparent;border-right:var(--ag-tab-selected-border-width) solid transparent;color:var(--ag-tab-text-color);cursor:pointer;display:flex;flex:1;justify-content:center;padding:var(--ag-tab-top-padding) var(--ag-tab-horizontal-padding) var(--ag-tab-bottom-padding);position:relative;&:hover{background-color:var(--ag-tab-hover-background-color);color:var(--ag-tab-hover-text-color)}&.ag-tab-selected{background-color:var(--ag-tab-selected-background-color);color:var(--ag-tab-selected-text-color)}&:after{background-color:var(--ag-tab-selected-underline-color);bottom:0;content:"";display:block;height:var(--ag-tab-selected-underline-width);left:0;opacity:0;position:absolute;right:0;transition:opacity var(--ag-tab-selected-underline-transition-duration)}&.ag-tab-selected:after{opacity:1}}:where(.ag-ltr) .ag-tab{&.ag-tab-selected{&:where(:not(:first-of-type)){border-left-color:var(--ag-tab-selected-border-color)}&:where(:not(:last-of-type)){border-right-color:var(--ag-tab-selected-border-color)}}}:where(.ag-rtl) .ag-tab{&.ag-tab-selected{&:where(:not(:first-of-type)){border-right-color:var(--ag-tab-selected-border-color)}&:where(:not(:last-of-type)){border-left-color:var(--ag-tab-selected-border-color)}}}`;


/***/ }),

/***/ 95797:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.tabStyleRolodexCSS = void 0;
exports.tabStyleRolodexCSS = `.ag-tab{border-left:var(--ag-tab-selected-border-width) solid transparent;border-right:var(--ag-tab-selected-border-width) solid transparent;border-top:var(--ag-tab-selected-border-width) solid transparent;flex:none;&.ag-tab-selected{border-left-color:var(--ag-tab-selected-border-color);border-right-color:var(--ag-tab-selected-border-color);border-top-color:var(--ag-tab-selected-border-color);margin-bottom:-1px;padding-bottom:calc(var(--ag-tab-bottom-padding) + 1px)}}`;


/***/ }),

/***/ 5117:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.tabStyleRolodex = exports.tabStyleAlpine = exports.tabStyleMaterial = exports.tabStyleQuartz = exports.tabStyleBase = void 0;
const Part_1 = __webpack_require__(86607);
const theme_utils_1 = __webpack_require__(77845);
const tab_style_base_css_GENERATED_1 = __webpack_require__(54907);
const tab_style_rolodex_css_GENERATED_1 = __webpack_require__(95797);
const baseParams = {
    tabBarBackgroundColor: 'transparent',
    tabBarHorizontalPadding: 0,
    tabBarTopPadding: 0,
    tabBackgroundColor: 'transparent',
    tabTextColor: {
        ref: 'textColor',
    },
    tabHorizontalPadding: {
        ref: 'spacing',
    },
    tabTopPadding: {
        ref: 'spacing',
    },
    tabBottomPadding: {
        ref: 'spacing',
    },
    tabSpacing: '0',
    tabHoverBackgroundColor: {
        ref: 'tabBackgroundColor',
    },
    tabHoverTextColor: {
        ref: 'tabTextColor',
    },
    tabSelectedBackgroundColor: {
        ref: 'tabBackgroundColor',
    },
    tabSelectedTextColor: {
        ref: 'tabTextColor',
    },
    tabSelectedBorderWidth: { ref: 'borderWidth' },
    tabSelectedBorderColor: 'transparent',
    tabSelectedUnderlineColor: 'transparent',
    tabSelectedUnderlineWidth: 0,
    tabSelectedUnderlineTransitionDuration: 0,
    tabBarBorder: false,
};
const makeTabStyleBaseTreeShakeable = () => (0, Part_1.createPart)({
    feature: 'tabStyle',
    params: baseParams,
    css: tab_style_base_css_GENERATED_1.tabStyleBaseCSS,
});
/**
 * This base tab style adds no visual styling, it provides a base upon which a
 * tab style can be built by setting the tab-related params
 */
exports.tabStyleBase = makeTabStyleBaseTreeShakeable();
const makeTabStyleQuartzTreeShakeable = () => (0, Part_1.createPart)({
    feature: 'tabStyle',
    params: {
        ...baseParams,
        tabBarBorder: true,
        tabBarBackgroundColor: (0, theme_utils_1.foregroundMix)(0.05),
        tabTextColor: {
            ref: 'textColor',
            mix: 0.7,
        },
        tabSelectedTextColor: {
            ref: 'textColor',
        },
        tabHoverTextColor: {
            ref: 'textColor',
        },
        tabSelectedBorderColor: {
            ref: 'borderColor',
        },
        tabSelectedBackgroundColor: theme_utils_1.backgroundColor,
    },
    css: tab_style_base_css_GENERATED_1.tabStyleBaseCSS,
});
/**
 * Tabs styled for the Quartz theme
 */
exports.tabStyleQuartz = makeTabStyleQuartzTreeShakeable();
const makeTabStyleMaterialTreeShakeable = () => (0, Part_1.createPart)({
    feature: 'tabStyle',
    params: {
        ...baseParams,
        tabBarBackgroundColor: {
            ref: 'chromeBackgroundColor',
        },
        tabSelectedUnderlineColor: {
            ref: 'primaryColor',
        },
        tabSelectedUnderlineWidth: 2,
        tabSelectedUnderlineTransitionDuration: 0,
    },
    css: tab_style_base_css_GENERATED_1.tabStyleBaseCSS,
});
/**
 * Tabs styled for the Material theme
 */
exports.tabStyleMaterial = makeTabStyleMaterialTreeShakeable();
const makeTabStyleAlpineTreeShakeable = () => (0, Part_1.createPart)({
    feature: 'tabStyle',
    params: {
        ...baseParams,
        tabBarBorder: true,
        tabBarBackgroundColor: {
            ref: 'chromeBackgroundColor',
        },
        tabHoverTextColor: theme_utils_1.accentColor,
        tabSelectedTextColor: theme_utils_1.accentColor,
        tabSelectedUnderlineColor: theme_utils_1.accentColor,
        tabSelectedUnderlineWidth: 2,
        tabSelectedUnderlineTransitionDuration: '0.3s',
    },
    css: tab_style_base_css_GENERATED_1.tabStyleBaseCSS,
});
/**
 * Tabs styled for the Alpine theme
 */
exports.tabStyleAlpine = makeTabStyleAlpineTreeShakeable();
const makeTabStyleRolodexTreeShakeable = () => (0, Part_1.createPart)({
    feature: 'tabStyle',
    params: {
        ...baseParams,
        tabBarBackgroundColor: {
            ref: 'chromeBackgroundColor',
        },
        tabBarHorizontalPadding: {
            ref: 'spacing',
        },
        tabBarTopPadding: {
            ref: 'spacing',
        },
        tabBarBorder: true,
        tabHorizontalPadding: { calc: 'spacing * 2' },
        tabTopPadding: {
            ref: 'spacing',
        },
        tabBottomPadding: {
            ref: 'spacing',
        },
        tabSpacing: {
            ref: 'spacing',
        },
        tabSelectedBorderColor: {
            ref: 'borderColor',
        },
        tabSelectedBackgroundColor: theme_utils_1.backgroundColor,
    },
    css: () => tab_style_base_css_GENERATED_1.tabStyleBaseCSS + tab_style_rolodex_css_GENERATED_1.tabStyleRolodexCSS,
});
/**
 * Tabs where the selected tab appears raised and attached the the active
 * content, like a rolodex or operating system tabs.
 */
exports.tabStyleRolodex = makeTabStyleRolodexTreeShakeable();


/***/ }),

/***/ 20142:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.materialAdjustmentsCSS = void 0;
exports.materialAdjustmentsCSS = `.ag-dnd-ghost,.ag-filter-toolpanel-header,.ag-filter-toolpanel-search,.ag-multi-filter-group-title-bar,.ag-panel-title-bar-title,.ag-status-bar{color:var(--ag-header-text-color);font-size:calc(var(--ag-font-size) - 1px);font-weight:600}.ag-column-drop-horizontal{background-color:color-mix(in srgb,var(--ag-background-color),var(--ag-foreground-color) 8%)}.ag-cell.ag-cell-inline-editing{background-color:var(--ag-background-color);background-image:linear-gradient(0deg,var(--ag-input-background-color),var(--ag-input-background-color));border:var(--ag-input-border)!important;border-width:1px!important;height:calc(var(--ag-row-height) + var(--ag-spacing)*3);padding:var(--ag-spacing);:where(.ag-row-last:not(.ag-row-first)) &{bottom:0}:where(.ag-has-focus) &{border:var(--ag-input-focus-border)!important;border-width:1px!important}}.ag-advanced-filter-builder-button,.ag-standard-button{text-transform:uppercase}.ag-status-bar{border:solid var(--ag-border-width) var(--ag-border-color)}.ag-list-item-hovered:after{background-color:var(--ag-primary-color)}.ag-pill-button:hover{color:var(--ag-primary-color)}.ag-header-highlight-after:after,.ag-header-highlight-before:after{background-color:var(--ag-primary-color)}.ag-filter-add-button,.ag-filter-add-button:hover{border-bottom:2px solid var(--ag-primary-color)}`;


/***/ }),

/***/ 2525:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.themeMaterial = exports.styleMaterial = exports.themeBalham = exports.themeAlpine = exports.themeQuartz = void 0;
const Part_1 = __webpack_require__(86607);
const Theme_1 = __webpack_require__(39621);
const theme_utils_1 = __webpack_require__(77845);
const button_styles_1 = __webpack_require__(82475);
const checkbox_styles_1 = __webpack_require__(98265);
const color_schemes_1 = __webpack_require__(38689);
const column_drop_styles_1 = __webpack_require__(21697);
const icon_set_balham_1 = __webpack_require__(65572);
const icon_sets_1 = __webpack_require__(26407);
const input_styles_1 = __webpack_require__(87161);
const tab_styles_1 = __webpack_require__(5117);
const material_adjustments_css_GENERATED_1 = __webpack_require__(20142);
const makeThemeQuartzTreeShakeable = () => (0, Theme_1.createTheme)()
    .withPart(checkbox_styles_1.checkboxStyleDefault)
    .withPart(color_schemes_1.colorSchemeVariable)
    .withPart(icon_sets_1.iconSetQuartzRegular)
    .withPart(tab_styles_1.tabStyleQuartz)
    .withPart(input_styles_1.inputStyleBordered)
    .withPart(column_drop_styles_1.columnDropStyleBordered)
    .withParams({
    fontFamily: [
        { googleFont: 'IBM Plex Sans' },
        '-apple-system',
        'BlinkMacSystemFont',
        'Segoe UI',
        'Roboto',
        'Oxygen-Sans',
        'Ubuntu',
    ],
});
exports.themeQuartz = 
/*#__PURE__*/
makeThemeQuartzTreeShakeable();
const makeThemeAlpineTreeShakeable = () => (0, Theme_1.createTheme)()
    .withPart(button_styles_1.buttonStyleAlpine)
    .withPart(checkbox_styles_1.checkboxStyleDefault)
    .withPart(color_schemes_1.colorSchemeVariable)
    .withPart(icon_sets_1.iconSetAlpine)
    .withPart(tab_styles_1.tabStyleAlpine)
    .withPart(input_styles_1.inputStyleBordered)
    .withPart(column_drop_styles_1.columnDropStyleBordered)
    .withParams({
    accentColor: '#2196f3',
    selectedRowBackgroundColor: (0, theme_utils_1.accentMix)(0.3),
    inputFocusBorder: {
        color: (0, theme_utils_1.accentMix)(0.4),
    },
    focusShadow: { radius: 2, spread: 1.6, color: (0, theme_utils_1.accentMix)(0.4) },
    iconButtonHoverBackgroundColor: 'transparent',
    iconButtonActiveBackgroundColor: 'transparent',
    checkboxUncheckedBorderColor: (0, theme_utils_1.foregroundBackgroundMix)(0.45),
    checkboxIndeterminateBackgroundColor: (0, theme_utils_1.foregroundBackgroundMix)(0.45),
    checkboxIndeterminateBorderColor: (0, theme_utils_1.foregroundBackgroundMix)(0.45),
    checkboxBorderWidth: 2,
    checkboxBorderRadius: 2,
    fontSize: 13,
    dataFontSize: 14,
    headerFontWeight: 700,
    borderRadius: 3,
    wrapperBorderRadius: 3,
    tabSelectedUnderlineColor: theme_utils_1.accentColor,
    tabSelectedBorderWidth: 0,
    tabSelectedUnderlineTransitionDuration: 0.3,
    sideButtonSelectedUnderlineColor: theme_utils_1.accentColor,
    sideButtonSelectedUnderlineWidth: 2,
    sideButtonSelectedUnderlineTransitionDuration: 0.3,
    sideButtonBorder: false,
    sideButtonSelectedBorder: false,
    sideButtonBarTopPadding: { calc: 'spacing * 3' },
    sideButtonSelectedBackgroundColor: 'transparent',
    sideButtonHoverTextColor: theme_utils_1.accentColor,
    iconButtonHoverColor: theme_utils_1.accentColor,
    toggleButtonWidth: 28,
    toggleButtonHeight: 18,
    toggleButtonSwitchInset: 1,
    toggleButtonOffBackgroundColor: (0, theme_utils_1.foregroundBackgroundMix)(0.45),
});
exports.themeAlpine = 
/*#__PURE__*/
makeThemeAlpineTreeShakeable();
const makeThemeBalhamTreeShakeable = () => (0, Theme_1.createTheme)()
    .withPart(button_styles_1.buttonStyleBalham)
    .withPart(checkbox_styles_1.checkboxStyleDefault)
    .withPart(color_schemes_1.colorSchemeVariable)
    .withPart(icon_set_balham_1.iconSetBalham)
    .withPart(tab_styles_1.tabStyleRolodex)
    .withPart(input_styles_1.inputStyleBordered)
    .withPart(column_drop_styles_1.columnDropStylePlain)
    .withParams({
    accentColor: '#0091ea',
    borderColor: (0, theme_utils_1.foregroundMix)(0.2),
    spacing: 4,
    widgetVerticalSpacing: { calc: 'max(8px, spacing)' },
    borderRadius: 2,
    wrapperBorderRadius: 2,
    headerColumnResizeHandleColor: 'transparent',
    headerColumnBorder: true,
    headerColumnBorderHeight: '50%',
    oddRowBackgroundColor: {
        ref: 'chromeBackgroundColor',
        mix: 0.5,
    },
    checkboxBorderRadius: 2,
    checkboxBorderWidth: 1,
    checkboxUncheckedBackgroundColor: theme_utils_1.backgroundColor,
    checkboxUncheckedBorderColor: (0, theme_utils_1.foregroundBackgroundMix)(0.5),
    checkboxCheckedBackgroundColor: theme_utils_1.backgroundColor,
    checkboxCheckedBorderColor: theme_utils_1.accentColor,
    checkboxCheckedShapeColor: theme_utils_1.accentColor,
    checkboxIndeterminateBackgroundColor: theme_utils_1.backgroundColor,
    checkboxIndeterminateBorderColor: (0, theme_utils_1.foregroundBackgroundMix)(0.5),
    checkboxIndeterminateShapeColor: (0, theme_utils_1.foregroundBackgroundMix)(0.5),
    focusShadow: { radius: 2, spread: 1, color: theme_utils_1.accentColor },
    headerTextColor: (0, theme_utils_1.foregroundMix)(0.6),
    iconButtonHoverBackgroundColor: 'transparent',
    iconButtonActiveBackgroundColor: 'transparent',
    fontSize: 12,
    tabSelectedBackgroundColor: theme_utils_1.backgroundColor,
    headerFontWeight: 'bold',
    toggleButtonWidth: 32,
    toggleButtonHeight: 16,
    toggleButtonSwitchInset: 1,
    toggleButtonOffBackgroundColor: (0, theme_utils_1.foregroundBackgroundMix)(0.5),
    sideButtonBorder: true,
    sideButtonBarTopPadding: { calc: 'spacing * 4' },
    popupShadow: '5px 5px 10px rgba(0, 0, 0, 0.3)',
    statusBarLabelColor: (0, theme_utils_1.foregroundMix)(0.54),
    statusBarLabelFontWeight: 600,
    statusBarValueFontWeight: 600,
    panelTitleBarIconColor: theme_utils_1.foregroundColor,
});
exports.themeBalham = 
/*#__PURE__*/
makeThemeBalhamTreeShakeable();
const makeStyleMaterialTreeShakeable = () => {
    // define these overrides separately so that they don't affect the type of
    // this part - adding styleMaterial to a theme should override the value of
    // e.g. tabSelectedUnderlineColor, but not add that param to the type if
    // it's not there already
    const sharedParams = {
        tabSelectedUnderlineColor: { ref: 'primaryColor' },
        sideButtonSelectedUnderlineColor: { ref: 'primaryColor' },
        buttonTextColor: { ref: 'primaryColor' },
        rangeSelectionBackgroundColor: {
            ref: 'primaryColor',
            mix: 0.2,
        },
        rangeSelectionBorderColor: {
            ref: 'primaryColor',
        },
        rangeSelectionHighlightColor: {
            ref: 'primaryColor',
            mix: 0.5,
        },
        rangeHeaderHighlightColor: {
            ref: 'foregroundColor',
            mix: 0.08,
        },
        rowNumbersSelectedColor: {
            ref: 'primaryColor',
            mix: 0.5,
        },
        inputFocusBorder: {
            width: 2,
            color: { ref: 'primaryColor' },
        },
        pickerButtonFocusBorder: {
            width: 1,
            color: { ref: 'primaryColor' },
        },
        cellEditingBorder: {
            color: { ref: 'primaryColor' },
        },
        menuBackgroundColor: { ref: 'backgroundColor' },
        sideButtonBarBackgroundColor: theme_utils_1.backgroundColor,
        sideButtonSelectedBackgroundColor: 'transparent',
        sideButtonBarTopPadding: { calc: 'spacing * 4' },
        headerColumnResizeHandleColor: 'none',
        headerBackgroundColor: {
            ref: 'backgroundColor',
        },
        rowHoverColor: (0, theme_utils_1.foregroundMix)(0.08),
        columnHoverColor: (0, theme_utils_1.foregroundMix)(0.08),
        headerCellHoverBackgroundColor: (0, theme_utils_1.foregroundMix)(0.05),
        statusBarLabelColor: (0, theme_utils_1.foregroundMix)(0.63),
        statusBarLabelFontWeight: 600,
        statusBarValueFontWeight: 600,
        valueChangeValueHighlightBackgroundColor: '#00acc1',
        panelTitleBarIconColor: theme_utils_1.foregroundColor,
        advancedFilterBuilderButtonBarBorder: false,
        filterPanelApplyButtonColor: { ref: 'buttonTextColor' },
        filterPanelApplyButtonBackgroundColor: { ref: 'buttonBackgroundColor' },
    };
    const lightParams = {
        ...sharedParams,
        primaryColor: '#3f51b5',
        foregroundColor: '#000D',
        headerTextColor: '#0008',
        accentColor: '#ff4081',
        checkboxUncheckedBorderColor: theme_utils_1.foregroundColor,
        checkboxIndeterminateBackgroundColor: theme_utils_1.foregroundColor,
        toggleButtonOffBackgroundColor: theme_utils_1.foregroundColor,
        selectedRowBackgroundColor: 'rgba(33, 150, 243, 0.3)',
    };
    const darkParams = {
        ...sharedParams,
        primaryColor: '#3f51b5',
        foregroundColor: '#fffD',
        headerTextColor: '#fff8',
        accentColor: '#bb86fc',
        checkboxUncheckedBorderColor: (0, theme_utils_1.foregroundBackgroundMix)(0.5),
        checkboxIndeterminateBackgroundColor: (0, theme_utils_1.foregroundBackgroundMix)(0.5),
        toggleButtonOffBackgroundColor: (0, theme_utils_1.foregroundBackgroundMix)(0.5),
        selectedRowBackgroundColor: '#bb86fc33',
    };
    return (0, Part_1.createPart)({
        feature: 'styleMaterial',
        css: material_adjustments_css_GENERATED_1.materialAdjustmentsCSS,
        params: lightParams,
        modeParams: {
            light: lightParams,
            dark: darkParams,
            'dark-blue': darkParams,
        },
    });
};
exports.styleMaterial = makeStyleMaterialTreeShakeable();
const makeThemeMaterialTreeShakeable = () => 
/*#__PURE__*/
(0, Theme_1.createTheme)()
    .withPart(button_styles_1.buttonStyleBase)
    .withPart(checkbox_styles_1.checkboxStyleDefault)
    .withPart(color_schemes_1.colorSchemeVariable)
    .withPart(icon_sets_1.iconSetMaterial)
    .withPart(tab_styles_1.tabStyleMaterial)
    .withPart(input_styles_1.inputStyleUnderlined)
    .withPart(column_drop_styles_1.columnDropStylePlain)
    .withPart(exports.styleMaterial)
    .withParams({
    rowHeight: {
        calc: 'max(iconSize, dataFontSize) + spacing * 3.75 * rowVerticalPaddingScale',
    },
    headerHeight: {
        calc: 'max(iconSize, dataFontSize) + spacing * 4.75 * headerVerticalPaddingScale',
    },
    widgetVerticalSpacing: {
        calc: 'spacing * 1.75',
    },
    cellHorizontalPadding: { calc: 'spacing * 3' },
    buttonHorizontalPadding: { ref: 'spacing' },
    widgetContainerHorizontalPadding: { calc: 'spacing * 1.5' },
    widgetContainerVerticalPadding: { calc: 'spacing * 2' },
    fontSize: 13,
    iconSize: 18,
    borderRadius: 0,
    wrapperBorderRadius: 0,
    wrapperBorder: false,
    menuBorder: false,
    dialogBorder: false,
    panelTitleBarBorder: false,
    tabSelectedBorderWidth: 0,
    tabSelectedUnderlineTransitionDuration: 0.3,
    sidePanelBorder: false,
    sideButtonSelectedBorder: false,
    sideButtonSelectedUnderlineWidth: 2,
    sideButtonSelectedUnderlineTransitionDuration: 0.3,
    sideButtonBorder: false,
    buttonBorder: false,
    buttonDisabledBorder: false,
    focusShadow: {
        spread: 4,
        color: (0, theme_utils_1.foregroundMix)(0.16),
    },
    fontFamily: [
        { googleFont: 'Roboto' },
        '-apple-system',
        'BlinkMacSystemFont',
        'Segoe UI',
        'Oxygen-Sans',
        'Ubuntu',
        'Cantarell',
        'Helvetica Neue',
        'sans-serif',
    ],
    inputHeight: {
        calc: 'max(iconSize, fontSize) + spacing * 3',
    },
    pickerButtonBorder: {
        width: 1,
        color: 'transparent',
    },
    headerFontWeight: 600,
    headerFontSize: { calc: 'fontSize - 1px' },
    checkboxBorderWidth: 2,
    checkboxBorderRadius: 2,
    toggleButtonWidth: 34,
    toggleButtonSwitchInset: 1,
    cardShadow: '0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12)',
    popupShadow: '5px 5px 10px rgba(0, 0, 0, 0.3)',
});
exports.themeMaterial = 
/*#__PURE__*/ makeThemeMaterialTreeShakeable();


/***/ }),

/***/ 50113:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paramValueToCss = exports.durationValueToCss = exports.imageValueToCss = exports.fontWeightValueToCss = exports.fontFamilyValueToCss = exports.borderStyleValueToCss = exports.shadowValueToCss = exports.borderValueToCss = exports.scaleValueToCss = exports.lengthValueToCss = exports.colorSchemeValueToCss = exports.colorValueToCss = exports.getParamType = void 0;
const logging_1 = __webpack_require__(47764);
const theme_utils_1 = __webpack_require__(77845);
const paramTypes = [
    'colorScheme',
    'color',
    'length',
    'scale',
    'borderStyle',
    'border',
    'shadow',
    'image',
    'fontFamily',
    'fontWeight',
    'duration',
];
/**
 * Return the ParamType for a given param name,
 */
exports.getParamType = (0, theme_utils_1.memoize)((param) => {
    param = param.toLowerCase();
    return paramTypes.find((type) => param.endsWith(type.toLowerCase())) ?? 'length';
});
const literalToCSS = (value) => {
    if (typeof value === 'object' && value?.ref)
        return (0, theme_utils_1.paramToVariableExpression)(value.ref);
    if (typeof value === 'string')
        return value;
    if (typeof value === 'number')
        return String(value);
    return false;
};
const colorValueToCss = (value) => {
    if (typeof value === 'string')
        return value;
    if (value && 'ref' in value) {
        const colorExpr = (0, theme_utils_1.paramToVariableExpression)(value.ref);
        if (value.mix == null) {
            return colorExpr;
        }
        const backgroundExpr = value.onto ? (0, theme_utils_1.paramToVariableExpression)(value.onto) : 'transparent';
        return `color-mix(in srgb, ${backgroundExpr}, ${colorExpr} ${(0, theme_utils_1.clamp)(value.mix * 100, 0, 100)}%)`;
    }
    return false;
};
exports.colorValueToCss = colorValueToCss;
exports.colorSchemeValueToCss = literalToCSS;
const lengthValueToCss = (value) => {
    if (typeof value === 'string')
        return value;
    if (typeof value === 'number')
        return `${value}px`;
    if (value && 'calc' in value) {
        // ensure a space around operators other than `-` (which can be part of an identifier)
        const valueWithSpaces = value.calc.replace(/ ?[*/+] ?/g, ' $& ');
        // convert param names to variable expressions, e.g. "fooBar" -> "var(--ag-foo-bar)",
        // ignoring words that are part of function names "fooBar()" or variables "--fooBar"
        return `calc(${valueWithSpaces.replace(/-?\b[a-z][a-z0-9]*\b(?![-(])/gi, (p) => (p[0] === '-' ? p : ` ${(0, theme_utils_1.paramToVariableExpression)(p)} `))})`;
    }
    if (value && 'ref' in value)
        return (0, theme_utils_1.paramToVariableExpression)(value.ref);
    return false;
};
exports.lengthValueToCss = lengthValueToCss;
exports.scaleValueToCss = literalToCSS;
const borderValueToCss = (value, param) => {
    if (typeof value === 'string')
        return value;
    if (value === true)
        return (0, exports.borderValueToCss)({}, param);
    if (value === false)
        return param === 'columnBorder' ? (0, exports.borderValueToCss)({ color: 'transparent' }, param) : 'none';
    if (value && 'ref' in value)
        return (0, theme_utils_1.paramToVariableExpression)(value.ref);
    return ((0, exports.borderStyleValueToCss)(value.style ?? 'solid') +
        ' ' +
        (0, exports.lengthValueToCss)(value.width ?? { ref: 'borderWidth' }) +
        ' ' +
        (0, exports.colorValueToCss)(value.color ?? { ref: 'borderColor' }));
};
exports.borderValueToCss = borderValueToCss;
const shadowValueToCss = (value) => {
    if (typeof value === 'string')
        return value;
    if (value === false)
        return 'none';
    if (value && 'ref' in value)
        return (0, theme_utils_1.paramToVariableExpression)(value.ref);
    return [
        (0, exports.lengthValueToCss)(value.offsetX ?? 0),
        (0, exports.lengthValueToCss)(value.offsetY ?? 0),
        (0, exports.lengthValueToCss)(value.radius ?? 0),
        (0, exports.lengthValueToCss)(value.spread ?? 0),
        (0, exports.colorValueToCss)(value.color ?? { ref: 'foregroundColor' }),
    ].join(' ');
};
exports.shadowValueToCss = shadowValueToCss;
exports.borderStyleValueToCss = literalToCSS;
const fontFamilyValueToCss = (value) => {
    // normally string values are passed through as CSS without modification,
    // but for fonts this means you need to add internal quotes around font
    // names like `fontFamily: '"Times New Roman"'` which is a bit awkward. So
    // we add the quotes, unless a comma is present in which case we assume that
    // it's a list of correctly quoted font names
    if (typeof value === 'string')
        return value.includes(',') ? value : quoteUnsafeChars(value);
    if (value && 'googleFont' in value)
        return (0, exports.fontFamilyValueToCss)(value.googleFont);
    if (value && 'ref' in value)
        return (0, theme_utils_1.paramToVariableExpression)(value.ref);
    if (Array.isArray(value)) {
        return value
            .map((font) => {
            if (typeof font === 'object' && 'googleFont' in font) {
                font = font.googleFont;
            }
            return quoteUnsafeChars(font);
        })
            .join(', ');
    }
    return false;
};
exports.fontFamilyValueToCss = fontFamilyValueToCss;
const quoteUnsafeChars = (font) => 
// don't quote var() expressions or quote safe identifier names, so that
// people can specify fonts like sans-serif which are keywords not strings,
// or var(--my-var)
/^[\w-]+$|\w\(/.test(font) ? font : JSON.stringify(font);
exports.fontWeightValueToCss = literalToCSS;
const imageValueToCss = (value) => {
    if (typeof value === 'string')
        return value;
    if (value && 'url' in value)
        return `url(${JSON.stringify(value.url)})`;
    if (value && 'svg' in value)
        return (0, exports.imageValueToCss)({ url: `data:image/svg+xml,${encodeURIComponent(value.svg)}` });
    if (value && 'ref' in value)
        return (0, theme_utils_1.paramToVariableExpression)(value.ref);
    return false;
};
exports.imageValueToCss = imageValueToCss;
const durationValueToCss = (value, param) => {
    if (typeof value === 'string')
        return value;
    if (typeof value === 'number') {
        if (value >= 10) {
            (0, logging_1._error)(104, { value, param });
        }
        return `${value}s`;
    }
    if (value && 'ref' in value)
        return (0, theme_utils_1.paramToVariableExpression)(value.ref);
    return false;
};
exports.durationValueToCss = durationValueToCss;
const paramValidators = {
    color: exports.colorValueToCss,
    colorScheme: exports.colorSchemeValueToCss,
    length: exports.lengthValueToCss,
    scale: exports.scaleValueToCss,
    border: exports.borderValueToCss,
    borderStyle: exports.borderStyleValueToCss,
    shadow: exports.shadowValueToCss,
    image: exports.imageValueToCss,
    fontFamily: exports.fontFamilyValueToCss,
    fontWeight: exports.fontWeightValueToCss,
    duration: exports.durationValueToCss,
};
const paramValueToCss = (param, value) => {
    const type = (0, exports.getParamType)(param);
    return paramValidators[type](value, param);
};
exports.paramValueToCss = paramValueToCss;


/***/ }),

/***/ 77845:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.accentColor = exports.foregroundColor = exports.backgroundColor = exports.foregroundHeaderBackgroundMix = exports.foregroundBackgroundMix = exports.foregroundMix = exports.accentMix = exports.memoize = exports.logErrorMessage = exports.clamp = exports.paramToVariableExpression = exports.paramToVariableName = exports.kebabCase = void 0;
const kebabCase = (str) => str.replace(/[A-Z]/g, (m) => `-${m}`).toLowerCase();
exports.kebabCase = kebabCase;
const paramToVariableName = (paramName) => `--ag-${(0, exports.kebabCase)(paramName)}`;
exports.paramToVariableName = paramToVariableName;
const paramToVariableExpression = (paramName) => `var(${(0, exports.paramToVariableName)(paramName)})`;
exports.paramToVariableExpression = paramToVariableExpression;
const clamp = (value, min, max) => Math.max(min, Math.min(max, value));
exports.clamp = clamp;
const logErrorMessage = (message, error) => {
    if (error) {
        // eslint-disable-next-line no-console
        console.error(message, error);
    }
    else {
        // eslint-disable-next-line no-console
        console.error(message);
    }
};
exports.logErrorMessage = logErrorMessage;
const memoize = (fn) => {
    const values = new Map();
    return (a) => {
        const key = a;
        if (!values.has(key)) {
            values.set(key, fn(a));
        }
        return values.get(key);
    };
};
exports.memoize = memoize;
const accentMix = (mix) => ({ ref: 'accentColor', mix });
exports.accentMix = accentMix;
const foregroundMix = (mix) => ({ ref: 'foregroundColor', mix });
exports.foregroundMix = foregroundMix;
const foregroundBackgroundMix = (mix) => ({
    ref: 'foregroundColor',
    mix,
    onto: 'backgroundColor',
});
exports.foregroundBackgroundMix = foregroundBackgroundMix;
const foregroundHeaderBackgroundMix = (mix) => ({
    ref: 'foregroundColor',
    mix,
    onto: 'headerBackgroundColor',
});
exports.foregroundHeaderBackgroundMix = foregroundHeaderBackgroundMix;
exports.backgroundColor = { ref: 'backgroundColor' };
exports.foregroundColor = { ref: 'foregroundColor' };
exports.accentColor = { ref: 'accentColor' };


/***/ }),

/***/ 48927:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.tooltipCSS = void 0;
exports.tooltipCSS = `.ag-tooltip{background-color:var(--ag-tooltip-background-color);border:var(--ag-tooltip-border);border-radius:var(--ag-border-radius);color:var(--ag-tooltip-text-color);padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding);position:absolute;white-space:normal;z-index:99999;&:where(.ag-cell-editor-tooltip){background-color:var(--ag-tooltip-error-background-color);border:var(--ag-tooltip-error-border);color:var(--ag-tooltip-error-text-color);font-weight:500}}.ag-tooltip-custom{position:absolute;z-index:99999}.ag-tooltip-custom:where(:not(.ag-tooltip-interactive)),.ag-tooltip:where(:not(.ag-tooltip-interactive)){pointer-events:none}.ag-tooltip-animate{transition:opacity 1s;&:where(.ag-tooltip-hiding){opacity:0}}`;


/***/ }),

/***/ 60243:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TooltipComponent = void 0;
const string_1 = __webpack_require__(37766);
const popupComponent_1 = __webpack_require__(63598);
const TooltipComponentElement = { tag: 'div', cls: 'ag-tooltip' };
class TooltipComponent extends popupComponent_1.PopupComponent {
    constructor() {
        super(TooltipComponentElement);
    }
    // will need to type params
    init(params) {
        const { value } = params;
        const eGui = this.getGui();
        eGui.textContent = (0, string_1._toString)(value);
        const locationKebabCase = params.location.replace(/([a-z])([A-Z0-9])/g, '$1-$2').toLowerCase();
        eGui.classList.add(`ag-${locationKebabCase}-tooltip`);
    }
}
exports.TooltipComponent = TooltipComponent;


/***/ }),

/***/ 93386:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TooltipFeature = exports._getShouldDisplayTooltip = exports._isShowTooltipWhenTruncated = void 0;
const beanStub_1 = __webpack_require__(68731);
const dom_1 = __webpack_require__(33507);
const tooltipStateManager_1 = __webpack_require__(73430);
function _isShowTooltipWhenTruncated(gos) {
    return gos.get('tooltipShowMode') === 'whenTruncated';
}
exports._isShowTooltipWhenTruncated = _isShowTooltipWhenTruncated;
function _getShouldDisplayTooltip(gos, getElement) {
    return _isShowTooltipWhenTruncated(gos) ? (0, dom_1._isElementOverflowingCallback)(getElement) : undefined;
}
exports._getShouldDisplayTooltip = _getShouldDisplayTooltip;
class TooltipFeature extends beanStub_1.BeanStub {
    constructor(ctrl, beans) {
        super();
        this.ctrl = ctrl;
        if (beans) {
            this.beans = beans;
        }
    }
    postConstruct() {
        this.refreshTooltip();
    }
    /**
     *
     * @param tooltip The tooltip value
     * @param allowEmptyString Set it to true to allow the title to be set to `''`. This is necessary
     * when the browser adds a default tooltip the element and the tooltip service will be displayed
     * next to a browser tooltip causing confusion.
     */
    setBrowserTooltip(tooltip, allowEmptyString) {
        const name = 'title';
        const eGui = this.ctrl.getGui();
        if (!eGui) {
            return;
        }
        if (tooltip != null && (tooltip != '' || allowEmptyString)) {
            eGui.setAttribute(name, tooltip);
        }
        else {
            eGui.removeAttribute(name);
        }
    }
    updateTooltipText() {
        const { getTooltipValue } = this.ctrl;
        if (getTooltipValue) {
            this.tooltip = getTooltipValue();
        }
    }
    createTooltipFeatureIfNeeded() {
        if (this.tooltipManager == null) {
            this.tooltipManager = this.createBean(new tooltipStateManager_1.TooltipStateManager(this.ctrl, () => this.tooltip), this.beans.context);
        }
    }
    setTooltipAndRefresh(tooltip) {
        this.tooltip = tooltip;
        this.refreshTooltip();
    }
    refreshTooltip(clearWithEmptyString) {
        this.browserTooltips = this.beans.gos.get('enableBrowserTooltips');
        this.updateTooltipText();
        if (this.browserTooltips) {
            this.setBrowserTooltip(this.tooltip);
            this.tooltipManager = this.destroyBean(this.tooltipManager, this.beans.context);
        }
        else {
            this.setBrowserTooltip(clearWithEmptyString ? '' : null, clearWithEmptyString);
            this.createTooltipFeatureIfNeeded();
        }
    }
    destroy() {
        this.tooltipManager = this.destroyBean(this.tooltipManager, this.beans.context);
        super.destroy();
    }
}
exports.TooltipFeature = TooltipFeature;


/***/ }),

/***/ 34658:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TooltipModule = void 0;
const version_1 = __webpack_require__(97205);
const popupModule_1 = __webpack_require__(3137);
const tooltip_css_GENERATED_1 = __webpack_require__(48927);
const tooltipComponent_1 = __webpack_require__(60243);
const tooltipFeature_1 = __webpack_require__(93386);
const tooltipService_1 = __webpack_require__(37931);
/**
 * @feature Tooltips
 * @colDef tooltipField, tooltipValueGetter, headerTooltip
 */
exports.TooltipModule = {
    moduleName: 'Tooltip',
    version: version_1.VERSION,
    beans: [tooltipService_1.TooltipService],
    dynamicBeans: {
        tooltipFeature: tooltipFeature_1.TooltipFeature,
    },
    userComponents: {
        agTooltipComponent: tooltipComponent_1.TooltipComponent,
    },
    dependsOn: [popupModule_1.PopupModule],
    css: [tooltip_css_GENERATED_1.tooltipCSS],
};


/***/ }),

/***/ 37931:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TooltipService = void 0;
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const dom_1 = __webpack_require__(33507);
const generic_1 = __webpack_require__(34422);
const object_1 = __webpack_require__(6996);
const tooltipFeature_1 = __webpack_require__(93386);
const getEditErrorsForPosition = (beans, cellCtrl, translate) => {
    const { editModelSvc } = beans;
    const cellValidationErrors = editModelSvc?.getCellValidationModel()?.getCellValidation(cellCtrl)?.errorMessages;
    const rowValidationErrors = editModelSvc?.getRowValidationModel().getRowValidation(cellCtrl)?.errorMessages;
    const errors = cellValidationErrors || rowValidationErrors;
    return errors && errors.length ? errors.join(translate('tooltipValidationErrorSeparator', '. ')) : undefined;
};
class TooltipService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'tooltipSvc';
    }
    setupHeaderTooltip(existingTooltipFeature, ctrl, value, shouldDisplayTooltip) {
        if (existingTooltipFeature) {
            ctrl.destroyBean(existingTooltipFeature);
        }
        const isTooltipWhenTruncated = (0, tooltipFeature_1._isShowTooltipWhenTruncated)(this.gos);
        const { column, eGui } = ctrl;
        const colDef = column.getColDef();
        if (!shouldDisplayTooltip && isTooltipWhenTruncated && !colDef.headerComponent) {
            shouldDisplayTooltip = (0, dom_1._isElementOverflowingCallback)(() => eGui.querySelector('.ag-header-cell-text'));
        }
        const tooltipCtrl = {
            getColumn: () => column,
            getColDef: () => column.getColDef(),
            getGui: () => eGui,
            getLocation: () => 'header',
            getTooltipValue: () => {
                if (value != null) {
                    return value;
                }
                const res = column.getColDef().headerTooltip;
                return res;
            },
            shouldDisplayTooltip,
        };
        let tooltipFeature = this.createTooltipFeature(tooltipCtrl);
        if (tooltipFeature) {
            tooltipFeature = ctrl.createBean(tooltipFeature);
            ctrl.setRefreshFunction('tooltip', () => tooltipFeature.refreshTooltip());
        }
        return tooltipFeature;
    }
    setupHeaderGroupTooltip(existingTooltipFeature, ctrl, value, shouldDisplayTooltip) {
        if (existingTooltipFeature) {
            ctrl.destroyBean(existingTooltipFeature);
        }
        const isTooltipWhenTruncated = (0, tooltipFeature_1._isShowTooltipWhenTruncated)(this.gos);
        const { column, eGui } = ctrl;
        const colGroupDef = column.getColGroupDef();
        if (!shouldDisplayTooltip && isTooltipWhenTruncated && !colGroupDef?.headerGroupComponent) {
            shouldDisplayTooltip = (0, dom_1._isElementOverflowingCallback)(() => eGui.querySelector('.ag-header-group-text'));
        }
        const tooltipCtrl = {
            getColumn: () => column,
            getGui: () => eGui,
            getLocation: () => 'headerGroup',
            getTooltipValue: () => value ?? (colGroupDef && colGroupDef.headerTooltip),
            shouldDisplayTooltip,
        };
        if (colGroupDef) {
            tooltipCtrl.getColDef = () => colGroupDef;
        }
        const tooltipFeature = this.createTooltipFeature(tooltipCtrl);
        return tooltipFeature ? ctrl.createBean(tooltipFeature) : tooltipFeature;
    }
    enableCellTooltipFeature(ctrl, value, shouldDisplayTooltip) {
        const { beans } = this;
        const { gos, editSvc } = beans;
        const { column, rowNode } = ctrl;
        let location = 'cell';
        const getTooltipValue = () => {
            const isEditing = !!editSvc?.isEditing(ctrl);
            const errorMessages = !isEditing && getEditErrorsForPosition(beans, ctrl, this.getLocaleTextFunc());
            if (errorMessages) {
                location = 'cellEditor';
                return errorMessages;
            }
            location = 'cell';
            const colDef = column.getColDef();
            const data = rowNode.data;
            if (colDef.tooltipField && (0, generic_1._exists)(data)) {
                return (0, object_1._getValueUsingField)(data, colDef.tooltipField, column.isTooltipFieldContainsDots());
            }
            const valueGetter = colDef.tooltipValueGetter;
            if (valueGetter) {
                return valueGetter((0, gridOptionsUtils_1._addGridCommonParams)(gos, {
                    location: 'cell',
                    colDef: column.getColDef(),
                    column: column,
                    rowIndex: ctrl.cellPosition.rowIndex,
                    node: rowNode,
                    data: rowNode.data,
                    value: ctrl.value,
                    valueFormatted: ctrl.valueFormatted,
                }));
            }
            return null;
        };
        const isTooltipWhenTruncated = (0, tooltipFeature_1._isShowTooltipWhenTruncated)(gos);
        if (!shouldDisplayTooltip) {
            if (isTooltipWhenTruncated && !ctrl.isCellRenderer()) {
                shouldDisplayTooltip = () => {
                    const isEditing = !!editSvc?.isEditing(ctrl);
                    const errorMessages = !isEditing && getEditErrorsForPosition(beans, ctrl, this.getLocaleTextFunc());
                    if (errorMessages) {
                        return true;
                    }
                    const isTooltipEnabled = column.isTooltipEnabled();
                    if (!isTooltipEnabled) {
                        return false;
                    }
                    const isElementOverflowing = (0, dom_1._isElementOverflowingCallback)(() => {
                        const eCell = ctrl.eGui;
                        return eCell.children.length === 0
                            ? eCell
                            : eCell.querySelector('.ag-cell-value');
                    });
                    return !isEditing && isElementOverflowing();
                };
            }
            else {
                shouldDisplayTooltip = () => !editSvc?.isEditing(ctrl);
            }
        }
        const tooltipCtrl = {
            getColumn: () => column,
            getColDef: () => column.getColDef(),
            getRowIndex: () => ctrl.cellPosition.rowIndex,
            getRowNode: () => rowNode,
            getGui: () => ctrl.eGui,
            getLocation: () => location,
            getTooltipValue: value != null ? () => value : getTooltipValue,
            // this makes no sense, why is the cell formatted value passed to the tooltip???
            getValueFormatted: () => ctrl.valueFormatted,
            shouldDisplayTooltip,
        };
        return this.createTooltipFeature(tooltipCtrl, beans);
    }
    setupFullWidthRowTooltip(existingTooltipFeature, ctrl, value, shouldDisplayTooltip) {
        const tooltipParams = {
            getGui: () => ctrl.getFullWidthElement(),
            getTooltipValue: () => value,
            getLocation: () => 'fullWidthRow',
            shouldDisplayTooltip,
        };
        const beans = this.beans;
        const context = beans.context;
        if (existingTooltipFeature) {
            ctrl.destroyBean(existingTooltipFeature, context);
        }
        const tooltipFeature = this.createTooltipFeature(tooltipParams, beans);
        if (!tooltipFeature) {
            return;
        }
        return ctrl.createBean(tooltipFeature, context);
    }
    setupCellEditorTooltip(cellCtrl, editor) {
        const { beans } = this;
        const { context } = beans;
        const el = editor.getValidationElement?.();
        if (!el) {
            return;
        }
        const tooltipParams = {
            getGui: () => el,
            getTooltipValue: () => getEditErrorsForPosition(beans, cellCtrl, this.getLocaleTextFunc()),
            getLocation: () => 'cellEditor',
            shouldDisplayTooltip: () => {
                const { editModelSvc } = beans;
                const rowValidationMap = editModelSvc?.getRowValidationModel()?.getRowValidationMap();
                const cellValidationMap = editModelSvc?.getCellValidationModel()?.getCellValidationMap();
                const hasRowValidationErrors = !!rowValidationMap && rowValidationMap.size > 0;
                const hasCellValidationErrors = !!cellValidationMap && cellValidationMap.size > 0;
                return hasRowValidationErrors || hasCellValidationErrors;
            },
        };
        const tooltipFeature = this.createTooltipFeature(tooltipParams, beans);
        if (!tooltipFeature) {
            return;
        }
        return cellCtrl.createBean(tooltipFeature, context);
    }
    initCol(column) {
        const { colDef } = column;
        column.tooltipEnabled =
            (0, generic_1._exists)(colDef.tooltipField) || (0, generic_1._exists)(colDef.tooltipValueGetter) || (0, generic_1._exists)(colDef.tooltipComponent);
    }
    createTooltipFeature(tooltipCtrl, beans) {
        return this.beans.registry.createDynamicBean('tooltipFeature', false, tooltipCtrl, beans);
    }
}
exports.TooltipService = TooltipService;


/***/ }),

/***/ 73430:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TooltipStateManager = void 0;
const userCompUtils_1 = __webpack_require__(12036);
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const browser_1 = __webpack_require__(98667);
const generic_1 = __webpack_require__(34422);
var TooltipStates;
(function (TooltipStates) {
    TooltipStates[TooltipStates["NOTHING"] = 0] = "NOTHING";
    TooltipStates[TooltipStates["WAITING_TO_SHOW"] = 1] = "WAITING_TO_SHOW";
    TooltipStates[TooltipStates["SHOWING"] = 2] = "SHOWING";
})(TooltipStates || (TooltipStates = {}));
var TooltipTrigger;
(function (TooltipTrigger) {
    TooltipTrigger[TooltipTrigger["HOVER"] = 0] = "HOVER";
    TooltipTrigger[TooltipTrigger["FOCUS"] = 1] = "FOCUS";
})(TooltipTrigger || (TooltipTrigger = {}));
const SHOW_QUICK_TOOLTIP_DIFF = 1000;
const FADE_OUT_TOOLTIP_TIMEOUT = 1000;
const INTERACTIVE_HIDE_DELAY = 100;
// different instances of tooltipFeature use this to see when the
// last tooltip was hidden.
let lastTooltipHideTime;
let isLocked = false;
class TooltipStateManager extends beanStub_1.BeanStub {
    wireBeans(beans) {
        this.popupSvc = beans.popupSvc;
        this.userCompFactory = beans.userCompFactory;
    }
    constructor(tooltipCtrl, getTooltipValue) {
        super();
        this.tooltipCtrl = tooltipCtrl;
        this.getTooltipValue = getTooltipValue;
        this.interactionEnabled = false;
        this.isInteractingWithTooltip = false;
        this.state = TooltipStates.NOTHING;
        // when showing the tooltip, we need to make sure it's the most recent instance we request, as due to
        // async we could request two tooltips before the first instance returns, in which case we should
        // disregard the second instance.
        this.tooltipInstanceCount = 0;
        this.tooltipMouseTrack = false;
    }
    postConstruct() {
        if (this.gos.get('tooltipInteraction')) {
            this.interactionEnabled = true;
        }
        this.tooltipTrigger = this.getTooltipTrigger();
        this.tooltipMouseTrack = this.gos.get('tooltipMouseTrack');
        const el = this.tooltipCtrl.getGui();
        if (this.tooltipTrigger === TooltipTrigger.HOVER) {
            this.addManagedListeners(el, {
                mouseenter: this.onMouseEnter.bind(this),
                mouseleave: this.onMouseLeave.bind(this),
            });
        }
        if (this.tooltipTrigger === TooltipTrigger.FOCUS) {
            this.addManagedListeners(el, {
                focusin: this.onFocusIn.bind(this),
                focusout: this.onFocusOut.bind(this),
            });
        }
        this.addManagedListeners(el, { mousemove: this.onMouseMove.bind(this) });
        if (!this.interactionEnabled) {
            this.addManagedListeners(el, {
                mousedown: this.onMouseDown.bind(this),
                keydown: this.onKeyDown.bind(this),
            });
        }
    }
    getGridOptionsTooltipDelay(delayOption) {
        const delay = this.gos.get(delayOption);
        return Math.max(200, delay);
    }
    getTooltipDelay(type) {
        if (type === 'show') {
            return (this.tooltipCtrl.getTooltipShowDelayOverride?.() ?? this.getGridOptionsTooltipDelay('tooltipShowDelay'));
        }
        return this.tooltipCtrl.getTooltipHideDelayOverride?.() ?? this.getGridOptionsTooltipDelay('tooltipHideDelay');
    }
    destroy() {
        // if this component gets destroyed while tooltip is showing, need to make sure
        // we don't end with no mouseLeave event resulting in zombie tooltip
        this.setToDoNothing();
        super.destroy();
    }
    getTooltipTrigger() {
        const trigger = this.gos.get('tooltipTrigger');
        if (!trigger || trigger === 'hover') {
            return TooltipTrigger.HOVER;
        }
        return TooltipTrigger.FOCUS;
    }
    onMouseEnter(e) {
        // if `interactiveTooltipTimeoutId` is set, it means that this cell has a tooltip
        // and we are in the process of moving the cursor from the tooltip back to the cell
        // so we need to unlock this service here.
        if (this.interactionEnabled && this.interactiveTooltipTimeoutId) {
            this.unlockService();
            this.startHideTimeout();
        }
        if ((0, browser_1._isIOSUserAgent)()) {
            return;
        }
        if (isLocked) {
            this.showTooltipTimeoutId = window.setTimeout(() => {
                this.prepareToShowTooltip(e);
            }, INTERACTIVE_HIDE_DELAY);
        }
        else {
            this.prepareToShowTooltip(e);
        }
    }
    onMouseMove(e) {
        // there is a delay from the time we mouseOver a component and the time the
        // tooltip is displayed, so we need to track mousemove to be able to correctly
        // position the tooltip when showTooltip is called.
        if (this.lastMouseEvent) {
            this.lastMouseEvent = e;
        }
        if (this.tooltipMouseTrack && this.state === TooltipStates.SHOWING && this.tooltipComp) {
            this.positionTooltip();
        }
    }
    onMouseDown() {
        this.setToDoNothing();
    }
    onMouseLeave() {
        // if interaction is enabled, we need to verify if the user is moving
        // the cursor from the cell onto the tooltip, so we lock the service
        // for 100ms to prevent other tooltips from being created while this is happening.
        if (this.interactionEnabled) {
            this.lockService();
        }
        else {
            this.setToDoNothing();
        }
    }
    onFocusIn() {
        this.prepareToShowTooltip();
    }
    onFocusOut(e) {
        const relatedTarget = e.relatedTarget;
        const parentCompGui = this.tooltipCtrl.getGui();
        const tooltipGui = this.tooltipComp?.getGui();
        if (this.isInteractingWithTooltip ||
            parentCompGui.contains(relatedTarget) ||
            (this.interactionEnabled && tooltipGui?.contains(relatedTarget))) {
            return;
        }
        this.setToDoNothing();
    }
    onKeyDown() {
        // if the keydown happens outside of the tooltip, we cancel
        // the tooltip interaction and hide the tooltip.
        if (this.isInteractingWithTooltip) {
            this.isInteractingWithTooltip = false;
        }
        this.setToDoNothing();
    }
    prepareToShowTooltip(mouseEvent) {
        // every mouseenter should be following by a mouseleave, however for some unknown, it's possible for
        // mouseenter to be called twice in a row, which can happen if editing the cell. this was reported
        // in https://ag-grid.atlassian.net/browse/AG-4422. to get around this, we check the state, and if
        // state is != nothing, then we know mouseenter was already received.
        if (this.state != TooltipStates.NOTHING || isLocked) {
            return;
        }
        // if we are showing the tooltip because of focus, no delay at all
        // if another tooltip was hidden very recently, we only wait 200ms to show, not the normal waiting time
        let delay = 0;
        if (mouseEvent) {
            delay = this.isLastTooltipHiddenRecently() ? 200 : this.getTooltipDelay('show');
        }
        this.lastMouseEvent = mouseEvent || null;
        this.showTooltipTimeoutId = window.setTimeout(this.showTooltip.bind(this), delay);
        this.state = TooltipStates.WAITING_TO_SHOW;
    }
    isLastTooltipHiddenRecently() {
        // return true if <1000ms since last time we hid a tooltip
        const now = Date.now();
        const then = lastTooltipHideTime;
        return now - then < SHOW_QUICK_TOOLTIP_DIFF;
    }
    setToDoNothing(fromHideTooltip) {
        if (!fromHideTooltip && this.state === TooltipStates.SHOWING) {
            this.hideTooltip();
        }
        if (this.onBodyScrollEventCallback) {
            this.onBodyScrollEventCallback();
            this.onBodyScrollEventCallback = undefined;
        }
        if (this.onColumnMovedEventCallback) {
            this.onColumnMovedEventCallback();
            this.onColumnMovedEventCallback = undefined;
        }
        if (this.onDocumentKeyDownCallback) {
            this.onDocumentKeyDownCallback();
            this.onDocumentKeyDownCallback = undefined;
        }
        this.clearTimeouts();
        this.state = TooltipStates.NOTHING;
        this.lastMouseEvent = null;
    }
    showTooltip() {
        const value = this.getTooltipValue();
        const ctrl = this.tooltipCtrl;
        if (!(0, generic_1._exists)(value) || (ctrl.shouldDisplayTooltip && !ctrl.shouldDisplayTooltip())) {
            this.setToDoNothing();
            return;
        }
        const rowNode = ctrl.getRowNode?.();
        const params = (0, gridOptionsUtils_1._addGridCommonParams)(this.gos, {
            location: ctrl.getLocation?.() ?? 'UNKNOWN',
            colDef: ctrl.getColDef?.(),
            column: ctrl.getColumn?.(),
            rowIndex: ctrl.getRowIndex?.(),
            node: rowNode,
            data: rowNode?.data,
            value,
            valueFormatted: ctrl.getValueFormatted?.(),
            hideTooltipCallback: () => this.hideTooltip(true),
            ...(ctrl.getAdditionalParams?.() ?? {}),
        });
        this.state = TooltipStates.SHOWING;
        this.tooltipInstanceCount++;
        // we pass in tooltipInstanceCount so the callback knows what the count was when
        // we requested the tooltip, so if another tooltip was requested in the mean time
        // we disregard it
        const callback = this.newTooltipComponentCallback.bind(this, this.tooltipInstanceCount);
        const userDetails = (0, userCompUtils_1._getTooltipCompDetails)(this.userCompFactory, params);
        userDetails?.newAgStackInstance().then(callback);
    }
    hideTooltip(forceHide) {
        if (!forceHide && this.isInteractingWithTooltip) {
            return;
        }
        // check if comp exists - due to async, although we asked for
        // one, the instance may not be back yet
        if (this.tooltipComp) {
            this.destroyTooltipComp();
            lastTooltipHideTime = Date.now();
        }
        this.eventSvc.dispatchEvent({
            type: 'tooltipHide',
            parentGui: this.tooltipCtrl.getGui(),
        });
        if (forceHide) {
            this.isInteractingWithTooltip = false;
        }
        this.setToDoNothing(true);
    }
    newTooltipComponentCallback(tooltipInstanceCopy, tooltipComp) {
        const compNoLongerNeeded = this.state !== TooltipStates.SHOWING || this.tooltipInstanceCount !== tooltipInstanceCopy;
        if (compNoLongerNeeded) {
            this.destroyBean(tooltipComp);
            return;
        }
        const eGui = tooltipComp.getGui();
        this.tooltipComp = tooltipComp;
        if (!eGui.classList.contains('ag-tooltip')) {
            eGui.classList.add('ag-tooltip-custom');
        }
        if (this.tooltipTrigger === TooltipTrigger.HOVER) {
            eGui.classList.add('ag-tooltip-animate');
        }
        if (this.interactionEnabled) {
            eGui.classList.add('ag-tooltip-interactive');
        }
        const translate = this.getLocaleTextFunc();
        const addPopupRes = this.popupSvc?.addPopup({
            eChild: eGui,
            ariaLabel: translate('ariaLabelTooltip', 'Tooltip'),
        });
        if (addPopupRes) {
            this.tooltipPopupDestroyFunc = addPopupRes.hideFunc;
        }
        this.positionTooltip();
        if (this.tooltipTrigger === TooltipTrigger.FOCUS) {
            const listener = () => this.setToDoNothing();
            [this.onBodyScrollEventCallback, this.onColumnMovedEventCallback] = this.addManagedEventListeners({
                bodyScroll: listener,
                columnMoved: listener,
            });
        }
        if (this.interactionEnabled) {
            [this.tooltipMouseEnterListener, this.tooltipMouseLeaveListener] = this.addManagedElementListeners(eGui, {
                mouseenter: this.onTooltipMouseEnter.bind(this),
                mouseleave: this.onTooltipMouseLeave.bind(this),
            });
            [this.onDocumentKeyDownCallback] = this.addManagedElementListeners((0, gridOptionsUtils_1._getDocument)(this.beans), {
                keydown: (e) => {
                    if (!eGui.contains(e?.target)) {
                        this.onKeyDown();
                    }
                },
            });
            if (this.tooltipTrigger === TooltipTrigger.FOCUS) {
                [this.tooltipFocusInListener, this.tooltipFocusOutListener] = this.addManagedElementListeners(eGui, {
                    focusin: this.onTooltipFocusIn.bind(this),
                    focusout: this.onTooltipFocusOut.bind(this),
                });
            }
        }
        this.eventSvc.dispatchEvent({
            type: 'tooltipShow',
            tooltipGui: eGui,
            parentGui: this.tooltipCtrl.getGui(),
        });
        this.startHideTimeout();
    }
    onTooltipMouseEnter() {
        this.isInteractingWithTooltip = true;
        this.unlockService();
    }
    onTooltipMouseLeave() {
        if (this.isTooltipFocused()) {
            return;
        }
        this.isInteractingWithTooltip = false;
        this.lockService();
    }
    onTooltipFocusIn() {
        this.isInteractingWithTooltip = true;
    }
    isTooltipFocused() {
        const tooltipGui = this.tooltipComp?.getGui();
        const activeEl = (0, gridOptionsUtils_1._getActiveDomElement)(this.beans);
        return !!tooltipGui && tooltipGui.contains(activeEl);
    }
    onTooltipFocusOut(e) {
        const parentGui = this.tooltipCtrl.getGui();
        // focusout is dispatched when inner elements lose focus
        // so we need to verify if focus is contained within the tooltip
        if (this.isTooltipFocused()) {
            return;
        }
        this.isInteractingWithTooltip = false;
        // if we move the focus from the tooltip back to the original cell
        // the tooltip should remain open, but we need to restart the hide timeout counter
        if (parentGui.contains(e.relatedTarget)) {
            this.startHideTimeout();
        }
        // if the parent cell doesn't contain the focus, simply hide the tooltip
        else {
            this.hideTooltip();
        }
    }
    positionTooltip() {
        const params = {
            type: 'tooltip',
            ePopup: this.tooltipComp.getGui(),
            nudgeY: 18,
            skipObserver: this.tooltipMouseTrack,
        };
        if (this.lastMouseEvent) {
            this.popupSvc?.positionPopupUnderMouseEvent({
                ...params,
                mouseEvent: this.lastMouseEvent,
            });
        }
        else {
            this.popupSvc?.positionPopupByComponent({
                ...params,
                eventSource: this.tooltipCtrl.getGui(),
                position: 'under',
                keepWithinBounds: true,
                nudgeY: 5,
            });
        }
    }
    destroyTooltipComp() {
        // add class to fade out the tooltip
        this.tooltipComp.getGui().classList.add('ag-tooltip-hiding');
        // make local copies of these variables, as we use them in the async function below,
        // and we clear then to 'undefined' later, so need to take a copy before they are undefined.
        const tooltipPopupDestroyFunc = this.tooltipPopupDestroyFunc;
        const tooltipComp = this.tooltipComp;
        const delay = this.tooltipTrigger === TooltipTrigger.HOVER ? FADE_OUT_TOOLTIP_TIMEOUT : 0;
        window.setTimeout(() => {
            tooltipPopupDestroyFunc();
            this.destroyBean(tooltipComp);
        }, delay);
        this.clearTooltipListeners();
        this.tooltipPopupDestroyFunc = undefined;
        this.tooltipComp = undefined;
    }
    clearTooltipListeners() {
        [
            this.tooltipMouseEnterListener,
            this.tooltipMouseLeaveListener,
            this.tooltipFocusInListener,
            this.tooltipFocusOutListener,
        ].forEach((listener) => {
            if (listener) {
                listener();
            }
        });
        this.tooltipMouseEnterListener =
            this.tooltipMouseLeaveListener =
                this.tooltipFocusInListener =
                    this.tooltipFocusOutListener =
                        null;
    }
    lockService() {
        isLocked = true;
        this.interactiveTooltipTimeoutId = window.setTimeout(() => {
            this.unlockService();
            this.setToDoNothing();
        }, INTERACTIVE_HIDE_DELAY);
    }
    unlockService() {
        isLocked = false;
        this.clearInteractiveTimeout();
    }
    startHideTimeout() {
        this.clearHideTimeout();
        this.hideTooltipTimeoutId = window.setTimeout(this.hideTooltip.bind(this), this.getTooltipDelay('hide'));
    }
    clearShowTimeout() {
        if (!this.showTooltipTimeoutId) {
            return;
        }
        window.clearTimeout(this.showTooltipTimeoutId);
        this.showTooltipTimeoutId = undefined;
    }
    clearHideTimeout() {
        if (!this.hideTooltipTimeoutId) {
            return;
        }
        window.clearTimeout(this.hideTooltipTimeoutId);
        this.hideTooltipTimeoutId = undefined;
    }
    clearInteractiveTimeout() {
        if (!this.interactiveTooltipTimeoutId) {
            return;
        }
        window.clearTimeout(this.interactiveTooltipTimeoutId);
        this.interactiveTooltipTimeoutId = undefined;
    }
    clearTimeouts() {
        this.clearShowTimeout();
        this.clearHideTimeout();
        this.clearInteractiveTimeout();
    }
}
exports.TooltipStateManager = TooltipStateManager;


/***/ }),

/***/ 57113:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UndoRedoService = void 0;
const beanStub_1 = __webpack_require__(68731);
const positionUtils_1 = __webpack_require__(6257);
const gridOptionsUtils_1 = __webpack_require__(67274);
const undoRedoStack_1 = __webpack_require__(92410);
class UndoRedoService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'undoRedo';
        this.cellValueChanges = [];
        this.activeCellEdit = null;
        this.activeRowEdit = null;
        this.isPasting = false;
        this.isRangeInAction = false;
        this.batchEditing = false;
        this.onCellValueChanged = (event) => {
            const eventCell = { column: event.column, rowIndex: event.rowIndex, rowPinned: event.rowPinned };
            const isCellEditing = this.activeCellEdit !== null && (0, positionUtils_1._areCellsEqual)(this.activeCellEdit, eventCell);
            const isRowEditing = this.activeRowEdit !== null && (0, positionUtils_1._isSameRow)(this.activeRowEdit, eventCell);
            const shouldCaptureAction = isCellEditing || isRowEditing || this.isPasting || this.isRangeInAction;
            if (!shouldCaptureAction) {
                return;
            }
            const { rowPinned, rowIndex, column, oldValue, value } = event;
            const cellValueChange = {
                rowPinned,
                rowIndex: rowIndex,
                columnId: column.getColId(),
                newValue: value,
                oldValue,
            };
            this.cellValueChanges.push(cellValueChange);
        };
        this.clearStacks = () => {
            this.undoStack.clear();
            this.redoStack.clear();
        };
    }
    postConstruct() {
        const { gos, ctrlsSvc } = this.beans;
        if (!gos.get('undoRedoCellEditing')) {
            return;
        }
        const undoRedoLimit = gos.get('undoRedoCellEditingLimit');
        if (undoRedoLimit <= 0) {
            return;
        }
        this.undoStack = new undoRedoStack_1.UndoRedoStack(undoRedoLimit);
        this.redoStack = new undoRedoStack_1.UndoRedoStack(undoRedoLimit);
        this.addListeners();
        const listener = this.clearStacks.bind(this);
        this.addManagedEventListeners({
            cellValueChanged: this.onCellValueChanged.bind(this),
            // undo / redo is restricted to actual editing so we clear the stacks when other operations are
            // performed that change the order of the row / cols.
            modelUpdated: (e) => {
                if (!e.keepUndoRedoStack) {
                    this.clearStacks();
                }
            },
            columnPivotModeChanged: listener,
            newColumnsLoaded: listener,
            columnGroupOpened: listener,
            columnRowGroupChanged: listener,
            columnMoved: listener,
            columnPinned: listener,
            columnVisible: listener,
            rowDragEnd: listener,
        });
        ctrlsSvc.whenReady(this, (p) => {
            this.gridBodyCtrl = p.gridBodyCtrl;
        });
    }
    getCurrentUndoStackSize() {
        return this.undoStack?.getCurrentStackSize() ?? 0;
    }
    getCurrentRedoStackSize() {
        return this.redoStack?.getCurrentStackSize() ?? 0;
    }
    undo(source) {
        const { eventSvc, undoStack, redoStack } = this;
        eventSvc.dispatchEvent({
            type: 'undoStarted',
            source,
        });
        const operationPerformed = this.undoRedo(undoStack, redoStack, 'initialRange', 'oldValue', 'undo');
        eventSvc.dispatchEvent({
            type: 'undoEnded',
            source,
            operationPerformed,
        });
    }
    redo(source) {
        const { eventSvc, undoStack, redoStack } = this;
        eventSvc.dispatchEvent({
            type: 'redoStarted',
            source,
        });
        const operationPerformed = this.undoRedo(redoStack, undoStack, 'finalRange', 'newValue', 'redo');
        eventSvc.dispatchEvent({
            type: 'redoEnded',
            source,
            operationPerformed,
        });
    }
    undoRedo(undoRedoStack, opposingUndoRedoStack, rangeProperty, cellValueChangeProperty, source) {
        if (!undoRedoStack) {
            return false;
        }
        const undoRedoAction = undoRedoStack.pop();
        if (!undoRedoAction || !undoRedoAction.cellValueChanges) {
            return false;
        }
        this.processAction(undoRedoAction, (cellValueChange) => cellValueChange[cellValueChangeProperty], source);
        if (undoRedoAction instanceof undoRedoStack_1.RangeUndoRedoAction) {
            this.processRange(undoRedoAction.ranges || [undoRedoAction[rangeProperty]]);
        }
        else {
            this.processCell(undoRedoAction.cellValueChanges);
        }
        opposingUndoRedoStack.push(undoRedoAction);
        return true;
    }
    processAction(action, valueExtractor, source) {
        action.cellValueChanges.forEach((cellValueChange) => {
            const { rowIndex, rowPinned, columnId } = cellValueChange;
            const rowPosition = { rowIndex, rowPinned };
            const currentRow = (0, positionUtils_1._getRowNode)(this.beans, rowPosition);
            // checks if the row has been filtered out
            if (!currentRow.displayed) {
                return;
            }
            currentRow.setDataValue(columnId, valueExtractor(cellValueChange), source);
        });
    }
    processRange(ranges) {
        let lastFocusedCell;
        const rangeSvc = this.beans.rangeSvc;
        rangeSvc.removeAllCellRanges(true);
        ranges.forEach((range, idx) => {
            if (!range) {
                return;
            }
            const startRow = range.startRow;
            const endRow = range.endRow;
            if (idx === ranges.length - 1) {
                lastFocusedCell = {
                    rowPinned: startRow.rowPinned,
                    rowIndex: startRow.rowIndex,
                    columnId: range.startColumn.getColId(),
                };
                this.setLastFocusedCell(lastFocusedCell);
            }
            const cellRangeParams = {
                rowStartIndex: startRow.rowIndex,
                rowStartPinned: startRow.rowPinned,
                rowEndIndex: endRow.rowIndex,
                rowEndPinned: endRow.rowPinned,
                columnStart: range.startColumn,
                columns: range.columns,
            };
            rangeSvc.addCellRange(cellRangeParams);
        });
    }
    processCell(cellValueChanges) {
        const cellValueChange = cellValueChanges[0];
        const { rowIndex, rowPinned } = cellValueChange;
        const rowPosition = { rowIndex, rowPinned };
        const row = (0, positionUtils_1._getRowNode)(this.beans, rowPosition);
        const lastFocusedCell = {
            rowPinned: cellValueChange.rowPinned,
            rowIndex: row.rowIndex,
            columnId: cellValueChange.columnId,
        };
        // when single cells are being processed, they should be considered
        // as ranges when the rangeSvc is present (singleCellRanges).
        // otherwise focus will be restore but the range will not.
        this.setLastFocusedCell(lastFocusedCell);
    }
    setLastFocusedCell(lastFocusedCell) {
        const { rowIndex, columnId, rowPinned } = lastFocusedCell;
        const { colModel, focusSvc, rangeSvc } = this.beans;
        const column = colModel.getCol(columnId);
        if (!column) {
            return;
        }
        const { scrollFeature } = this.gridBodyCtrl;
        scrollFeature.ensureIndexVisible(rowIndex);
        scrollFeature.ensureColumnVisible(column);
        const cellPosition = { rowIndex, column, rowPinned };
        focusSvc.setFocusedCell({ ...cellPosition, forceBrowserFocus: true });
        rangeSvc?.setRangeToCell(cellPosition);
    }
    addListeners() {
        this.addManagedEventListeners({
            rowEditingStarted: (e) => {
                this.activeRowEdit = { rowIndex: e.rowIndex, rowPinned: e.rowPinned };
            },
            rowEditingStopped: () => {
                const action = new undoRedoStack_1.UndoRedoAction(this.cellValueChanges);
                this.pushActionsToUndoStack(action);
                this.activeRowEdit = null;
            },
            cellEditingStarted: (e) => {
                this.activeCellEdit = { column: e.column, rowIndex: e.rowIndex, rowPinned: e.rowPinned };
            },
            cellEditingStopped: (e) => {
                this.activeCellEdit = null;
                const shouldPushAction = e.valueChanged && !this.activeRowEdit && !this.isPasting && !this.isRangeInAction;
                if (shouldPushAction) {
                    const action = new undoRedoStack_1.UndoRedoAction(this.cellValueChanges);
                    this.pushActionsToUndoStack(action);
                }
            },
            pasteStart: () => {
                this.isPasting = true;
            },
            pasteEnd: () => {
                const action = new undoRedoStack_1.UndoRedoAction(this.cellValueChanges);
                this.pushActionsToUndoStack(action);
                this.isPasting = false;
            },
            fillStart: () => {
                this.isRangeInAction = true;
            },
            fillEnd: (event) => {
                const action = new undoRedoStack_1.RangeUndoRedoAction(this.cellValueChanges, event.initialRange, event.finalRange);
                this.pushActionsToUndoStack(action);
                this.isRangeInAction = false;
            },
            keyShortcutChangedCellStart: () => {
                this.isRangeInAction = true;
            },
            keyShortcutChangedCellEnd: () => {
                let action;
                const { rangeSvc, gos } = this.beans;
                if (rangeSvc && (0, gridOptionsUtils_1._isCellSelectionEnabled)(gos)) {
                    action = new undoRedoStack_1.RangeUndoRedoAction(this.cellValueChanges, undefined, undefined, [
                        ...rangeSvc.getCellRanges(),
                    ]);
                }
                else {
                    action = new undoRedoStack_1.UndoRedoAction(this.cellValueChanges);
                }
                this.pushActionsToUndoStack(action);
                this.isRangeInAction = false;
            },
            batchEditingStarted: () => {
                this.batchEditing = true;
            },
            batchEditingStopped: (event) => {
                if (!this.batchEditing) {
                    return;
                }
                this.batchEditing = false;
                if (event.changes?.length === 0) {
                    return;
                }
                const action = new undoRedoStack_1.UndoRedoAction(event.changes ?? []);
                this.pushActionsToUndoStack(action);
                this.cellValueChanges = [];
            },
        });
    }
    pushActionsToUndoStack(action) {
        this.undoStack.push(action);
        this.cellValueChanges = [];
        this.redoStack.clear();
    }
}
exports.UndoRedoService = UndoRedoService;


/***/ }),

/***/ 92410:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UndoRedoStack = exports.RangeUndoRedoAction = exports.UndoRedoAction = void 0;
class UndoRedoAction {
    constructor(cellValueChanges) {
        this.cellValueChanges = cellValueChanges;
    }
}
exports.UndoRedoAction = UndoRedoAction;
class RangeUndoRedoAction extends UndoRedoAction {
    constructor(cellValueChanges, initialRange, finalRange, ranges) {
        super(cellValueChanges);
        this.initialRange = initialRange;
        this.finalRange = finalRange;
        this.ranges = ranges;
    }
}
exports.RangeUndoRedoAction = RangeUndoRedoAction;
const DEFAULT_STACK_SIZE = 10;
class UndoRedoStack {
    constructor(maxStackSize) {
        this.actionStack = [];
        this.maxStackSize = maxStackSize ? maxStackSize : DEFAULT_STACK_SIZE;
        this.actionStack = new Array(this.maxStackSize);
    }
    pop() {
        return this.actionStack.pop();
    }
    push(item) {
        const shouldAddActions = item.cellValueChanges && item.cellValueChanges.length > 0;
        if (!shouldAddActions) {
            return;
        }
        if (this.actionStack.length === this.maxStackSize) {
            this.actionStack.shift();
        }
        this.actionStack.push(item);
    }
    clear() {
        this.actionStack = [];
    }
    getCurrentStackSize() {
        return this.actionStack.length;
    }
}
exports.UndoRedoStack = UndoRedoStack;


/***/ }),

/***/ 95230:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._getAriaCheckboxStateName = exports._setAriaHasPopup = exports._setAriaControlsAndLabel = exports._setAriaControls = exports._setAriaChecked = exports._setAriaSelected = exports._removeAriaSort = exports._setAriaSort = exports._setAriaColSpan = exports._setAriaColIndex = exports._setAriaColCount = exports._setAriaRowSpan = exports._setAriaRowIndex = exports._setAriaRowCount = exports._setAriaMultiSelectable = exports._setAriaPosInSet = exports._setAriaSetSize = exports._removeAriaExpanded = exports._setAriaExpanded = exports._setAriaActiveDescendant = exports._setAriaHidden = exports._setAriaDisabled = exports._setAriaLevel = exports._setAriaInvalid = exports._setAriaRelevant = exports._setAriaAtomic = exports._setAriaLive = exports._setAriaDescribedBy = exports._setAriaLabelledBy = exports._setAriaLabel = exports._getAriaLabel = exports._getAriaPosInSet = exports._getAriaLevel = exports._getAriaSortState = exports._setAriaRole = void 0;
// ARIA HELPER FUNCTIONS
function _toggleAriaAttribute(element, attribute, value) {
    if (value == null || (typeof value === 'string' && value == '')) {
        _removeAriaAttribute(element, attribute);
    }
    else {
        _setAriaAttribute(element, attribute, value);
    }
}
function _setAriaAttribute(element, attribute, value) {
    element.setAttribute(_ariaAttributeName(attribute), value.toString());
}
function _removeAriaAttribute(element, attribute) {
    element.removeAttribute(_ariaAttributeName(attribute));
}
function _ariaAttributeName(attribute) {
    return `aria-${attribute}`;
}
function _setAriaRole(element, role) {
    if (role) {
        element.setAttribute('role', role);
    }
    else {
        element.removeAttribute('role');
    }
}
exports._setAriaRole = _setAriaRole;
function _getAriaSortState(sortDirection) {
    let sort;
    if (sortDirection === 'asc') {
        sort = 'ascending';
    }
    else if (sortDirection === 'desc') {
        sort = 'descending';
    }
    else if (sortDirection === 'mixed') {
        sort = 'other';
    }
    else {
        sort = 'none';
    }
    return sort;
}
exports._getAriaSortState = _getAriaSortState;
// ARIA ATTRIBUTE GETTERS
function _getAriaLevel(element) {
    return parseInt(element.getAttribute('aria-level'), 10);
}
exports._getAriaLevel = _getAriaLevel;
function _getAriaPosInSet(element) {
    return parseInt(element.getAttribute('aria-posinset'), 10);
}
exports._getAriaPosInSet = _getAriaPosInSet;
function _getAriaLabel(element) {
    return element.getAttribute('aria-label');
}
exports._getAriaLabel = _getAriaLabel;
// ARIA ATTRIBUTE SETTERS
function _setAriaLabel(element, label) {
    _toggleAriaAttribute(element, 'label', label);
}
exports._setAriaLabel = _setAriaLabel;
function _setAriaLabelledBy(element, labelledBy) {
    _toggleAriaAttribute(element, 'labelledby', labelledBy);
}
exports._setAriaLabelledBy = _setAriaLabelledBy;
function _setAriaDescribedBy(element, describedby) {
    _toggleAriaAttribute(element, 'describedby', describedby);
}
exports._setAriaDescribedBy = _setAriaDescribedBy;
function _setAriaLive(element, live) {
    _toggleAriaAttribute(element, 'live', live);
}
exports._setAriaLive = _setAriaLive;
function _setAriaAtomic(element, atomic) {
    _toggleAriaAttribute(element, 'atomic', atomic);
}
exports._setAriaAtomic = _setAriaAtomic;
function _setAriaRelevant(element, relevant) {
    _toggleAriaAttribute(element, 'relevant', relevant);
}
exports._setAriaRelevant = _setAriaRelevant;
function _setAriaInvalid(element, invalid) {
    _toggleAriaAttribute(element, 'invalid', invalid);
}
exports._setAriaInvalid = _setAriaInvalid;
function _setAriaLevel(element, level) {
    _toggleAriaAttribute(element, 'level', level);
}
exports._setAriaLevel = _setAriaLevel;
function _setAriaDisabled(element, disabled) {
    _toggleAriaAttribute(element, 'disabled', disabled);
}
exports._setAriaDisabled = _setAriaDisabled;
function _setAriaHidden(element, hidden) {
    _toggleAriaAttribute(element, 'hidden', hidden);
}
exports._setAriaHidden = _setAriaHidden;
function _setAriaActiveDescendant(element, descendantId) {
    _toggleAriaAttribute(element, 'activedescendant', descendantId);
}
exports._setAriaActiveDescendant = _setAriaActiveDescendant;
function _setAriaExpanded(element, expanded) {
    _setAriaAttribute(element, 'expanded', expanded);
}
exports._setAriaExpanded = _setAriaExpanded;
function _removeAriaExpanded(element) {
    _removeAriaAttribute(element, 'expanded');
}
exports._removeAriaExpanded = _removeAriaExpanded;
function _setAriaSetSize(element, setsize) {
    _setAriaAttribute(element, 'setsize', setsize);
}
exports._setAriaSetSize = _setAriaSetSize;
function _setAriaPosInSet(element, position) {
    _setAriaAttribute(element, 'posinset', position);
}
exports._setAriaPosInSet = _setAriaPosInSet;
function _setAriaMultiSelectable(element, multiSelectable) {
    _setAriaAttribute(element, 'multiselectable', multiSelectable);
}
exports._setAriaMultiSelectable = _setAriaMultiSelectable;
function _setAriaRowCount(element, rowCount) {
    _setAriaAttribute(element, 'rowcount', rowCount);
}
exports._setAriaRowCount = _setAriaRowCount;
function _setAriaRowIndex(element, rowIndex) {
    _setAriaAttribute(element, 'rowindex', rowIndex);
}
exports._setAriaRowIndex = _setAriaRowIndex;
function _setAriaRowSpan(element, spanCount) {
    _setAriaAttribute(element, 'rowspan', spanCount);
}
exports._setAriaRowSpan = _setAriaRowSpan;
function _setAriaColCount(element, colCount) {
    _setAriaAttribute(element, 'colcount', colCount);
}
exports._setAriaColCount = _setAriaColCount;
function _setAriaColIndex(element, colIndex) {
    _setAriaAttribute(element, 'colindex', colIndex);
}
exports._setAriaColIndex = _setAriaColIndex;
function _setAriaColSpan(element, colSpan) {
    _setAriaAttribute(element, 'colspan', colSpan);
}
exports._setAriaColSpan = _setAriaColSpan;
function _setAriaSort(element, sort) {
    _setAriaAttribute(element, 'sort', sort);
}
exports._setAriaSort = _setAriaSort;
function _removeAriaSort(element) {
    _removeAriaAttribute(element, 'sort');
}
exports._removeAriaSort = _removeAriaSort;
function _setAriaSelected(element, selected) {
    _toggleAriaAttribute(element, 'selected', selected);
}
exports._setAriaSelected = _setAriaSelected;
function _setAriaChecked(element, checked) {
    _setAriaAttribute(element, 'checked', checked === undefined ? 'mixed' : checked);
}
exports._setAriaChecked = _setAriaChecked;
function _setAriaControls(controllerElement, controlledId) {
    _toggleAriaAttribute(controllerElement, 'controls', controlledId);
}
exports._setAriaControls = _setAriaControls;
function _setAriaControlsAndLabel(controllerElement, controlledElement) {
    _setAriaControls(controllerElement, controlledElement.id);
    _setAriaLabelledBy(controlledElement, controllerElement.id);
}
exports._setAriaControlsAndLabel = _setAriaControlsAndLabel;
function _setAriaHasPopup(element, hasPopup) {
    _toggleAriaAttribute(element, 'haspopup', hasPopup === false ? null : hasPopup);
}
exports._setAriaHasPopup = _setAriaHasPopup;
function _getAriaCheckboxStateName(translate, state) {
    return state === undefined
        ? translate('ariaIndeterminate', 'indeterminate')
        : state === true
            ? translate('ariaChecked', 'checked')
            : translate('ariaUnchecked', 'unchecked');
}
exports._getAriaCheckboxStateName = _getAriaCheckboxStateName;


/***/ }),

/***/ 31502:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._flatten = exports._moveInArray = exports._removeFromArray = exports._forAll = exports._areEqual = exports._last = exports._EmptyArray = void 0;
/** An array that is always empty and that cannot be modified */
exports._EmptyArray = Object.freeze([]);
function _last(arr) {
    if (!arr?.length) {
        return;
    }
    return arr[arr.length - 1];
}
exports._last = _last;
function _areEqual(a, b, comparator) {
    if (a == null && b == null) {
        return true;
    }
    return (a != null &&
        b != null &&
        a.length === b.length &&
        a.every((value, index) => (comparator ? comparator(value, b[index]) : b[index] === value)));
}
exports._areEqual = _areEqual;
/**
 * Utility that uses the fastest looping approach to apply a callback to each element of the array
 * https://jsperf.app/for-for-of-for-in-foreach-comparison
 */
function _forAll(array, callback) {
    if (!array) {
        return;
    }
    for (const value of array) {
        callback(value);
    }
}
exports._forAll = _forAll;
function _removeFromArray(array, object) {
    const index = array.indexOf(object);
    if (index >= 0) {
        array.splice(index, 1);
    }
}
exports._removeFromArray = _removeFromArray;
// should consider refactoring the callers to create a new array rather than mutating the original, which is expensive
function _moveInArray(array, objectsToMove, toIndex) {
    // first take out items from the array
    for (let i = 0; i < objectsToMove.length; i++) {
        _removeFromArray(array, objectsToMove[i]);
    }
    // now add the objects, in same order as provided to us, that means we start at the end
    // as the objects will be pushed to the right as they are inserted
    for (let i = objectsToMove.length - 1; i >= 0; i--) {
        array.splice(toIndex, 0, objectsToMove[i]);
    }
}
exports._moveInArray = _moveInArray;
function _flatten(arrays) {
    // Currently the fastest way to flatten an array according to https://jsbench.me/adlib26t2y/2
    return [].concat.apply([], arrays);
}
exports._flatten = _flatten;


/***/ }),

/***/ 98667:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._isInvisibleScrollbar = exports._getScrollbarWidth = exports._getMaxDivHeight = exports._getTabIndex = exports._isIOSUserAgent = exports._isMacOsUserAgent = exports._isBrowserFirefox = exports._isBrowserChrome = exports._isBrowserSafari = void 0;
/**
 * These variables are lazy loaded, as otherwise they try and get initialised when we are loading
 * unit tests and we don't have references to window or document in the unit tests
 */
let isSafari;
let isChrome;
let isFirefox;
let isMacOs;
let isIOS;
let invisibleScrollbar;
let browserScrollbarWidth;
let maxDivHeight;
function _isBrowserSafari() {
    if (isSafari === undefined) {
        isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    }
    return isSafari;
}
exports._isBrowserSafari = _isBrowserSafari;
/**
 * Returns true for Chrome and also for Edge (Chromium)
 */
function _isBrowserChrome() {
    if (isChrome === undefined) {
        const win = window;
        isChrome =
            (!!win.chrome && (!!win.chrome.webstore || !!win.chrome.runtime)) ||
                (/Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor));
    }
    return isChrome;
}
exports._isBrowserChrome = _isBrowserChrome;
function _isBrowserFirefox() {
    if (isFirefox === undefined) {
        isFirefox = /(firefox)/i.test(navigator.userAgent);
    }
    return isFirefox;
}
exports._isBrowserFirefox = _isBrowserFirefox;
function _isMacOsUserAgent() {
    if (isMacOs === undefined) {
        isMacOs = /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);
    }
    return isMacOs;
}
exports._isMacOsUserAgent = _isMacOsUserAgent;
function _isIOSUserAgent() {
    if (isIOS === undefined) {
        isIOS =
            /iPad|iPhone|iPod/.test(navigator.platform) ||
                (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
    }
    return isIOS;
}
exports._isIOSUserAgent = _isIOSUserAgent;
function _getTabIndex(el) {
    if (!el) {
        return null;
    }
    const numberTabIndex = el.tabIndex;
    const tabIndex = el.getAttribute('tabIndex');
    if (numberTabIndex === -1 && (tabIndex === null || (tabIndex === '' && !_isBrowserFirefox()))) {
        return null;
    }
    return numberTabIndex.toString();
}
exports._getTabIndex = _getTabIndex;
function _getMaxDivHeight() {
    if (maxDivHeight !== undefined) {
        return maxDivHeight;
    }
    if (!document.body) {
        return -1;
    }
    let res = 1000000;
    // FF reports the height back but still renders blank after ~6M px
    const testUpTo = _isBrowserFirefox() ? 6000000 : 1000000000;
    const div = document.createElement('div');
    document.body.appendChild(div);
    while (true) {
        const test = res * 2;
        div.style.height = test + 'px';
        if (test > testUpTo || div.clientHeight !== test) {
            break;
        }
        else {
            res = test;
        }
    }
    document.body.removeChild(div);
    maxDivHeight = res;
    return res;
}
exports._getMaxDivHeight = _getMaxDivHeight;
function _getScrollbarWidth() {
    if (browserScrollbarWidth == null) {
        initScrollbarWidthAndVisibility();
    }
    return browserScrollbarWidth;
}
exports._getScrollbarWidth = _getScrollbarWidth;
function initScrollbarWidthAndVisibility() {
    const body = document.body;
    const div = document.createElement('div');
    div.style.width = div.style.height = '100px';
    div.style.opacity = '0';
    div.style.overflow = 'scroll';
    div.style.msOverflowStyle = 'scrollbar'; // needed for WinJS apps
    div.style.position = 'absolute';
    body.appendChild(div);
    let width = div.offsetWidth - div.clientWidth;
    // if width is 0 and client width is 0, means the DOM isn't ready
    if (width === 0 && div.clientWidth === 0) {
        width = null;
    }
    // remove div
    if (div.parentNode) {
        div.parentNode.removeChild(div);
    }
    if (width != null) {
        browserScrollbarWidth = width;
        invisibleScrollbar = width === 0;
    }
}
function _isInvisibleScrollbar() {
    if (invisibleScrollbar == null) {
        initScrollbarWidthAndVisibility();
    }
    return invisibleScrollbar;
}
exports._isInvisibleScrollbar = _isInvisibleScrollbar;


/***/ }),

/***/ 76800:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChangedPath = void 0;
// when doing transactions, or change detection, and grouping is present
// in the data, there is no need for the ClientSideRowModel to update each
// group after an update, ony parts that were impacted by the change.
// this class keeps track of all groups that were impacted by a transaction.
// the the different CSRM operations (filter, sort etc) use the forEach method
// to visit each group that was changed.
class ChangedPath {
    constructor(keepingColumns, rootNode) {
        // whether changed path is active of not. it is active when a) doing
        // a transaction update or b) doing change detection. if we are doing
        // a CSRM refresh for other reasons (after sort or filter, or user calling
        // setRowData() without delta mode) then we are not active. we are also
        // marked as not active if secondary columns change in pivot (as this impacts
        // aggregations).
        // can be set inactive by:
        // a) ClientSideRowModel, if no transactions or
        // b) PivotService, if secondary columns changed
        this.active = true;
        // for each node in the change path, we also store which columns need
        // to be re-aggregated.
        this.nodeIdsToColumns = {};
        // for quick lookup, all items in the change path are mapped by nodeId
        this.mapToItems = {};
        this.keepingColumns = keepingColumns;
        this.pathRoot = {
            rowNode: rootNode,
            children: null,
        };
        this.mapToItems[rootNode.id] = this.pathRoot;
    }
    depthFirstSearchChangedPath(pathItem, callback) {
        const { rowNode, children } = pathItem;
        if (children) {
            for (let i = 0; i < children.length; ++i) {
                this.depthFirstSearchChangedPath(children[i], callback);
            }
        }
        callback(rowNode);
    }
    depthFirstSearchEverything(rowNode, callback, traverseEverything) {
        const childrenAfterGroup = rowNode.childrenAfterGroup;
        if (childrenAfterGroup) {
            for (let i = 0, len = childrenAfterGroup.length; i < len; ++i) {
                const childNode = childrenAfterGroup[i];
                if (childNode.childrenAfterGroup) {
                    this.depthFirstSearchEverything(childNode, callback, traverseEverything);
                }
                else if (traverseEverything) {
                    callback(childNode);
                }
            }
        }
        callback(rowNode);
    }
    // traverseLeafNodes -> used when NOT doing changed path, ie traversing everything. the callback
    // will be called for child nodes in addition to parent nodes.
    forEachChangedNodeDepthFirst(callback, traverseLeafNodes = false, includeUnchangedNodes = false) {
        if (this.active && !includeUnchangedNodes) {
            // if we are active, then use the change path to callback
            // only for updated groups
            this.depthFirstSearchChangedPath(this.pathRoot, callback);
        }
        else {
            // we are not active, so callback for everything, walk the entire path
            this.depthFirstSearchEverything(this.pathRoot.rowNode, callback, traverseLeafNodes);
        }
    }
    executeFromRootNode(callback) {
        callback(this.pathRoot.rowNode);
    }
    createPathItems(rowNode) {
        let pointer = rowNode;
        let newEntryCount = 0;
        while (!this.mapToItems[pointer.id]) {
            const newEntry = {
                rowNode: pointer,
                children: null,
            };
            this.mapToItems[pointer.id] = newEntry;
            newEntryCount++;
            pointer = pointer.parent;
        }
        return newEntryCount;
    }
    populateColumnsMap(rowNode, columns) {
        if (!this.keepingColumns || !columns) {
            return;
        }
        let pointer = rowNode;
        while (pointer) {
            // if columns, add the columns in all the way to parent, merging
            // in any other columns that might be there already
            if (!this.nodeIdsToColumns[pointer.id]) {
                this.nodeIdsToColumns[pointer.id] = {};
            }
            columns.forEach((col) => (this.nodeIdsToColumns[pointer.id][col.getId()] = true));
            pointer = pointer.parent;
        }
    }
    linkPathItems(rowNode, newEntryCount) {
        let pointer = rowNode;
        for (let i = 0; i < newEntryCount; i++) {
            const thisItem = this.mapToItems[pointer.id];
            const parentItem = this.mapToItems[pointer.parent.id];
            if (!parentItem.children) {
                parentItem.children = [];
            }
            parentItem.children.push(thisItem);
            pointer = pointer.parent;
        }
    }
    // called by
    // 1) change detection (provides cols) and
    // 2) groupStage if doing transaction update (doesn't provide cols)
    addParentNode(rowNode, columns) {
        if (!rowNode || rowNode.isRowPinned()) {
            return;
        }
        // we cannot do  both steps below in the same loop as
        // the second loop has a dependency on the first loop.
        // ie the hierarchy cannot be stitched up yet because
        // we don't have it built yet
        // create the new PathItem objects.
        const newEntryCount = this.createPathItems(rowNode);
        // link in the node items
        this.linkPathItems(rowNode, newEntryCount);
        // update columns
        this.populateColumnsMap(rowNode, columns);
    }
    canSkip(rowNode) {
        return this.active && !this.mapToItems[rowNode.id];
    }
    getValueColumnsForNode(rowNode, valueColumns) {
        if (!this.keepingColumns) {
            return valueColumns;
        }
        const colsForThisNode = this.nodeIdsToColumns[rowNode.id];
        const result = valueColumns.filter((col) => colsForThisNode[col.getId()]);
        return result;
    }
    getNotValueColumnsForNode(rowNode, valueColumns) {
        if (!this.keepingColumns) {
            return null;
        }
        const colsForThisNode = this.nodeIdsToColumns[rowNode.id];
        const result = valueColumns.filter((col) => !colsForThisNode[col.getId()]);
        return result;
    }
}
exports.ChangedPath = ChangedPath;


/***/ }),

/***/ 39827:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._parseDateTimeFromString = exports._isValidDateTime = exports._isValidDate = exports._dateToFormattedString = exports._getDateParts = exports._serialiseDate = void 0;
const DATE_TIME_SEPARATOR = 'T';
/**
 * Executing this against date produces the following:
 * ["2008-08-24T21:00:08"," 21:00:08"]
 */
const DATE_TIME_REGEXP = new RegExp(`^\\d{4}-\\d{2}-\\d{2}(${DATE_TIME_SEPARATOR}\\d{2}:\\d{2}:\\d{2}\\D?)?`);
function _padStartWidthZeros(value, totalStringSize) {
    return value.toString().padStart(totalStringSize, '0');
}
/**
 * Serialises a Date to a string of format `yyyy-MM-ddTHH:mm:ss`.
 * An alternative separator can be provided to be used instead of hyphens.
 * @param date The date to serialise
 * @param includeTime Whether to include the time in the serialised string
 * @param separator The separator to use between date parts, e.g. 2025-01-01 or 2025/01/01
 */
function _serialiseDate(date, includeTime = true, separator = '-') {
    if (!date) {
        return null;
    }
    let serialised = [date.getFullYear(), date.getMonth() + 1, date.getDate()]
        .map((part) => _padStartWidthZeros(part, 2))
        .join(separator);
    if (includeTime) {
        serialised +=
            DATE_TIME_SEPARATOR +
                [date.getHours(), date.getMinutes(), date.getSeconds()]
                    .map((part) => _padStartWidthZeros(part, 2))
                    .join(':');
    }
    return serialised;
}
exports._serialiseDate = _serialiseDate;
/**
 * Helper function to get the date parts of a date. Used in set filter.
 * @param d The date to get the parts from
 * @param includeTime Whether to include the time in the returned array
 * @returns The date parts as an array of strings or null if the date is null or undefined
 */
function _getDateParts(d, includeTime = true) {
    if (!d) {
        return null;
    }
    if (includeTime) {
        return [
            String(d.getFullYear()),
            String(d.getMonth() + 1),
            _padStartWidthZeros(d.getDate(), 2),
            _padStartWidthZeros(d.getHours(), 2),
            `:${_padStartWidthZeros(d.getMinutes(), 2)}`,
            `:${_padStartWidthZeros(d.getSeconds(), 2)}`,
        ];
    }
    return [d.getFullYear(), d.getMonth() + 1, _padStartWidthZeros(d.getDate(), 2)].map(String);
}
exports._getDateParts = _getDateParts;
const calculateOrdinal = (value) => {
    if (value > 3 && value < 21) {
        return 'th';
    }
    const remainder = value % 10;
    switch (remainder) {
        case 1:
            return 'st';
        case 2:
            return 'nd';
        case 3:
            return 'rd';
    }
    return 'th';
};
/**
 * Serialises a Date to a string of format the defined format, does not include time.
 * @param date The date to serialise
 * @param format The string to format the date to, defaults to YYYY-MM-DD
 */
function _dateToFormattedString(date, format) {
    if (format == null) {
        // returns YYYY-MM-DD, but is more efficient
        return _serialiseDate(date, false);
    }
    const fullYear = _padStartWidthZeros(date.getFullYear(), 4);
    const months = [
        'January',
        'February',
        'March',
        'April',
        'May',
        'June',
        'July',
        'August',
        'September',
        'October',
        'November',
        'December',
    ];
    const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    const replace = {
        YYYY: () => fullYear.slice(fullYear.length - 4, fullYear.length),
        YY: () => fullYear.slice(fullYear.length - 2, fullYear.length),
        Y: () => `${date.getFullYear()}`,
        MMMM: () => months[date.getMonth()],
        MMM: () => months[date.getMonth()].slice(0, 3),
        MM: () => _padStartWidthZeros(date.getMonth() + 1, 2),
        Mo: () => `${date.getMonth() + 1}${calculateOrdinal(date.getMonth() + 1)}`,
        M: () => `${date.getMonth() + 1}`,
        Do: () => `${date.getDate()}${calculateOrdinal(date.getDate())}`,
        DD: () => _padStartWidthZeros(date.getDate(), 2),
        D: () => `${date.getDate()}`,
        dddd: () => days[date.getDay()],
        ddd: () => days[date.getDay()].slice(0, 3),
        dd: () => days[date.getDay()].slice(0, 2),
        do: () => `${date.getDay()}${calculateOrdinal(date.getDay())}`,
        d: () => `${date.getDay()}`,
    };
    const regexp = new RegExp(Object.keys(replace).join('|'), 'g');
    return format.replace(regexp, (match) => {
        if (match in replace) {
            return replace[match]();
        }
        return match;
    });
}
exports._dateToFormattedString = _dateToFormattedString;
/**
 * Helper function to check if a date is valid. Use isValidDateTime() to check if a date is valid and has time parts.
 */
function _isValidDate(value, bailIfInvalidTime = false) {
    return !!_parseDateTimeFromString(value, bailIfInvalidTime);
}
exports._isValidDate = _isValidDate;
// check if dateTime is a valid date and has time parts
function _isValidDateTime(value) {
    return !!value && _isValidDate(value, true) && !!value.match(DATE_TIME_REGEXP)?.[1]; // matches the 'T14:22:19' part
}
exports._isValidDateTime = _isValidDateTime;
/**
 * Parses a date and time from a string. Expected format is ISO-compatible `yyyy-MM-dd` or `yyyy-MM-ddTHH:mm:ssZ`.
 *
 * Because of javascript historical reasons, we need to parse the datetime manually:
 * Per MDN:
 *   When the time zone offset is absent, **date-only** forms are interpreted as a UTC time and **date-time** forms are interpreted as a local time.
 *   The interpretation as a UTC time is due to a historical spec error that was not consistent with ISO 8601 but could not be changed due to web compatibility.
 */
function _parseDateTimeFromString(value, bailIfInvalidTime = false) {
    if (!value) {
        return null;
    }
    const [dateStr, timeStr] = value.split(DATE_TIME_SEPARATOR);
    if (!dateStr) {
        return null;
    }
    const fields = dateStr.split('-').map((f) => parseInt(f, 10));
    if (fields.filter((f) => !isNaN(f)).length !== 3) {
        return null;
    }
    const [year, month, day] = fields;
    const date = new Date(year, month - 1, day);
    if (date.getFullYear() !== year || date.getMonth() !== month - 1 || date.getDate() !== day) {
        // date was not parsed as expected so must have been invalid
        return null;
    }
    if (!timeStr || timeStr === '00:00:00') {
        return date;
    }
    const [hours, minutes, seconds] = timeStr.split(':').map((part) => parseInt(part, 10)); // if last part includes Z, it is dropped here
    if (hours >= 0 && hours < 24) {
        date.setHours(hours);
    }
    else if (bailIfInvalidTime) {
        return null;
    }
    if (minutes >= 0 && minutes < 60) {
        date.setMinutes(minutes);
    }
    else if (bailIfInvalidTime) {
        return null;
    }
    if (seconds >= 0 && seconds < 60) {
        date.setSeconds(seconds);
    }
    else if (bailIfInvalidTime) {
        return null;
    }
    return date;
}
exports._parseDateTimeFromString = _parseDateTimeFromString;


/***/ }),

/***/ 33507:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._createElement = exports.DataRefAttribute = exports._requestAnimationFrame = exports._preserveRangesWhile = exports._observeResize = exports._addOrRemoveAttribute = exports._isNodeOrElement = exports._formatSize = exports._setFixedHeight = exports._setFixedWidth = exports._setElementWidth = exports._isVerticalScrollShowing = exports._isHorizontalScrollShowing = exports._isElementOverflowingCallback = exports._addStylesToElement = exports._insertWithDomOrder = exports._setDomChildOrder = exports._ensureDomOrder = exports._loadTemplate = exports._isVisible = exports._isInDOM = exports._removeFromParent = exports._clearElement = exports._setScrollLeft = exports._getScrollLeft = exports._getElementRectWithOffset = exports._getAbsoluteWidth = exports._getAbsoluteHeight = exports._getInnerWidth = exports._getInnerHeight = exports._getElementSize = exports._isElementChildOfClass = exports._setDisabled = exports._setVisible = exports._setDisplayed = exports._isFocusableFormField = exports.FOCUSABLE_EXCLUDE = exports.FOCUSABLE_SELECTOR = exports._radioCssClass = void 0;
const gridOptionsUtils_1 = __webpack_require__(67274);
const aria_1 = __webpack_require__(95230);
const browser_1 = __webpack_require__(98667);
/**
 * This method adds a class to an element and remove that class from all siblings.
 * Useful for toggling state.
 * @param {HTMLElement} element The element to receive the class
 * @param {string} elementClass The class to be assigned to the element
 * @param {boolean} otherElementClass The class to be assigned to siblings of the element, but not the element itself
 */
function _radioCssClass(element, elementClass, otherElementClass) {
    const parent = element.parentElement;
    let sibling = parent && parent.firstChild;
    while (sibling) {
        if (elementClass) {
            sibling.classList.toggle(elementClass, sibling === element);
        }
        if (otherElementClass) {
            sibling.classList.toggle(otherElementClass, sibling !== element);
        }
        sibling = sibling.nextSibling;
    }
}
exports._radioCssClass = _radioCssClass;
exports.FOCUSABLE_SELECTOR = '[tabindex], input, select, button, textarea, [href]';
exports.FOCUSABLE_EXCLUDE = '[disabled], .ag-disabled:not(.ag-button), .ag-disabled *';
function _isFocusableFormField(element) {
    const matches = Element.prototype.matches || Element.prototype.msMatchesSelector;
    const inputSelector = 'input, select, button, textarea';
    const isFocusable = matches.call(element, inputSelector);
    const isNotFocusable = matches.call(element, exports.FOCUSABLE_EXCLUDE);
    const isElementVisible = _isVisible(element);
    const focusable = isFocusable && !isNotFocusable && isElementVisible;
    return focusable;
}
exports._isFocusableFormField = _isFocusableFormField;
function _setDisplayed(element, displayed, options = {}) {
    const { skipAriaHidden } = options;
    element.classList.toggle('ag-hidden', !displayed);
    if (!skipAriaHidden) {
        (0, aria_1._setAriaHidden)(element, !displayed);
    }
}
exports._setDisplayed = _setDisplayed;
function _setVisible(element, visible, options = {}) {
    const { skipAriaHidden } = options;
    element.classList.toggle('ag-invisible', !visible);
    if (!skipAriaHidden) {
        (0, aria_1._setAriaHidden)(element, !visible);
    }
}
exports._setVisible = _setVisible;
function _setDisabled(element, disabled) {
    const attributeName = 'disabled';
    const addOrRemoveDisabledAttribute = disabled
        ? (e) => e.setAttribute(attributeName, '')
        : (e) => e.removeAttribute(attributeName);
    addOrRemoveDisabledAttribute(element);
    const inputs = element.querySelectorAll('input') ?? [];
    for (const input of inputs) {
        addOrRemoveDisabledAttribute(input);
    }
}
exports._setDisabled = _setDisabled;
function _isElementChildOfClass(element, cls, maxNest) {
    let counter = 0;
    while (element) {
        if (element.classList.contains(cls)) {
            return true;
        }
        element = element.parentElement;
        if (typeof maxNest == 'number') {
            if (++counter > maxNest) {
                break;
            }
        }
        else if (element === maxNest) {
            break;
        }
    }
    return false;
}
exports._isElementChildOfClass = _isElementChildOfClass;
// returns back sizes as doubles instead of strings. similar to
// getBoundingClientRect, however getBoundingClientRect does not:
// a) work with fractions (eg browser is zooming)
// b) has CSS transitions applied (eg CSS scale, browser zoom), which we don't want, we want the un-transitioned values
function _getElementSize(el) {
    const { height, width, borderTopWidth, borderRightWidth, borderBottomWidth, borderLeftWidth, paddingTop, paddingRight, paddingBottom, paddingLeft, marginTop, marginRight, marginBottom, marginLeft, boxSizing, } = window.getComputedStyle(el);
    return {
        height: parseFloat(height || '0'),
        width: parseFloat(width || '0'),
        borderTopWidth: parseFloat(borderTopWidth || '0'),
        borderRightWidth: parseFloat(borderRightWidth || '0'),
        borderBottomWidth: parseFloat(borderBottomWidth || '0'),
        borderLeftWidth: parseFloat(borderLeftWidth || '0'),
        paddingTop: parseFloat(paddingTop || '0'),
        paddingRight: parseFloat(paddingRight || '0'),
        paddingBottom: parseFloat(paddingBottom || '0'),
        paddingLeft: parseFloat(paddingLeft || '0'),
        marginTop: parseFloat(marginTop || '0'),
        marginRight: parseFloat(marginRight || '0'),
        marginBottom: parseFloat(marginBottom || '0'),
        marginLeft: parseFloat(marginLeft || '0'),
        boxSizing,
    };
}
exports._getElementSize = _getElementSize;
function _getInnerHeight(el) {
    const size = _getElementSize(el);
    if (size.boxSizing === 'border-box') {
        return size.height - size.paddingTop - size.paddingBottom;
    }
    return size.height;
}
exports._getInnerHeight = _getInnerHeight;
function _getInnerWidth(el) {
    const size = _getElementSize(el);
    if (size.boxSizing === 'border-box') {
        return size.width - size.paddingLeft - size.paddingRight;
    }
    return size.width;
}
exports._getInnerWidth = _getInnerWidth;
function _getAbsoluteHeight(el) {
    const { height, marginBottom, marginTop } = _getElementSize(el);
    return Math.floor(height + marginBottom + marginTop);
}
exports._getAbsoluteHeight = _getAbsoluteHeight;
function _getAbsoluteWidth(el) {
    const { width, marginLeft, marginRight } = _getElementSize(el);
    return Math.floor(width + marginLeft + marginRight);
}
exports._getAbsoluteWidth = _getAbsoluteWidth;
function _getElementRectWithOffset(el) {
    const offsetElementRect = el.getBoundingClientRect();
    const { borderTopWidth, borderLeftWidth, borderRightWidth, borderBottomWidth } = _getElementSize(el);
    return {
        top: offsetElementRect.top + (borderTopWidth || 0),
        left: offsetElementRect.left + (borderLeftWidth || 0),
        right: offsetElementRect.right + (borderRightWidth || 0),
        bottom: offsetElementRect.bottom + (borderBottomWidth || 0),
    };
}
exports._getElementRectWithOffset = _getElementRectWithOffset;
function _getScrollLeft(element, rtl) {
    let scrollLeft = element.scrollLeft;
    if (rtl) {
        scrollLeft = Math.abs(scrollLeft);
    }
    return scrollLeft;
}
exports._getScrollLeft = _getScrollLeft;
function _setScrollLeft(element, value, rtl) {
    if (rtl) {
        value *= -1;
    }
    element.scrollLeft = value;
}
exports._setScrollLeft = _setScrollLeft;
function _clearElement(el) {
    while (el && el.firstChild) {
        el.removeChild(el.firstChild);
    }
}
exports._clearElement = _clearElement;
function _removeFromParent(node) {
    if (node && node.parentNode) {
        node.parentNode.removeChild(node);
    }
}
exports._removeFromParent = _removeFromParent;
function _isInDOM(element) {
    return !!element.offsetParent;
}
exports._isInDOM = _isInDOM;
function _isVisible(element) {
    const el = element;
    if (el.checkVisibility) {
        return el.checkVisibility({ checkVisibilityCSS: true });
    }
    const isHidden = !_isInDOM(element) || window.getComputedStyle(element).visibility !== 'visible';
    return !isHidden;
}
exports._isVisible = _isVisible;
/**
 * Loads the template and returns it as an element.
 * NOTE: Prefer _createElement
 * @param {string} template
 * @returns {HTMLElement}
 */
function _loadTemplate(template) {
    const tempDiv = document.createElement('div');
    // eslint-disable-next-line no-restricted-properties -- no other way to parse custom HTML strings from the user
    tempDiv.innerHTML = (template || '').trim();
    return tempDiv.firstChild;
}
exports._loadTemplate = _loadTemplate;
function _ensureDomOrder(eContainer, eChild, eChildBefore) {
    // if already in right order, do nothing
    if (eChildBefore && eChildBefore.nextSibling === eChild) {
        return;
    }
    if (!eContainer.firstChild) {
        eContainer.appendChild(eChild);
    }
    else if (eChildBefore) {
        if (eChildBefore.nextSibling) {
            // insert between the eRowBefore and the row after it
            eContainer.insertBefore(eChild, eChildBefore.nextSibling);
        }
        else {
            // if nextSibling is missing, means other row is at end, so just append new row at the end
            eContainer.appendChild(eChild);
        }
    }
    else if (eContainer.firstChild && eContainer.firstChild !== eChild) {
        // otherwise put at start
        // insert it at the first location
        eContainer.insertAdjacentElement('afterbegin', eChild);
    }
}
exports._ensureDomOrder = _ensureDomOrder;
function _setDomChildOrder(eContainer, orderedChildren) {
    for (let i = 0; i < orderedChildren.length; i++) {
        const correctCellAtIndex = orderedChildren[i];
        const actualCellAtIndex = eContainer.children[i];
        if (actualCellAtIndex !== correctCellAtIndex) {
            eContainer.insertBefore(correctCellAtIndex, actualCellAtIndex);
        }
    }
}
exports._setDomChildOrder = _setDomChildOrder;
function _insertWithDomOrder(eContainer, eToInsert, eChildBefore) {
    if (eChildBefore) {
        // if previous element exists, just slot in after the previous element
        eChildBefore.insertAdjacentElement('afterend', eToInsert);
    }
    else {
        if (eContainer.firstChild) {
            // insert it at the first location
            eContainer.insertAdjacentElement('afterbegin', eToInsert);
        }
        else {
            // otherwise eContainer is empty, so just append it
            eContainer.appendChild(eToInsert);
        }
    }
}
exports._insertWithDomOrder = _insertWithDomOrder;
/**
 * Converts a camelCase string into hyphenated string
 * @param {string} camelCase
 * @returns {string}
 */
function _camelCaseToHyphenated(camelCase) {
    return camelCase.replace(/[A-Z]/g, (s) => `-${s.toLocaleLowerCase()}`);
}
function _addStylesToElement(eElement, styles) {
    if (!styles) {
        return;
    }
    for (const key of Object.keys(styles)) {
        const value = styles[key];
        if (!key || !key.length || value == null) {
            continue;
        }
        // changes the key from camelCase into a hyphenated-string
        const parsedKey = _camelCaseToHyphenated(key);
        const valueAsString = value.toString();
        const parsedValue = valueAsString.replace(/\s*!important/g, '');
        const priority = parsedValue.length != valueAsString.length ? 'important' : undefined;
        eElement.style.setProperty(parsedKey, parsedValue, priority);
    }
}
exports._addStylesToElement = _addStylesToElement;
function _isElementOverflowingCallback(getElement) {
    return () => {
        const element = getElement();
        if (!element) {
            // defaults to true
            return true;
        }
        return _isHorizontalScrollShowing(element);
    };
}
exports._isElementOverflowingCallback = _isElementOverflowingCallback;
function _isHorizontalScrollShowing(element) {
    return element.clientWidth < element.scrollWidth;
}
exports._isHorizontalScrollShowing = _isHorizontalScrollShowing;
function _isVerticalScrollShowing(element) {
    return element.clientHeight < element.scrollHeight;
}
exports._isVerticalScrollShowing = _isVerticalScrollShowing;
function _setElementWidth(element, width) {
    if (width === 'flex') {
        element.style.removeProperty('width');
        element.style.removeProperty('minWidth');
        element.style.removeProperty('maxWidth');
        element.style.flex = '1 1 auto';
    }
    else {
        _setFixedWidth(element, width);
    }
}
exports._setElementWidth = _setElementWidth;
function _setFixedWidth(element, width) {
    width = _formatSize(width);
    element.style.width = width;
    element.style.maxWidth = width;
    element.style.minWidth = width;
}
exports._setFixedWidth = _setFixedWidth;
function _setFixedHeight(element, height) {
    height = _formatSize(height);
    element.style.height = height;
    element.style.maxHeight = height;
    element.style.minHeight = height;
}
exports._setFixedHeight = _setFixedHeight;
function _formatSize(size) {
    return typeof size === 'number' ? `${size}px` : size;
}
exports._formatSize = _formatSize;
function _isNodeOrElement(o) {
    return o instanceof Node || o instanceof HTMLElement;
}
exports._isNodeOrElement = _isNodeOrElement;
function _addOrRemoveAttribute(element, name, value) {
    if (value == null || value === '') {
        element.removeAttribute(name);
    }
    else {
        element.setAttribute(name, value.toString());
    }
}
exports._addOrRemoveAttribute = _addOrRemoveAttribute;
function _observeResize(beans, element, callback) {
    const win = (0, gridOptionsUtils_1._getWindow)(beans);
    const ResizeObserverImpl = win.ResizeObserver;
    const resizeObserver = ResizeObserverImpl ? new ResizeObserverImpl(callback) : null;
    resizeObserver?.observe(element);
    return () => resizeObserver?.disconnect();
}
exports._observeResize = _observeResize;
function _getTextSelectionRanges(beans) {
    const rootNode = (0, gridOptionsUtils_1._getRootNode)(beans);
    const selection = 'getSelection' in rootNode ? rootNode.getSelection() : null;
    const ranges = [];
    for (let i = 0; i < (selection?.rangeCount ?? 0); i++) {
        const range = selection?.getRangeAt(i);
        if (range) {
            ranges.push(range);
        }
    }
    return { selection, ranges };
}
/**
 * FF and Safari remove text selections when the focus changes. This is inconsistent with Chrome, whose behaviour
 * we prefer in this case. This utility preserves whatever text selection exists before the given action is taken.
 */
function _preserveRangesWhile(beans, fn) {
    const enableCellTextSelection = beans.gos.get('enableCellTextSelection');
    if (!enableCellTextSelection) {
        return fn();
    }
    if (!(0, browser_1._isBrowserFirefox)() && !(0, browser_1._isBrowserSafari)()) {
        return fn();
    }
    const { selection, ranges } = _getTextSelectionRanges(beans);
    fn();
    selection?.removeAllRanges();
    for (const range of ranges) {
        selection?.addRange(range);
    }
}
exports._preserveRangesWhile = _preserveRangesWhile;
function _requestAnimationFrame(beans, callback) {
    const win = (0, gridOptionsUtils_1._getWindow)(beans);
    if (win.requestAnimationFrame) {
        win.requestAnimationFrame(callback);
    }
    else if (win.webkitRequestAnimationFrame) {
        win.webkitRequestAnimationFrame(callback);
    }
    else {
        win.setTimeout(callback, 0);
    }
}
exports._requestAnimationFrame = _requestAnimationFrame;
/** AG Grid attribute used to automatically assign DOM Elements to class properties */
exports.DataRefAttribute = 'data-ref';
let whitespaceNode;
function getWhitespaceNode() {
    // Cloning is slightly faster than creating a new node each time
    whitespaceNode ?? (whitespaceNode = document.createTextNode(' '));
    return whitespaceNode.cloneNode();
}
function _createElement(params) {
    const { attrs, children, cls, ref, role, tag } = params;
    const element = document.createElement(tag);
    if (cls) {
        element.className = cls;
    }
    if (ref) {
        element.setAttribute(exports.DataRefAttribute, ref);
    }
    if (role) {
        element.setAttribute('role', role);
    }
    if (attrs) {
        for (const key of Object.keys(attrs)) {
            element.setAttribute(key, attrs[key]);
        }
    }
    if (children) {
        if (typeof children === 'string') {
            element.textContent = children;
        }
        else {
            let addFirstWhitespace = true;
            for (const child of children) {
                if (child) {
                    if (typeof child === 'string') {
                        element.appendChild(document.createTextNode(child));
                        addFirstWhitespace = false;
                    }
                    else if (typeof child === 'function') {
                        element.appendChild(child());
                    }
                    else {
                        // NOTE: To match the previous behaviour of when component templates where defined on multi line strings we need
                        // to add a whitespace node before and after each child element.
                        // Ideally we would not do this but this reduces the chance of breaking changes.
                        if (addFirstWhitespace) {
                            element.appendChild(getWhitespaceNode());
                            addFirstWhitespace = false;
                        }
                        element.append(_createElement(child));
                        element.appendChild(getWhitespaceNode());
                    }
                }
            }
        }
    }
    return element;
}
exports._createElement = _createElement;


/***/ }),

/***/ 92979:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPassiveStateForEvent = exports._addSafePassiveEventListener = exports._getEventPath = exports._createEventPath = exports._isElementInEventPath = exports._getCtrlForEventTarget = exports._isEventSupported = exports._isStopPropagationForAgGrid = exports._stopPropagationForAgGrid = void 0;
const gridOptionsUtils_1 = __webpack_require__(67274);
const AG_GRID_STOP_PROPAGATION = '__ag_Grid_Stop_Propagation';
const PASSIVE_EVENTS = ['touchstart', 'touchend', 'touchmove', 'touchcancel', 'scroll'];
const NON_PASSIVE_EVENTS = ['wheel'];
const supports = {};
/**
 * a user once raised an issue - they said that when you opened a popup (eg context menu)
 * and then clicked on a selection checkbox, the popup wasn't closed. this is because the
 * popup listens for clicks on the body, however ag-grid WAS stopping propagation on the
 * checkbox clicks (so the rows didn't pick them up as row selection selection clicks).
 * to get around this, we have a pattern to stop propagation for the purposes of AG Grid,
 * but we still let the event pass back to the body.
 * @param {Event} event
 */
function _stopPropagationForAgGrid(event) {
    event[AG_GRID_STOP_PROPAGATION] = true;
}
exports._stopPropagationForAgGrid = _stopPropagationForAgGrid;
function _isStopPropagationForAgGrid(event) {
    return event[AG_GRID_STOP_PROPAGATION] === true;
}
exports._isStopPropagationForAgGrid = _isStopPropagationForAgGrid;
exports._isEventSupported = (() => {
    const tags = {
        select: 'input',
        change: 'input',
        submit: 'form',
        reset: 'form',
        error: 'img',
        load: 'img',
        abort: 'img',
    };
    const eventChecker = (eventName) => {
        if (typeof supports[eventName] === 'boolean') {
            return supports[eventName];
        }
        const el = document.createElement(tags[eventName] || 'div');
        eventName = 'on' + eventName;
        return (supports[eventName] = eventName in el);
    };
    return eventChecker;
})();
function _getCtrlForEventTarget(gos, eventTarget, type) {
    let sourceElement = eventTarget;
    while (sourceElement) {
        const renderedComp = (0, gridOptionsUtils_1._getDomData)(gos, sourceElement, type);
        if (renderedComp) {
            return renderedComp;
        }
        sourceElement = sourceElement.parentElement;
    }
    return null;
}
exports._getCtrlForEventTarget = _getCtrlForEventTarget;
function _isElementInEventPath(element, event) {
    if (!event || !element) {
        return false;
    }
    return _getEventPath(event).indexOf(element) >= 0;
}
exports._isElementInEventPath = _isElementInEventPath;
function _createEventPath(event) {
    const res = [];
    let pointer = event.target;
    while (pointer) {
        res.push(pointer);
        pointer = pointer.parentElement;
    }
    return res;
}
exports._createEventPath = _createEventPath;
/**
 * Gets the path for a browser Event or from the target on an AG Grid Event
 * https://developer.mozilla.org/en-US/docs/Web/API/Event
 * @param {Event| { target: EventTarget }} event
 * @returns {EventTarget[]}
 */
function _getEventPath(event) {
    // This can be called with either a browser event or an AG Grid Event that has a target property.
    const eventNoType = event;
    if (eventNoType.path) {
        return eventNoType.path;
    }
    if (eventNoType.composedPath) {
        return eventNoType.composedPath();
    }
    // If this is an AG Grid event build the path ourselves
    return _createEventPath(eventNoType);
}
exports._getEventPath = _getEventPath;
function _addSafePassiveEventListener(frameworkOverrides, eElement, event, listener) {
    const passive = (0, exports.getPassiveStateForEvent)(event);
    let options;
    if (passive != null) {
        options = { passive };
    }
    // this check is here for certain scenarios where I believe the user must be destroying
    // the grid somehow but continuing for it to be used
    if (frameworkOverrides && frameworkOverrides.addEventListener) {
        frameworkOverrides.addEventListener(eElement, event, listener, options);
    }
}
exports._addSafePassiveEventListener = _addSafePassiveEventListener;
const getPassiveStateForEvent = (event) => {
    const isPassive = PASSIVE_EVENTS.includes(event);
    const isNonPassive = NON_PASSIVE_EVENTS.includes(event);
    if (isPassive) {
        return true;
    }
    if (isNonPassive) {
        return false;
    }
};
exports.getPassiveStateForEvent = getPassiveStateForEvent;


/***/ }),

/***/ 82331:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._focusNextGridCoreContainer = exports._isCellFocusSuppressed = exports._isHeaderFocusSuppressed = exports._focusGridInnerElement = exports._findTabbableParent = exports._findNextFocusableElement = exports._focusInto = exports._findFocusableElements = exports._addFocusableContainerListener = exports._isKeyboardMode = exports._registerKeyboardFocusEvents = void 0;
const keyCode_1 = __webpack_require__(39853);
const gridOptionsUtils_1 = __webpack_require__(67274);
const array_1 = __webpack_require__(31502);
const browser_1 = __webpack_require__(98667);
const dom_1 = __webpack_require__(33507);
let keyboardModeActive = false;
let instanceCount = 0;
function addKeyboardModeEvents(doc) {
    if (instanceCount > 0) {
        return;
    }
    doc.addEventListener('keydown', toggleKeyboardMode);
    doc.addEventListener('mousedown', toggleKeyboardMode);
}
function removeKeyboardModeEvents(doc) {
    if (instanceCount > 0)
        return;
    doc.removeEventListener('keydown', toggleKeyboardMode);
    doc.removeEventListener('mousedown', toggleKeyboardMode);
}
function toggleKeyboardMode(event) {
    const isKeyboardActive = keyboardModeActive;
    const isKeyboardEvent = event.type === 'keydown';
    if (isKeyboardEvent) {
        // the following keys should not toggle keyboard mode.
        if (event.ctrlKey || event.metaKey || event.altKey) {
            return;
        }
    }
    if (isKeyboardActive === isKeyboardEvent) {
        return;
    }
    keyboardModeActive = isKeyboardEvent;
}
function _registerKeyboardFocusEvents(beans) {
    const eDocument = (0, gridOptionsUtils_1._getDocument)(beans);
    addKeyboardModeEvents(eDocument);
    instanceCount++;
    return () => {
        instanceCount--;
        removeKeyboardModeEvents(eDocument);
    };
}
exports._registerKeyboardFocusEvents = _registerKeyboardFocusEvents;
function _isKeyboardMode() {
    return keyboardModeActive;
}
exports._isKeyboardMode = _isKeyboardMode;
function _addFocusableContainerListener(beans, comp, eGui) {
    comp.addManagedElementListeners(eGui, {
        keydown: (e) => {
            if (!e.defaultPrevented && e.key === keyCode_1.KeyCode.TAB) {
                const backwards = e.shiftKey;
                if (!_findNextFocusableElement(beans, eGui, false, backwards)) {
                    if (_focusNextGridCoreContainer(beans, backwards)) {
                        e.preventDefault();
                    }
                }
            }
        },
    });
}
exports._addFocusableContainerListener = _addFocusableContainerListener;
function _findFocusableElements(rootNode, exclude, onlyUnmanaged = false) {
    const focusableString = dom_1.FOCUSABLE_SELECTOR;
    let excludeString = dom_1.FOCUSABLE_EXCLUDE;
    if (exclude) {
        excludeString += ', ' + exclude;
    }
    if (onlyUnmanaged) {
        excludeString += ', [tabindex="-1"]';
    }
    const nodes = Array.prototype.slice
        .apply(rootNode.querySelectorAll(focusableString))
        .filter((node) => {
        return (0, dom_1._isVisible)(node);
    });
    const excludeNodes = Array.prototype.slice.apply(rootNode.querySelectorAll(excludeString));
    if (!excludeNodes.length) {
        return nodes;
    }
    const diff = (a, b) => a.filter((element) => b.indexOf(element) === -1);
    return diff(nodes, excludeNodes);
}
exports._findFocusableElements = _findFocusableElements;
function _focusInto(rootNode, up = false, onlyUnmanaged = false, excludeTabGuards = false) {
    const focusableElements = _findFocusableElements(rootNode, excludeTabGuards ? '.ag-tab-guard' : null, onlyUnmanaged);
    const toFocus = up ? (0, array_1._last)(focusableElements) : focusableElements[0];
    if (toFocus) {
        toFocus.focus({ preventScroll: true });
        return true;
    }
    return false;
}
exports._focusInto = _focusInto;
function _findNextFocusableElement(beans, rootNode, onlyManaged, backwards) {
    const focusable = _findFocusableElements(rootNode, onlyManaged ? ':not([tabindex="-1"])' : null);
    const activeEl = (0, gridOptionsUtils_1._getActiveDomElement)(beans);
    let currentIndex;
    if (onlyManaged) {
        currentIndex = focusable.findIndex((el) => el.contains(activeEl));
    }
    else {
        currentIndex = focusable.indexOf(activeEl);
    }
    const nextIndex = currentIndex + (backwards ? -1 : 1);
    if (nextIndex < 0 || nextIndex >= focusable.length) {
        return null;
    }
    return focusable[nextIndex];
}
exports._findNextFocusableElement = _findNextFocusableElement;
function _findTabbableParent(node, limit = 5) {
    let counter = 0;
    while (node && (0, browser_1._getTabIndex)(node) === null && ++counter <= limit) {
        node = node.parentElement;
    }
    if ((0, browser_1._getTabIndex)(node) === null) {
        return null;
    }
    return node;
}
exports._findTabbableParent = _findTabbableParent;
function _focusGridInnerElement(beans, fromBottom) {
    return beans.ctrlsSvc.get('gridCtrl').focusInnerElement(fromBottom);
}
exports._focusGridInnerElement = _focusGridInnerElement;
function _isHeaderFocusSuppressed(beans) {
    return beans.gos.get('suppressHeaderFocus') || !!beans.overlays?.isExclusive();
}
exports._isHeaderFocusSuppressed = _isHeaderFocusSuppressed;
function _isCellFocusSuppressed(beans) {
    return beans.gos.get('suppressCellFocus') || !!beans.overlays?.isExclusive();
}
exports._isCellFocusSuppressed = _isCellFocusSuppressed;
function _focusNextGridCoreContainer(beans, backwards, forceOut = false) {
    const gridCtrl = beans.ctrlsSvc.get('gridCtrl');
    if (!forceOut && gridCtrl.focusNextInnerContainer(backwards)) {
        return true;
    }
    if (forceOut || (!backwards && !gridCtrl.isDetailGrid())) {
        gridCtrl.forceFocusOutOfContainer(backwards);
    }
    return false;
}
exports._focusNextGridCoreContainer = _focusNextGridCoreContainer;


/***/ }),

/***/ 92043:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._waitUntil = exports._throttle = exports._debounce = exports._batchCall = exports._errorOnce = exports._warnOnce = exports._logIfDebug = exports._doOnce = void 0;
const dom_1 = __webpack_require__(33507);
const doOnceFlags = {};
/**
 * If the key was passed before, then doesn't execute the func
 * @param {Function} func
 * @param {string} key
 */
function _doOnce(func, key) {
    if (doOnceFlags[key]) {
        return;
    }
    func();
    doOnceFlags[key] = true;
}
exports._doOnce = _doOnce;
function _logIfDebug(gos, message, ...args) {
    if (gos.get('debug')) {
        // eslint-disable-next-line no-console
        console.log('AG Grid: ' + message, ...args);
    }
}
exports._logIfDebug = _logIfDebug;
function _warnOnce(msg, ...args) {
    // eslint-disable-next-line no-console
    _doOnce(() => console.warn('AG Grid: ' + msg, ...args), msg + args?.join(''));
}
exports._warnOnce = _warnOnce;
function _errorOnce(msg, ...args) {
    // eslint-disable-next-line no-console
    _doOnce(() => console.error('AG Grid: ' + msg, ...args), msg + args?.join(''));
}
exports._errorOnce = _errorOnce;
const batchedCallsSetTimeout = {
    pending: false,
    funcs: [],
};
const batchedCallsRaf = {
    pending: false,
    funcs: [],
};
function _batchCall(func, mode = 'setTimeout', beans) {
    const batch = mode === 'raf' ? batchedCallsRaf : batchedCallsSetTimeout;
    batch.funcs.push(func);
    if (batch.pending) {
        return;
    }
    batch.pending = true;
    const runBatch = () => {
        const funcsCopy = batch.funcs.slice();
        batch.funcs.length = 0;
        batch.pending = false;
        funcsCopy.forEach((func) => func());
    };
    if (mode === 'raf') {
        (0, dom_1._requestAnimationFrame)(beans, runBatch);
    }
    else {
        window.setTimeout(runBatch, 0);
    }
}
exports._batchCall = _batchCall;
/**
 * Creates a debounced function a function, and attach it to a bean for lifecycle
 * @param {Function} func The function to be debounced
 * @param {number} delay The time in ms to debounce
 * @returns {Function} The debounced function
 */
function _debounce(bean, func, delay) {
    let timeout;
    // Calling debounce returns a new anonymous function
    return function (...args) {
        //@ts-expect-error no implicit this
        const context = this;
        window.clearTimeout(timeout);
        // Set the new timeout
        timeout = window.setTimeout(function () {
            // at the moment we just check if the bean is still alive, in the future the bean stub should
            // another option is to manage a list of active timers and clear them when the bean is destroyed.
            if (bean.isAlive()) {
                func.apply(context, args);
            }
        }, delay);
    };
}
exports._debounce = _debounce;
/**
 * @param {Function} func The function to be throttled
 * @param {number} wait The time in ms to throttle
 * @returns {Function} The throttled function
 */
function _throttle(func, wait) {
    let previousCall = 0;
    return function (...args) {
        //@ts-expect-error no implicit this
        const context = this;
        const currentCall = Date.now();
        if (currentCall - previousCall < wait) {
            return;
        }
        previousCall = currentCall;
        func.apply(context, args);
    };
}
exports._throttle = _throttle;
function _waitUntil(condition, callback, timeout = 100, timeoutMessage) {
    const timeStamp = Date.now();
    let interval = null;
    let executed = false;
    const internalCallback = () => {
        const reachedTimeout = Date.now() - timeStamp > timeout;
        if (condition() || reachedTimeout) {
            callback();
            executed = true;
            if (interval != null) {
                window.clearInterval(interval);
                interval = null;
            }
            if (reachedTimeout && timeoutMessage) {
                _warnOnce(timeoutMessage);
            }
        }
    };
    internalCallback();
    if (!executed) {
        interval = window.setInterval(internalCallback, 10);
    }
}
exports._waitUntil = _waitUntil;


/***/ }),

/***/ 21298:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._fuzzySuggestions = void 0;
/**
 *
 * @param {String} inputValue The value to be compared against a list of strings
 * @param allSuggestions The list of strings to be compared against
 */
function _fuzzySuggestions(params) {
    const { inputValue, allSuggestions, hideIrrelevant, filterByPercentageOfBestMatch } = params;
    let thisSuggestions = allSuggestions.map((text, idx) => ({
        value: text,
        relevance: hybridFuzzySearch(inputValue, text),
        idx,
    }));
    thisSuggestions.sort((a, b) => b.relevance - a.relevance);
    if (hideIrrelevant) {
        thisSuggestions = thisSuggestions.filter((suggestion) => suggestion.relevance !== 0);
    }
    if (thisSuggestions.length > 0 && filterByPercentageOfBestMatch && filterByPercentageOfBestMatch > 0) {
        const bestMatch = thisSuggestions[0].relevance;
        const limit = bestMatch * filterByPercentageOfBestMatch;
        thisSuggestions = thisSuggestions.filter((suggestion) => limit - suggestion.relevance < 0);
    }
    const values = [];
    const indices = [];
    for (const suggestion of thisSuggestions) {
        values.push(suggestion.value);
        indices.push(suggestion.idx);
    }
    return { values, indices };
}
exports._fuzzySuggestions = _fuzzySuggestions;
/**
 * This uses a combination of matchAny and Levenshtein Distance
 * to match strings but also account for typos.
 */
function hybridFuzzySearch(str1, str2) {
    if (str1 === str2) {
        return 1000; // Exact match, highest possible score
    }
    const len1 = str1.length;
    const len2 = str2.length;
    if (len1 === 0 || len2 === 0) {
        return 0; // No match at all
    }
    const str1Lower = str1.toLocaleLowerCase();
    const str2Lower = str2.toLocaleLowerCase();
    // Direct substring match gets a higher reward
    const str2PositionInStr1 = str2Lower.indexOf(str1Lower);
    if (str2PositionInStr1 !== -1) {
        return 980 - str2PositionInStr1 * 2;
    }
    // If there are no common characters, return 0 (no match)
    const commonChars = [...str1Lower].filter((char) => str2Lower.includes(char));
    if (commonChars.length === 0) {
        return 0;
    }
    let previousRow = Array.from({ length: len2 + 1 }, (_, i) => i);
    for (let i = 0; i < len1; i++) {
        const currentRow = [i + 1];
        for (let j = 0; j < len2; j++) {
            const insertions = previousRow[j + 1] + 1;
            const deletions = currentRow[j] + 1;
            let substitutions = previousRow[j] + (str1[i] !== str2[j] ? 1 : 0);
            // Favour matches that appear earlier in the string
            if (len2 > 10 && j > len2 / 2) {
                substitutions += 1;
            }
            // Higher weight for sequential matches
            if (i > 0 && j > 0 && str1[i - 1] === str2[j - 1]) {
                substitutions -= 4;
            }
            currentRow.push(Math.min(insertions, deletions, substitutions));
        }
        previousRow = currentRow;
    }
    const distance = Math.round(previousRow[len2]);
    // Convert distance into a similarity score (higher is better)
    const score = Math.max(1, 1000 - distance * 30);
    return Math.max(1, score);
}


/***/ }),

/***/ 34422:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._defaultComparator = exports._jsonEquals = exports._toStringOrNull = exports._missing = exports._exists = exports._makeNull = void 0;
/**
 * If value is undefined, null or blank, returns null, otherwise returns the value
 * @param {T} value
 * @returns {T | null}
 */
function _makeNull(value) {
    if (value == null || value === '') {
        return null;
    }
    return value;
}
exports._makeNull = _makeNull;
function _exists(value) {
    return value != null && value !== '';
}
exports._exists = _exists;
function _missing(value) {
    return !_exists(value);
}
exports._missing = _missing;
function _toStringOrNull(value) {
    return value != null && typeof value.toString === 'function' ? value.toString() : null;
}
exports._toStringOrNull = _toStringOrNull;
function _jsonEquals(val1, val2) {
    const val1Json = val1 ? JSON.stringify(val1) : null;
    const val2Json = val2 ? JSON.stringify(val2) : null;
    return val1Json === val2Json;
}
exports._jsonEquals = _jsonEquals;
function _defaultComparator(valueA, valueB, accentedCompare = false) {
    const valueAMissing = valueA == null;
    const valueBMissing = valueB == null;
    // this is for aggregations sum and avg, where the result can be a number that is wrapped.
    // if we didn't do this, then the toString() value would be used, which would result in
    // the strings getting used instead of the numbers.
    if (valueA && valueA.toNumber) {
        valueA = valueA.toNumber();
    }
    if (valueB && valueB.toNumber) {
        valueB = valueB.toNumber();
    }
    if (valueAMissing && valueBMissing) {
        return 0;
    }
    if (valueAMissing) {
        return -1;
    }
    if (valueBMissing) {
        return 1;
    }
    function doQuickCompare(a, b) {
        return a > b ? 1 : a < b ? -1 : 0;
    }
    if (typeof valueA !== 'string') {
        return doQuickCompare(valueA, valueB);
    }
    if (!accentedCompare) {
        return doQuickCompare(valueA, valueB);
    }
    try {
        // using local compare also allows chinese comparisons
        return valueA.localeCompare(valueB);
    }
    catch (e) {
        // if something wrong with localeCompare, eg not supported
        // by browser, then just continue with the quick one
        return doQuickCompare(valueA, valueB);
    }
}
exports._defaultComparator = _defaultComparator;


/***/ }),

/***/ 59970:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._createIconNoSpan = exports._createIcon = void 0;
const logging_1 = __webpack_require__(47764);
const dom_1 = __webpack_require__(33507);
/**
 * If icon provided, use this (either a string, or a function callback).
 * if not, then use the default icon from the theme.
 * Technically `iconName` could be any string, if using user-provided icons map.
 * However, in most cases we're providing a specific icon name, so better to have type-checking.
 */
function _createIcon(iconName, beans, column) {
    const iconContents = _createIconNoSpan(iconName, beans, column);
    if (iconContents) {
        const { className } = iconContents;
        if ((typeof className === 'string' && className.indexOf('ag-icon') > -1) ||
            (typeof className === 'object' && className['ag-icon'])) {
            return iconContents;
        }
    }
    const eResult = (0, dom_1._createElement)({ tag: 'span' });
    eResult.appendChild(iconContents);
    return eResult;
}
exports._createIcon = _createIcon;
/**
 * Technically `iconName` could be any string, if using user-provided icons map.
 * However, in most cases we're providing a specific icon name, so better to have type-checking.
 */
function _createIconNoSpan(iconName, beans, column) {
    let userProvidedIcon = null;
    if (iconName === 'smallDown') {
        (0, logging_1._warn)(262);
    }
    else if (iconName === 'smallLeft') {
        (0, logging_1._warn)(263);
    }
    else if (iconName === 'smallRight') {
        (0, logging_1._warn)(264);
    }
    // check col for icon first
    const icons = column && column.getColDef().icons;
    if (icons) {
        userProvidedIcon = icons[iconName];
    }
    // if not in col, try grid options
    if (beans.gos && !userProvidedIcon) {
        const optionsIcons = beans.gos.get('icons');
        if (optionsIcons) {
            userProvidedIcon = optionsIcons[iconName];
        }
    }
    // now if user provided, use it
    if (userProvidedIcon) {
        let rendererResult;
        if (typeof userProvidedIcon === 'function') {
            rendererResult = userProvidedIcon();
        }
        else if (typeof userProvidedIcon === 'string') {
            rendererResult = userProvidedIcon;
        }
        else {
            (0, logging_1._warn)(38, { iconName });
            return undefined;
        }
        if (typeof rendererResult === 'string') {
            return (0, dom_1._loadTemplate)(rendererResult);
        }
        if ((0, dom_1._isNodeOrElement)(rendererResult)) {
            return rendererResult;
        }
        (0, logging_1._warn)(133, { iconName });
        return undefined;
    }
    else {
        const iconValue = beans.registry.getIcon(iconName);
        if (!iconValue) {
            beans.validation?.validateIcon(iconName);
        }
        return (0, dom_1._createElement)({
            tag: 'span',
            cls: `ag-icon ag-icon-${iconValue ?? iconName}`,
            role: 'presentation',
            attrs: { unselectable: 'on' },
        });
    }
}
exports._createIconNoSpan = _createIconNoSpan;


/***/ }),

/***/ 16466:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._isUserSuppressingKeyboardEvent = exports._isEventFromPrintableCharacter = void 0;
const gridOptionsUtils_1 = __webpack_require__(67274);
function _isEventFromPrintableCharacter(event) {
    // no allowed printable chars have alt or ctrl key combinations
    if (event.altKey || event.ctrlKey || event.metaKey) {
        return false;
    }
    // if key is length 1, eg if it is 'a' for the a key, or '2' for the '2' key.
    // non-printable characters have names, eg 'Enter' or 'Backspace'.
    const printableCharacter = event.key?.length === 1;
    return printableCharacter;
}
exports._isEventFromPrintableCharacter = _isEventFromPrintableCharacter;
/**
 * Allows user to tell the grid to skip specific keyboard events
 * @param {GridOptionsService} gos
 * @param {KeyboardEvent} keyboardEvent
 * @param {IRowNode} rowNode
 * @param {Column} column
 * @param {boolean} editing
 * @returns {boolean}
 */
function _isUserSuppressingKeyboardEvent(gos, keyboardEvent, rowNode, column, editing) {
    const colDefFunc = column ? column.getColDef().suppressKeyboardEvent : undefined;
    // if no callbacks provided by user, then do nothing
    if (!colDefFunc) {
        return false;
    }
    const params = (0, gridOptionsUtils_1._addGridCommonParams)(gos, {
        event: keyboardEvent,
        editing,
        column,
        node: rowNode,
        data: rowNode.data,
        colDef: column.getColDef(),
    });
    // colDef get first preference on suppressing events
    if (colDefFunc) {
        const colDefFuncResult = colDefFunc(params);
        // if colDef func suppressed, then return now, no need to call gridOption func
        if (colDefFuncResult) {
            return true;
        }
    }
    // otherwise return false, don't suppress, as colDef didn't suppress and no func on gridOptions
    return false;
}
exports._isUserSuppressingKeyboardEvent = _isUserSuppressingKeyboardEvent;


/***/ }),

/***/ 3276:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._interpretAsRightClick = exports._areEventsNear = void 0;
/**
 * `True` if the event is close to the original event by X pixels either vertically or horizontally.
 * we only start dragging after X pixels so this allows us to know if we should start dragging yet.
 * @param {MouseEvent | TouchEvent} e1
 * @param {MouseEvent | TouchEvent} e2
 * @param {number} pixelCount
 * @returns {boolean}
 */
function _areEventsNear(e1, e2, pixelCount) {
    // by default, we wait 4 pixels before starting the drag
    if (pixelCount === 0) {
        return false;
    }
    const diffX = Math.abs(e1.clientX - e2.clientX);
    const diffY = Math.abs(e1.clientY - e2.clientY);
    return Math.max(diffX, diffY) <= pixelCount;
}
exports._areEventsNear = _areEventsNear;
function _interpretAsRightClick({ gos }, event) {
    return event.button === 2 || (event.ctrlKey && gos.get('allowContextMenuWithControlKey'));
}
exports._interpretAsRightClick = _interpretAsRightClick;


/***/ }),

/***/ 27698:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._formatNumberCommas = void 0;
/**
 * the native method number.toLocaleString(undefined, {minimumFractionDigits: 0})
 * puts in decimal places in IE, so we use this method instead
 * from: http://blog.tompawlak.org/number-currency-formatting-javascript
 * @param {number} value
 * @returns {string}
 */
function _formatNumberCommas(value, getLocaleTextFunc) {
    if (typeof value !== 'number') {
        return '';
    }
    const localeTextFunc = getLocaleTextFunc();
    const thousandSeparator = localeTextFunc('thousandSeparator', ',');
    const decimalSeparator = localeTextFunc('decimalSeparator', '.');
    return value
        .toString()
        .replace('.', decimalSeparator)
        .replace(/(\d)(?=(\d{3})+(?!\d))/g, `$1${thousandSeparator}`);
}
exports._formatNumberCommas = _formatNumberCommas;


/***/ }),

/***/ 6996:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._getValueUsingField = exports._mergeDeep = exports.SKIP_JS_BUILTINS = void 0;
const generic_1 = __webpack_require__(34422);
// Prevents the risk of prototype pollution
exports.SKIP_JS_BUILTINS = new Set(['__proto__', 'constructor', 'prototype']);
function _iterateObject(object, callback) {
    if (object == null) {
        return;
    }
    if (Array.isArray(object)) {
        for (let i = 0; i < object.length; i++) {
            callback(i.toString(), object[i]);
        }
        return;
    }
    for (const key of Object.keys(object)) {
        callback(key, object[key]);
    }
}
function _mergeDeep(dest, source, copyUndefined = true, makeCopyOfSimpleObjects = false) {
    if (!(0, generic_1._exists)(source)) {
        return;
    }
    _iterateObject(source, (key, sourceValue) => {
        if (exports.SKIP_JS_BUILTINS.has(key)) {
            return;
        }
        let destValue = dest[key];
        if (destValue === sourceValue) {
            return;
        }
        // when creating params, we don't want to just copy objects over. otherwise merging ColDefs (eg DefaultColDef
        // and Column Types) would result in params getting shared between objects.
        // by putting an empty value into destValue first, it means we end up copying over values from
        // the source object, rather than just copying in the source object in it's entirety.
        if (makeCopyOfSimpleObjects) {
            const objectIsDueToBeCopied = destValue == null && sourceValue != null;
            if (objectIsDueToBeCopied) {
                // 'simple object' means a bunch of key/value pairs, eg {filter: 'myFilter'}, as opposed
                // to a Class instance (such as api instance).
                const doNotCopyAsSourceIsSimpleObject = typeof sourceValue === 'object' && sourceValue.constructor === Object;
                if (doNotCopyAsSourceIsSimpleObject) {
                    destValue = {};
                    dest[key] = destValue;
                }
            }
        }
        if (_isNonNullObject(sourceValue) && _isNonNullObject(destValue) && !Array.isArray(destValue)) {
            _mergeDeep(destValue, sourceValue, copyUndefined, makeCopyOfSimpleObjects);
        }
        else if (copyUndefined || sourceValue !== undefined) {
            dest[key] = sourceValue;
        }
    });
}
exports._mergeDeep = _mergeDeep;
function _getValueUsingField(data, field, fieldContainsDots) {
    if (!field || !data) {
        return;
    }
    // if no '.', then it's not a deep value
    if (!fieldContainsDots) {
        return data[field];
    }
    // otherwise it is a deep value, so need to dig for it
    const fields = field.split('.');
    let currentObject = data;
    for (let i = 0; i < fields.length; i++) {
        if (currentObject == null) {
            return undefined;
        }
        currentObject = currentObject[fields[i]];
    }
    return currentObject;
}
exports._getValueUsingField = _getValueUsingField;
function _isNonNullObject(value) {
    return typeof value === 'object' && value !== null;
}


/***/ }),

/***/ 57990:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgPromise = exports._isPromise = void 0;
function _isPromise(fn) {
    if (typeof fn.then === 'function') {
        return true;
    }
    return false;
}
exports._isPromise = _isPromise;
var AgPromiseStatus;
(function (AgPromiseStatus) {
    AgPromiseStatus[AgPromiseStatus["IN_PROGRESS"] = 0] = "IN_PROGRESS";
    AgPromiseStatus[AgPromiseStatus["RESOLVED"] = 1] = "RESOLVED";
})(AgPromiseStatus || (AgPromiseStatus = {}));
class AgPromise {
    static all(promises) {
        return promises.length
            ? new AgPromise((resolve) => {
                let remainingToResolve = promises.length;
                const combinedValues = new Array(remainingToResolve);
                promises.forEach((promise, index) => {
                    promise.then((value) => {
                        combinedValues[index] = value;
                        remainingToResolve--;
                        if (remainingToResolve === 0) {
                            resolve(combinedValues);
                        }
                    });
                });
            })
            : AgPromise.resolve();
    }
    static resolve(value = null) {
        return new AgPromise((resolve) => resolve(value));
    }
    constructor(callback) {
        this.status = AgPromiseStatus.IN_PROGRESS;
        this.resolution = null;
        this.waiters = [];
        callback((value) => this.onDone(value), (params) => this.onReject(params));
    }
    then(func) {
        return new AgPromise((resolve) => {
            if (this.status === AgPromiseStatus.RESOLVED) {
                resolve(func(this.resolution));
            }
            else {
                this.waiters.push((value) => resolve(func(value)));
            }
        });
    }
    onDone(value) {
        this.status = AgPromiseStatus.RESOLVED;
        this.resolution = value;
        this.waiters.forEach((waiter) => waiter(value));
    }
    onReject(_) { }
}
exports.AgPromise = AgPromise;


/***/ }),

/***/ 24009:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._selectAllCells = void 0;
function _selectAllCells(beans) {
    const { pinnedRowModel, rowModel } = beans;
    const [isEmptyPinnedTop, isEmptyPinnedBottom] = [
        pinnedRowModel?.isEmpty('top') ?? true,
        pinnedRowModel?.isEmpty('bottom') ?? true,
    ];
    const floatingStart = isEmptyPinnedTop ? null : 'top';
    let floatingEnd;
    let rowEnd;
    if (isEmptyPinnedBottom) {
        floatingEnd = null;
        rowEnd = rowModel.getRowCount() - 1;
    }
    else {
        floatingEnd = 'bottom';
        rowEnd = pinnedRowModel?.getPinnedBottomRowCount() ?? 0 - 1;
    }
    const { visibleCols, rangeSvc } = beans;
    const allDisplayedColumns = visibleCols.allCols;
    if (!rangeSvc || !allDisplayedColumns?.length) {
        return;
    }
    rangeSvc.setCellRange({
        rowStartIndex: 0,
        rowStartPinned: floatingStart,
        rowEndIndex: rowEnd,
        rowEndPinned: floatingEnd,
    });
}
exports._selectAllCells = _selectAllCells;


/***/ }),

/***/ 37766:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._escapeString = exports._toString = void 0;
const reUnescapedHtml = /[&<>"']/g;
/**
 * HTML Escapes.
 */
const HTML_ESCAPES = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
};
/**
 * Calls toString() twice, in case value is an object, where user provides a toString() method.
 * The first call to toString() returns back something other than a string (eg a number to render)
 */
function _toString(toEscape) {
    return toEscape?.toString().toString() ?? null;
}
exports._toString = _toString;
function _escapeString(toEscape) {
    // in react we don't need to escape html characters, as it's done by the framework
    return _toString(toEscape)?.replace(reUnescapedHtml, (chr) => HTML_ESCAPES[chr]) ?? null;
}
exports._escapeString = _escapeString;


/***/ }),

/***/ 8179:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateApiFunction = void 0;
const function_1 = __webpack_require__(92043);
const clientSide = 'clientSide';
const serverSide = 'serverSide';
const infinite = 'infinite';
const functionRowModels = {
    onGroupExpandedOrCollapsed: [clientSide],
    refreshClientSideRowModel: [clientSide],
    isRowDataEmpty: [clientSide],
    forEachLeafNode: [clientSide],
    forEachNodeAfterFilter: [clientSide],
    forEachNodeAfterFilterAndSort: [clientSide],
    resetRowHeights: [clientSide],
    applyTransaction: [clientSide],
    applyTransactionAsync: [clientSide],
    flushAsyncTransactions: [clientSide],
    getBestCostNodeSelection: [clientSide],
    getServerSideSelectionState: [serverSide],
    setServerSideSelectionState: [serverSide],
    applyServerSideTransaction: [serverSide],
    applyServerSideTransactionAsync: [serverSide],
    applyServerSideRowData: [serverSide],
    retryServerSideLoads: [serverSide],
    flushServerSideAsyncTransactions: [serverSide],
    refreshServerSide: [serverSide],
    getServerSideGroupLevelState: [serverSide],
    refreshInfiniteCache: [infinite],
    purgeInfiniteCache: [infinite],
    getInfiniteRowCount: [infinite],
    isLastRowIndexKnown: [infinite, serverSide],
    expandAll: [clientSide, serverSide],
    collapseAll: [clientSide, serverSide],
    onRowHeightChanged: [clientSide, serverSide],
    setRowCount: [infinite, serverSide],
    getCacheBlockState: [infinite, serverSide],
};
const deprecatedFunctions = {
    showLoadingOverlay: {
        version: 'v32',
        message: '`showLoadingOverlay` is deprecated. Use the grid option "loading"=true instead or setGridOption("loading", true).',
    },
    clearRangeSelection: {
        version: 'v32.2',
        message: 'Use `clearCellSelection` instead.',
    },
    getInfiniteRowCount: {
        version: 'v32.2',
        old: 'getInfiniteRowCount()',
        new: 'getDisplayedRowCount()',
    },
    selectAllFiltered: {
        version: 'v33',
        old: 'selectAllFiltered()',
        new: 'selectAll("filtered")',
    },
    deselectAllFiltered: {
        version: 'v33',
        old: 'deselectAllFiltered()',
        new: 'deselectAll("filtered")',
    },
    selectAllOnCurrentPage: {
        version: 'v33',
        old: 'selectAllOnCurrentPage()',
        new: 'selectAll("currentPage")',
    },
    deselectAllOnCurrentPage: {
        version: 'v33',
        old: 'deselectAllOnCurrentPage()',
        new: 'deselectAll("currentPage")',
    },
};
function validateApiFunction(functionName, apiFunction, beans) {
    const deprecation = deprecatedFunctions[functionName];
    if (deprecation) {
        const { version, new: replacement, old, message } = deprecation;
        const apiMethod = old ?? functionName;
        return (...args) => {
            const replacementMessage = replacement ? `Please use ${replacement} instead. ` : '';
            (0, function_1._warnOnce)(`Since ${version} api.${apiMethod} is deprecated. ${replacementMessage}${message ?? ''}`);
            return apiFunction.apply(apiFunction, args);
        };
    }
    const rowModels = functionRowModels[functionName];
    if (rowModels) {
        return (...args) => {
            const rowModel = beans.rowModel.getType();
            if (!rowModels.includes(rowModel)) {
                (0, function_1._errorOnce)(`api.${functionName} can only be called when gridOptions.rowModelType is ${rowModels.join(' or ')}`);
                return undefined;
            }
            return apiFunction.apply(apiFunction, args);
        };
    }
    return apiFunction;
}
exports.validateApiFunction = validateApiFunction;


/***/ }),

/***/ 28732:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ENTERPRISE_MODULE_NAMES = void 0;
exports.ENTERPRISE_MODULE_NAMES = {
    AdvancedFilter: 1,
    AllEnterprise: 1,
    BatchEdit: 1,
    CellSelection: 1,
    Clipboard: 1,
    ColumnMenu: 1,
    ColumnsToolPanel: 1,
    ContextMenu: 1,
    ExcelExport: 1,
    FiltersToolPanel: 1,
    Find: 1,
    GridCharts: 1,
    IntegratedCharts: 1,
    GroupFilter: 1,
    MasterDetail: 1,
    Menu: 1,
    MultiFilter: 1,
    NewFiltersToolPanel: 1,
    Pivot: 1,
    RangeSelection: 1,
    RichSelect: 1,
    RowNumbers: 1,
    RowGrouping: 1,
    RowGroupingPanel: 1,
    ServerSideRowModelApi: 1,
    ServerSideRowModel: 1,
    SetFilter: 1,
    SideBar: 1,
    Sparklines: 1,
    StatusBar: 1,
    TreeData: 1,
    ViewportRowModel: 1,
};


/***/ }),

/***/ 15205:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MISSING_MODULE_REASONS = exports.getError = exports.AG_GRID_ERRORS = exports.missingRowModelTypeError = exports.moduleImportMsg = exports.NoModulesRegisteredError = void 0;
const fuzzyMatch_1 = __webpack_require__(21298);
const enterpriseModuleNames_1 = __webpack_require__(28732);
const logging_1 = __webpack_require__(47764);
const resolvableModuleNames_1 = __webpack_require__(80342);
const userCompValidations_1 = __webpack_require__(51389);
const NoModulesRegisteredError = () => `No AG Grid modules are registered! It is recommended to start with all Community features via the AllCommunityModule:
                    
    import { ModuleRegistry, AllCommunityModule } from 'ag-grid-community';
    
    ModuleRegistry.registerModules([ AllCommunityModule ]);
    `;
exports.NoModulesRegisteredError = NoModulesRegisteredError;
const moduleImportMsg = (moduleNames) => {
    const imports = moduleNames.map((moduleName) => `import { ${convertToUserModuleName(moduleName)} } from '${enterpriseModuleNames_1.ENTERPRISE_MODULE_NAMES[moduleName] ? 'ag-grid-enterprise' : 'ag-grid-community'}';`);
    const includeCharts = moduleNames.some((m) => m === 'IntegratedCharts' || m === 'Sparklines');
    if (includeCharts) {
        const chartImport = `import { AgChartsEnterpriseModule } from 'ag-charts-enterprise';`;
        imports.push(chartImport);
    }
    return `import { ModuleRegistry } from 'ag-grid-community'; \n${imports.join(' \n')} \n\nModuleRegistry.registerModules([ ${moduleNames.map((m) => convertToUserModuleName(m, true)).join(', ')} ]); \n\nFor more info see: ${logging_1.baseDocLink}/modules/`;
};
exports.moduleImportMsg = moduleImportMsg;
function convertToUserModuleName(moduleName, inModuleRegistration = false) {
    if (inModuleRegistration && (moduleName === 'IntegratedCharts' || moduleName === 'Sparklines')) {
        return `${moduleName}Module.with(AgChartsEnterpriseModule)`;
    }
    return `${moduleName}Module`;
}
function umdMissingModule(reasonOrId, moduleNames) {
    const chartModules = moduleNames.filter((m) => m === 'IntegratedCharts' || m === 'Sparklines');
    let message = '';
    const agChartsDynamic = globalThis?.agCharts;
    if (!agChartsDynamic && chartModules.length > 0) {
        message = `Unable to use ${reasonOrId} as either the ag-charts-community or ag-charts-enterprise script needs to be included alongside ag-grid-enterprise.\n`;
    }
    else if (moduleNames.some((m) => enterpriseModuleNames_1.ENTERPRISE_MODULE_NAMES[m])) {
        message =
            message + `Unable to use ${reasonOrId} as that requires the ag-grid-enterprise script to be included.\n`;
    }
    return message;
}
function missingRowModelTypeError({ moduleName, rowModelType, }) {
    return `To use the ${moduleName}Module you must set the gridOption "rowModelType='${rowModelType}'"`;
}
exports.missingRowModelTypeError = missingRowModelTypeError;
const missingModule = ({ reasonOrId, moduleName, gridScoped, gridId, rowModelType, additionalText, isUmd, }) => {
    const resolvedModuleNames = (0, resolvableModuleNames_1.resolveModuleNames)(moduleName, rowModelType);
    const reason = typeof reasonOrId === 'string' ? reasonOrId : exports.MISSING_MODULE_REASONS[reasonOrId];
    if (isUmd) {
        return umdMissingModule(reason, resolvedModuleNames);
    }
    const chartModules = resolvedModuleNames.filter((m) => m === 'IntegratedCharts' || m === 'Sparklines');
    const chartImportRequired = chartModules.length > 0
        ? `${chartModules.map((m) => convertToUserModuleName(m)).join()} must be initialised with an AG Charts module. One of 'AgChartsCommunityModule' / 'AgChartsEnterpriseModule'.`
        : '';
    const explanation = `Unable to use ${reason} as ${resolvedModuleNames.length > 1 ? 'one of ' + resolvedModuleNames.map((m) => convertToUserModuleName(m)).join(', ') : convertToUserModuleName(resolvedModuleNames[0])} is not registered${gridScoped ? ' for gridId: ' + gridId : ''}. ${chartImportRequired} Check if you have registered the module:\n`;
    return (`${explanation}
${(0, exports.moduleImportMsg)(resolvedModuleNames)}` + (additionalText ? ` \n\n${additionalText}` : ''));
};
const missingChartsWithModule = (gridModule) => {
    return `${gridModule} must be initialised with an AG Charts module. One of 'AgChartsCommunityModule' / 'AgChartsEnterpriseModule'.

import { AgChartsEnterpriseModule } from 'ag-charts-enterprise';
import { ModuleRegistry } from 'ag-grid-community';
import { ${gridModule} } from 'ag-grid-enterprise';
    
ModuleRegistry.registerModules([${gridModule}.with(AgChartsEnterpriseModule)]);
    `;
};
const clipboardApiError = (method) => `AG Grid: Unable to use the Clipboard API (navigator.clipboard.${method}()). ` +
    'The reason why it could not be used has been logged in the previous line. ' +
    "For this reason the grid has defaulted to using a workaround which doesn't perform as well. " +
    'Either fix why Clipboard API is blocked, OR stop this message from appearing by setting grid ' +
    'property suppressClipboardApi=true (which will default the grid to using the workaround rather than the API.';
/**
 * NOTES on setting console messages:
 * 1. The message is a function that returns either a string or an array of any type.
 * 2. Returning an array enables the console to log actual objects / numbers / booleans nicely as this will be spread to the underlying console call instead of being cast to a string.
 * 3. Each entry should be followed by as const so that the IDE hover shows the actual message to aid devs
 */
exports.AG_GRID_ERRORS = {
    1: () => '`rowData` must be an array',
    2: ({ nodeId }) => `Duplicate node id '${nodeId}' detected from getRowId callback, this could cause issues in your grid.`,
    3: () => 'Calling gridApi.resetRowHeights() makes no sense when using Auto Row Height.',
    4: ({ id }) => `Could not find row id=${id}, data item was not found for this id`,
    5: ({ data }) => [
        `Could not find data item as object was not found.`,
        data,
        ' Consider using getRowId to help the Grid find matching row data',
    ],
    6: () => `'groupHideOpenParents' only works when specifying specific columns for 'colDef.showRowGroup'`,
    7: () => 'Pivoting is not supported with aligned grids as it may produce different columns in each grid.',
    8: ({ key }) => `Unknown key for navigation ${key}`,
    9: ({ variable }) => `No value for ${variable?.cssName}. This usually means that the grid has been initialised before styles have been loaded. The default value of ${variable?.defaultValue} will be used and updated when styles load.`,
    10: ({ eventType }) => `As of v33, the '${eventType}' event is deprecated. Use the global 'modelUpdated' event to determine when row children have changed.`,
    11: () => 'No gridOptions provided to createGrid',
    12: ({ colKey }) => ['column ', colKey, ' not found'],
    13: () => 'Could not find rowIndex, this means tasks are being executed on a rowNode that has been removed from the grid.',
    14: ({ groupPrefix }) => `Row IDs cannot start with ${groupPrefix}, this is a reserved prefix for AG Grid's row grouping feature.`,
    15: ({ expression }) => ['value should be either a string or a function', expression],
    16: ({ expression, params, e }) => [
        'Processing of the expression failed',
        'Expression = ',
        expression,
        'Params = ',
        params,
        'Exception = ',
        e,
    ],
    17: () => 'you need either field or valueSetter set on colDef for editing to work',
    18: () => `alignedGrids contains an undefined option.`,
    19: () => `alignedGrids - No api found on the linked grid.`,
    20: () => `You may want to configure via a callback to avoid setup race conditions:
                     "alignedGrids: () => [linkedGrid]"`,
    21: () => 'pivoting is not supported with aligned grids. You can only use one of these features at a time in a grid.',
    22: ({ key }) => `${key} is an initial property and cannot be updated.`,
    23: () => 'The return of `getRowHeight` cannot be zero. If the intention is to hide rows, use a filter instead.',
    24: () => 'row height must be a number if not using standard row model',
    25: ({ id }) => [`The getRowId callback must return a string. The ID `, id, ` is being cast to a string.`],
    26: ({ fnName, preDestroyLink }) => {
        return `Grid API function ${fnName}() cannot be called as the grid has been destroyed.\n Either clear local references to the grid api, when it is destroyed, or check gridApi.isDestroyed() to avoid calling methods against a destroyed grid.\n To run logic when the grid is about to be destroyed use the gridPreDestroy event. See: ${preDestroyLink}`;
    },
    27: ({ fnName, module }) => `API function '${fnName}' not registered to module '${module}'`,
    28: () => 'setRowCount cannot be used while using row grouping.',
    29: () => 'tried to call sizeColumnsToFit() but the grid is coming back with zero width, maybe the grid is not visible yet on the screen?',
    30: ({ toIndex }) => [
        'tried to insert columns in invalid location, toIndex = ',
        toIndex,
        'remember that you should not count the moving columns when calculating the new index',
    ],
    31: () => 'infinite loop in resizeColumnSets',
    32: () => 'applyColumnState() - the state attribute should be an array, however an array was not found. Please provide an array of items (one for each col you want to change) for state.',
    33: () => 'stateItem.aggFunc must be a string. if using your own aggregation functions, register the functions first before using them in get/set state. This is because it is intended for the column state to be stored and retrieved as simple JSON.',
    34: ({ key }) => `the column type '${key}' is a default column type and cannot be overridden.`,
    35: () => `Column type definitions 'columnTypes' with a 'type' attribute are not supported because a column type cannot refer to another column type. Only column definitions 'columnDefs' can use the 'type' attribute to refer to a column type.`,
    36: ({ t }) => "colDef.type '" + t + "' does not correspond to defined gridOptions.columnTypes",
    37: () => `Changing the column pinning status is not allowed with domLayout='print'`,
    38: ({ iconName }) => `provided icon '${iconName}' needs to be a string or a function`,
    39: () => 'Applying column order broke a group where columns should be married together. Applying new order has been discarded.',
    40: ({ e, method }) => `${e}\n${clipboardApiError(method)}`,
    41: () => "Browser did not allow document.execCommand('copy'). Ensure 'api.copySelectedRowsToClipboard() is invoked via a user event, i.e. button click, otherwise the browser will prevent it for security reasons.",
    42: () => "Browser does not support document.execCommand('copy') for clipboard operations",
    43: ({ iconName }) => `As of v33, icon '${iconName}' is deprecated. Use the icon CSS name instead.`,
    44: () => 'Data type definition hierarchies (via the "extendsDataType" property) cannot contain circular references.',
    45: ({ parentCellDataType }) => `The data type definition ${parentCellDataType} does not exist.`,
    46: () => 'The "baseDataType" property of a data type definition must match that of its parent.',
    47: ({ cellDataType }) => `Missing data type definition - "${cellDataType}"`,
    48: ({ property }) => `Cell data type is "object" but no Value ${property} has been provided. Please either provide an object data type definition with a Value ${property}, or set "colDef.value${property}"`,
    49: ({ methodName }) => `Framework component is missing the method ${methodName}()`,
    50: ({ compName }) => `Could not find component ${compName}, did you forget to configure this component?`,
    51: () => `Export cancelled. Export is not allowed as per your configuration.`,
    52: () => 'There is no `window` associated with the current `document`',
    53: () => `unknown value type during csv conversion`,
    54: () => 'Could not find document body, it is needed for drag and drop and context menu.',
    55: () => 'addRowDropZone - A container target needs to be provided',
    56: () => 'addRowDropZone - target already exists in the list of DropZones. Use `removeRowDropZone` before adding it again.',
    57: () => 'unable to show popup filter, filter instantiation failed',
    58: () => 'no values found for select cellEditor',
    59: () => 'cannot select pinned rows',
    60: () => 'cannot select node until it has finished loading',
    61: () => 'since version v32.2.0, rowNode.isFullWidthCell() has been deprecated. Instead check `rowNode.detail` followed by the user provided `isFullWidthRow` grid option.',
    62: ({ colId }) => `setFilterModel() - no column found for colId: ${colId}`,
    63: ({ colId }) => `setFilterModel() - unable to fully apply model, filtering disabled for colId: ${colId}`,
    64: ({ colId }) => `setFilterModel() - unable to fully apply model, unable to create filter for colId: ${colId}`,
    65: () => 'filter missing setModel method, which is needed for setFilterModel',
    66: () => 'filter API missing getModel method, which is needed for getFilterModel',
    67: () => 'Filter is missing isFilterActive() method',
    68: () => 'Column Filter API methods have been disabled as Advanced Filters are enabled.',
    69: ({ guiFromFilter }) => `getGui method from filter returned ${guiFromFilter}; it should be a DOM element.`,
    70: ({ newFilter }) => `Grid option quickFilterText only supports string inputs, received: ${typeof newFilter}`,
    71: () => 'debounceMs is ignored when apply button is present',
    72: ({ keys }) => [`ignoring FilterOptionDef as it doesn't contain one of `, keys],
    73: () => `invalid FilterOptionDef supplied as it doesn't contain a 'displayKey'`,
    74: () => 'no filter options for filter',
    75: () => 'Unknown button type specified',
    76: ({ filterModelType }) => [
        'Unexpected type of filter "',
        filterModelType,
        '", it looks like the filter was configured with incorrect Filter Options',
    ],
    77: () => `Filter model is missing 'conditions'`,
    78: () => 'Filter Model contains more conditions than "filterParams.maxNumConditions". Additional conditions have been ignored.',
    79: () => '"filterParams.maxNumConditions" must be greater than or equal to zero.',
    80: () => '"filterParams.numAlwaysVisibleConditions" must be greater than or equal to zero.',
    81: () => '"filterParams.numAlwaysVisibleConditions" cannot be greater than "filterParams.maxNumConditions".',
    82: ({ param }) => `DateFilter ${param} is not a number`,
    83: () => `DateFilter minValidYear should be <= maxValidYear`,
    84: () => `DateFilter minValidDate should be <= maxValidDate`,
    85: () => 'DateFilter should not have both minValidDate and minValidYear parameters set at the same time! minValidYear will be ignored.',
    86: () => 'DateFilter should not have both maxValidDate and maxValidYear parameters set at the same time! maxValidYear will be ignored.',
    87: () => 'DateFilter parameter minValidDate should always be lower than or equal to parameter maxValidDate.',
    88: ({ index }) => `Invalid row index for ensureIndexVisible: ${index}`,
    89: () => `A template was provided for Header Group Comp - templates are only supported for Header Comps (not groups)`,
    90: () => `datasource is missing getRows method`,
    91: () => 'Filter is missing method doesFilterPass',
    92: () => `AnimationFrameService called but animation frames are off`,
    93: () => 'cannot add multiple ranges when `cellSelection.suppressMultiRanges = true`',
    94: ({ paginationPageSizeOption, pageSizeSet, pageSizesSet, pageSizeOptions, }) => `'paginationPageSize=${paginationPageSizeOption}'${pageSizeSet ? '' : ' (default value)'}, but ${paginationPageSizeOption} is not included in${pageSizesSet ? '' : ' the default'} paginationPageSizeSelector=[${pageSizeOptions?.join(', ')}].`,
    95: ({ paginationPageSizeOption, paginationPageSizeSelector, }) => `Either set '${paginationPageSizeSelector}' to an array that includes ${paginationPageSizeOption} or to 'false' to disable the page size selector.`,
    96: ({ id, data }) => [
        'Duplicate ID',
        id,
        'found for pinned row with data',
        data,
        'When `getRowId` is defined, it must return unique IDs for all pinned rows. Use the `rowPinned` parameter.',
    ],
    97: ({ colId }) => `cellEditor for column ${colId} is missing getGui() method`,
    98: () => 'popup cellEditor does not work with fullRowEdit - you cannot use them both - either turn off fullRowEdit, or stop using popup editors.',
    99: () => 'Since v32, `api.hideOverlay()` does not hide the loading overlay when `loading=true`. Set `loading=false` instead.',
    // 100: ({ rowModelType }: { rowModelType: RowModelType }) =>
    //     `selectAll only available when rowModelType='clientSide', ie not ${rowModelType}` as const,
    101: ({ propertyName, componentName, agGridDefaults, jsComps, }) => {
        const textOutput = [];
        const validComponents = [
            // Don't include the old names / internals in potential suggestions
            ...Object.keys(agGridDefaults ?? []).filter((k) => !['agCellEditor', 'agGroupRowRenderer', 'agSortIndicator'].includes(k)),
            ...Object.keys(jsComps ?? []),
        ];
        const suggestions = (0, fuzzyMatch_1._fuzzySuggestions)({
            inputValue: componentName,
            allSuggestions: validComponents,
            hideIrrelevant: true,
            filterByPercentageOfBestMatch: 0.8,
        }).values;
        textOutput.push(`Could not find '${componentName}' component. It was configured as "${propertyName}: '${componentName}'" but it wasn't found in the list of registered components.\n`);
        if (suggestions.length > 0) {
            textOutput.push(`         Did you mean: [${suggestions.slice(0, 3)}]?\n`);
        }
        textOutput.push(`If using a custom component check it has been registered correctly.`);
        return textOutput;
    },
    102: () => "selectAll: 'filtered' only works when gridOptions.rowModelType='clientSide'",
    103: () => 'Invalid selection state. When using client-side row model, the state must conform to `string[]`.',
    104: ({ value, param }) => `Numeric value ${value} passed to ${param} param will be interpreted as ${value} seconds. If this is intentional use "${value}s" to silence this warning.`,
    105: ({ e }) => [`chart rendering failed`, e],
    106: () => `Theming API and Legacy Themes are both used in the same page. A Theming API theme has been provided to the 'theme' grid option, but the file (ag-grid.css) is also included and will cause styling issues. Remove ag-grid.css from the page. See the migration guide: ${logging_1.baseDocLink}/theming-migration/`,
    107: ({ key, value }) => `Invalid value for theme param ${key} - ${value}`,
    108: ({ e }) => ['chart update failed', e],
    109: ({ aggFuncOrString }) => `unrecognised aggregation function ${aggFuncOrString}`,
    110: () => 'groupHideOpenParents only works when specifying specific columns for colDef.showRowGroup',
    111: () => 'Invalid selection state. When `groupSelects` is enabled, the state must conform to `IServerSideGroupSelectionState`.',
    113: () => 'Set Filter cannot initialise because you are using a row model that does not contain all rows in the browser. Either use a different filter type, or configure Set Filter such that you provide it with values',
    114: ({ component }) => `Could not find component with name of ${component}. Is it in Vue.components?`,
    // 115: () => 'The provided selection state should be an object.' as const,
    116: () => 'Invalid selection state. The state must conform to `IServerSideSelectionState`.',
    117: () => 'selectAll must be of boolean type.',
    118: () => 'Infinite scrolling must be enabled in order to set the row count.',
    119: () => 'Unable to instantiate filter',
    120: () => 'MultiFloatingFilterComp expects MultiFilter as its parent',
    121: () => 'a column you are grouping or pivoting by has objects as values. If you want to group by complex objects then either a) use a colDef.keyCreator (see AG Grid docs) or b) to toString() on the object to return a key',
    122: () => 'could not find the document, document is empty',
    123: () => 'Advanced Filter is only supported with the Client-Side Row Model or Server-Side Row Model.',
    124: () => 'No active charts to update.',
    125: ({ chartId }) => `Unable to update chart. No active chart found with ID: ${chartId}.`,
    126: () => 'unable to restore chart as no chart model is provided',
    127: ({ allRange }) => `unable to create chart as ${allRange ? 'there are no columns in the grid' : 'no range is selected'}.`,
    128: ({ feature }) => `${feature} is only available if using 'multiRow' selection mode.`,
    129: ({ feature, rowModel }) => `${feature} is only available if using 'clientSide' or 'serverSide' rowModelType, you are using ${rowModel}.`,
    130: () => 'cannot multi select unless selection mode is "multiRow"',
    // 131: () => 'cannot range select while selecting multiple rows' as const,
    132: () => 'Row selection features are not available unless `rowSelection` is enabled.',
    133: ({ iconName }) => `icon '${iconName}' function should return back a string or a dom object`,
    134: ({ iconName }) => `Did not find icon '${iconName}'`,
    135: () => `Data type of the new value does not match the cell data type of the column`,
    136: () => `Unable to update chart as the 'type' is missing. It must be either 'rangeChartUpdate', 'pivotChartUpdate', or 'crossFilterChartUpdate'.`,
    137: ({ type, currentChartType }) => `Unable to update chart as a '${type}' update type is not permitted on a ${currentChartType}.`,
    138: ({ chartType }) => `invalid chart type supplied: ${chartType}`,
    139: ({ customThemeName }) => `a custom chart theme with the name ${customThemeName} has been supplied but not added to the 'chartThemes' list`,
    140: ({ name }) => `no stock theme exists with the name '${name}' and no custom chart theme with that name was supplied to 'customChartThemes'`,
    141: () => 'cross filtering with row grouping is not supported.',
    142: () => 'cross filtering is only supported in the client side row model.',
    143: ({ panel }) => `'${panel}' is not a valid Chart Tool Panel name`,
    144: ({ type }) => `Invalid charts data panel group name supplied: '${type}'`,
    145: ({ group }) => `As of v32, only one charts customize panel group can be expanded at a time. '${group}' will not be expanded.`,
    146: ({ comp }) => `Unable to instantiate component '${comp}' as its module hasn't been loaded. Add 'ValidationModule' to see which module is required.`,
    147: ({ group }) => `Invalid charts customize panel group name supplied: '${group}'`,
    148: ({ group }) => `invalid chartGroupsDef config '${group}'`,
    149: ({ group, chartType }) => `invalid chartGroupsDef config '${group}.${chartType}'`,
    150: () => `'seriesChartTypes' are required when the 'customCombo' chart type is specified.`,
    151: ({ chartType }) => `invalid chartType '${chartType}' supplied in 'seriesChartTypes', converting to 'line' instead.`,
    152: ({ colId }) => `no 'seriesChartType' found for colId = '${colId}', defaulting to 'line'.`,
    153: ({ chartDataType }) => `unexpected chartDataType value '${chartDataType}' supplied, instead use 'category', 'series' or 'excluded'`,
    154: ({ colId }) => `cross filtering requires a 'agSetColumnFilter' or 'agMultiColumnFilter' to be defined on the column with id: ${colId}`,
    155: ({ option }) => `'${option}' is not a valid Chart Toolbar Option`,
    156: ({ panel }) => `Invalid panel in chartToolPanelsDef.panels: '${panel}'`,
    157: ({ unrecognisedGroupIds }) => ['unable to find group(s) for supplied groupIds:', unrecognisedGroupIds],
    158: () => 'can not expand a column item that does not represent a column group header',
    159: () => 'Invalid params supplied to createExcelFileForExcel() - `ExcelExportParams.data` is empty.',
    160: () => `Export cancelled. Export is not allowed as per your configuration.`,
    161: () => "The Excel Exporter is currently on Multi Sheet mode. End that operation by calling 'api.getMultipleSheetAsExcel()' or 'api.exportMultipleSheetsAsExcel()'",
    162: ({ id, dataType }) => `Unrecognized data type for excel export [${id}.dataType=${dataType}]`,
    163: ({ featureName }) => `Excel table export does not work with ${featureName}. The exported Excel file will not contain any Excel tables.\n Please turn off ${featureName} to enable Excel table exports.`,
    164: () => 'Unable to add data table to Excel sheet: A table already exists.',
    165: () => 'Unable to add data table to Excel sheet: Missing required parameters.',
    166: ({ unrecognisedGroupIds }) => ['unable to find groups for these supplied groupIds:', unrecognisedGroupIds],
    167: ({ unrecognisedColIds }) => ['unable to find columns for these supplied colIds:', unrecognisedColIds],
    168: () => 'detailCellRendererParams.template should be function or string',
    169: () => 'Reference to eDetailGrid was missing from the details template. Please add data-ref="eDetailGrid" to the template.',
    170: ({ providedStrategy }) => `invalid cellRendererParams.refreshStrategy = ${providedStrategy} supplied, defaulting to refreshStrategy = 'rows'.`,
    171: () => 'could not find detail grid options for master detail, please set gridOptions.detailCellRendererParams.detailGridOptions',
    172: () => 'could not find getDetailRowData for master / detail, please set gridOptions.detailCellRendererParams.getDetailRowData',
    173: ({ group }) => `invalid chartGroupsDef config '${group}'`,
    174: ({ group, chartType }) => `invalid chartGroupsDef config '${group}.${chartType}'`,
    175: ({ menuTabName, itemsToConsider }) => [
        `Trying to render an invalid menu item '${menuTabName}'. Check that your 'menuTabs' contains one of `,
        itemsToConsider,
    ],
    176: ({ key }) => `unknown menu item type ${key}`,
    177: () => `valid values for cellSelection.handle.direction are 'x', 'y' and 'xy'. Default to 'xy'.`,
    178: ({ colId }) => `column ${colId} is not visible`,
    179: () => 'totalValueGetter should be either a function or a string (expression)',
    180: () => 'agRichSelectCellEditor requires cellEditorParams.values to be set',
    181: () => 'agRichSelectCellEditor cannot have `multiSelect` and `allowTyping` set to `true`. AllowTyping has been turned off.',
    182: () => 'you cannot mix groupDisplayType = "multipleColumns" with treeData, only one column can be used to display groups when doing tree data',
    183: () => 'Group Column Filter only works on group columns. Please use a different filter.',
    184: ({ parentGroupData, childNodeData }) => [`duplicate group keys for row data, keys should be unique`, [parentGroupData, childNodeData]],
    185: ({ data }) => [`getDataPath() should not return an empty path`, [data]],
    186: ({ rowId, rowData, duplicateRowsData, }) => [
        `duplicate group keys for row data, keys should be unique`,
        rowId,
        rowData,
        ...(duplicateRowsData ?? []),
    ],
    187: ({ rowId, firstData, secondData }) => [
        `Duplicate node id ${rowId}. Row IDs are provided via the getRowId() callback. Please modify the getRowId() callback code to provide unique row id values.`,
        'first instance',
        firstData,
        'second instance',
        secondData,
    ],
    188: () => `getRowId callback must be provided for Server Side Row Model selection to work correctly.`,
    189: ({ startRow }) => `invalid value ${startRow} for startRow, the value should be >= 0`,
    190: ({ rowGroupId, data }) => [
        `null and undefined values are not allowed for server side row model keys`,
        rowGroupId ? `column = ${rowGroupId}` : ``,
        `data is `,
        data,
    ],
    // 191: () => `cannot multi select unless selection mode is 'multiRow'` as const,
    // 192: () => `cannot use range selection when multi selecting rows` as const,
    // 193: () => "cannot multi select unless selection mode is 'multiRow'" as const,
    194: ({ method }) => `calling gridApi.${method}() is only possible when using rowModelType=\`clientSide\`.`,
    195: ({ justCurrentPage }) => `selecting just ${justCurrentPage ? 'current page' : 'filtered'} only works when gridOptions.rowModelType='clientSide'`,
    196: ({ key }) => `Provided ids must be of string type. Invalid id provided: ${key}`,
    197: () => '`toggledNodes` must be an array of string ids.',
    // 198: () => `cannot multi select unless selection mode is 'multiRow'` as const,
    199: () => `getSelectedNodes and getSelectedRows functions cannot be used with select all functionality with the server-side row model. Use \`api.getServerSideSelectionState()\` instead.`,
    200: missingModule,
    201: ({ rowModelType }) => `Could not find row model for rowModelType = ${rowModelType}`,
    202: () => `\`getSelectedNodes\` and \`getSelectedRows\` functions cannot be used with \`groupSelectsChildren\` and the server-side row model. Use \`api.getServerSideSelectionState()\` instead.`,
    203: () => 'Server Side Row Model does not support Dynamic Row Height and Cache Purging. Either a) remove getRowHeight() callback or b) remove maxBlocksInCache property. Purging has been disabled.',
    204: () => 'Server Side Row Model does not support Auto Row Height and Cache Purging. Either a) remove colDef.autoHeight or b) remove maxBlocksInCache property. Purging has been disabled.',
    205: ({ duplicateIdText }) => `Unable to display rows as duplicate row ids (${duplicateIdText}) were returned by the getRowId callback. Please modify the getRowId callback to provide unique ids.`,
    206: () => 'getRowId callback must be implemented for transactions to work. Transaction was ignored.',
    207: () => 'The Set Filter Parameter "defaultToNothingSelected" value was ignored because it does not work when "excelMode" is used.',
    208: () => `Set Filter Value Formatter must return string values. Please ensure the Set Filter Value Formatter returns string values for complex objects.`,
    209: () => `Set Filter Key Creator is returning null for provided values and provided values are primitives. Please provide complex objects. See ${logging_1.baseDocLink}/filter-set-filter-list/#filter-value-types`,
    210: () => 'Set Filter has a Key Creator, but provided values are primitives. Did you mean to provide complex objects?',
    211: () => 'property treeList=true for Set Filter params, but you did not provide a treeListPathGetter or values of type Date.',
    212: () => `please review all your toolPanel components, it seems like at least one of them doesn't have an id`,
    213: () => 'Advanced Filter does not work with Filters Tool Panel. Filters Tool Panel has been disabled.',
    214: ({ key }) => `unable to lookup Tool Panel as invalid key supplied: ${key}`,
    215: ({ key, defaultByKey }) => `the key ${key} is not a valid key for specifying a tool panel, valid keys are: ${Object.keys(defaultByKey ?? {}).join(',')}`,
    216: ({ name }) => `Missing component for '${name}'`,
    217: ({ invalidColIds }) => ['unable to find grid columns for the supplied colDef(s):', invalidColIds],
    218: ({ property, defaultOffset }) => `${property} must be a number, the value you provided is not a valid number. Using the default of ${defaultOffset}px.`,
    219: ({ property }) => `Property ${property} does not exist on the target object.`,
    220: ({ lineDash }) => `'${lineDash}' is not a valid 'lineDash' option.`,
    221: () => `agAggregationComponent should only be used with the client and server side row model.`,
    222: () => `agFilteredRowCountComponent should only be used with the client side row model.`,
    223: () => `agSelectedRowCountComponent should only be used with the client and server side row model.`,
    224: () => `agTotalAndFilteredRowCountComponent should only be used with the client side row model.`,
    225: () => 'agTotalRowCountComponent should only be used with the client side row model.',
    226: () => 'viewport is missing init method.',
    227: () => 'menu item icon must be DOM node or string',
    228: ({ menuItemOrString }) => `unrecognised menu item ${menuItemOrString}`,
    229: ({ index }) => ['invalid row index for ensureIndexVisible: ', index],
    230: () => 'detailCellRendererParams.template is not supported by AG Grid React. To change the template, provide a Custom Detail Cell Renderer. See https://www.ag-grid.com/react-data-grid/master-detail-custom-detail/',
    // @deprecated v32 mark for removal as part of v32 deprecated features
    231: () => 'As of v32, using custom components with `reactiveCustomComponents = false` is deprecated.',
    232: () => 'Using both rowData and v-model. rowData will be ignored.',
    233: ({ methodName }) => `Framework component is missing the method ${methodName}()`,
    234: () => 'Group Column Filter does not work with the colDef property "field". This property will be ignored.',
    235: () => 'Group Column Filter does not work with the colDef property "filterValueGetter". This property will be ignored.',
    236: () => 'Group Column Filter does not work with the colDef property "filterParams". This property will be ignored.',
    237: () => 'Group Column Filter does not work with Tree Data enabled. Please disable Tree Data, or use a different filter.',
    238: () => 'setRowCount can only accept a positive row count.',
    239: () => 'Theming API and CSS File Themes are both used in the same page. In v33 we released the Theming API as the new default method of styling the grid. See the migration docs https://www.ag-grid.com/react-data-grid/theming-migration/. Because no value was provided to the `theme` grid option it defaulted to themeQuartz. But the file (ag-grid.css) is also included and will cause styling issues. Either pass the string "legacy" to the theme grid option to use v32 style themes, or remove ag-grid.css from the page to use Theming API.',
    240: ({ theme }) => `theme grid option must be a Theming API theme object or the string "legacy", received: ${theme}`,
    // 241: () => `cannot select multiple rows when rowSelection.mode is set to 'singleRow'` as const,
    // 242: () => 'cannot select multiple rows when using rangeSelect' as const,
    243: () => 'Failed to deserialize state - each provided state object must be an object.',
    244: () => 'Failed to deserialize state - `selectAllChildren` must be a boolean value or undefined.',
    245: () => 'Failed to deserialize state - `toggledNodes` must be an array.',
    246: () => 'Failed to deserialize state - Every `toggledNode` requires an associated string id.',
    247: () => `Row selection state could not be parsed due to invalid data. Ensure all child state has toggledNodes or does not conform with the parent rule. \nPlease rebuild the selection state and reapply it.`,
    248: () => 'SetFloatingFilter expects SetFilter as its parent',
    249: () => 'Must supply a Value Formatter in Set Filter params when using a Key Creator',
    250: () => 'Must supply a Key Creator in Set Filter params when `treeList = true` on a group column, and Tree Data or Row Grouping is enabled.',
    251: ({ chartType }) => `AG Grid: Unable to create chart as an invalid chartType = '${chartType}' was supplied.`,
    252: () => 'cannot get grid to draw rows when it is in the middle of drawing rows. \nYour code probably called a grid API method while the grid was in the render stage. \nTo overcome this, put the API call into a timeout, e.g. instead of api.redrawRows(), call setTimeout(function() { api.redrawRows(); }, 0). \nTo see what part of your code that caused the refresh check this stacktrace.',
    253: ({ version }) => ['Illegal version string: ', version],
    254: () => 'Cannot create chart: no chart themes available.',
    255: ({ point }) => `Lone surrogate U+${point?.toString(16).toUpperCase()} is not a scalar value`,
    256: () => 'Unable to initialise. See validation error, or load ValidationModule if missing.',
    257: () => missingChartsWithModule('IntegratedChartsModule'),
    258: () => missingChartsWithModule('SparklinesModule'),
    259: ({ part }) => `the argument to theme.withPart must be a Theming API part object, received: ${part}`,
    260: ({ propName, compName, gridScoped, gridId, rowModelType, }) => missingModule({
        reasonOrId: `AG Grid '${propName}' component: ${compName}`,
        moduleName: userCompValidations_1.USER_COMP_MODULES[compName],
        gridId,
        gridScoped,
        rowModelType,
    }),
    261: () => 'As of v33, `column.isHovered()` is deprecated. Use `api.isColumnHovered(column)` instead.',
    262: () => 'As of v33, icon key "smallDown" is deprecated. Use "advancedFilterBuilderSelect" for Advanced Filter Builder dropdown, "selectOpen" for Select cell editor and dropdowns (e.g. Integrated Charts menu), "richSelectOpen" for Rich Select cell editor.',
    263: () => 'As of v33, icon key "smallLeft" is deprecated. Use "panelDelimiterRtl" for Row Group Panel / Pivot Panel, "subMenuOpenRtl" for sub-menus.',
    264: () => 'As of v33, icon key "smallRight" is deprecated. Use "panelDelimiter" for Row Group Panel / Pivot Panel, "subMenuOpen" for sub-menus.',
    265: ({ colId }) => `Unable to infer chart data type for column '${colId}' if first data entry is null. Please specify "chartDataType", or a "cellDataType" in the column definition. For more information, see ${logging_1.baseDocLink}/integrated-charts-range-chart#coldefchartdatatype .`,
    266: () => 'As of v33.1, using "keyCreator" with the Rich Select Editor has been deprecated. It now requires the "formatValue" callback to convert complex data to strings.',
    267: () => 'Detail grids can not use a different theme to the master grid, the `theme` detail grid option will be ignored.',
    268: () => "Transactions aren't supported with tree data when using treeDataChildrenField",
    269: () => "When `masterSelects: 'detail'`, detail grids must be configured with multi-row selection",
    270: ({ id, parentId }) => `Cycle detected for row with id='${id}' and parent id='${parentId}'. Resetting the parent for row with id='${id}' and showing it as a root-level node.`,
    271: ({ id, parentId }) => `Parent row not found for row with id='${id}' and parent id='${parentId}'. Showing row with id='${id}' as a root-level node.`,
    272: () => (0, exports.NoModulesRegisteredError)(),
    273: ({ providedId, usedId }) => `Provided column id '${providedId}' was already in use, ensure all column and group ids are unique. Using '${usedId}' instead.`,
    274: ({ prop }) => {
        let msg = `Since v33, ${prop} has been deprecated.`;
        switch (prop) {
            case 'maxComponentCreationTimeMs':
                msg += ' This property is no longer required and so will be removed in a future version.';
                break;
            case 'setGridApi':
                msg += ` This method is not called by AG Grid. To access the GridApi see: https://ag-grid.com/react-data-grid/grid-interface/#grid-api `;
                break;
            case 'children':
                msg += ` For multiple versions AgGridReact does not support children.`;
                break;
        }
        return msg;
    },
    275: missingRowModelTypeError,
    276: () => 'Row Numbers Row Resizer cannot be used when Grid Columns have `autoHeight` enabled.',
    277: ({ colId }) => `'enableFilterHandlers' is set to true, but column '${colId}' does not have 'filter.doesFilterPass' or 'filter.handler' set.`,
    278: ({ colId }) => `Unable to create filter handler for column '${colId}'`,
    279: (_) => { },
    280: ({ colId }) => `'name' must be provided for custom filter components for column '${colId}`,
    281: ({ colId }) => `Filter for column '${colId}' does not have 'filterParams.buttons', but the new Filters Tool Panel has buttons configured. Either configure buttons for the filter, or disable buttons on the Filters Tool Panel.`,
    282: () => 'New filter tool panel requires `enableFilterHandlers: true`.',
    283: () => 'As of v34, use the same method on the filter handler (`api.getColumnFilterHandler()`) instead.',
    284: () => 'As of v34, filters are active when they have a model. Use `api.getColumnFilterModel()` instead.',
    285: () => 'As of v34, use (`api.getColumnFilterModel()`) instead.',
    286: () => 'As of v34, use (`api.setColumnFilterModel()`) instead.',
    287: () => '`api.doFilterAction()` requires `enableFilterHandlers = true',
    288: () => '`api.getColumnFilterModel(key, true)` requires `enableFilterHandlers = true',
    289: ({ rowModelType }) => `Row Model '${rowModelType}' is not supported with Batch Editing`,
};
function getError(errorId, args) {
    const msgOrFunc = exports.AG_GRID_ERRORS[errorId];
    if (!msgOrFunc) {
        return [`Missing error text for error id ${errorId}!`];
    }
    const errorBody = msgOrFunc(args);
    const errorLink = (0, logging_1.getErrorLink)(errorId, args);
    const errorSuffix = `\nSee ${errorLink}`;
    return Array.isArray(errorBody) ? errorBody.concat(errorSuffix) : [errorBody, errorSuffix];
}
exports.getError = getError;
exports.MISSING_MODULE_REASONS = {
    1: 'Charting Aggregation',
    2: 'pivotResultFields',
    3: 'setTooltip',
};


/***/ }),

/***/ 47764:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._preInitErrMsg = exports._errMsg = exports._logPreInitErr = exports._error = exports._warn = exports.getErrorLink = exports.toStringWithNullUndefined = exports.setValidationDocLink = exports.suppressAllLogs = exports.provideValidationServiceLogger = exports.baseDocLink = void 0;
const baseUrl_1 = __webpack_require__(83263);
const function_1 = __webpack_require__(92043);
const version_1 = __webpack_require__(97205);
const MAX_URL_LENGTH = 2000;
const MIN_PARAM_LENGTH = 100;
const VERSION_PARAM_NAME = '_version_';
let validation = null;
let suppressAllLogging = false;
exports.baseDocLink = `${baseUrl_1.BASE_URL}/javascript-data-grid`;
/**
 * The ValidationService passes itself in if it has been included.
 * @param logger
 */
function provideValidationServiceLogger(logger) {
    validation = logger;
}
exports.provideValidationServiceLogger = provideValidationServiceLogger;
function suppressAllLogs() {
    suppressAllLogging = true;
}
exports.suppressAllLogs = suppressAllLogs;
/** Set by the Framework override to give us accurate links for the framework  */
function setValidationDocLink(docLink) {
    exports.baseDocLink = docLink;
}
exports.setValidationDocLink = setValidationDocLink;
function getErrorParts(id, args, defaultMessage) {
    return validation?.getConsoleMessage(id, args) ?? [minifiedLog(id, args, defaultMessage)];
}
function getMsgOrDefault(logger, id, args, defaultMessage) {
    if (suppressAllLogging)
        return;
    logger(`error #${id}`, ...getErrorParts(id, args, defaultMessage));
}
/**
 * Stringify object, removing any circular dependencies
 */
function stringifyObject(inputObj) {
    if (!inputObj)
        return String(inputObj);
    const object = {};
    for (const prop of Object.keys(inputObj)) {
        if (typeof inputObj[prop] !== 'object' && typeof inputObj[prop] !== 'function') {
            object[prop] = inputObj[prop];
        }
    }
    return JSON.stringify(object);
}
function stringifyValue(value) {
    let output = value;
    if (value instanceof Error) {
        output = value.toString();
    }
    else if (typeof value === 'object') {
        output = stringifyObject(value);
    }
    return output;
}
/**
 * Correctly formats a string or undefined or null value into a human readable string
 * @param input
 */
function toStringWithNullUndefined(str) {
    return str === undefined ? 'undefined' : str === null ? 'null' : str;
}
exports.toStringWithNullUndefined = toStringWithNullUndefined;
function getParamsUrl(baseUrl, params) {
    return `${baseUrl}?${params.toString()}`;
}
function truncateUrl(baseUrl, params, maxLength) {
    const sortedParams = Array.from(params.entries()).sort((a, b) => b[1].length - a[1].length);
    let url = getParamsUrl(baseUrl, params);
    for (const [key, value] of sortedParams) {
        if (key === VERSION_PARAM_NAME) {
            continue;
        }
        const excessLength = url.length - maxLength;
        if (excessLength <= 0) {
            break;
        }
        const ellipse = '...';
        const truncateAmount = excessLength + ellipse.length;
        // Truncate by `truncateAmount`, unless the result is shorter than the min param
        // length. In which case, shorten to min param length, then continue shortening
        // other params.
        // Assume there isn't a lot of params that are all long.
        const truncatedValue = value.length - truncateAmount > MIN_PARAM_LENGTH
            ? value.slice(0, value.length - truncateAmount) + ellipse
            : value.slice(0, MIN_PARAM_LENGTH) + ellipse;
        params.set(key, truncatedValue);
        url = getParamsUrl(baseUrl, params);
    }
    return url;
}
function getErrorLink(errorNum, args) {
    const params = new URLSearchParams();
    params.append(VERSION_PARAM_NAME, version_1.VERSION);
    if (args) {
        for (const key of Object.keys(args)) {
            params.append(key, stringifyValue(args[key]));
        }
    }
    const baseUrl = `${exports.baseDocLink}/errors/${errorNum}`;
    const url = getParamsUrl(baseUrl, params);
    return url.length <= MAX_URL_LENGTH ? url : truncateUrl(baseUrl, params, MAX_URL_LENGTH);
}
exports.getErrorLink = getErrorLink;
const minifiedLog = (errorNum, args, defaultMessage) => {
    const errorLink = getErrorLink(errorNum, args);
    return `${defaultMessage ? defaultMessage + ' \n' : ''}Visit ${errorLink}${defaultMessage ? '' : ' \n  Alternatively register the ValidationModule to see the full message in the console.'}`;
};
function _warn(...args) {
    getMsgOrDefault(function_1._warnOnce, args[0], args[1]);
}
exports._warn = _warn;
function _error(...args) {
    getMsgOrDefault(function_1._errorOnce, args[0], args[1]);
}
exports._error = _error;
/** Used for messages before the ValidationService has been created */
function _logPreInitErr(id, args, defaultMessage) {
    getMsgOrDefault(function_1._errorOnce, id, args, defaultMessage);
}
exports._logPreInitErr = _logPreInitErr;
function getErrMsg(defaultMessage, args) {
    const id = args[0];
    return `error #${id} ` + getErrorParts(id, args[1], defaultMessage).join(' ');
}
function _errMsg(...args) {
    return getErrMsg(undefined, args);
}
exports._errMsg = _errMsg;
/** Used for messages before the ValidationService has been created */
function _preInitErrMsg(...args) {
    // as well as displaying an extra line break, this will remove the part of the message about adding the validation module
    return getErrMsg('\n', args);
}
exports._preInitErrMsg = _preInitErrMsg;


/***/ }),

/***/ 80342:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveModuleNames = exports.MODULES_FOR_ROW_MODELS = exports.RESOLVABLE_MODULE_NAMES = void 0;
const ALL_COLUMN_FILTERS = [
    'TextFilter',
    'NumberFilter',
    'DateFilter',
    'SetFilter',
    'MultiFilter',
    'GroupFilter',
    'CustomFilter',
];
/**
 * Some of these modules are (for now) included by default in core. For these, we just return AllCommunityModule.
 */
exports.RESOLVABLE_MODULE_NAMES = {
    EditCore: [
        'TextEditor',
        'NumberEditor',
        'DateEditor',
        'CheckboxEditor',
        'LargeTextEditor',
        'SelectEditor',
        'RichSelect',
        'CustomEditor',
    ],
    CheckboxCellRenderer: ['AllCommunity'],
    ClientSideRowModelHierarchy: ['RowGrouping', 'Pivot', 'TreeData'],
    ColumnFilter: ALL_COLUMN_FILTERS,
    ColumnGroupHeaderComp: ['AllCommunity'],
    ColumnGroup: ['AllCommunity'],
    ColumnHeaderComp: ['AllCommunity'],
    ColumnMove: ['AllCommunity'],
    ColumnResize: ['AllCommunity'],
    CommunityCore: ['AllCommunity'],
    CsrmSsrmSharedApi: ['ClientSideRowModelApi', 'ServerSideRowModelApi'],
    EnterpriseCore: ['AllEnterprise'],
    FilterCore: [...ALL_COLUMN_FILTERS, 'QuickFilter', 'ExternalFilter', 'AdvancedFilter'],
    GroupCellRenderer: ['RowGrouping', 'Pivot', 'TreeData', 'MasterDetail', 'ServerSideRowModel'],
    KeyboardNavigation: ['AllCommunity'],
    LoadingCellRenderer: ['ServerSideRowModel'],
    MenuCore: ['ColumnMenu', 'ContextMenu'],
    MenuItem: ['ColumnMenu', 'ContextMenu', 'MultiFilter', 'IntegratedCharts', 'ColumnsToolPanel'],
    Overlay: ['AllCommunity'],
    PinnedColumn: ['AllCommunity'],
    SharedAggregation: ['RowGrouping', 'Pivot', 'TreeData', 'ServerSideRowModel'],
    SharedDragAndDrop: ['AllCommunity'],
    SharedMasterDetail: ['MasterDetail', 'ServerSideRowModel'],
    SharedMenu: [...ALL_COLUMN_FILTERS, 'ColumnMenu', 'ContextMenu'],
    SharedPivot: ['Pivot', 'ServerSideRowModel'],
    SharedRowGrouping: ['RowGrouping', 'ServerSideRowModel'],
    SharedRowSelection: ['RowSelection', 'ServerSideRowModel'],
    SkeletonCellRenderer: ['ServerSideRowModel'],
    Sort: ['AllCommunity'],
    SsrmInfiniteSharedApi: ['InfiniteRowModel', 'ServerSideRowModelApi'],
    SharedTreeData: ['TreeData', 'ServerSideRowModel'],
};
exports.MODULES_FOR_ROW_MODELS = {
    InfiniteRowModel: 'infinite',
    ClientSideRowModelApi: 'clientSide',
    ClientSideRowModel: 'clientSide',
    ServerSideRowModelApi: 'serverSide',
    ServerSideRowModel: 'serverSide',
    ViewportRowModel: 'viewport',
};
function resolveModuleNames(moduleName, rowModelType) {
    const resolvedModuleNames = [];
    (Array.isArray(moduleName) ? moduleName : [moduleName]).forEach((modName) => {
        const resolved = exports.RESOLVABLE_MODULE_NAMES[modName];
        if (resolved) {
            resolved.forEach((resolvedModName) => {
                const rowModelForModule = exports.MODULES_FOR_ROW_MODELS[resolvedModName];
                // don't show module for different row models
                if (!rowModelForModule || rowModelForModule === rowModelType) {
                    resolvedModuleNames.push(resolvedModName);
                }
            });
        }
        else {
            resolvedModuleNames.push(modName);
        }
    });
    return resolvedModuleNames;
}
exports.resolveModuleNames = resolveModuleNames;


/***/ }),

/***/ 34842:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.COL_DEF_VALIDATORS = exports.COLUMN_DEFINITION_MOD_VALIDATIONS = void 0;
const sortService_1 = __webpack_require__(48125);
const logging_1 = __webpack_require__(47764);
const userCompValidations_1 = __webpack_require__(51389);
const COLUMN_DEFINITION_DEPRECATIONS = () => ({
    checkboxSelection: { version: '32.2', message: 'Use `rowSelection.checkboxes` in `GridOptions` instead.' },
    headerCheckboxSelection: {
        version: '32.2',
        message: 'Use `rowSelection.headerCheckbox = true` in `GridOptions` instead.',
    },
    headerCheckboxSelectionFilteredOnly: {
        version: '32.2',
        message: 'Use `rowSelection.selectAll = "filtered"` in `GridOptions` instead.',
    },
    headerCheckboxSelectionCurrentPageOnly: {
        version: '32.2',
        message: 'Use `rowSelection.selectAll = "currentPage"` in `GridOptions` instead.',
    },
    showDisabledCheckboxes: {
        version: '32.2',
        message: 'Use `rowSelection.hideDisabledCheckboxes = true` in `GridOptions` instead.',
    },
});
exports.COLUMN_DEFINITION_MOD_VALIDATIONS = {
    aggFunc: 'SharedAggregation',
    autoHeight: 'RowAutoHeight',
    cellClass: 'CellStyle',
    cellClassRules: 'CellStyle',
    cellEditor: ({ cellEditor, editable }) => {
        if (!editable) {
            return null;
        }
        if (typeof cellEditor === 'string') {
            return userCompValidations_1.USER_COMP_MODULES[cellEditor] ?? 'CustomEditor';
        }
        return 'CustomEditor';
    },
    cellRenderer: ({ cellRenderer }) => {
        if (typeof cellRenderer !== 'string') {
            return null;
        }
        return userCompValidations_1.USER_COMP_MODULES[cellRenderer];
    },
    cellStyle: 'CellStyle',
    columnChooserParams: 'ColumnMenu',
    contextMenuItems: 'ContextMenu',
    dndSource: 'DragAndDrop',
    dndSourceOnRowDrag: 'DragAndDrop',
    editable: ({ editable, cellEditor }) => {
        if (editable && !cellEditor) {
            return 'TextEditor';
        }
        return null;
    },
    enableCellChangeFlash: 'HighlightChanges',
    enablePivot: 'SharedPivot',
    enableRowGroup: 'SharedRowGrouping',
    enableValue: 'SharedAggregation',
    filter: ({ filter }) => {
        if (filter && typeof filter !== 'string' && typeof filter !== 'boolean') {
            return 'CustomFilter';
        }
        if (typeof filter === 'string') {
            return userCompValidations_1.USER_COMP_MODULES[filter] ?? 'ColumnFilter';
        }
        return 'ColumnFilter';
    },
    floatingFilter: 'ColumnFilter',
    getQuickFilterText: 'QuickFilter',
    headerTooltip: 'Tooltip',
    mainMenuItems: 'ColumnMenu',
    menuTabs: (options) => {
        const enterpriseMenuTabs = ['columnsMenuTab', 'generalMenuTab'];
        if (options.menuTabs?.some((tab) => enterpriseMenuTabs.includes(tab))) {
            return 'ColumnMenu';
        }
        return null;
    },
    pivot: 'SharedPivot',
    pivotIndex: 'SharedPivot',
    rowDrag: 'RowDrag',
    rowGroup: 'SharedRowGrouping',
    rowGroupIndex: 'SharedRowGrouping',
    tooltipField: 'Tooltip',
    tooltipValueGetter: 'Tooltip',
    spanRows: 'CellSpan',
};
const COLUMN_DEFINITION_VALIDATIONS = () => {
    const validations = {
        autoHeight: {
            supportedRowModels: ['clientSide', 'serverSide'],
            validate: (_colDef, { paginationAutoPageSize }) => {
                if (paginationAutoPageSize) {
                    return 'colDef.autoHeight is not supported with paginationAutoPageSize.';
                }
                return null;
            },
        },
        cellRendererParams: {
            validate: (colDef) => {
                const groupColumn = colDef.rowGroup != null ||
                    colDef.rowGroupIndex != null ||
                    colDef.cellRenderer === 'agGroupCellRenderer';
                if (groupColumn && 'checkbox' in colDef.cellRendererParams) {
                    return 'Since v33.0, `cellRendererParams.checkbox` has been deprecated. Use `rowSelection.checkboxLocation = "autoGroupColumn"` instead.';
                }
                return null;
            },
        },
        flex: {
            validate: (_options, gridOptions) => {
                if (gridOptions.autoSizeStrategy) {
                    return 'colDef.flex is not supported with gridOptions.autoSizeStrategy';
                }
                return null;
            },
        },
        headerCheckboxSelection: {
            supportedRowModels: ['clientSide', 'serverSide'],
            validate: (_options, { rowSelection }) => rowSelection === 'multiple'
                ? null
                : 'headerCheckboxSelection is only supported with rowSelection=multiple',
        },
        headerCheckboxSelectionCurrentPageOnly: {
            supportedRowModels: ['clientSide'],
            validate: (_options, { rowSelection }) => rowSelection === 'multiple'
                ? null
                : 'headerCheckboxSelectionCurrentPageOnly is only supported with rowSelection=multiple',
        },
        headerCheckboxSelectionFilteredOnly: {
            supportedRowModels: ['clientSide'],
            validate: (_options, { rowSelection }) => rowSelection === 'multiple'
                ? null
                : 'headerCheckboxSelectionFilteredOnly is only supported with rowSelection=multiple',
        },
        headerValueGetter: {
            validate: (_options) => {
                const headerValueGetter = _options.headerValueGetter;
                if (typeof headerValueGetter === 'function' || typeof headerValueGetter === 'string') {
                    return null;
                }
                return 'headerValueGetter must be a function or a valid string expression';
            },
        },
        icons: {
            validate: ({ icons }) => {
                if (icons) {
                    if (icons['smallDown']) {
                        return (0, logging_1._errMsg)(262);
                    }
                    if (icons['smallLeft']) {
                        return (0, logging_1._errMsg)(263);
                    }
                    if (icons['smallRight']) {
                        return (0, logging_1._errMsg)(264);
                    }
                }
                return null;
            },
        },
        sortingOrder: {
            validate: (_options) => {
                const sortingOrder = _options.sortingOrder;
                if (Array.isArray(sortingOrder) && sortingOrder.length > 0) {
                    const invalidItems = sortingOrder.filter((a) => !sortService_1.DEFAULT_SORTING_ORDER.includes(a));
                    if (invalidItems.length > 0) {
                        return `sortingOrder must be an array with elements from [${sortService_1.DEFAULT_SORTING_ORDER.map(logging_1.toStringWithNullUndefined).join()}], currently it includes [${invalidItems.map(logging_1.toStringWithNullUndefined).join()}]`;
                    }
                }
                else if (!Array.isArray(sortingOrder) || sortingOrder.length <= 0) {
                    return `sortingOrder must be an array with at least one element, currently it's ${sortingOrder}`;
                }
                return null;
            },
        },
        type: {
            validate: (_options) => {
                const type = _options.type;
                if (type instanceof Array) {
                    const invalidArray = type.some((a) => typeof a !== 'string');
                    if (invalidArray) {
                        return "if colDef.type is supplied an array it should be of type 'string[]'";
                    }
                    return null;
                }
                if (typeof type === 'string') {
                    return null;
                }
                return "colDef.type should be of type 'string' | 'string[]'";
            },
        },
        rowSpan: {
            validate: (_options, { suppressRowTransform }) => {
                if (!suppressRowTransform) {
                    return 'colDef.rowSpan requires suppressRowTransform to be enabled.';
                }
                return null;
            },
        },
        spanRows: {
            dependencies: {
                editable: { required: [false, undefined] },
                rowDrag: { required: [false, undefined] },
                colSpan: { required: [undefined] },
                rowSpan: { required: [undefined] },
            },
            validate: (_options, { rowSelection, cellSelection, suppressRowTransform, enableCellSpan, rowDragEntireRow, enableCellTextSelection, }) => {
                if (typeof rowSelection === 'object') {
                    if (rowSelection?.mode === 'singleRow' && rowSelection?.enableClickSelection) {
                        return 'colDef.spanRows is not supported with rowSelection.clickSelection';
                    }
                }
                if (cellSelection) {
                    return 'colDef.spanRows is not supported with cellSelection.';
                }
                if (suppressRowTransform) {
                    return 'colDef.spanRows is not supported with suppressRowTransform.';
                }
                if (!enableCellSpan) {
                    return 'colDef.spanRows requires enableCellSpan to be enabled.';
                }
                if (rowDragEntireRow) {
                    return 'colDef.spanRows is not supported with rowDragEntireRow.';
                }
                if (enableCellTextSelection) {
                    return 'colDef.spanRows is not supported with enableCellTextSelection.';
                }
                return null;
            },
        },
    };
    return validations;
};
const colDefPropertyMap = {
    headerName: undefined,
    columnGroupShow: undefined,
    headerStyle: undefined,
    headerClass: undefined,
    toolPanelClass: undefined,
    headerValueGetter: undefined,
    pivotKeys: undefined,
    groupId: undefined,
    colId: undefined,
    sort: undefined,
    initialSort: undefined,
    field: undefined,
    type: undefined,
    cellDataType: undefined,
    tooltipComponent: undefined,
    tooltipField: undefined,
    headerTooltip: undefined,
    cellClass: undefined,
    showRowGroup: undefined,
    filter: undefined,
    initialAggFunc: undefined,
    defaultAggFunc: undefined,
    aggFunc: undefined,
    pinned: undefined,
    initialPinned: undefined,
    chartDataType: undefined,
    cellAriaRole: undefined,
    cellEditorPopupPosition: undefined,
    headerGroupComponent: undefined,
    headerGroupComponentParams: undefined,
    cellStyle: undefined,
    cellRenderer: undefined,
    cellRendererParams: undefined,
    cellEditor: undefined,
    cellEditorParams: undefined,
    filterParams: undefined,
    pivotValueColumn: undefined,
    headerComponent: undefined,
    headerComponentParams: undefined,
    floatingFilterComponent: undefined,
    floatingFilterComponentParams: undefined,
    tooltipComponentParams: undefined,
    refData: undefined,
    columnChooserParams: undefined,
    children: undefined,
    sortingOrder: undefined,
    allowedAggFuncs: undefined,
    menuTabs: undefined,
    pivotTotalColumnIds: undefined,
    cellClassRules: undefined,
    icons: undefined,
    sortIndex: undefined,
    initialSortIndex: undefined,
    flex: undefined,
    initialFlex: undefined,
    width: undefined,
    initialWidth: undefined,
    minWidth: undefined,
    maxWidth: undefined,
    rowGroupIndex: undefined,
    initialRowGroupIndex: undefined,
    pivotIndex: undefined,
    initialPivotIndex: undefined,
    suppressColumnsToolPanel: undefined,
    suppressFiltersToolPanel: undefined,
    openByDefault: undefined,
    marryChildren: undefined,
    suppressStickyLabel: undefined,
    hide: undefined,
    initialHide: undefined,
    rowGroup: undefined,
    initialRowGroup: undefined,
    pivot: undefined,
    initialPivot: undefined,
    checkboxSelection: undefined,
    showDisabledCheckboxes: undefined,
    headerCheckboxSelection: undefined,
    headerCheckboxSelectionFilteredOnly: undefined,
    headerCheckboxSelectionCurrentPageOnly: undefined,
    suppressHeaderMenuButton: undefined,
    suppressMovable: undefined,
    lockPosition: undefined,
    lockVisible: undefined,
    lockPinned: undefined,
    unSortIcon: undefined,
    suppressSizeToFit: undefined,
    suppressAutoSize: undefined,
    enableRowGroup: undefined,
    enablePivot: undefined,
    enableValue: undefined,
    editable: undefined,
    suppressPaste: undefined,
    suppressNavigable: undefined,
    enableCellChangeFlash: undefined,
    rowDrag: undefined,
    dndSource: undefined,
    autoHeight: undefined,
    wrapText: undefined,
    sortable: undefined,
    resizable: undefined,
    singleClickEdit: undefined,
    floatingFilter: undefined,
    cellEditorPopup: undefined,
    suppressFillHandle: undefined,
    wrapHeaderText: undefined,
    autoHeaderHeight: undefined,
    dndSourceOnRowDrag: undefined,
    valueGetter: undefined,
    valueSetter: undefined,
    filterValueGetter: undefined,
    keyCreator: undefined,
    valueFormatter: undefined,
    valueParser: undefined,
    comparator: undefined,
    equals: undefined,
    pivotComparator: undefined,
    suppressKeyboardEvent: undefined,
    suppressHeaderKeyboardEvent: undefined,
    colSpan: undefined,
    rowSpan: undefined,
    spanRows: undefined,
    getQuickFilterText: undefined,
    onCellValueChanged: undefined,
    onCellClicked: undefined,
    onCellDoubleClicked: undefined,
    onCellContextMenu: undefined,
    rowDragText: undefined,
    tooltipValueGetter: undefined,
    cellRendererSelector: undefined,
    cellEditorSelector: undefined,
    suppressSpanHeaderHeight: undefined,
    useValueFormatterForExport: undefined,
    useValueParserForImport: undefined,
    mainMenuItems: undefined,
    contextMenuItems: undefined,
    suppressFloatingFilterButton: undefined,
    suppressHeaderFilterButton: undefined,
    suppressHeaderContextMenu: undefined,
    loadingCellRenderer: undefined,
    loadingCellRendererParams: undefined,
    loadingCellRendererSelector: undefined,
    context: undefined,
    dateComponent: undefined,
    dateComponentParams: undefined,
    getFindText: undefined,
};
const ALL_PROPERTIES = () => Object.keys(colDefPropertyMap);
const COL_DEF_VALIDATORS = () => ({
    objectName: 'colDef',
    allProperties: ALL_PROPERTIES(),
    docsUrl: 'column-properties/',
    deprecations: COLUMN_DEFINITION_DEPRECATIONS(),
    validations: COLUMN_DEFINITION_VALIDATIONS(),
});
exports.COL_DEF_VALIDATORS = COL_DEF_VALIDATORS;


/***/ }),

/***/ 3368:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DYNAMIC_BEAN_MODULES = void 0;
exports.DYNAMIC_BEAN_MODULES = {
    detailCellRendererCtrl: 'SharedMasterDetail',
    dndSourceComp: 'DragAndDrop',
    fillHandle: 'CellSelection',
    groupCellRendererCtrl: 'GroupCellRenderer',
    headerFilterCellCtrl: 'ColumnFilter',
    headerGroupCellCtrl: 'ColumnGroup',
    rangeHandle: 'CellSelection',
    tooltipFeature: 'Tooltip',
    groupStrategy: 'RowGrouping',
    treeGroupStrategy: 'TreeData',
    rowNumberRowResizer: 'RowNumbers',
    singleCell: 'EditCore',
    fullRow: 'EditCore',
    agSetColumnFilterHandler: 'SetFilter',
    agMultiColumnFilterHandler: 'MultiFilter',
    agGroupColumnFilterHandler: 'GroupFilter',
    agNumberColumnFilterHandler: 'NumberFilter',
    agDateColumnFilterHandler: 'DateFilter',
    agTextColumnFilterHandler: 'TextFilter',
};


/***/ }),

/***/ 50711:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GRID_OPTIONS_VALIDATORS = exports.GRID_OPTIONS_MODULES = void 0;
const propertyKeys_1 = __webpack_require__(40920);
const publicEventHandlersMap_1 = __webpack_require__(8829);
const sortService_1 = __webpack_require__(48125);
const object_1 = __webpack_require__(6996);
const logging_1 = __webpack_require__(47764);
/**
 * Deprecations have been kept separately for ease of removing them in the future.
 *
 */
const GRID_OPTION_DEPRECATIONS = () => ({
    suppressLoadingOverlay: { version: '32', message: 'Use `loading`=false instead.' },
    enableFillHandle: { version: '32.2', message: 'Use `cellSelection.handle` instead.' },
    enableRangeHandle: { version: '32.2', message: 'Use `cellSelection.handle` instead.' },
    enableRangeSelection: { version: '32.2', message: 'Use `cellSelection = true` instead.' },
    suppressMultiRangeSelection: {
        version: '32.2',
        message: 'Use `cellSelection.suppressMultiRanges` instead.',
    },
    suppressClearOnFillReduction: {
        version: '32.2',
        message: 'Use `cellSelection.handle.suppressClearOnFillReduction` instead.',
    },
    fillHandleDirection: { version: '32.2', message: 'Use `cellSelection.handle.direction` instead.' },
    fillOperation: { version: '32.2', message: 'Use `cellSelection.handle.setFillValue` instead.' },
    suppressRowClickSelection: {
        version: '32.2',
        message: 'Use `rowSelection.enableClickSelection` instead.',
    },
    suppressRowDeselection: { version: '32.2', message: 'Use `rowSelection.enableClickSelection` instead.' },
    rowMultiSelectWithClick: {
        version: '32.2',
        message: 'Use `rowSelection.enableSelectionWithoutKeys` instead.',
    },
    groupSelectsChildren: {
        version: '32.2',
        message: 'Use `rowSelection.groupSelects = "descendants"` instead.',
    },
    groupSelectsFiltered: {
        version: '32.2',
        message: 'Use `rowSelection.groupSelects = "filteredDescendants"` instead.',
    },
    isRowSelectable: { version: '32.2', message: 'Use `selectionOptions.isRowSelectable` instead.' },
    suppressCopySingleCellRanges: { version: '32.2', message: 'Use `rowSelection.copySelectedRows` instead.' },
    suppressCopyRowsToClipboard: { version: '32.2', message: 'Use `rowSelection.copySelectedRows` instead.' },
    onRangeSelectionChanged: { version: '32.2', message: 'Use `onCellSelectionChanged` instead.' },
    onRangeDeleteStart: { version: '32.2', message: 'Use `onCellSelectionDeleteStart` instead.' },
    onRangeDeleteEnd: { version: '32.2', message: 'Use `onCellSelectionDeleteEnd` instead.' },
    suppressBrowserResizeObserver: {
        version: '32.2',
        message: "The grid always uses the browser's ResizeObserver, this grid option has no effect.",
    },
    onColumnEverythingChanged: {
        version: '32.2',
        message: 'Either use `onDisplayedColumnsChanged` which is fired at the same time, or use one of the more specific column events.',
    },
    groupRemoveSingleChildren: {
        version: '33',
        message: 'Use `groupHideParentOfSingleChild` instead.',
    },
    groupRemoveLowestSingleChildren: {
        version: '33',
        message: 'Use `groupHideParentOfSingleChild: "leafGroupsOnly"` instead.',
    },
    suppressRowGroupHidesColumns: {
        version: '33',
        message: 'Use `suppressGroupChangesColumnVisibility: "suppressHideOnGroup"` instead.',
    },
    suppressMakeColumnVisibleAfterUnGroup: {
        version: '33',
        message: 'Use `suppressGroupChangesColumnVisibility: "suppressShowOnUngroup"` instead.',
    },
    unSortIcon: { version: '33', message: 'Use `defaultColDef.unSortIcon` instead.' },
    sortingOrder: { version: '33', message: 'Use `defaultColDef.sortingOrder` instead.' },
    suppressPropertyNamesCheck: {
        version: '33',
        message: '`gridOptions` and `columnDefs` both have a `context` property that should be used for arbitrary user data. This means that column definitions and gridOptions should only contain valid properties making this property redundant.',
    },
    suppressAdvancedFilterEval: {
        version: '34',
        message: 'Advanced filter no longer uses function evaluation, so this option has no effect.',
    },
});
function toConstrainedNum(key, value, min) {
    if (typeof value === 'number' || value == null) {
        if (value == null) {
            return null;
        }
        return value >= min ? null : `${key}: value should be greater than or equal to ${min}`;
    }
    return `${key}: value should be a number`;
}
exports.GRID_OPTIONS_MODULES = {
    alignedGrids: 'AlignedGrids',
    allowContextMenuWithControlKey: 'ContextMenu',
    autoSizeStrategy: 'ColumnAutoSize',
    cellSelection: 'CellSelection',
    columnHoverHighlight: 'ColumnHover',
    datasource: 'InfiniteRowModel',
    doesExternalFilterPass: 'ExternalFilter',
    editType: 'EditCore',
    invalidEditValueMode: 'EditCore',
    enableAdvancedFilter: 'AdvancedFilter',
    enableCellSpan: 'CellSpan',
    enableCharts: 'IntegratedCharts',
    enableRangeSelection: 'CellSelection',
    enableRowPinning: 'PinnedRow',
    findSearchValue: 'Find',
    getFullRowEditValidationErrors: 'EditCore',
    getContextMenuItems: 'ContextMenu',
    getLocaleText: 'Locale',
    getMainMenuItems: 'ColumnMenu',
    getRowClass: 'RowStyle',
    getRowStyle: 'RowStyle',
    groupTotalRow: 'SharedRowGrouping',
    grandTotalRow: 'SharedRowGrouping',
    initialState: 'GridState',
    isExternalFilterPresent: 'ExternalFilter',
    isRowPinnable: 'PinnedRow',
    isRowPinned: 'PinnedRow',
    localeText: 'Locale',
    masterDetail: 'SharedMasterDetail',
    pagination: 'Pagination',
    pinnedBottomRowData: 'PinnedRow',
    pinnedTopRowData: 'PinnedRow',
    pivotMode: 'SharedPivot',
    pivotPanelShow: 'RowGroupingPanel',
    quickFilterText: 'QuickFilter',
    rowClass: 'RowStyle',
    rowClassRules: 'RowStyle',
    rowData: 'ClientSideRowModel',
    rowDragManaged: 'RowDrag',
    rowGroupPanelShow: 'RowGroupingPanel',
    rowNumbers: 'RowNumbers',
    rowSelection: 'SharedRowSelection',
    rowStyle: 'RowStyle',
    serverSideDatasource: 'ServerSideRowModel',
    sideBar: 'SideBar',
    statusBar: 'StatusBar',
    treeData: 'SharedTreeData',
    undoRedoCellEditing: 'UndoRedoEdit',
    valueCache: 'ValueCache',
    viewportDatasource: 'ViewportRowModel',
};
/**
 * Validation rules for gridOptions
 */
const GRID_OPTION_VALIDATIONS = () => {
    const definedValidations = {
        autoSizePadding: {
            validate({ autoSizePadding }) {
                return toConstrainedNum('autoSizePadding', autoSizePadding, 0);
            },
        },
        cacheBlockSize: {
            supportedRowModels: ['serverSide', 'infinite'],
            validate({ cacheBlockSize }) {
                return toConstrainedNum('cacheBlockSize', cacheBlockSize, 1);
            },
        },
        cacheOverflowSize: {
            validate({ cacheOverflowSize }) {
                return toConstrainedNum('cacheOverflowSize', cacheOverflowSize, 1);
            },
        },
        datasource: {
            supportedRowModels: ['infinite'],
        },
        domLayout: {
            validate: (options) => {
                const domLayout = options.domLayout;
                const validLayouts = ['autoHeight', 'normal', 'print'];
                if (domLayout && !validLayouts.includes(domLayout)) {
                    return `domLayout must be one of [${validLayouts.join()}], currently it's ${domLayout}`;
                }
                return null;
            },
        },
        enableFillHandle: {
            dependencies: {
                enableRangeSelection: { required: [true] },
            },
        },
        enableRangeHandle: {
            dependencies: {
                enableRangeSelection: { required: [true] },
            },
        },
        enableRangeSelection: {
            dependencies: {
                rowDragEntireRow: { required: [false, undefined] },
            },
        },
        enableRowPinning: {
            supportedRowModels: ['clientSide'],
            validate({ enableRowPinning, pinnedTopRowData, pinnedBottomRowData }) {
                if (enableRowPinning && (pinnedTopRowData || pinnedBottomRowData)) {
                    return 'Manual row pinning cannot be used together with pinned row data. Either set `enableRowPinning` to `false`, or remove `pinnedTopRowData` and `pinnedBottomRowData`.';
                }
                return null;
            },
        },
        isRowPinnable: {
            supportedRowModels: ['clientSide'],
            validate({ enableRowPinning, isRowPinnable, pinnedTopRowData, pinnedBottomRowData }) {
                if (isRowPinnable && (pinnedTopRowData || pinnedBottomRowData)) {
                    return 'Manual row pinning cannot be used together with pinned row data. Either remove `isRowPinnable`, or remove `pinnedTopRowData` and `pinnedBottomRowData`.';
                }
                if (!enableRowPinning && isRowPinnable) {
                    return '`isRowPinnable` requires `enableRowPinning` to be set.';
                }
                return null;
            },
        },
        isRowPinned: {
            supportedRowModels: ['clientSide'],
            validate({ enableRowPinning, isRowPinned, pinnedTopRowData, pinnedBottomRowData }) {
                if (isRowPinned && (pinnedTopRowData || pinnedBottomRowData)) {
                    return 'Manual row pinning cannot be used together with pinned row data. Either remove `isRowPinned`, or remove `pinnedTopRowData` and `pinnedBottomRowData`.';
                }
                if (!enableRowPinning && isRowPinned) {
                    return '`isRowPinned` requires `enableRowPinning` to be set.';
                }
                return null;
            },
        },
        groupDefaultExpanded: {
            supportedRowModels: ['clientSide'],
        },
        groupHideOpenParents: {
            supportedRowModels: ['clientSide', 'serverSide'],
            dependencies: {
                groupTotalRow: { required: [undefined, 'bottom'] },
                treeData: {
                    required: [undefined, false],
                    reason: "Tree Data has values at the group level so it doesn't make sense to hide them.",
                },
            },
        },
        groupHideParentOfSingleChild: {
            dependencies: {
                groupHideOpenParents: { required: [undefined, false] },
            },
        },
        groupRemoveLowestSingleChildren: {
            dependencies: {
                groupHideOpenParents: { required: [undefined, false] },
                groupRemoveSingleChildren: { required: [undefined, false] },
            },
        },
        groupRemoveSingleChildren: {
            dependencies: {
                groupHideOpenParents: { required: [undefined, false] },
                groupRemoveLowestSingleChildren: { required: [undefined, false] },
            },
        },
        groupSelectsChildren: {
            dependencies: {
                rowSelection: { required: ['multiple'] },
            },
        },
        icons: {
            validate: ({ icons }) => {
                if (icons) {
                    if (icons['smallDown']) {
                        return (0, logging_1._errMsg)(262);
                    }
                    if (icons['smallLeft']) {
                        return (0, logging_1._errMsg)(263);
                    }
                    if (icons['smallRight']) {
                        return (0, logging_1._errMsg)(264);
                    }
                }
                return null;
            },
        },
        infiniteInitialRowCount: {
            validate({ infiniteInitialRowCount }) {
                return toConstrainedNum('infiniteInitialRowCount', infiniteInitialRowCount, 1);
            },
        },
        initialGroupOrderComparator: {
            supportedRowModels: ['clientSide'],
        },
        keepDetailRowsCount: {
            validate({ keepDetailRowsCount }) {
                return toConstrainedNum('keepDetailRowsCount', keepDetailRowsCount, 1);
            },
        },
        paginationPageSize: {
            validate({ paginationPageSize }) {
                return toConstrainedNum('paginationPageSize', paginationPageSize, 1);
            },
        },
        paginationPageSizeSelector: {
            validate: (options) => {
                const values = options.paginationPageSizeSelector;
                if (typeof values === 'boolean' || values == null) {
                    return null;
                }
                if (!values.length) {
                    return `'paginationPageSizeSelector' cannot be an empty array.
                    If you want to hide the page size selector, set paginationPageSizeSelector to false.`;
                }
                return null;
            },
        },
        pivotMode: {
            dependencies: {
                treeData: {
                    required: [false, undefined],
                    reason: 'Pivot Mode is not supported with Tree Data.',
                },
            },
        },
        quickFilterText: {
            supportedRowModels: ['clientSide'],
        },
        rowBuffer: {
            validate({ rowBuffer }) {
                return toConstrainedNum('rowBuffer', rowBuffer, 0);
            },
        },
        rowClass: {
            validate: (options) => {
                const rowClass = options.rowClass;
                if (typeof rowClass === 'function') {
                    return 'rowClass should not be a function, please use getRowClass instead';
                }
                return null;
            },
        },
        rowData: {
            supportedRowModels: ['clientSide'],
        },
        rowDragManaged: {
            supportedRowModels: ['clientSide'],
            dependencies: {
                pagination: {
                    required: [false, undefined],
                },
            },
        },
        rowSelection: {
            validate({ rowSelection }) {
                if (rowSelection && typeof rowSelection === 'string') {
                    return 'As of version 32.2.1, using `rowSelection` with the values "single" or "multiple" has been deprecated. Use the object value instead.';
                }
                if (rowSelection && typeof rowSelection !== 'object') {
                    return 'Expected `RowSelectionOptions` object for the `rowSelection` property.';
                }
                if (rowSelection && rowSelection.mode !== 'multiRow' && rowSelection.mode !== 'singleRow') {
                    return `Selection mode "${rowSelection.mode}" is invalid. Use one of 'singleRow' or 'multiRow'.`;
                }
                return null;
            },
        },
        rowStyle: {
            validate: (options) => {
                const rowStyle = options.rowStyle;
                if (rowStyle && typeof rowStyle === 'function') {
                    return 'rowStyle should be an object of key/value styles, not be a function, use getRowStyle() instead';
                }
                return null;
            },
        },
        serverSideDatasource: {
            supportedRowModels: ['serverSide'],
        },
        serverSideInitialRowCount: {
            supportedRowModels: ['serverSide'],
            validate({ serverSideInitialRowCount }) {
                return toConstrainedNum('serverSideInitialRowCount', serverSideInitialRowCount, 1);
            },
        },
        serverSideOnlyRefreshFilteredGroups: {
            supportedRowModels: ['serverSide'],
        },
        serverSideSortAllLevels: {
            supportedRowModels: ['serverSide'],
        },
        sortingOrder: {
            validate: (_options) => {
                const sortingOrder = _options.sortingOrder;
                if (Array.isArray(sortingOrder) && sortingOrder.length > 0) {
                    const invalidItems = sortingOrder.filter((a) => !sortService_1.DEFAULT_SORTING_ORDER.includes(a));
                    if (invalidItems.length > 0) {
                        return `sortingOrder must be an array with elements from [${sortService_1.DEFAULT_SORTING_ORDER.map(logging_1.toStringWithNullUndefined).join()}], currently it includes [${invalidItems.map(logging_1.toStringWithNullUndefined).join()}]`;
                    }
                }
                else if (!Array.isArray(sortingOrder) || sortingOrder.length <= 0) {
                    return `sortingOrder must be an array with at least one element, currently it's ${sortingOrder}`;
                }
                return null;
            },
        },
        tooltipHideDelay: {
            validate: (options) => {
                if (options.tooltipHideDelay && options.tooltipHideDelay < 0) {
                    return 'tooltipHideDelay should not be lower than 0';
                }
                return null;
            },
        },
        tooltipShowDelay: {
            validate: (options) => {
                if (options.tooltipShowDelay && options.tooltipShowDelay < 0) {
                    return 'tooltipShowDelay should not be lower than 0';
                }
                return null;
            },
        },
        treeData: {
            supportedRowModels: ['clientSide', 'serverSide'],
            validate: (options) => {
                const rowModel = options.rowModelType ?? 'clientSide';
                switch (rowModel) {
                    case 'clientSide': {
                        const { treeDataChildrenField, treeDataParentIdField, getDataPath, getRowId } = options;
                        if (!treeDataChildrenField && !treeDataParentIdField && !getDataPath) {
                            return "treeData requires either 'treeDataChildrenField' or 'treeDataParentIdField' or 'getDataPath' in the clientSide row model.";
                        }
                        if (treeDataChildrenField) {
                            if (getDataPath) {
                                return "Cannot use both 'treeDataChildrenField' and 'getDataPath' at the same time.";
                            }
                            if (treeDataParentIdField) {
                                return "Cannot use both 'treeDataChildrenField' and 'treeDataParentIdField' at the same time.";
                            }
                        }
                        if (treeDataParentIdField) {
                            if (!getRowId) {
                                return 'getRowId callback not provided, tree data with parent id cannot be built.';
                            }
                            if (getDataPath) {
                                return "Cannot use both 'treeDataParentIdField' and 'getDataPath' at the same time.";
                            }
                        }
                        return null;
                    }
                    case 'serverSide': {
                        const ssrmWarning = `treeData requires 'isServerSideGroup' and 'getServerSideGroupKey' in the ${rowModel} row model.`;
                        return options.isServerSideGroup && options.getServerSideGroupKey ? null : ssrmWarning;
                    }
                }
                return null;
            },
        },
        viewportDatasource: {
            supportedRowModels: ['viewport'],
        },
        viewportRowModelBufferSize: {
            validate({ viewportRowModelBufferSize }) {
                return toConstrainedNum('viewportRowModelBufferSize', viewportRowModelBufferSize, 0);
            },
        },
        viewportRowModelPageSize: {
            validate({ viewportRowModelPageSize }) {
                return toConstrainedNum('viewportRowModelPageSize', viewportRowModelPageSize, 1);
            },
        },
        rowDragEntireRow: {
            dependencies: {
                cellSelection: { required: [undefined] },
            },
        },
        autoGroupColumnDef: {
            validate({ autoGroupColumnDef, showOpenedGroup }) {
                if (autoGroupColumnDef?.field && showOpenedGroup) {
                    return 'autoGroupColumnDef.field and showOpenedGroup are not supported when used together.';
                }
                if (autoGroupColumnDef?.valueGetter && showOpenedGroup) {
                    return 'autoGroupColumnDef.valueGetter and showOpenedGroup are not supported when used together.';
                }
                return null;
            },
        },
        renderingMode: {
            validate: (options) => {
                const renderingMode = options.renderingMode;
                const validModes = ['default', 'legacy'];
                if (renderingMode && !validModes.includes(renderingMode)) {
                    return `renderingMode must be one of [${validModes.join()}], currently it's ${renderingMode}`;
                }
                return null;
            },
        },
    };
    const validations = {};
    propertyKeys_1._BOOLEAN_GRID_OPTIONS.forEach((key) => {
        validations[key] = { expectedType: 'boolean' };
    });
    propertyKeys_1._NUMBER_GRID_OPTIONS.forEach((key) => {
        validations[key] = { expectedType: 'number' };
    });
    (0, object_1._mergeDeep)(validations, definedValidations);
    return validations;
};
const GRID_OPTIONS_VALIDATORS = () => ({
    objectName: 'gridOptions',
    allProperties: [...(0, propertyKeys_1._GET_ALL_GRID_OPTIONS)(), ...Object.values(publicEventHandlersMap_1._PUBLIC_EVENT_HANDLERS_MAP)],
    propertyExceptions: ['api'],
    docsUrl: 'grid-options/',
    deprecations: GRID_OPTION_DEPRECATIONS(),
    validations: GRID_OPTION_VALIDATIONS(),
});
exports.GRID_OPTIONS_VALIDATORS = GRID_OPTIONS_VALIDATORS;


/***/ }),

/***/ 49938:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DEPRECATED_ICONS_V33 = exports.ICON_MODULES = exports.ICON_VALUES = void 0;
exports.ICON_VALUES = {
    expanded: 1,
    contracted: 1,
    'tree-closed': 1,
    'tree-open': 1,
    'tree-indeterminate': 1,
    pin: 1,
    'eye-slash': 1,
    arrows: 1,
    left: 1,
    right: 1,
    group: 1,
    aggregation: 1,
    pivot: 1,
    'not-allowed': 1,
    chart: 1,
    cross: 1,
    cancel: 1,
    tick: 1,
    first: 1,
    previous: 1,
    next: 1,
    last: 1,
    linked: 1,
    unlinked: 1,
    'color-picker': 1,
    loading: 1,
    menu: 1,
    'menu-alt': 1,
    filter: 1,
    'filter-add': 1,
    columns: 1,
    maximize: 1,
    minimize: 1,
    copy: 1,
    cut: 1,
    paste: 1,
    grip: 1,
    save: 1,
    csv: 1,
    excel: 1,
    'small-down': 1,
    'small-left': 1,
    'small-right': 1,
    'small-up': 1,
    asc: 1,
    desc: 1,
    none: 1,
    up: 1,
    down: 1,
    plus: 1,
    minus: 1,
    settings: 1,
    'checkbox-checked': 1,
    'checkbox-indeterminate': 1,
    'checkbox-unchecked': 1,
    'radio-button-on': 1,
    'radio-button-off': 1,
    eye: 1,
    'column-arrow': 1,
    'un-pin': 1,
    'pinned-top': 1,
    'pinned-bottom': 1,
    'chevron-up': 1,
    'chevron-down': 1,
    'chevron-left': 1,
    'chevron-right': 1,
    edit: 1,
};
exports.ICON_MODULES = {
    chart: 'MenuCore',
    cancel: 'EnterpriseCore',
    first: 'Pagination',
    previous: 'Pagination',
    next: 'Pagination',
    last: 'Pagination',
    linked: 'IntegratedCharts',
    loadingMenuItems: 'MenuCore',
    unlinked: 'IntegratedCharts',
    menu: 'ColumnHeaderComp',
    legacyMenu: 'ColumnMenu',
    filter: 'ColumnFilter',
    filterActive: 'ColumnFilter',
    filterAdd: 'NewFiltersToolPanel',
    filterCardCollapse: 'NewFiltersToolPanel',
    filterCardExpand: 'NewFiltersToolPanel',
    filterCardEditing: 'NewFiltersToolPanel',
    filterTab: 'ColumnMenu',
    filtersToolPanel: 'FiltersToolPanel',
    columns: ['MenuCore'],
    columnsToolPanel: ['ColumnsToolPanel'],
    maximize: 'EnterpriseCore',
    minimize: 'EnterpriseCore',
    save: 'MenuCore',
    columnGroupOpened: 'ColumnGroupHeaderComp',
    columnGroupClosed: 'ColumnGroupHeaderComp',
    accordionOpen: 'EnterpriseCore',
    accordionClosed: 'EnterpriseCore',
    accordionIndeterminate: 'EnterpriseCore',
    columnSelectClosed: ['ColumnsToolPanel', 'ColumnMenu'],
    columnSelectOpen: ['ColumnsToolPanel', 'ColumnMenu'],
    columnSelectIndeterminate: ['ColumnsToolPanel', 'ColumnMenu'],
    columnMovePin: 'SharedDragAndDrop',
    columnMoveHide: 'SharedDragAndDrop',
    columnMoveMove: 'SharedDragAndDrop',
    columnMoveLeft: 'SharedDragAndDrop',
    columnMoveRight: 'SharedDragAndDrop',
    columnMoveGroup: 'SharedDragAndDrop',
    columnMoveValue: 'SharedDragAndDrop',
    columnMovePivot: 'SharedDragAndDrop',
    dropNotAllowed: 'SharedDragAndDrop',
    ensureColumnVisible: ['ColumnsToolPanel', 'ColumnMenu'],
    groupContracted: 'GroupCellRenderer',
    groupExpanded: 'GroupCellRenderer',
    setFilterGroupClosed: 'SetFilter',
    setFilterGroupOpen: 'SetFilter',
    setFilterGroupIndeterminate: 'SetFilter',
    setFilterLoading: 'SetFilter',
    close: 'EnterpriseCore',
    check: 'MenuItem',
    colorPicker: 'CommunityCore',
    groupLoading: 'LoadingCellRenderer',
    menuAlt: 'ColumnHeaderComp',
    menuPin: 'MenuCore',
    menuValue: 'MenuCore',
    menuAddRowGroup: ['MenuCore', 'ColumnsToolPanel'],
    menuRemoveRowGroup: ['MenuCore', 'ColumnsToolPanel'],
    clipboardCopy: 'MenuCore',
    clipboardCut: 'MenuCore',
    clipboardPaste: 'MenuCore',
    pivotPanel: ['ColumnsToolPanel', 'RowGroupingPanel'],
    rowGroupPanel: ['ColumnsToolPanel', 'RowGroupingPanel'],
    valuePanel: 'ColumnsToolPanel',
    columnDrag: 'EnterpriseCore',
    rowDrag: ['RowDrag', 'DragAndDrop'],
    csvExport: 'MenuCore',
    excelExport: 'MenuCore',
    smallDown: 'CommunityCore',
    selectOpen: 'CommunityCore',
    richSelectOpen: 'RichSelect',
    richSelectRemove: 'RichSelect',
    smallLeft: 'CommunityCore',
    smallRight: 'CommunityCore',
    subMenuOpen: 'MenuItem',
    subMenuOpenRtl: 'MenuItem',
    panelDelimiter: 'RowGroupingPanel',
    panelDelimiterRtl: 'RowGroupingPanel',
    smallUp: 'CommunityCore',
    sortAscending: ['MenuCore', 'Sort'],
    sortDescending: ['MenuCore', 'Sort'],
    sortUnSort: ['MenuCore', 'Sort'],
    advancedFilterBuilder: 'AdvancedFilter',
    advancedFilterBuilderDrag: 'AdvancedFilter',
    advancedFilterBuilderInvalid: 'AdvancedFilter',
    advancedFilterBuilderMoveUp: 'AdvancedFilter',
    advancedFilterBuilderMoveDown: 'AdvancedFilter',
    advancedFilterBuilderAdd: 'AdvancedFilter',
    advancedFilterBuilderRemove: 'AdvancedFilter',
    advancedFilterBuilderSelectOpen: 'AdvancedFilter',
    chartsMenu: 'IntegratedCharts',
    chartsMenuEdit: 'IntegratedCharts',
    chartsMenuAdvancedSettings: 'IntegratedCharts',
    chartsMenuAdd: 'IntegratedCharts',
    chartsColorPicker: 'IntegratedCharts',
    chartsThemePrevious: 'IntegratedCharts',
    chartsThemeNext: 'IntegratedCharts',
    chartsDownload: 'IntegratedCharts',
    checkboxChecked: 'CommunityCore',
    checkboxIndeterminate: 'CommunityCore',
    checkboxUnchecked: 'CommunityCore',
    radioButtonOn: 'CommunityCore',
    radioButtonOff: 'CommunityCore',
    rowPin: 'PinnedRow',
    rowUnpin: 'PinnedRow',
    rowPinBottom: 'PinnedRow',
    rowPinTop: 'PinnedRow',
};
exports.DEPRECATED_ICONS_V33 = new Set([
    'colorPicker',
    'smallUp',
    'checkboxChecked',
    'checkboxIndeterminate',
    'checkboxUnchecked',
    'radioButtonOn',
    'radioButtonOff',
    'smallDown',
    'smallLeft',
    'smallRight',
]);


/***/ }),

/***/ 51389:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.USER_COMP_MODULES = void 0;
exports.USER_COMP_MODULES = {
    agSetColumnFilter: 'SetFilter',
    agSetColumnFloatingFilter: 'SetFilter',
    agMultiColumnFilter: 'MultiFilter',
    agMultiColumnFloatingFilter: 'MultiFilter',
    agGroupColumnFilter: 'GroupFilter',
    agGroupColumnFloatingFilter: 'GroupFilter',
    agGroupCellRenderer: 'GroupCellRenderer',
    agGroupRowRenderer: 'GroupCellRenderer',
    agRichSelect: 'RichSelect',
    agRichSelectCellEditor: 'RichSelect',
    agDetailCellRenderer: 'SharedMasterDetail',
    agSparklineCellRenderer: 'Sparklines',
    agDragAndDropImage: 'SharedDragAndDrop',
    agColumnHeader: 'ColumnHeaderComp',
    agColumnGroupHeader: 'ColumnGroupHeaderComp',
    agSortIndicator: 'Sort',
    agAnimateShowChangeCellRenderer: 'HighlightChanges',
    agAnimateSlideCellRenderer: 'HighlightChanges',
    agLoadingCellRenderer: 'LoadingCellRenderer',
    agSkeletonCellRenderer: 'SkeletonCellRenderer',
    agCheckboxCellRenderer: 'CheckboxCellRenderer',
    agLoadingOverlay: 'Overlay',
    agNoRowsOverlay: 'Overlay',
    agTooltipComponent: 'Tooltip',
    agReadOnlyFloatingFilter: 'CustomFilter',
    agTextColumnFilter: 'TextFilter',
    agNumberColumnFilter: 'NumberFilter',
    agDateColumnFilter: 'DateFilter',
    agDateInput: 'DateFilter',
    agTextColumnFloatingFilter: 'TextFilter',
    agNumberColumnFloatingFilter: 'NumberFilter',
    agDateColumnFloatingFilter: 'DateFilter',
    agCellEditor: 'TextEditor',
    agSelectCellEditor: 'SelectEditor',
    agTextCellEditor: 'TextEditor',
    agNumberCellEditor: 'NumberEditor',
    agDateCellEditor: 'DateEditor',
    agDateStringCellEditor: 'DateEditor',
    agCheckboxCellEditor: 'CheckboxEditor',
    agLargeTextCellEditor: 'LargeTextEditor',
    agMenuItem: 'MenuItem',
    agColumnsToolPanel: 'ColumnsToolPanel',
    agFiltersToolPanel: 'FiltersToolPanel',
    agNewFiltersToolPanel: 'NewFiltersToolPanel',
    agAggregationComponent: 'StatusBar',
    agSelectedRowCountComponent: 'StatusBar',
    agTotalRowCountComponent: 'StatusBar',
    agFilteredRowCountComponent: 'StatusBar',
    agTotalAndFilteredRowCountComponent: 'StatusBar',
    agFindCellRenderer: 'Find',
};


/***/ }),

/***/ 15010:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ValidationModule = void 0;
const version_1 = __webpack_require__(97205);
const validationService_1 = __webpack_require__(35147);
/**
 * @feature Validation
 */
exports.ValidationModule = {
    moduleName: 'Validation',
    version: version_1.VERSION,
    beans: [validationService_1.ValidationService],
};


/***/ }),

/***/ 35147:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._fuzzyCheckStrings = exports.ValidationService = void 0;
const beanStub_1 = __webpack_require__(68731);
const gridOptionsInitial_1 = __webpack_require__(2891);
const moduleRegistry_1 = __webpack_require__(2132);
const function_1 = __webpack_require__(92043);
const fuzzyMatch_1 = __webpack_require__(21298);
const apiFunctionValidator_1 = __webpack_require__(8179);
const errorText_1 = __webpack_require__(15205);
const logging_1 = __webpack_require__(47764);
const colDefValidations_1 = __webpack_require__(34842);
const dynamicBeanValidations_1 = __webpack_require__(3368);
const gridOptionsValidations_1 = __webpack_require__(50711);
const iconValidations_1 = __webpack_require__(49938);
const userCompValidations_1 = __webpack_require__(51389);
class ValidationService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'validation';
    }
    wireBeans(beans) {
        this.gridOptions = beans.gridOptions;
        (0, logging_1.provideValidationServiceLogger)(this);
    }
    warnOnInitialPropertyUpdate(source, key) {
        if (source === 'api' && gridOptionsInitial_1.INITIAL_GRID_OPTION_KEYS[key]) {
            (0, logging_1._warn)(22, { key });
        }
    }
    processGridOptions(options) {
        this.processOptions(options, (0, gridOptionsValidations_1.GRID_OPTIONS_VALIDATORS)());
    }
    validateApiFunction(functionName, apiFunction) {
        return (0, apiFunctionValidator_1.validateApiFunction)(functionName, apiFunction, this.beans);
    }
    missingUserComponent(propertyName, componentName, agGridDefaults, jsComps) {
        const moduleForComponent = userCompValidations_1.USER_COMP_MODULES[componentName];
        if (moduleForComponent) {
            this.gos.assertModuleRegistered(moduleForComponent, `AG Grid '${propertyName}' component: ${componentName}`);
        }
        else {
            (0, logging_1._warn)(101, {
                propertyName,
                componentName,
                agGridDefaults,
                jsComps,
            });
        }
    }
    missingDynamicBean(beanName) {
        const moduleName = dynamicBeanValidations_1.DYNAMIC_BEAN_MODULES[beanName];
        return moduleName
            ? (0, logging_1._errMsg)(200, {
                ...this.gos.getModuleErrorParams(),
                moduleName,
                reasonOrId: beanName,
            })
            : undefined;
    }
    checkRowEvents(eventType) {
        if (DEPRECATED_ROW_NODE_EVENTS.has(eventType)) {
            (0, logging_1._warn)(10, { eventType });
        }
    }
    validateIcon(iconName) {
        if (iconValidations_1.DEPRECATED_ICONS_V33.has(iconName)) {
            (0, logging_1._warn)(43, { iconName });
        }
        if (iconValidations_1.ICON_VALUES[iconName]) {
            // directly referencing icon
            return;
        }
        const moduleName = iconValidations_1.ICON_MODULES[iconName];
        if (moduleName) {
            (0, logging_1._error)(200, {
                reasonOrId: `icon '${iconName}'`,
                moduleName,
                gridScoped: (0, moduleRegistry_1._areModulesGridScoped)(),
                gridId: this.beans.context.getGridId(),
                rowModelType: this.gos.get('rowModelType'),
                additionalText: 'Alternatively, use the CSS icon name directly.',
            });
            return;
        }
        (0, logging_1._warn)(134, { iconName });
    }
    isProvidedUserComp(compName) {
        return !!userCompValidations_1.USER_COMP_MODULES[compName];
    }
    /** Should only be called via the GridOptionsService */
    validateColDef(colDef) {
        this.processOptions(colDef, (0, colDefValidations_1.COL_DEF_VALIDATORS)());
    }
    processOptions(options, validator) {
        const { validations, deprecations, allProperties, propertyExceptions, objectName, docsUrl } = validator;
        if (allProperties && this.gridOptions.suppressPropertyNamesCheck !== true) {
            this.checkProperties(options, [...(propertyExceptions ?? []), ...Object.keys(deprecations)], allProperties, objectName, docsUrl);
        }
        const warnings = new Set();
        const optionKeys = Object.keys(options);
        optionKeys.forEach((key) => {
            const deprecation = deprecations[key];
            if (deprecation) {
                const { message, version } = deprecation;
                warnings.add(`As of v${version}, ${String(key)} is deprecated. ${message ?? ''}`);
            }
            const value = options[key];
            if (value == null || value === false) {
                // false implies feature is disabled, don't validate.
                return;
            }
            const rules = validations[key];
            if (!rules) {
                return;
            }
            const { dependencies, validate, supportedRowModels, expectedType } = rules;
            if (expectedType) {
                const actualType = typeof value;
                if (actualType !== expectedType) {
                    warnings.add(`${String(key)} should be of type '${expectedType}' but received '${actualType}' (${value}).`);
                    return;
                }
            }
            if (supportedRowModels) {
                const rowModel = this.gridOptions.rowModelType ?? 'clientSide';
                if (!supportedRowModels.includes(rowModel)) {
                    warnings.add(`${String(key)} is not supported with the '${rowModel}' row model. It is only valid with: ${supportedRowModels.join(', ')}.`);
                    return;
                }
            }
            if (dependencies) {
                const warning = this.checkForRequiredDependencies(key, dependencies, options);
                if (warning) {
                    warnings.add(warning);
                    return;
                }
            }
            if (validate) {
                const warning = validate(options, this.gridOptions, this.beans);
                if (warning) {
                    warnings.add(warning);
                    return;
                }
            }
        });
        if (warnings.size > 0) {
            warnings.forEach((warning) => {
                (0, function_1._warnOnce)(warning);
            });
        }
    }
    checkForRequiredDependencies(key, validator, options) {
        // eslint-disable-next-line no-restricted-properties
        const optionEntries = Object.entries(validator);
        const failedOptions = optionEntries.filter(([key, value]) => {
            const gridOptionValue = options[key];
            return !value.required.includes(gridOptionValue);
        });
        if (failedOptions.length === 0) {
            return null;
        }
        return failedOptions
            .map(([failedKey, possibleOptions]) => `'${String(key)}' requires '${failedKey}' to be one of [${possibleOptions.required
            .map((o) => {
            if (o === null) {
                return 'null';
            }
            else if (o === undefined) {
                return 'undefined';
            }
            return o;
        })
            .join(', ')}]. ${possibleOptions.reason ?? ''}`)
            .join('\n           '); // make multiple messages easier to read
    }
    checkProperties(object, exceptions, // deprecated properties generally
    validProperties, // properties to recommend
    containerName, docsUrl) {
        // Vue adds these properties to all objects, so we ignore them when checking for invalid properties
        const VUE_FRAMEWORK_PROPS = ['__ob__', '__v_skip', '__metadata__'];
        const invalidProperties = _fuzzyCheckStrings(Object.getOwnPropertyNames(object), [...VUE_FRAMEWORK_PROPS, ...exceptions, ...validProperties], validProperties);
        const invalidPropertiesKeys = Object.keys(invalidProperties);
        for (const key of invalidPropertiesKeys) {
            const value = invalidProperties[key];
            let message = `invalid ${containerName} property '${key}' did you mean any of these: ${value.slice(0, 8).join(', ')}.`;
            if (validProperties.includes('context')) {
                message += `\nIf you are trying to annotate ${containerName} with application data, use the '${containerName}.context' property instead.`;
            }
            (0, function_1._warnOnce)(message);
        }
        if (invalidPropertiesKeys.length > 0 && docsUrl) {
            const url = this.beans.frameworkOverrides.getDocLink(docsUrl);
            (0, function_1._warnOnce)(`to see all the valid ${containerName} properties please check: ${url}`);
        }
    }
    getConsoleMessage(id, args) {
        return (0, errorText_1.getError)(id, args);
    }
}
exports.ValidationService = ValidationService;
function _fuzzyCheckStrings(inputValues, validValues, allSuggestions) {
    const fuzzyMatches = {};
    const invalidInputs = inputValues.filter((inputValue) => !validValues.some((validValue) => validValue === inputValue));
    if (invalidInputs.length > 0) {
        invalidInputs.forEach((invalidInput) => (fuzzyMatches[invalidInput] = (0, fuzzyMatch_1._fuzzySuggestions)({ inputValue: invalidInput, allSuggestions }).values));
    }
    return fuzzyMatches;
}
exports._fuzzyCheckStrings = _fuzzyCheckStrings;
const DEPRECATED_ROW_NODE_EVENTS = new Set([
    'firstChildChanged',
    'lastChildChanged',
    'childIndexChanged',
]);


/***/ }),

/***/ 17486:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCellValue = exports.expireValueCache = void 0;
const generic_1 = __webpack_require__(34422);
const string_1 = __webpack_require__(37766);
function expireValueCache(beans) {
    beans.valueCache?.expire();
}
exports.expireValueCache = expireValueCache;
function getCellValue(beans, params) {
    const { colKey, rowNode, useFormatter } = params;
    const column = beans.colModel.getColDefCol(colKey) ?? beans.colModel.getCol(colKey);
    if ((0, generic_1._missing)(column)) {
        return null;
    }
    const value = beans.valueSvc.getValueForDisplay(column, rowNode).value;
    if (useFormatter) {
        const formattedValue = beans.valueSvc.formatValue(column, rowNode, value);
        // Match the logic in the default cell renderer insertValueWithoutCellRenderer if no formatter is used
        return formattedValue ?? (0, string_1._toString)(value);
    }
    return value;
}
exports.getCellValue = getCellValue;


/***/ }),

/***/ 52878:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChangeDetectionService = void 0;
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const changedPath_1 = __webpack_require__(76800);
// Matches value in clipboard module
const SOURCE_PASTE = 'paste';
class ChangeDetectionService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'changeDetectionSvc';
        this.clientSideRowModel = null;
    }
    postConstruct() {
        const { gos, rowModel } = this.beans;
        if ((0, gridOptionsUtils_1._isClientSideRowModel)(gos, rowModel)) {
            this.clientSideRowModel = rowModel;
        }
        this.addManagedEventListeners({ cellValueChanged: this.onCellValueChanged.bind(this) });
    }
    onCellValueChanged(event) {
        const { gos, rowRenderer } = this.beans;
        // Clipboard service manages its own change detection, so no need to do it here.
        // The clipboard manages its own as otherwise this would happen once for every cell
        // that got updated as part of a paste operation, so e.g. if 100 cells in a paste operation,
        // this doChangeDetection would get called 100 times (once for each cell), instead clipboard
        // service executes the logic we have here once (in essence batching up all cell changes
        // into one change detection).
        if (event.source === SOURCE_PASTE || gos.get('suppressChangeDetection')) {
            return;
        }
        const rowNode = event.node;
        const nodesToRefresh = [rowNode];
        const clientSideRowModel = this.clientSideRowModel;
        const rootNode = clientSideRowModel?.rootNode;
        // step 1 of change detection is to update the aggregated values
        if (rootNode && !rowNode.isRowPinned()) {
            const onlyChangedColumns = gos.get('aggregateOnlyChangedColumns');
            const changedPath = new changedPath_1.ChangedPath(onlyChangedColumns, rootNode);
            changedPath.addParentNode(rowNode.parent, [event.column]);
            clientSideRowModel.doAggregate(changedPath);
            // add all nodes impacted by aggregation, as they need refreshed also.
            changedPath.forEachChangedNodeDepthFirst((rowNode) => {
                nodesToRefresh.push(rowNode);
                if (rowNode.sibling) {
                    nodesToRefresh.push(rowNode.sibling);
                }
            });
        }
        // step 2 of change detection is to refresh the cells
        rowRenderer.refreshCells({ rowNodes: nodesToRefresh });
    }
}
exports.ChangeDetectionService = ChangeDetectionService;


/***/ }),

/***/ 45751:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExpressionService = void 0;
const beanStub_1 = __webpack_require__(68731);
const logging_1 = __webpack_require__(47764);
class ExpressionService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'expressionSvc';
        this.cache = {};
    }
    evaluate(expression, params) {
        if (typeof expression === 'string') {
            // valueGetter is an expression, so execute the expression
            return this.evaluateExpression(expression, params);
        }
        else {
            (0, logging_1._error)(15, { expression });
        }
    }
    evaluateExpression(expression, params) {
        try {
            const javaScriptFunction = this.createExpressionFunction(expression);
            // the params don't have all these values, rather we add every possible
            // value a params can have, which makes whatever is in the params available.
            const result = javaScriptFunction(params.value, params.context, params.oldValue, params.newValue, params.value, params.node, params.data, params.colDef, params.rowIndex, params.api, params.getValue, params.column, params.columnGroup);
            return result;
        }
        catch (e) {
            // the expression failed, which can happen, as it's the client that
            // provides the expression. so print a nice message
            (0, logging_1._error)(16, { expression, params, e });
            return null;
        }
    }
    createExpressionFunction(expression) {
        const expressionToFunctionCache = this.cache;
        // check cache first
        if (expressionToFunctionCache[expression]) {
            return expressionToFunctionCache[expression];
        }
        // if not found in cache, return the function
        const functionBody = this.createFunctionBody(expression);
        const theFunction = new Function('x, ctx, oldValue, newValue, value, node, data, colDef, rowIndex, api, getValue, column, columnGroup', functionBody);
        // store in cache
        expressionToFunctionCache[expression] = theFunction;
        return theFunction;
    }
    createFunctionBody(expression) {
        // if the expression has the 'return' word in it, then use as is,
        // if not, then wrap it with return and ';' to make a function
        if (expression.indexOf('return') >= 0) {
            return expression;
        }
        else {
            return 'return ' + expression + ';';
        }
    }
}
exports.ExpressionService = ExpressionService;


/***/ }),

/***/ 53913:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ValueCache = void 0;
const beanStub_1 = __webpack_require__(68731);
class ValueCache extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'valueCache';
        this.cacheVersion = 0;
    }
    postConstruct() {
        const gos = this.gos;
        this.active = gos.get('valueCache');
        this.neverExpires = gos.get('valueCacheNeverExpires');
    }
    onDataChanged() {
        if (this.neverExpires) {
            return;
        }
        this.expire();
    }
    expire() {
        this.cacheVersion++;
    }
    setValue(rowNode, colId, value) {
        if (this.active) {
            const cacheVersion = this.cacheVersion;
            if (rowNode.__cacheVersion !== cacheVersion) {
                rowNode.__cacheVersion = cacheVersion;
                rowNode.__cacheData = {};
            }
            rowNode.__cacheData[colId] = value;
        }
    }
    getValue(rowNode, colId) {
        if (!this.active || rowNode.__cacheVersion !== this.cacheVersion) {
            return undefined;
        }
        return rowNode.__cacheData[colId];
    }
}
exports.ValueCache = ValueCache;


/***/ }),

/***/ 76431:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CellApiModule = exports.ChangeDetectionModule = exports.ExpressionModule = exports.ValueCacheModule = void 0;
const version_1 = __webpack_require__(97205);
const cellApi_1 = __webpack_require__(17486);
const changeDetectionService_1 = __webpack_require__(52878);
const expressionService_1 = __webpack_require__(45751);
const valueCache_1 = __webpack_require__(53913);
/**
 * @feature Performance -> Value Cache
 * @gridOption valueCache
 */
exports.ValueCacheModule = {
    moduleName: 'ValueCache',
    version: version_1.VERSION,
    beans: [valueCache_1.ValueCache],
    apiFunctions: {
        expireValueCache: cellApi_1.expireValueCache,
    },
};
/**
 * @feature Cells -> Expression
 */
exports.ExpressionModule = {
    moduleName: 'Expression',
    version: version_1.VERSION,
    beans: [expressionService_1.ExpressionService],
};
/**
 * @feature Change Detection
 * @gridOption suppressChangeDetection
 */
exports.ChangeDetectionModule = {
    moduleName: 'ChangeDetection',
    version: version_1.VERSION,
    beans: [changeDetectionService_1.ChangeDetectionService],
};
/**
 * @feature Cells -> API
 */
exports.CellApiModule = {
    moduleName: 'CellApi',
    version: version_1.VERSION,
    apiFunctions: {
        getCellValue: cellApi_1.getCellValue,
    },
};


/***/ }),

/***/ 35736:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ValueService = void 0;
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const generic_1 = __webpack_require__(34422);
const object_1 = __webpack_require__(6996);
const logging_1 = __webpack_require__(47764);
const EDITING_CHECK_SIBLINGS = { checkSiblings: true };
class ValueService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'valueSvc';
        this.hasEdit = false;
        this.initialised = false;
        this.isSsrm = false;
    }
    wireBeans(beans) {
        this.expressionSvc = beans.expressionSvc;
        this.colModel = beans.colModel;
        this.valueCache = beans.valueCache;
        this.dataTypeSvc = beans.dataTypeSvc;
        this.editSvc = beans.editSvc;
        this.hasEdit = !!beans.editSvc;
    }
    postConstruct() {
        if (!this.initialised) {
            this.init();
        }
    }
    init() {
        this.executeValueGetter = this.valueCache
            ? this.executeValueGetterWithValueCache.bind(this)
            : this.executeValueGetterWithoutValueCache.bind(this);
        this.isSsrm = (0, gridOptionsUtils_1._isServerSideRowModel)(this.gos);
        this.cellExpressions = this.gos.get('enableCellExpressions');
        this.isTreeData = this.gos.get('treeData');
        this.initialised = true;
        // We listen to our own event and use it to call the columnSpecific callback,
        // this way the handler calls are correctly interleaved with other global events
        const listener = (event) => this.callColumnCellValueChangedHandler(event);
        this.eventSvc.addEventListener('cellValueChanged', listener, true);
        this.addDestroyFunc(() => this.eventSvc.removeEventListener('cellValueChanged', listener, true));
        this.addManagedPropertyListener('treeData', (propChange) => (this.isTreeData = propChange.currentValue));
    }
    /**
     * Use this function to get a displayable cell value.
     * The values from this function are not used for sorting, filtering, or aggregation purposes.
     * Handles: groupHideOpenParents, showOpenedGroup and groupSuppressBlankHeader behaviours
     */
    getValueForDisplay(column, node, includeValueFormatted = false, exporting = false, source = 'ui') {
        const { showRowGroupColValueSvc } = this.beans;
        const isFullWidthGroup = !column && node.group;
        const isGroupCol = column?.colDef.showRowGroup;
        // Tree data auto col acts as a traditional column, with the exception of footers, so only process footers with
        // showRowGroupColValueSvc
        const processTreeDataAsGroup = !this.isTreeData || node.footer;
        // handle group cell value
        if (showRowGroupColValueSvc && processTreeDataAsGroup && (isFullWidthGroup || isGroupCol)) {
            const groupValue = showRowGroupColValueSvc.getGroupValue(node, column);
            if (groupValue == null) {
                return {
                    value: null,
                    valueFormatted: null,
                };
            }
            if (!includeValueFormatted) {
                return {
                    value: groupValue.value,
                    valueFormatted: null,
                };
            }
            const valueFormatted = showRowGroupColValueSvc.formatAndPrefixGroupColValue(groupValue, column, exporting);
            return {
                value: groupValue.value,
                valueFormatted,
            };
        }
        // full width row, not full width group - probably should be supported by getValue
        if (!column) {
            return {
                value: node.key,
                valueFormatted: null,
            };
        }
        // when in pivot mode, leafGroups cannot be expanded
        const isPivotLeaf = node.leafGroup && this.colModel.isPivotMode();
        const isOpenedGroup = node.group && node.expanded && !node.footer && !isPivotLeaf;
        // checks if we show header data
        const groupShowsAggData = this.gos.get('groupSuppressBlankHeader') || !node.sibling;
        // if doing grouping and footers, we don't want to include the agg value
        // in the header when the group is open
        const ignoreAggData = isOpenedGroup && !groupShowsAggData;
        const value = this.getValue(column, node, ignoreAggData, source);
        const format = includeValueFormatted && !(exporting && column.colDef.useValueFormatterForExport === false);
        return {
            value,
            valueFormatted: format ? this.formatValue(column, node, value) : null,
        };
    }
    getValue(column, rowNode, ignoreAggData = false, source = 'ui') {
        // hack - the grid is getting refreshed before this bean gets initialised, race condition.
        // really should have a way so they get initialised in the right order???
        if (!this.initialised) {
            this.init();
        }
        if (!rowNode) {
            return;
        }
        // pull these out to make code below easier to read
        const colDef = column.getColDef();
        const field = colDef.field;
        const colId = column.getColId();
        let data = rowNode.data;
        if (this.hasEdit && source === 'ui') {
            const editSvc = this.editSvc;
            // if the row is editing, make sure we sync data fields with any pending values, for display purposes
            if (editSvc.isRowEditing(rowNode, EDITING_CHECK_SIBLINGS)) {
                data = editSvc.getRowDataValue(rowNode, EDITING_CHECK_SIBLINGS);
            }
            // if the row is editing, we want to return the new value, if available
            if (editSvc.isEditing()) {
                const newValue = editSvc.getCellDataValue({ rowNode, column });
                if (newValue !== undefined) {
                    return newValue;
                }
            }
        }
        let result;
        // when using multiple columns, the group column should have no value higher than its level
        const rowGroupColId = colDef.showRowGroup;
        if (typeof rowGroupColId === 'string') {
            // if multiple columns, don't show values in cells grouped at a higher level
            const colRowGroupIndex = this.beans.rowGroupColsSvc?.getColumnIndex(rowGroupColId) ?? -1;
            if (colRowGroupIndex > rowNode.level) {
                return null;
            }
        }
        // don't retrieve group values from field or valueGetter for multiple auto cols
        const allowUserValuesForCell = typeof rowGroupColId !== 'string' || !rowNode.group;
        // if there is a value getter, this gets precedence over a field
        const groupDataExists = rowNode.groupData && colId in rowNode.groupData;
        const aggDataExists = !ignoreAggData && rowNode.aggData && rowNode.aggData[colId] !== undefined;
        // SSRM agg data comes from the data attribute, so ignore that instead
        const ignoreSsrmAggData = this.isSsrm && ignoreAggData && !!colDef.aggFunc;
        const ssrmFooterGroupCol = this.isSsrm &&
            rowNode.footer &&
            rowNode.field &&
            (colDef.showRowGroup === true || colDef.showRowGroup === rowNode.field);
        if (this.isTreeData && aggDataExists) {
            result = rowNode.aggData[colId];
        }
        else if (this.isTreeData && colDef.valueGetter) {
            result = this.executeValueGetter(colDef.valueGetter, data, column, rowNode);
        }
        else if (this.isTreeData && field && data) {
            result = (0, object_1._getValueUsingField)(data, field, column.isFieldContainsDots());
        }
        else if (groupDataExists) {
            result = rowNode.groupData[colId];
        }
        else if (aggDataExists) {
            result = rowNode.aggData[colId];
        }
        else if (colDef.valueGetter && !ignoreSsrmAggData) {
            if (!allowUserValuesForCell) {
                return result;
            }
            result = this.executeValueGetter(colDef.valueGetter, data, column, rowNode);
        }
        else if (ssrmFooterGroupCol) {
            // this is for group footers in SSRM, as the SSRM row won't have groupData, need to extract
            // the group value from the data using the row field
            result = (0, object_1._getValueUsingField)(data, rowNode.field, column.isFieldContainsDots());
        }
        else if (field && data && !ignoreSsrmAggData) {
            if (!allowUserValuesForCell) {
                return result;
            }
            result = (0, object_1._getValueUsingField)(data, field, column.isFieldContainsDots());
        }
        // the result could be an expression itself, if we are allowing cell values to be expressions
        if (this.cellExpressions && typeof result === 'string' && result.indexOf('=') === 0) {
            const cellValueGetter = result.substring(1);
            result = this.executeValueGetter(cellValueGetter, data, column, rowNode);
        }
        return result;
    }
    parseValue(column, rowNode, newValue, oldValue) {
        const colDef = column.getColDef();
        const valueParser = colDef.valueParser;
        if ((0, generic_1._exists)(valueParser)) {
            const params = (0, gridOptionsUtils_1._addGridCommonParams)(this.gos, {
                node: rowNode,
                data: rowNode?.data,
                oldValue,
                newValue,
                colDef,
                column,
            });
            if (typeof valueParser === 'function') {
                return valueParser(params);
            }
            return this.expressionSvc?.evaluate(valueParser, params);
        }
        return newValue;
    }
    getDeleteValue(column, rowNode) {
        if ((0, generic_1._exists)(column.getColDef().valueParser)) {
            return this.parseValue(column, rowNode, '', this.getValueForDisplay(column, rowNode).value) ?? null;
        }
        return null;
    }
    formatValue(column, node, value, suppliedFormatter, useFormatterFromColumn = true) {
        const { expressionSvc } = this.beans;
        let result = null;
        let formatter;
        const colDef = column.getColDef();
        if (suppliedFormatter) {
            // use supplied formatter if provided, e.g. set filter items can have their own value formatters
            formatter = suppliedFormatter;
        }
        else if (useFormatterFromColumn) {
            formatter = colDef.valueFormatter;
        }
        if (formatter) {
            let data = node ? node.data : null;
            if (node) {
                const position = { rowNode: node };
                if (this.hasEdit) {
                    const editSvc = this.editSvc;
                    if (editSvc.isEditing(position, EDITING_CHECK_SIBLINGS)) {
                        // if editing, then use the edited value, not the value from the data
                        data = editSvc.getRowDataValue(node, EDITING_CHECK_SIBLINGS);
                    }
                }
            }
            const params = (0, gridOptionsUtils_1._addGridCommonParams)(this.gos, {
                value,
                node,
                data,
                colDef,
                column,
            });
            if (typeof formatter === 'function') {
                result = formatter(params);
            }
            else {
                result = expressionSvc ? expressionSvc.evaluate(formatter, params) : null;
            }
        }
        else if (colDef.refData) {
            return colDef.refData[value] || '';
        }
        // if we don't do this, then arrays get displayed as 1,2,3, but we want 1, 2, 3 (i.e. with spaces)
        if (result == null && Array.isArray(value)) {
            result = value.join(', ');
        }
        return result;
    }
    /**
     * Sets the value of a GridCell
     * @param rowNode The `RowNode` to be updated
     * @param colKey The `Column` to be updated
     * @param newValue The new value to be set
     * @param eventSource The event source
     * @returns `True` if the value has been updated, otherwise`False`.
     */
    setValue(rowNode, colKey, newValue, eventSource) {
        const column = this.colModel.getColDefCol(colKey);
        if (!rowNode || !column) {
            return false;
        }
        // this happens when enableGroupEdit is turned on and editing is performed on group rows
        if ((0, generic_1._missing)(rowNode.data)) {
            rowNode.data = {};
        }
        const { field, valueSetter } = column.getColDef();
        if ((0, generic_1._missing)(field) && (0, generic_1._missing)(valueSetter)) {
            (0, logging_1._warn)(17);
            return false;
        }
        if (this.dataTypeSvc && !this.dataTypeSvc.checkType(column, newValue)) {
            (0, logging_1._warn)(135);
            return false;
        }
        const params = (0, gridOptionsUtils_1._addGridCommonParams)(this.gos, {
            node: rowNode,
            data: rowNode.data,
            oldValue: this.getValue(column, rowNode, undefined, eventSource),
            newValue: newValue,
            colDef: column.getColDef(),
            column: column,
        });
        params.newValue = newValue;
        let valueWasDifferent;
        if ((0, generic_1._exists)(valueSetter)) {
            if (typeof valueSetter === 'function') {
                valueWasDifferent = valueSetter(params);
            }
            else {
                valueWasDifferent = this.expressionSvc?.evaluate(valueSetter, params);
            }
        }
        else {
            valueWasDifferent = this.setValueUsingField(rowNode.data, field, newValue, column.isFieldContainsDots());
        }
        // in case user forgot to return something (possible if they are not using TypeScript
        // and just forgot we default the return value to true, so we always refresh.
        if (valueWasDifferent === undefined) {
            valueWasDifferent = true;
        }
        // if no change to the value, then no need to do the updating, or notifying via events.
        // otherwise the user could be tabbing around the grid, and cellValueChange would get called
        // all the time.
        if (!valueWasDifferent) {
            return false;
        }
        // reset quick filter on this row
        rowNode.resetQuickFilterAggregateText();
        this.valueCache?.onDataChanged();
        const savedValue = this.getValue(column, rowNode);
        this.dispatchCellValueChangedEvent(rowNode, params, savedValue, eventSource);
        if (rowNode.pinnedSibling) {
            this.dispatchCellValueChangedEvent(rowNode.pinnedSibling, params, savedValue, eventSource);
        }
        return true;
    }
    dispatchCellValueChangedEvent(rowNode, params, value, source) {
        this.eventSvc.dispatchEvent({
            type: 'cellValueChanged',
            event: null,
            rowIndex: rowNode.rowIndex,
            rowPinned: rowNode.rowPinned,
            column: params.column,
            colDef: params.colDef,
            data: rowNode.data,
            node: rowNode,
            oldValue: params.oldValue,
            newValue: value,
            value,
            source,
        });
    }
    callColumnCellValueChangedHandler(event) {
        const onCellValueChanged = event.colDef.onCellValueChanged;
        if (typeof onCellValueChanged === 'function') {
            this.beans.frameworkOverrides.wrapOutgoing(() => {
                onCellValueChanged({
                    node: event.node,
                    data: event.data,
                    oldValue: event.oldValue,
                    newValue: event.newValue,
                    colDef: event.colDef,
                    column: event.column,
                    api: event.api,
                    context: event.context,
                });
            });
        }
    }
    setValueUsingField(data, field, newValue, isFieldContainsDots) {
        if (!field) {
            return false;
        }
        // if no '.', then it's not a deep value
        let valuesAreSame = false;
        if (!isFieldContainsDots) {
            valuesAreSame = data[field] === newValue;
            if (!valuesAreSame) {
                data[field] = newValue;
            }
        }
        else {
            // otherwise it is a deep value, so need to dig for it
            const fieldPieces = field.split('.');
            let currentObject = data;
            while (fieldPieces.length > 0 && currentObject) {
                const fieldPiece = fieldPieces.shift();
                if (fieldPieces.length === 0) {
                    valuesAreSame = currentObject[fieldPiece] === newValue;
                    if (!valuesAreSame) {
                        currentObject[fieldPiece] = newValue;
                    }
                }
                else {
                    currentObject = currentObject[fieldPiece];
                }
            }
        }
        return !valuesAreSame;
    }
    executeValueGetterWithValueCache(
    // eslint-disable-next-line @typescript-eslint/ban-types
    valueGetter, data, column, rowNode) {
        const colId = column.getColId();
        // if inside the same turn, just return back the value we got last time
        const valueFromCache = this.valueCache.getValue(rowNode, colId);
        if (valueFromCache !== undefined) {
            return valueFromCache;
        }
        const result = this.executeValueGetterWithoutValueCache(valueGetter, data, column, rowNode);
        // if a turn is active, store the value in case the grid asks for it again
        this.valueCache.setValue(rowNode, colId, result);
        return result;
    }
    executeValueGetterWithoutValueCache(
    // eslint-disable-next-line @typescript-eslint/ban-types
    valueGetter, data, column, rowNode) {
        const params = (0, gridOptionsUtils_1._addGridCommonParams)(this.gos, {
            data: data,
            node: rowNode,
            column: column,
            colDef: column.getColDef(),
            getValue: this.getValueCallback.bind(this, rowNode),
        });
        let result;
        if (typeof valueGetter === 'function') {
            result = valueGetter(params);
        }
        else {
            result = this.expressionSvc?.evaluate(valueGetter, params);
        }
        return result;
    }
    getValueCallback(node, field) {
        const otherColumn = this.colModel.getColDefCol(field);
        if (otherColumn) {
            return this.getValue(otherColumn, node);
        }
        return null;
    }
    // used by row grouping and pivot, to get key for a row. col can be a pivot col or a row grouping col
    getKeyForNode(col, rowNode) {
        const value = this.getValue(col, rowNode);
        const keyCreator = col.getColDef().keyCreator;
        let result = value;
        if (keyCreator) {
            const keyParams = (0, gridOptionsUtils_1._addGridCommonParams)(this.gos, {
                value: value,
                colDef: col.getColDef(),
                column: col,
                node: rowNode,
                data: rowNode.data,
            });
            result = keyCreator(keyParams);
        }
        // if already a string, or missing, just return it
        if (typeof result === 'string' || result == null) {
            return result;
        }
        result = String(result);
        if (result === '[object Object]') {
            (0, logging_1._warn)(121);
        }
        return result;
    }
}
exports.ValueService = ValueService;


/***/ }),

/***/ 56511:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VanillaFrameworkOverrides = void 0;
const baseUrl_1 = __webpack_require__(83263);
const event_1 = __webpack_require__(92979);
const promise_1 = __webpack_require__(57990);
const logging_1 = __webpack_require__(47764);
/** The base frameworks, eg React & Angular, override this bean with implementations specific to their requirement. */
class VanillaFrameworkOverrides {
    constructor(frameworkName = 'javascript') {
        this.frameworkName = frameworkName;
        this.renderingEngine = 'vanilla';
        this.batchFrameworkComps = false;
        this.wrapIncoming = (callback) => callback();
        this.wrapOutgoing = (callback) => callback();
        this.baseDocLink = `${baseUrl_1.BASE_URL}/${this.frameworkName}-data-grid`;
        (0, logging_1.setValidationDocLink)(this.baseDocLink);
    }
    setInterval(action, timeout) {
        return new promise_1.AgPromise((resolve) => {
            resolve(window.setInterval(action, timeout));
        });
    }
    // for Vanilla JS, we just add the event to the element
    addEventListener(element, type, listener, options) {
        let eventListenerOptions = {};
        if (typeof options === 'object') {
            eventListenerOptions = options;
        }
        else if (typeof options === 'boolean') {
            eventListenerOptions = { capture: options };
        }
        if (eventListenerOptions.passive == null) {
            const passive = (0, event_1.getPassiveStateForEvent)(type);
            if (passive != null) {
                eventListenerOptions.passive = passive;
            }
        }
        element.addEventListener(type, listener, eventListenerOptions);
    }
    frameworkComponent(_) {
        return null;
    }
    isFrameworkComponent(_) {
        return false;
    }
    getDocLink(path) {
        return `${this.baseDocLink}${path ? `/${path}` : ''}`;
    }
}
exports.VanillaFrameworkOverrides = VanillaFrameworkOverrides;


/***/ }),

/***/ 97205:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VERSION = void 0;
// DO NOT UPDATE MANUALLY: Generated from script during build time
exports.VERSION = '34.0.0';


/***/ }),

/***/ 94872:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgAbstractCellEditor = void 0;
const popupComponent_1 = __webpack_require__(63598);
class AgAbstractCellEditor extends popupComponent_1.PopupComponent {
    constructor() {
        super(...arguments);
        this.errorMessages = null;
    }
    init(params) {
        this.params = params;
        this.initialiseEditor(params);
        this.eEditor.onValueChange(() => params.validate());
    }
    destroy() {
        this.errorMessages = null;
    }
}
exports.AgAbstractCellEditor = AgAbstractCellEditor;


/***/ }),

/***/ 37321:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgAbstractField = void 0;
const aria_1 = __webpack_require__(95230);
const dom_1 = __webpack_require__(33507);
const agAbstractLabel_1 = __webpack_require__(72747);
class AgAbstractField extends agAbstractLabel_1.AgAbstractLabel {
    constructor(config, template, components, className) {
        super(config, template, components);
        this.className = className;
    }
    postConstruct() {
        super.postConstruct();
        const { width, value, onValueChange } = this.config;
        if (width != null) {
            this.setWidth(width);
        }
        if (value != null) {
            this.setValue(value);
        }
        if (onValueChange != null) {
            this.onValueChange(onValueChange);
        }
        if (this.className) {
            this.addCss(this.className);
        }
        this.refreshAriaLabelledBy();
    }
    setLabel(label) {
        super.setLabel(label);
        this.refreshAriaLabelledBy();
        return this;
    }
    refreshAriaLabelledBy() {
        const ariaEl = this.getAriaElement();
        const labelId = this.getLabelId();
        const label = this.getLabel();
        if (label == null || label == '' || (0, aria_1._getAriaLabel)(ariaEl) !== null) {
            (0, aria_1._setAriaLabelledBy)(ariaEl, '');
        }
        else {
            (0, aria_1._setAriaLabelledBy)(ariaEl, labelId ?? '');
        }
    }
    setAriaLabel(label) {
        (0, aria_1._setAriaLabel)(this.getAriaElement(), label);
        this.refreshAriaLabelledBy();
        return this;
    }
    onValueChange(callbackFn) {
        this.addManagedListeners(this, { fieldValueChanged: () => callbackFn(this.getValue()) });
        return this;
    }
    getWidth() {
        return this.getGui().clientWidth;
    }
    setWidth(width) {
        (0, dom_1._setFixedWidth)(this.getGui(), width);
        return this;
    }
    getPreviousValue() {
        return this.previousValue;
    }
    getValue() {
        return this.value;
    }
    setValue(value, silent) {
        if (this.value === value) {
            return this;
        }
        this.previousValue = this.value;
        this.value = value;
        if (!silent) {
            this.dispatchLocalEvent({ type: 'fieldValueChanged' });
        }
        return this;
    }
}
exports.AgAbstractField = AgAbstractField;


/***/ }),

/***/ 98085:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgAbstractInputField = void 0;
const aria_1 = __webpack_require__(95230);
const dom_1 = __webpack_require__(33507);
const agAbstractField_1 = __webpack_require__(37321);
const component_1 = __webpack_require__(78020);
function buildTemplate(displayFieldTag) {
    return {
        tag: 'div',
        role: 'presentation',
        children: [
            { tag: 'div', ref: 'eLabel', cls: 'ag-input-field-label' },
            {
                tag: 'div',
                ref: 'eWrapper',
                cls: 'ag-wrapper ag-input-wrapper',
                role: 'presentation',
                children: [{ tag: displayFieldTag, ref: 'eInput', cls: 'ag-input-field-input' }],
            },
        ],
    };
}
class AgAbstractInputField extends agAbstractField_1.AgAbstractField {
    constructor(config, className, inputType = 'text', displayFieldTag = 'input') {
        super(config, config?.template ?? buildTemplate(displayFieldTag), [], className);
        this.inputType = inputType;
        this.displayFieldTag = displayFieldTag;
        this.eLabel = component_1.RefPlaceholder;
        this.eWrapper = component_1.RefPlaceholder;
        this.eInput = component_1.RefPlaceholder;
    }
    postConstruct() {
        super.postConstruct();
        this.setInputType(this.inputType);
        const { eLabel, eWrapper, eInput, className } = this;
        eLabel.classList.add(`${className}-label`);
        eWrapper.classList.add(`${className}-input-wrapper`);
        eInput.classList.add(`${className}-input`);
        this.addCss('ag-input-field');
        eInput.id = eInput.id || `ag-${this.getCompId()}-input`;
        const { inputName, inputWidth } = this.config;
        if (inputName != null) {
            this.setInputName(inputName);
        }
        if (inputWidth != null) {
            this.setInputWidth(inputWidth);
        }
        this.addInputListeners();
        this.activateTabIndex([eInput]);
    }
    addInputListeners() {
        this.addManagedElementListeners(this.eInput, {
            input: (e) => this.setValue(e.target.value),
        });
    }
    setInputType(inputType) {
        if (this.displayFieldTag === 'input') {
            this.inputType = inputType;
            (0, dom_1._addOrRemoveAttribute)(this.eInput, 'type', inputType);
        }
    }
    getInputElement() {
        return this.eInput;
    }
    setInputWidth(width) {
        (0, dom_1._setElementWidth)(this.eWrapper, width);
        return this;
    }
    setInputName(name) {
        this.getInputElement().setAttribute('name', name);
        return this;
    }
    getFocusableElement() {
        return this.eInput;
    }
    setMaxLength(length) {
        const eInput = this.eInput;
        eInput.maxLength = length;
        return this;
    }
    setInputPlaceholder(placeholder) {
        (0, dom_1._addOrRemoveAttribute)(this.eInput, 'placeholder', placeholder);
        return this;
    }
    setInputAriaLabel(label) {
        (0, aria_1._setAriaLabel)(this.eInput, label);
        this.refreshAriaLabelledBy();
        return this;
    }
    setDisabled(disabled) {
        (0, dom_1._setDisabled)(this.eInput, disabled);
        return super.setDisabled(disabled);
    }
    setAutoComplete(value) {
        if (value === true) {
            // Remove the autocomplete attribute if the value is explicitly set to true
            // to allow the default browser autocomplete/autofill behaviour.
            (0, dom_1._addOrRemoveAttribute)(this.eInput, 'autocomplete', null);
        }
        else {
            // When a string is provided, use it as the value of the autocomplete attribute.
            // This enables users to specify how they want to the browser to handle the autocomplete on the input, as per spec:
            // https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete#values
            const autoCompleteValue = typeof value === 'string' ? value : 'off';
            (0, dom_1._addOrRemoveAttribute)(this.eInput, 'autocomplete', autoCompleteValue);
        }
        return this;
    }
}
exports.AgAbstractInputField = AgAbstractInputField;


/***/ }),

/***/ 92178:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.agAbstractLabelCSS = void 0;
exports.agAbstractLabelCSS = `.ag-label{white-space:nowrap}:where(.ag-ltr) .ag-label{margin-right:var(--ag-spacing)}:where(.ag-rtl) .ag-label{margin-left:var(--ag-spacing)}:where(.ag-label-align-right) .ag-label{order:1}:where(.ag-ltr) :where(.ag-label-align-right) .ag-label{margin-left:var(--ag-spacing)}:where(.ag-rtl) :where(.ag-label-align-right) .ag-label{margin-right:var(--ag-spacing)}.ag-label-align-right>*{flex:none}.ag-label-align-top{align-items:flex-start;flex-direction:column;>*{align-self:stretch}}.ag-label-ellipsis{flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}:where(.ag-label-align-top) .ag-label{margin-bottom:calc(var(--ag-spacing)*.5)}`;


/***/ }),

/***/ 72747:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgAbstractLabel = void 0;
const aria_1 = __webpack_require__(95230);
const dom_1 = __webpack_require__(33507);
const agAbstractLabel_css_GENERATED_1 = __webpack_require__(92178);
const component_1 = __webpack_require__(78020);
class AgAbstractLabel extends component_1.Component {
    constructor(config, template, components) {
        super(template, components);
        this.labelSeparator = '';
        this.labelAlignment = 'left';
        this.disabled = false;
        this.label = '';
        this.config = config || {};
        this.registerCSS(agAbstractLabel_css_GENERATED_1.agAbstractLabelCSS);
    }
    postConstruct() {
        this.addCss('ag-labeled');
        this.eLabel.classList.add('ag-label');
        const { labelSeparator, label, labelWidth, labelAlignment, disabled } = this.config;
        if (disabled != null) {
            this.setDisabled(disabled);
        }
        if (labelSeparator != null) {
            this.setLabelSeparator(labelSeparator);
        }
        if (label != null) {
            this.setLabel(label);
        }
        if (labelWidth != null) {
            this.setLabelWidth(labelWidth);
        }
        this.setLabelAlignment(labelAlignment || this.labelAlignment);
        this.refreshLabel();
    }
    refreshLabel() {
        const { label, eLabel } = this;
        (0, dom_1._clearElement)(eLabel);
        if (typeof label === 'string') {
            // eslint-disable-next-line no-restricted-properties -- Could swap to textContent, but could be a breaking change
            eLabel.innerText = label + this.labelSeparator;
        }
        else if (label) {
            eLabel.appendChild(label);
        }
        if (label === '') {
            (0, dom_1._setDisplayed)(eLabel, false);
            (0, aria_1._setAriaRole)(eLabel, 'presentation');
        }
        else {
            (0, dom_1._setDisplayed)(eLabel, true);
            (0, aria_1._setAriaRole)(eLabel, null);
        }
    }
    setLabelSeparator(labelSeparator) {
        if (this.labelSeparator === labelSeparator) {
            return this;
        }
        this.labelSeparator = labelSeparator;
        if (this.label != null) {
            this.refreshLabel();
        }
        return this;
    }
    getLabelId() {
        const eLabel = this.eLabel;
        eLabel.id = eLabel.id || `ag-${this.getCompId()}-label`;
        return eLabel.id;
    }
    getLabel() {
        return this.label;
    }
    setLabel(label) {
        if (this.label === label) {
            return this;
        }
        this.label = label;
        this.refreshLabel();
        return this;
    }
    setLabelAlignment(alignment) {
        const eGui = this.getGui();
        const eGuiClassList = eGui.classList;
        eGuiClassList.toggle('ag-label-align-left', alignment === 'left');
        eGuiClassList.toggle('ag-label-align-right', alignment === 'right');
        eGuiClassList.toggle('ag-label-align-top', alignment === 'top');
        return this;
    }
    setLabelEllipsis(hasEllipsis) {
        this.eLabel.classList.toggle('ag-label-ellipsis', hasEllipsis);
        return this;
    }
    setLabelWidth(width) {
        if (this.label == null) {
            return this;
        }
        (0, dom_1._setElementWidth)(this.eLabel, width);
        return this;
    }
    setDisabled(disabled) {
        disabled = !!disabled;
        const element = this.getGui();
        (0, dom_1._setDisabled)(element, disabled);
        element.classList.toggle('ag-disabled', disabled);
        this.disabled = disabled;
        return this;
    }
    isDisabled() {
        return !!this.disabled;
    }
}
exports.AgAbstractLabel = AgAbstractLabel;


/***/ }),

/***/ 90066:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgCheckboxSelector = exports.AgCheckbox = void 0;
const agAbstractInputField_1 = __webpack_require__(98085);
class AgCheckbox extends agAbstractInputField_1.AgAbstractInputField {
    constructor(config, className = 'ag-checkbox', inputType = 'checkbox') {
        super(config, className, inputType);
        this.labelAlignment = 'right';
        this.selected = false;
        this.readOnly = false;
        this.passive = false;
    }
    postConstruct() {
        super.postConstruct();
        const { readOnly, passive } = this.config;
        if (typeof readOnly === 'boolean')
            this.setReadOnly(readOnly);
        if (typeof passive === 'boolean')
            this.setPassive(passive);
    }
    addInputListeners() {
        this.addManagedElementListeners(this.eInput, { click: this.onCheckboxClick.bind(this) });
        this.addManagedElementListeners(this.eLabel, { click: this.toggle.bind(this) });
    }
    getNextValue() {
        return this.selected === undefined ? true : !this.selected;
    }
    setPassive(passive) {
        this.passive = passive;
    }
    isReadOnly() {
        return this.readOnly;
    }
    setReadOnly(readOnly) {
        this.eWrapper.classList.toggle('ag-disabled', readOnly);
        this.eInput.disabled = readOnly;
        this.readOnly = readOnly;
    }
    setDisabled(disabled) {
        this.eWrapper.classList.toggle('ag-disabled', disabled);
        return super.setDisabled(disabled);
    }
    toggle() {
        if (this.eInput.disabled) {
            return;
        }
        const previousValue = this.isSelected();
        const nextValue = this.getNextValue();
        if (this.passive) {
            this.dispatchChange(nextValue, previousValue);
        }
        else {
            this.setValue(nextValue);
        }
    }
    getValue() {
        return this.isSelected();
    }
    setValue(value, silent) {
        this.refreshSelectedClass(value);
        this.setSelected(value, silent);
        return this;
    }
    setName(name) {
        const input = this.getInputElement();
        input.name = name;
        return this;
    }
    isSelected() {
        return this.selected;
    }
    setSelected(selected, silent) {
        if (this.isSelected() === selected) {
            return;
        }
        this.previousValue = this.isSelected();
        selected = this.selected = typeof selected === 'boolean' ? selected : undefined;
        const eInput = this.eInput;
        eInput.checked = selected;
        eInput.indeterminate = selected === undefined;
        if (!silent) {
            this.dispatchChange(this.selected, this.previousValue);
        }
    }
    dispatchChange(selected, previousValue, event) {
        this.dispatchLocalEvent({ type: 'fieldValueChanged', selected, previousValue, event });
        const input = this.getInputElement();
        this.eventSvc.dispatchEvent({
            type: 'checkboxChanged',
            id: input.id,
            name: input.name,
            selected,
            previousValue,
        });
    }
    onCheckboxClick(e) {
        if (this.passive || this.eInput.disabled) {
            return;
        }
        const previousValue = this.isSelected();
        const selected = (this.selected = e.target.checked);
        this.refreshSelectedClass(selected);
        this.dispatchChange(selected, previousValue, e);
    }
    refreshSelectedClass(value) {
        const classList = this.eWrapper.classList;
        classList.toggle('ag-checked', value === true);
        classList.toggle('ag-indeterminate', value == null);
    }
}
exports.AgCheckbox = AgCheckbox;
exports.AgCheckboxSelector = {
    selector: 'AG-CHECKBOX',
    component: AgCheckbox,
};


/***/ }),

/***/ 23611:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgInputDateFieldSelector = exports.AgInputDateField = void 0;
const gridOptionsUtils_1 = __webpack_require__(67274);
const browser_1 = __webpack_require__(98667);
const date_1 = __webpack_require__(39827);
const dom_1 = __webpack_require__(33507);
const agInputTextField_1 = __webpack_require__(45946);
class AgInputDateField extends agInputTextField_1.AgInputTextField {
    constructor(config) {
        super(config, 'ag-date-field', 'date');
    }
    postConstruct() {
        super.postConstruct();
        // ensures that the input element is focussed when a clear button is clicked,
        // unless using safari as there is no clear button and focus does not work properly
        const usingSafari = (0, browser_1._isBrowserSafari)();
        this.addManagedListeners(this.eInput, {
            wheel: this.onWheel.bind(this),
            mousedown: () => {
                if (this.isDisabled() || usingSafari) {
                    return;
                }
                this.eInput.focus();
            },
        });
        this.eInput.step = 'any';
    }
    onWheel(e) {
        // Prevent default scroll events from incrementing / decrementing the input, since its inconsistent between browsers
        if ((0, gridOptionsUtils_1._getActiveDomElement)(this.beans) === this.eInput) {
            e.preventDefault();
        }
    }
    setMin(minDate) {
        const min = minDate instanceof Date ? (0, date_1._serialiseDate)(minDate ?? null, !!this.includeTime) ?? undefined : minDate;
        if (this.min === min) {
            return this;
        }
        this.min = min;
        (0, dom_1._addOrRemoveAttribute)(this.eInput, 'min', min);
        return this;
    }
    setMax(maxDate) {
        const max = maxDate instanceof Date ? (0, date_1._serialiseDate)(maxDate ?? null, !!this.includeTime) ?? undefined : maxDate;
        if (this.max === max) {
            return this;
        }
        this.max = max;
        (0, dom_1._addOrRemoveAttribute)(this.eInput, 'max', max);
        return this;
    }
    setStep(step) {
        if (this.step === step) {
            return this;
        }
        this.step = step;
        (0, dom_1._addOrRemoveAttribute)(this.eInput, 'step', step);
        return this;
    }
    setIncludeTime(includeTime) {
        if (this.includeTime === includeTime) {
            return this;
        }
        this.includeTime = includeTime;
        super.setInputType(includeTime ? 'datetime-local' : 'date');
        if (includeTime)
            this.setStep(1);
        return this;
    }
    getDate() {
        if (!this.eInput.validity.valid) {
            return undefined;
        }
        return (0, date_1._parseDateTimeFromString)(this.getValue()) ?? undefined;
    }
    setDate(date, silent) {
        this.setValue((0, date_1._serialiseDate)(date ?? null, this.includeTime), silent);
    }
}
exports.AgInputDateField = AgInputDateField;
exports.AgInputDateFieldSelector = {
    selector: 'AG-INPUT-DATE-FIELD',
    component: AgInputDateField,
};


/***/ }),

/***/ 18792:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgInputNumberFieldSelector = exports.AgInputNumberField = void 0;
const gridOptionsUtils_1 = __webpack_require__(67274);
const dom_1 = __webpack_require__(33507);
const generic_1 = __webpack_require__(34422);
const agInputTextField_1 = __webpack_require__(45946);
class AgInputNumberField extends agInputTextField_1.AgInputTextField {
    constructor(config) {
        super(config, 'ag-number-field', 'number');
    }
    postConstruct() {
        super.postConstruct();
        const eInput = this.eInput;
        this.addManagedListeners(eInput, {
            blur: () => {
                const floatedValue = parseFloat(eInput.value);
                const value = isNaN(floatedValue) ? '' : this.normalizeValue(floatedValue.toString());
                if (this.value !== value) {
                    this.setValue(value);
                }
            },
            wheel: this.onWheel.bind(this),
        });
        eInput.step = 'any';
        const { precision, min, max, step } = this.config;
        if (typeof precision === 'number')
            this.setPrecision(precision);
        if (typeof min === 'number')
            this.setMin(min);
        if (typeof max === 'number')
            this.setMax(max);
        if (typeof step === 'number')
            this.setStep(step);
    }
    onWheel(e) {
        // Prevent default scroll events from incrementing / decrementing the input, since its inconsistent between browsers
        if ((0, gridOptionsUtils_1._getActiveDomElement)(this.beans) === this.eInput) {
            e.preventDefault();
        }
    }
    normalizeValue(value) {
        if (value === '') {
            return '';
        }
        if (this.precision != null) {
            value = this.adjustPrecision(value);
        }
        return value;
    }
    adjustPrecision(value, isScientificNotation) {
        const precision = this.precision;
        if (precision == null) {
            return value;
        }
        if (isScientificNotation) {
            const floatString = parseFloat(value).toFixed(precision);
            return parseFloat(floatString).toString();
        }
        // can't use toFixed here because we don't want to round up
        const parts = String(value).split('.');
        if (parts.length > 1) {
            if (parts[1].length <= precision) {
                return value;
            }
            else if (precision > 0) {
                return `${parts[0]}.${parts[1].slice(0, precision)}`;
            }
        }
        return parts[0];
    }
    setMin(min) {
        if (this.min === min) {
            return this;
        }
        this.min = min;
        (0, dom_1._addOrRemoveAttribute)(this.eInput, 'min', min);
        return this;
    }
    setMax(max) {
        if (this.max === max) {
            return this;
        }
        this.max = max;
        (0, dom_1._addOrRemoveAttribute)(this.eInput, 'max', max);
        return this;
    }
    setPrecision(precision) {
        this.precision = precision;
        return this;
    }
    setStep(step) {
        if (this.step === step) {
            return this;
        }
        this.step = step;
        (0, dom_1._addOrRemoveAttribute)(this.eInput, 'step', step);
        return this;
    }
    setValue(value, silent) {
        return this.setValueOrInputValue((v) => super.setValue(v, silent), () => this, value);
    }
    setStartValue(value) {
        return this.setValueOrInputValue((v) => super.setValue(v, true), (v) => {
            this.eInput.value = v;
        }, value);
    }
    setValueOrInputValue(setValueFunc, setInputValueOnlyFunc, value) {
        if ((0, generic_1._exists)(value)) {
            // need to maintain the scientific notation format whilst typing (e.g. 1e10)
            let setInputValueOnly = this.isScientificNotation(value);
            if (setInputValueOnly && this.eInput.validity.valid) {
                return setValueFunc(value);
            }
            if (!setInputValueOnly) {
                value = this.adjustPrecision(value);
                const normalizedValue = this.normalizeValue(value);
                // outside of valid range
                setInputValueOnly = value != normalizedValue;
            }
            if (setInputValueOnly) {
                return setInputValueOnlyFunc(value);
            }
        }
        return setValueFunc(value);
    }
    getValue() {
        const eInput = this.eInput;
        if (!eInput.validity.valid) {
            return undefined;
        }
        const inputValue = eInput.value;
        if (this.isScientificNotation(inputValue)) {
            return this.adjustPrecision(inputValue, true);
        }
        return super.getValue();
    }
    isScientificNotation(value) {
        return typeof value === 'string' && value.includes('e');
    }
}
exports.AgInputNumberField = AgInputNumberField;
exports.AgInputNumberFieldSelector = {
    selector: 'AG-INPUT-NUMBER-FIELD',
    component: AgInputNumberField,
};


/***/ }),

/***/ 56209:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgInputTextAreaSelector = exports.AgInputTextArea = void 0;
const agAbstractInputField_1 = __webpack_require__(98085);
class AgInputTextArea extends agAbstractInputField_1.AgAbstractInputField {
    constructor(config) {
        super(config, 'ag-text-area', null, 'textarea');
    }
    setValue(value, silent) {
        const ret = super.setValue(value, silent);
        this.eInput.value = value;
        return ret;
    }
    setCols(cols) {
        this.eInput.cols = cols;
        return this;
    }
    setRows(rows) {
        this.eInput.rows = rows;
        return this;
    }
}
exports.AgInputTextArea = AgInputTextArea;
exports.AgInputTextAreaSelector = {
    selector: 'AG-INPUT-TEXT-AREA',
    component: AgInputTextArea,
};


/***/ }),

/***/ 45946:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgInputTextFieldSelector = exports.AgInputTextField = void 0;
const generic_1 = __webpack_require__(34422);
const keyboard_1 = __webpack_require__(16466);
const agAbstractInputField_1 = __webpack_require__(98085);
class AgInputTextField extends agAbstractInputField_1.AgAbstractInputField {
    constructor(config, className = 'ag-text-field', inputType = 'text') {
        super(config, className, inputType);
    }
    postConstruct() {
        super.postConstruct();
        if (this.config.allowedCharPattern) {
            this.preventDisallowedCharacters();
        }
    }
    setValue(value, silent) {
        const eInput = this.eInput;
        // update the input before we call super.setValue, so it's updated before the value changed event is fired
        if (eInput.value !== value) {
            eInput.value = (0, generic_1._exists)(value) ? value : '';
        }
        return super.setValue(value, silent);
    }
    /** Used to set an initial value into the input without necessarily setting `this.value` or triggering events (e.g. to set an invalid value) */
    setStartValue(value) {
        this.setValue(value, true);
    }
    preventDisallowedCharacters() {
        const pattern = new RegExp(`[${this.config.allowedCharPattern}]`);
        const preventCharacters = (event) => {
            if (!(0, keyboard_1._isEventFromPrintableCharacter)(event)) {
                return;
            }
            if (event.key && !pattern.test(event.key)) {
                event.preventDefault();
            }
        };
        this.addManagedListeners(this.eInput, {
            keydown: preventCharacters,
            paste: (e) => {
                const text = e.clipboardData?.getData('text');
                if (text && text.split('').some((c) => !pattern.test(c))) {
                    e.preventDefault();
                }
            },
        });
    }
}
exports.AgInputTextField = AgInputTextField;
exports.AgInputTextFieldSelector = {
    selector: 'AG-INPUT-TEXT-FIELD',
    component: AgInputTextField,
};


/***/ }),

/***/ 87283:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgList = void 0;
const keyCode_1 = __webpack_require__(39853);
const aria_1 = __webpack_require__(95230);
const dom_1 = __webpack_require__(33507);
const component_1 = __webpack_require__(78020);
class AgList extends component_1.Component {
    constructor(cssIdentifier = 'default', unFocusable = false) {
        super({ tag: 'div', cls: `ag-list ag-${cssIdentifier}-list` });
        this.cssIdentifier = cssIdentifier;
        this.unFocusable = unFocusable;
        this.activeClass = 'ag-active-item';
        this.options = [];
        this.itemEls = [];
    }
    postConstruct() {
        const eGui = this.getGui();
        this.addManagedElementListeners(eGui, { mouseleave: () => this.clearHighlighted() });
        if (this.unFocusable) {
            return;
        }
        this.addManagedElementListeners(eGui, { keydown: this.handleKeyDown.bind(this) });
    }
    handleKeyDown(e) {
        const key = e.key;
        switch (key) {
            case keyCode_1.KeyCode.ENTER:
                if (!this.highlightedEl) {
                    this.setValue(this.getValue());
                }
                else {
                    const pos = this.itemEls.indexOf(this.highlightedEl);
                    this.setValueByIndex(pos);
                }
                break;
            case keyCode_1.KeyCode.DOWN:
            case keyCode_1.KeyCode.UP:
                e.preventDefault();
                this.navigate(key);
                break;
            case keyCode_1.KeyCode.PAGE_DOWN:
            case keyCode_1.KeyCode.PAGE_UP:
            case keyCode_1.KeyCode.PAGE_HOME:
            case keyCode_1.KeyCode.PAGE_END:
                e.preventDefault();
                this.navigateToPage(key);
                break;
        }
    }
    navigate(key) {
        const isDown = key === keyCode_1.KeyCode.DOWN;
        let itemToHighlight;
        const { itemEls, highlightedEl } = this;
        if (!highlightedEl) {
            itemToHighlight = itemEls[isDown ? 0 : itemEls.length - 1];
        }
        else {
            const currentIdx = itemEls.indexOf(highlightedEl);
            let nextPos = currentIdx + (isDown ? 1 : -1);
            nextPos = Math.min(Math.max(nextPos, 0), itemEls.length - 1);
            itemToHighlight = itemEls[nextPos];
        }
        this.highlightItem(itemToHighlight);
    }
    navigateToPage(key) {
        const { itemEls, highlightedEl } = this;
        if (!highlightedEl || itemEls.length === 0) {
            return;
        }
        const currentIdx = itemEls.indexOf(highlightedEl);
        const rowCount = this.options.length - 1;
        const itemHeight = itemEls[0].clientHeight;
        const pageSize = Math.floor(this.getGui().clientHeight / itemHeight);
        let newIndex = -1;
        if (key === keyCode_1.KeyCode.PAGE_HOME) {
            newIndex = 0;
        }
        else if (key === keyCode_1.KeyCode.PAGE_END) {
            newIndex = rowCount;
        }
        else if (key === keyCode_1.KeyCode.PAGE_DOWN) {
            newIndex = Math.min(currentIdx + pageSize, rowCount);
        }
        else if (key === keyCode_1.KeyCode.PAGE_UP) {
            newIndex = Math.max(currentIdx - pageSize, 0);
        }
        if (newIndex === -1) {
            return;
        }
        this.highlightItem(itemEls[newIndex]);
    }
    addOptions(listOptions) {
        listOptions.forEach((listOption) => this.addOption(listOption));
        return this;
    }
    addOption(listOption) {
        const { value, text } = listOption;
        const valueToRender = text ?? value;
        this.options.push({ value, text: valueToRender });
        this.renderOption(value, valueToRender);
        this.updateIndices();
        return this;
    }
    clearOptions() {
        this.options = [];
        this.reset(true);
        this.itemEls.forEach((itemEl) => {
            (0, dom_1._removeFromParent)(itemEl);
        });
        this.itemEls = [];
        this.refreshAriaRole();
    }
    refreshAriaRole() {
        const eGui = this.getGui();
        (0, aria_1._setAriaRole)(eGui, this.options.length === 0 ? 'presentation' : 'listbox');
    }
    updateIndices() {
        const options = this.getGui().querySelectorAll('.ag-list-item');
        this.refreshAriaRole();
        options.forEach((option, idx) => {
            (0, aria_1._setAriaPosInSet)(option, idx + 1);
            (0, aria_1._setAriaSetSize)(option, options.length);
        });
    }
    renderOption(value, text) {
        const itemEl = (0, dom_1._createElement)({
            tag: 'div',
            cls: `ag-list-item ag-${this.cssIdentifier}-list-item`,
            attrs: { role: 'option' },
        });
        const span = (0, dom_1._createElement)({
            tag: 'span',
            children: text,
        });
        itemEl.appendChild(span);
        if (!this.unFocusable) {
            itemEl.tabIndex = -1;
        }
        this.itemEls.push(itemEl);
        this.addManagedListeners(itemEl, {
            mouseover: () => this.highlightItem(itemEl),
            mousedown: (e) => {
                e.preventDefault();
                // `setValue` will already close the list popup, without stopPropagation
                // the mousedown event will close popups that own AgSelect
                e.stopPropagation();
                this.setValue(value);
            },
        });
        this.createOptionalManagedBean(this.beans.registry.createDynamicBean('tooltipFeature', false, {
            getTooltipValue: () => text,
            getGui: () => itemEl,
            getLocation: () => 'UNKNOWN',
            // only show tooltips for items where the text cannot be fully displayed
            shouldDisplayTooltip: () => span.scrollWidth > span.clientWidth,
        }));
        this.getGui().appendChild(itemEl);
    }
    setValue(value, silent) {
        if (this.value === value) {
            this.fireItemSelected();
            return this;
        }
        if (value == null) {
            this.reset(silent);
            return this;
        }
        const idx = this.options.findIndex((option) => option.value === value);
        if (idx !== -1) {
            const option = this.options[idx];
            this.value = option.value;
            this.displayValue = option.text;
            this.highlightItem(this.itemEls[idx]);
            if (!silent) {
                this.fireChangeEvent();
            }
        }
        return this;
    }
    setValueByIndex(idx) {
        return this.setValue(this.options[idx].value);
    }
    getValue() {
        return this.value;
    }
    getDisplayValue() {
        return this.displayValue;
    }
    refreshHighlighted() {
        this.clearHighlighted();
        const idx = this.options.findIndex((option) => option.value === this.value);
        if (idx !== -1) {
            this.highlightItem(this.itemEls[idx]);
        }
    }
    reset(silent) {
        this.value = null;
        this.displayValue = null;
        this.clearHighlighted();
        if (!silent) {
            this.fireChangeEvent();
        }
    }
    highlightItem(el) {
        if (!(0, dom_1._isVisible)(el)) {
            return;
        }
        this.clearHighlighted();
        this.highlightedEl = el;
        el.classList.add(this.activeClass);
        (0, aria_1._setAriaSelected)(el, true);
        const eGui = this.getGui();
        const { scrollTop, clientHeight } = eGui;
        const { offsetTop, offsetHeight } = el;
        if (offsetTop + offsetHeight > scrollTop + clientHeight || offsetTop < scrollTop) {
            el.scrollIntoView({ block: 'nearest' });
        }
        if (!this.unFocusable) {
            el.focus();
        }
    }
    clearHighlighted() {
        const highlightedEl = this.highlightedEl;
        if (!highlightedEl || !(0, dom_1._isVisible)(highlightedEl)) {
            return;
        }
        highlightedEl.classList.remove(this.activeClass);
        (0, aria_1._setAriaSelected)(highlightedEl, false);
        this.highlightedEl = null;
    }
    fireChangeEvent() {
        this.dispatchLocalEvent({ type: 'fieldValueChanged' });
        this.fireItemSelected();
    }
    fireItemSelected() {
        this.dispatchLocalEvent({ type: 'selectedItem' });
    }
}
exports.AgList = AgList;


/***/ }),

/***/ 34772:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.agPickerFieldCSS = void 0;
exports.agPickerFieldCSS = `.ag-picker-field-display{flex:1 1 auto}.ag-picker-field{align-items:center;display:flex}.ag-picker-field-icon{border:0;cursor:pointer;display:flex;margin:0;padding:0}.ag-picker-field-wrapper{background-color:var(--ag-picker-button-background-color);border:var(--ag-picker-button-border);border-radius:5px;min-height:max(var(--ag-list-item-height),calc(var(--ag-spacing)*4));overflow:hidden;&:where(.invalid){background-color:var(--ag-input-invalid-background-color);border:var(--ag-input-invalid-border);color:var(--ag-input-invalid-text-color)}&:where(.ag-picker-has-focus:not(.invalid)),&:where(:focus-within:not(.invalid)){background-color:var(--ag-picker-button-focus-background-color);border:var(--ag-picker-button-focus-border);box-shadow:var(--ag-focus-shadow)}&:disabled{opacity:.5}}`;


/***/ }),

/***/ 79497:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgPickerField = void 0;
const keyCode_1 = __webpack_require__(39853);
const gridOptionsUtils_1 = __webpack_require__(67274);
const aria_1 = __webpack_require__(95230);
const dom_1 = __webpack_require__(33507);
const icon_1 = __webpack_require__(59970);
const agAbstractField_1 = __webpack_require__(37321);
const agPickerField_css_GENERATED_1 = __webpack_require__(34772);
const component_1 = __webpack_require__(78020);
const AgPickerFieldElement = {
    tag: 'div',
    cls: 'ag-picker-field',
    role: 'presentation',
    children: [
        { tag: 'div', ref: 'eLabel' },
        {
            tag: 'div',
            ref: 'eWrapper',
            cls: 'ag-wrapper ag-picker-field-wrapper ag-picker-collapsed',
            children: [
                { tag: 'div', ref: 'eDisplayField', cls: 'ag-picker-field-display' },
                { tag: 'div', ref: 'eIcon', cls: 'ag-picker-field-icon', attrs: { 'aria-hidden': 'true' } },
            ],
        },
    ],
};
class AgPickerField extends agAbstractField_1.AgAbstractField {
    constructor(config) {
        super(config, config?.template || AgPickerFieldElement, config?.agComponents || [], config?.className);
        this.isPickerDisplayed = false;
        this.skipClick = false;
        this.pickerGap = 4;
        this.hideCurrentPicker = null;
        this.eLabel = component_1.RefPlaceholder;
        this.eWrapper = component_1.RefPlaceholder;
        this.eDisplayField = component_1.RefPlaceholder;
        this.eIcon = component_1.RefPlaceholder;
        this.registerCSS(agPickerField_css_GENERATED_1.agPickerFieldCSS);
        this.ariaRole = config?.ariaRole;
        this.onPickerFocusIn = this.onPickerFocusIn.bind(this);
        this.onPickerFocusOut = this.onPickerFocusOut.bind(this);
        if (!config) {
            return;
        }
        const { pickerGap, maxPickerHeight, variableWidth, minPickerWidth, maxPickerWidth } = config;
        if (pickerGap != null) {
            this.pickerGap = pickerGap;
        }
        this.variableWidth = !!variableWidth;
        if (maxPickerHeight != null) {
            this.setPickerMaxHeight(maxPickerHeight);
        }
        if (minPickerWidth != null) {
            this.setPickerMinWidth(minPickerWidth);
        }
        if (maxPickerWidth != null) {
            this.setPickerMaxWidth(maxPickerWidth);
        }
    }
    postConstruct() {
        super.postConstruct();
        this.setupAria();
        const displayId = `ag-${this.getCompId()}-display`;
        this.eDisplayField.setAttribute('id', displayId);
        const ariaEl = this.getAriaElement();
        this.addManagedElementListeners(ariaEl, { keydown: this.onKeyDown.bind(this) });
        this.addManagedElementListeners(this.eLabel, { mousedown: this.onLabelOrWrapperMouseDown.bind(this) });
        this.addManagedElementListeners(this.eWrapper, { mousedown: this.onLabelOrWrapperMouseDown.bind(this) });
        const { pickerIcon, inputWidth } = this.config;
        if (pickerIcon) {
            const icon = (0, icon_1._createIconNoSpan)(pickerIcon, this.beans);
            if (icon) {
                this.eIcon.appendChild(icon);
            }
        }
        if (inputWidth != null) {
            this.setInputWidth(inputWidth);
        }
    }
    setupAria() {
        const ariaEl = this.getAriaElement();
        ariaEl.setAttribute('tabindex', this.gos.get('tabIndex').toString());
        (0, aria_1._setAriaExpanded)(ariaEl, false);
        if (this.ariaRole) {
            (0, aria_1._setAriaRole)(ariaEl, this.ariaRole);
        }
    }
    onLabelOrWrapperMouseDown(e) {
        if (e) {
            const focusableEl = this.getFocusableElement();
            // if the focusableEl is not the wrapper and the mousedown
            // targets the focusableEl, we should not expand/collapse the picker.
            // Note: this will happen when AgRichSelect is set with `allowTyping=true`
            if (focusableEl !== this.eWrapper && e?.target === focusableEl) {
                return;
            }
            // this prevents a BUG where MouseDown causes the element to be focused
            // after the picker is shown and focus ends up being lost.
            e.preventDefault();
            this.getFocusableElement().focus();
        }
        if (this.skipClick) {
            this.skipClick = false;
            return;
        }
        if (this.isDisabled()) {
            return;
        }
        if (this.isPickerDisplayed) {
            this.hidePicker();
        }
        else {
            this.showPicker();
        }
    }
    onKeyDown(e) {
        switch (e.key) {
            case keyCode_1.KeyCode.UP:
            case keyCode_1.KeyCode.DOWN:
            case keyCode_1.KeyCode.ENTER:
            case keyCode_1.KeyCode.SPACE:
                e.preventDefault();
                this.onLabelOrWrapperMouseDown();
                break;
            case keyCode_1.KeyCode.ESCAPE:
                if (this.isPickerDisplayed) {
                    e.preventDefault();
                    e.stopPropagation();
                    if (this.hideCurrentPicker) {
                        this.hideCurrentPicker();
                    }
                }
                break;
        }
    }
    showPicker() {
        this.isPickerDisplayed = true;
        if (!this.pickerComponent) {
            this.pickerComponent = this.createPickerComponent();
        }
        const pickerGui = this.pickerComponent.getGui();
        pickerGui.addEventListener('focusin', this.onPickerFocusIn);
        pickerGui.addEventListener('focusout', this.onPickerFocusOut);
        this.hideCurrentPicker = this.renderAndPositionPicker();
        this.toggleExpandedStyles(true);
    }
    renderAndPositionPicker() {
        const ePicker = this.pickerComponent.getGui();
        if (!this.gos.get('suppressScrollWhenPopupsAreOpen')) {
            [this.destroyMouseWheelFunc] = this.addManagedEventListeners({
                bodyScroll: () => {
                    this.hidePicker();
                },
            });
        }
        const translate = this.getLocaleTextFunc();
        const { config: { pickerAriaLabelKey, pickerAriaLabelValue, modalPicker = true }, maxPickerHeight, minPickerWidth, maxPickerWidth, variableWidth, beans, eWrapper, } = this;
        const popupParams = {
            modal: modalPicker,
            eChild: ePicker,
            closeOnEsc: true,
            closedCallback: () => {
                const shouldRestoreFocus = (0, gridOptionsUtils_1._isNothingFocused)(beans);
                this.beforeHidePicker();
                if (shouldRestoreFocus && this.isAlive()) {
                    this.getFocusableElement().focus();
                }
            },
            ariaLabel: translate(pickerAriaLabelKey, pickerAriaLabelValue),
            anchorToElement: eWrapper,
        };
        // need to set position before adding to the dom
        ePicker.style.position = 'absolute';
        const popupSvc = beans.popupSvc;
        const addPopupRes = popupSvc.addPopup(popupParams);
        if (variableWidth) {
            if (minPickerWidth) {
                ePicker.style.minWidth = minPickerWidth;
            }
            ePicker.style.width = (0, dom_1._formatSize)((0, dom_1._getAbsoluteWidth)(eWrapper));
            if (maxPickerWidth) {
                ePicker.style.maxWidth = maxPickerWidth;
            }
        }
        else {
            (0, dom_1._setElementWidth)(ePicker, maxPickerWidth ?? (0, dom_1._getAbsoluteWidth)(eWrapper));
        }
        const maxHeight = maxPickerHeight ?? `${(0, dom_1._getInnerHeight)(popupSvc.getPopupParent())}px`;
        ePicker.style.setProperty('max-height', maxHeight);
        this.alignPickerToComponent();
        return addPopupRes.hideFunc;
    }
    alignPickerToComponent() {
        if (!this.pickerComponent) {
            return;
        }
        const { pickerGap, config: { pickerType }, beans: { popupSvc, gos }, eWrapper, pickerComponent, } = this;
        const alignSide = gos.get('enableRtl') ? 'right' : 'left';
        popupSvc.positionPopupByComponent({
            type: pickerType,
            eventSource: eWrapper,
            ePopup: pickerComponent.getGui(),
            position: 'under',
            alignSide,
            keepWithinBounds: true,
            nudgeY: pickerGap,
        });
    }
    beforeHidePicker() {
        if (this.destroyMouseWheelFunc) {
            this.destroyMouseWheelFunc();
            this.destroyMouseWheelFunc = undefined;
        }
        this.toggleExpandedStyles(false);
        const pickerGui = this.pickerComponent.getGui();
        pickerGui.removeEventListener('focusin', this.onPickerFocusIn);
        pickerGui.removeEventListener('focusout', this.onPickerFocusOut);
        this.isPickerDisplayed = false;
        this.pickerComponent = undefined;
        this.hideCurrentPicker = null;
    }
    toggleExpandedStyles(expanded) {
        if (!this.isAlive()) {
            return;
        }
        const ariaEl = this.getAriaElement();
        (0, aria_1._setAriaExpanded)(ariaEl, expanded);
        const classList = this.eWrapper.classList;
        classList.toggle('ag-picker-expanded', expanded);
        classList.toggle('ag-picker-collapsed', !expanded);
    }
    onPickerFocusIn() {
        this.togglePickerHasFocus(true);
    }
    onPickerFocusOut(e) {
        if (!this.pickerComponent?.getGui().contains(e.relatedTarget)) {
            this.togglePickerHasFocus(false);
        }
    }
    togglePickerHasFocus(focused) {
        if (!this.pickerComponent) {
            return;
        }
        this.eWrapper.classList.toggle('ag-picker-has-focus', focused);
    }
    hidePicker() {
        if (this.hideCurrentPicker) {
            this.hideCurrentPicker();
            this.dispatchLocalEvent({
                type: 'pickerHidden',
            });
        }
    }
    setInputWidth(width) {
        (0, dom_1._setElementWidth)(this.eWrapper, width);
        return this;
    }
    getFocusableElement() {
        return this.eWrapper;
    }
    setPickerGap(gap) {
        this.pickerGap = gap;
        return this;
    }
    setPickerMinWidth(width) {
        if (typeof width === 'number') {
            width = `${width}px`;
        }
        this.minPickerWidth = width == null ? undefined : width;
        return this;
    }
    setPickerMaxWidth(width) {
        if (typeof width === 'number') {
            width = `${width}px`;
        }
        this.maxPickerWidth = width == null ? undefined : width;
        return this;
    }
    setPickerMaxHeight(height) {
        if (typeof height === 'number') {
            height = `${height}px`;
        }
        this.maxPickerHeight = height == null ? undefined : height;
        return this;
    }
    destroy() {
        this.hidePicker();
        super.destroy();
    }
}
exports.AgPickerField = AgPickerField;


/***/ }),

/***/ 77336:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgRadioButton = void 0;
const agCheckbox_1 = __webpack_require__(90066);
class AgRadioButton extends agCheckbox_1.AgCheckbox {
    constructor(config) {
        super(config, 'ag-radio-button', 'radio');
    }
    isSelected() {
        return this.eInput.checked;
    }
    toggle() {
        if (this.eInput.disabled) {
            return;
        }
        // do not allow an active radio button to be deselected
        if (!this.isSelected()) {
            this.setValue(true);
        }
    }
    addInputListeners() {
        super.addInputListeners();
        this.addManagedEventListeners({ checkboxChanged: this.onChange.bind(this) });
    }
    /**
     * This ensures that if another radio button in the same named group is selected, we deselect this radio button.
     * By default the browser does this for you, but we are managing classes ourselves in order to ensure input
     * elements are styled correctly in IE11, and the DOM 'changed' event is only fired when a button is selected,
     * not deselected, so we need to use our own event.
     */
    onChange(event) {
        const eInput = this.eInput;
        if (event.selected &&
            event.name &&
            eInput.name &&
            eInput.name === event.name &&
            event.id &&
            eInput.id !== event.id) {
            this.setValue(false, true);
        }
    }
}
exports.AgRadioButton = AgRadioButton;


/***/ }),

/***/ 85310:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.agSelectCSS = void 0;
exports.agSelectCSS = `.ag-select{align-items:center;display:flex;&.ag-disabled{opacity:.5}}:where(.ag-select){.ag-picker-field-wrapper{cursor:default}&.ag-disabled .ag-picker-field-wrapper:focus{box-shadow:none}&:not(.ag-cell-editor,.ag-label-align-top){min-height:var(--ag-list-item-height)}.ag-picker-field-display{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.ag-picker-field-icon{align-items:center;display:flex}}:where(.ag-ltr) :where(.ag-select){.ag-picker-field-wrapper{padding-left:calc(var(--ag-cell-horizontal-padding)/2);padding-right:var(--ag-spacing)}}:where(.ag-rtl) :where(.ag-select){.ag-picker-field-wrapper{padding-left:var(--ag-spacing);padding-right:calc(var(--ag-cell-horizontal-padding)/2)}}`;


/***/ }),

/***/ 70159:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgSelectSelector = exports.AgSelect = void 0;
const keyCode_1 = __webpack_require__(39853);
const aria_1 = __webpack_require__(95230);
const dom_1 = __webpack_require__(33507);
const agList_1 = __webpack_require__(87283);
const agPickerField_1 = __webpack_require__(79497);
const agSelect_css_GENERATED_1 = __webpack_require__(85310);
class AgSelect extends agPickerField_1.AgPickerField {
    constructor(config) {
        super({
            pickerAriaLabelKey: 'ariaLabelSelectField',
            pickerAriaLabelValue: 'Select Field',
            pickerType: 'ag-list',
            className: 'ag-select',
            pickerIcon: 'selectOpen',
            ariaRole: 'combobox',
            ...config,
        });
        this.registerCSS(agSelect_css_GENERATED_1.agSelectCSS);
    }
    postConstruct() {
        this.tooltipFeature = this.createOptionalManagedBean(this.beans.registry.createDynamicBean('tooltipFeature', false, {
            shouldDisplayTooltip: (0, dom_1._isElementOverflowingCallback)(() => this.eDisplayField),
            getGui: () => this.getGui(),
        }));
        super.postConstruct();
        this.createListComponent();
        this.eWrapper.tabIndex = this.gos.get('tabIndex');
        const { options, value, placeholder } = this.config;
        if (options != null) {
            this.addOptions(options);
        }
        if (value != null) {
            // need to reapply value after list component created
            this.setValue(value, true);
        }
        if (placeholder && value == null) {
            this.eDisplayField.textContent = placeholder;
        }
        this.addManagedElementListeners(this.eWrapper, { focusout: this.onWrapperFocusOut.bind(this) });
    }
    onWrapperFocusOut(e) {
        if (!this.eWrapper.contains(e.relatedTarget)) {
            this.hidePicker();
        }
    }
    createListComponent() {
        const listComponent = this.createBean(new agList_1.AgList('select', true));
        this.listComponent = listComponent;
        listComponent.setParentComponent(this);
        const eListAriaEl = listComponent.getAriaElement();
        const listId = `ag-select-list-${listComponent.getCompId()}`;
        eListAriaEl.setAttribute('id', listId);
        (0, aria_1._setAriaControlsAndLabel)(this.getAriaElement(), eListAriaEl);
        listComponent.addManagedElementListeners(listComponent.getGui(), {
            mousedown: (e) => {
                e?.preventDefault();
            },
        });
        listComponent.addManagedListeners(listComponent, {
            selectedItem: () => {
                this.hidePicker();
                this.dispatchLocalEvent({ type: 'selectedItem' });
            },
            fieldValueChanged: () => {
                if (!this.listComponent) {
                    return;
                }
                this.setValue(this.listComponent.getValue(), false, true);
                this.hidePicker();
            },
        });
    }
    createPickerComponent() {
        // do not create the picker every time to save state
        return this.listComponent;
    }
    onKeyDown(e) {
        const { key } = e;
        if (key === keyCode_1.KeyCode.TAB) {
            this.hidePicker();
        }
        switch (key) {
            case keyCode_1.KeyCode.ENTER:
            case keyCode_1.KeyCode.UP:
            case keyCode_1.KeyCode.DOWN:
            case keyCode_1.KeyCode.PAGE_UP:
            case keyCode_1.KeyCode.PAGE_DOWN:
            case keyCode_1.KeyCode.PAGE_HOME:
            case keyCode_1.KeyCode.PAGE_END:
                e.preventDefault();
                if (this.isPickerDisplayed) {
                    this.listComponent?.handleKeyDown(e);
                }
                else {
                    super.onKeyDown(e);
                }
                break;
            case keyCode_1.KeyCode.ESCAPE:
                super.onKeyDown(e);
                break;
            case keyCode_1.KeyCode.SPACE:
                if (this.isPickerDisplayed) {
                    e.preventDefault();
                }
                else {
                    super.onKeyDown(e);
                }
                break;
        }
    }
    showPicker() {
        const listComponent = this.listComponent;
        if (!listComponent) {
            return;
        }
        super.showPicker();
        listComponent.refreshHighlighted();
    }
    addOptions(options) {
        options.forEach((option) => this.addOption(option));
        return this;
    }
    addOption(option) {
        this.listComponent.addOption(option);
        return this;
    }
    clearOptions() {
        this.listComponent?.clearOptions();
        this.setValue(undefined, true);
        return this;
    }
    setValue(value, silent, fromPicker) {
        const { listComponent, config: { placeholder }, eDisplayField, tooltipFeature, } = this;
        if (this.value === value || !listComponent) {
            return this;
        }
        if (!fromPicker) {
            listComponent.setValue(value, true);
        }
        const newValue = listComponent.getValue();
        if (newValue === this.getValue()) {
            return this;
        }
        let displayValue = listComponent.getDisplayValue();
        if (displayValue == null && placeholder) {
            displayValue = placeholder;
        }
        eDisplayField.textContent = displayValue;
        tooltipFeature?.setTooltipAndRefresh(displayValue ?? null);
        return super.setValue(value, silent);
    }
    destroy() {
        this.listComponent = this.destroyBean(this.listComponent);
        super.destroy();
    }
}
exports.AgSelect = AgSelect;
exports.AgSelectSelector = {
    selector: 'AG-SELECT',
    component: AgSelect,
};


/***/ }),

/***/ 98398:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.agToggleButtonCSS = void 0;
exports.agToggleButtonCSS = `.ag-toggle-button{flex:none;min-width:unset;width:unset}.ag-toggle-button-input-wrapper{background-color:var(--ag-toggle-button-off-background-color);border-radius:calc(var(--ag-toggle-button-height)*.5);flex:none;height:var(--ag-toggle-button-height);max-width:var(--ag-toggle-button-width);min-width:var(--ag-toggle-button-width);position:relative;transition:background-color .1s;:where(.ag-toggle-button-input){-webkit-appearance:none;-moz-appearance:none;appearance:none;cursor:pointer;display:block;height:var(--ag-toggle-button-height);margin:0;max-width:var(--ag-toggle-button-width);min-width:var(--ag-toggle-button-width);opacity:0}&:before{background-color:var(--ag-toggle-button-switch-background-color);border-radius:100%;content:"";display:block;height:calc(var(--ag-toggle-button-height) - var(--ag-toggle-button-switch-inset)*2);left:var(--ag-toggle-button-switch-inset);pointer-events:none;position:absolute;top:var(--ag-toggle-button-switch-inset);transition:left .1s;width:calc(var(--ag-toggle-button-height) - var(--ag-toggle-button-switch-inset)*2)}&.ag-checked{background-color:var(--ag-toggle-button-on-background-color);&:before{left:calc(100% - var(--ag-toggle-button-height) + var(--ag-toggle-button-switch-inset))}}&:focus-within{box-shadow:var(--ag-focus-shadow)}&.ag-disabled{opacity:.5}}`;


/***/ }),

/***/ 54927:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AgToggleButtonSelector = exports.AgToggleButton = void 0;
const agCheckbox_1 = __webpack_require__(90066);
const agToggleButton_css_GENERATED_1 = __webpack_require__(98398);
class AgToggleButton extends agCheckbox_1.AgCheckbox {
    constructor(config) {
        super(config, 'ag-toggle-button');
        this.registerCSS(agToggleButton_css_GENERATED_1.agToggleButtonCSS);
    }
    setValue(value, silent) {
        super.setValue(value, silent);
        this.toggleCss('ag-selected', this.getValue());
        return this;
    }
}
exports.AgToggleButton = AgToggleButton;
exports.AgToggleButtonSelector = {
    selector: 'AG-TOGGLE-BUTTON',
    component: AgToggleButton,
};


/***/ }),

/***/ 78020:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Component = exports.RefPlaceholder = void 0;
const beanStub_1 = __webpack_require__(68731);
const cssClassManager_1 = __webpack_require__(21734);
const dom_1 = __webpack_require__(33507);
let compIdSequence = 0;
/** The RefPlaceholder is used to control when data-ref attribute should be applied to the component
 * There are hanging data-refs in the DOM that are not being used internally by the component which we don't want to apply to the component.
 * There is also the case where data-refs are solely used for passing parameters to the component and should not be applied to the component.
 * It also enables validation to catch typo errors in the data-ref attribute vs component name.
 * The value is `null` so that it can be identified in the component and distinguished from just missing with undefined.
 * The `null` value also allows for existing falsy checks to work as expected when code can be run before the template is setup.
 */
exports.RefPlaceholder = null;
class Component extends beanStub_1.BeanStub {
    constructor(templateOrParams, componentSelectors) {
        super();
        this.suppressDataRefValidation = false;
        // if false, then CSS class "ag-hidden" is applied, which sets "display: none"
        this.displayed = true;
        // if false, then CSS class "ag-invisible" is applied, which sets "visibility: hidden"
        this.visible = true;
        // unique id for this row component. this is used for getting a reference to the HTML dom.
        // we cannot use the RowNode id as this is not unique (due to animation, old rows can be lying
        // around as we create a new rowComp instance for the same row node).
        this.compId = compIdSequence++;
        this.cssManager = new cssClassManager_1.CssClassManager(() => this.eGui);
        this.componentSelectors = new Map((componentSelectors ?? []).map((comp) => [comp.selector, comp]));
        if (templateOrParams) {
            this.setTemplate(templateOrParams);
        }
    }
    preConstruct() {
        this.wireTemplate(this.getGui());
        const debugId = 'component-' + Object.getPrototypeOf(this)?.constructor?.name;
        this.css?.forEach((css) => this.beans.environment.addGlobalCSS(css, debugId));
    }
    wireTemplate(element, paramsMap) {
        // ui exists if user sets template in constructor. when this happens,
        // We have to wait for the context to be autoWired first before we can create child components.
        if (element && this.gos) {
            this.applyElementsToComponent(element);
            this.createChildComponentsFromTags(element, paramsMap);
        }
    }
    getCompId() {
        return this.compId;
    }
    getDataRefAttribute(element) {
        if (element.getAttribute) {
            return element.getAttribute(dom_1.DataRefAttribute);
        }
        // Plain text nodes don't have attributes or getAttribute method
        return null;
    }
    applyElementsToComponent(element, elementRef, paramsMap, newComponent = null) {
        if (elementRef === undefined) {
            elementRef = this.getDataRefAttribute(element);
        }
        if (elementRef) {
            // We store the reference to the element in the parent component under that same name
            // if there is a placeholder property with the same name.
            const current = this[elementRef];
            if (current === exports.RefPlaceholder) {
                this[elementRef] = newComponent ?? element;
            }
            else {
                // Don't warn if the data-ref is used for passing parameters to the component
                const usedAsParamRef = paramsMap && paramsMap[elementRef];
                if (!this.suppressDataRefValidation && !usedAsParamRef) {
                    // This can happen because of:
                    // 1. The data-ref has a typo and doesn't match the property in the component
                    // 2. The  property is not initialised with the RefPlaceholder and should be.
                    // 3. The property is on a child component and not available on the parent during construction.
                    //    In which case you may need to pass the template via setTemplate() instead of in the super constructor.
                    // 4. The data-ref is not used by the component and should be removed from the template.
                    throw new Error(`data-ref: ${elementRef} on ${this.constructor.name} with ${current}`);
                }
            }
        }
    }
    // for registered components only, eg creates AgCheckbox instance from ag-checkbox HTML tag
    createChildComponentsFromTags(parentNode, paramsMap) {
        // we MUST take a copy of the list first, as the 'swapComponentForNode' adds comments into the DOM
        // which messes up the traversal order of the children.
        const childNodeList = [];
        for (const childNode of parentNode.childNodes ?? []) {
            childNodeList.push(childNode);
        }
        childNodeList.forEach((childNode) => {
            if (!(childNode instanceof HTMLElement)) {
                return;
            }
            const childComp = this.createComponentFromElement(childNode, (childComp) => {
                // copy over all attributes, including css classes, so any attributes user put on the tag
                // wll be carried across
                const childGui = childComp.getGui();
                if (childGui) {
                    for (const attr of childNode.attributes ?? []) {
                        childGui.setAttribute(attr.name, attr.value);
                    }
                }
            }, paramsMap);
            if (childComp) {
                if (childComp.addItems && childNode.children.length) {
                    this.createChildComponentsFromTags(childNode, paramsMap);
                    // converting from HTMLCollection to Array
                    const items = Array.prototype.slice.call(childNode.children);
                    childComp.addItems(items);
                }
                // replace the tag (eg ag-checkbox) with the proper HTMLElement (eg 'div') in the dom
                this.swapComponentForNode(childComp, parentNode, childNode);
            }
            else if (childNode.childNodes) {
                this.createChildComponentsFromTags(childNode, paramsMap);
            }
        });
    }
    createComponentFromElement(element, afterPreCreateCallback, paramsMap) {
        const key = element.nodeName;
        const elementRef = this.getDataRefAttribute(element);
        const isAgGridComponent = key.indexOf('AG-') === 0;
        const componentSelector = isAgGridComponent ? this.componentSelectors.get(key) : null;
        let newComponent = null;
        if (componentSelector) {
            const componentParams = paramsMap && elementRef ? paramsMap[elementRef] : undefined;
            newComponent = new componentSelector.component(componentParams);
            newComponent.setParentComponent(this);
            this.createBean(newComponent, null, afterPreCreateCallback);
        }
        else if (isAgGridComponent) {
            throw new Error(`selector: ${key}`);
        }
        this.applyElementsToComponent(element, elementRef, paramsMap, newComponent);
        return newComponent;
    }
    swapComponentForNode(newComponent, parentNode, childNode) {
        const eComponent = newComponent.getGui();
        parentNode.replaceChild(eComponent, childNode);
        parentNode.insertBefore(document.createComment(childNode.nodeName), eComponent);
        this.addDestroyFunc(this.destroyBean.bind(this, newComponent));
    }
    activateTabIndex(elements) {
        const tabIndex = this.gos.get('tabIndex');
        if (!elements) {
            elements = [];
        }
        if (!elements.length) {
            elements.push(this.getGui());
        }
        elements.forEach((el) => el.setAttribute('tabindex', tabIndex.toString()));
    }
    setTemplate(templateOrParams, componentSelectors, paramsMap) {
        let eGui;
        if (typeof templateOrParams === 'string' || templateOrParams == null) {
            eGui = (0, dom_1._loadTemplate)(templateOrParams);
        }
        else {
            eGui = (0, dom_1._createElement)(templateOrParams);
        }
        this.setTemplateFromElement(eGui, componentSelectors, paramsMap);
    }
    setTemplateFromElement(element, components, paramsMap, suppressDataRefValidation = false) {
        this.eGui = element;
        this.suppressDataRefValidation = suppressDataRefValidation;
        if (components) {
            for (let i = 0; i < components.length; i++) {
                const component = components[i];
                this.componentSelectors.set(component.selector, component);
            }
        }
        this.wireTemplate(element, paramsMap);
    }
    getGui() {
        return this.eGui;
    }
    getFocusableElement() {
        return this.eGui;
    }
    getAriaElement() {
        return this.getFocusableElement();
    }
    setParentComponent(component) {
        this.parentComponent = component;
    }
    getParentComponent() {
        return this.parentComponent;
    }
    // this method is for older code, that wants to provide the gui element,
    // it is not intended for this to be in ag-Stack
    setGui(eGui) {
        this.eGui = eGui;
    }
    queryForHtmlElement(cssSelector) {
        return this.eGui.querySelector(cssSelector);
    }
    getContainerAndElement(newChild, container) {
        let parent = container;
        if (newChild == null) {
            return null;
        }
        if (!parent) {
            parent = this.eGui;
        }
        if ((0, dom_1._isNodeOrElement)(newChild)) {
            return {
                element: newChild,
                parent,
            };
        }
        return {
            element: newChild.getGui(),
            parent,
        };
    }
    prependChild(newChild, container) {
        const { element, parent } = this.getContainerAndElement(newChild, container) || {};
        if (!element || !parent) {
            return;
        }
        parent.insertAdjacentElement('afterbegin', element);
    }
    appendChild(newChild, container) {
        const { element, parent } = this.getContainerAndElement(newChild, container) || {};
        if (!element || !parent) {
            return;
        }
        parent.appendChild(element);
    }
    isDisplayed() {
        return this.displayed;
    }
    setVisible(visible, options = {}) {
        if (visible !== this.visible) {
            this.visible = visible;
            const { skipAriaHidden } = options;
            (0, dom_1._setVisible)(this.eGui, visible, { skipAriaHidden });
        }
    }
    setDisplayed(displayed, options = {}) {
        if (displayed !== this.displayed) {
            this.displayed = displayed;
            const { skipAriaHidden } = options;
            (0, dom_1._setDisplayed)(this.eGui, displayed, { skipAriaHidden });
            const event = {
                type: 'displayChanged',
                visible: this.displayed,
            };
            this.dispatchLocalEvent(event);
        }
    }
    destroy() {
        if (this.parentComponent) {
            this.parentComponent = undefined;
        }
        super.destroy();
    }
    addGuiEventListener(event, listener, options) {
        this.eGui.addEventListener(event, listener, options);
        this.addDestroyFunc(() => this.eGui.removeEventListener(event, listener));
    }
    addCss(className) {
        this.cssManager.toggleCss(className, true);
    }
    removeCss(className) {
        this.cssManager.toggleCss(className, false);
    }
    toggleCss(className, addOrRemove) {
        this.cssManager.toggleCss(className, addOrRemove);
    }
    registerCSS(css) {
        this.css || (this.css = []);
        this.css.push(css);
    }
}
exports.Component = Component;


/***/ }),

/***/ 31772:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ManagedFocusFeature = exports.FOCUS_MANAGED_CLASS = void 0;
const keyCode_1 = __webpack_require__(39853);
const beanStub_1 = __webpack_require__(68731);
const event_1 = __webpack_require__(92979);
const focus_1 = __webpack_require__(82331);
exports.FOCUS_MANAGED_CLASS = 'ag-focus-managed';
class ManagedFocusFeature extends beanStub_1.BeanStub {
    constructor(eFocusable, callbacks = {}) {
        super();
        this.eFocusable = eFocusable;
        this.callbacks = callbacks;
        this.callbacks = {
            shouldStopEventPropagation: () => false,
            onTabKeyDown: (e) => {
                if (e.defaultPrevented) {
                    return;
                }
                const nextRoot = (0, focus_1._findNextFocusableElement)(this.beans, this.eFocusable, false, e.shiftKey);
                if (!nextRoot) {
                    return;
                }
                nextRoot.focus();
                e.preventDefault();
            },
            ...callbacks,
        };
    }
    postConstruct() {
        const { eFocusable, callbacks: { onFocusIn, onFocusOut }, } = this;
        eFocusable.classList.add(exports.FOCUS_MANAGED_CLASS);
        this.addKeyDownListeners(eFocusable);
        if (onFocusIn) {
            this.addManagedElementListeners(eFocusable, { focusin: onFocusIn });
        }
        if (onFocusOut) {
            this.addManagedElementListeners(eFocusable, { focusout: onFocusOut });
        }
    }
    addKeyDownListeners(eGui) {
        this.addManagedElementListeners(eGui, {
            keydown: (e) => {
                if (e.defaultPrevented || (0, event_1._isStopPropagationForAgGrid)(e)) {
                    return;
                }
                const { callbacks } = this;
                if (callbacks.shouldStopEventPropagation(e)) {
                    (0, event_1._stopPropagationForAgGrid)(e);
                    return;
                }
                if (e.key === keyCode_1.KeyCode.TAB) {
                    callbacks.onTabKeyDown(e);
                }
                else if (callbacks.handleKeyDown) {
                    callbacks.handleKeyDown(e);
                }
            },
        });
    }
}
exports.ManagedFocusFeature = ManagedFocusFeature;


/***/ }),

/***/ 63598:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PopupComponent = void 0;
const component_1 = __webpack_require__(78020);
class PopupComponent extends component_1.Component {
    isPopup() {
        return true;
    }
    setParentComponent(container) {
        container.addCss('ag-has-popup');
        super.setParentComponent(container);
    }
    destroy() {
        const parentComp = this.parentComponent;
        const hasParent = parentComp && parentComp.isAlive();
        if (hasParent) {
            parentComp.getGui().classList.remove('ag-has-popup');
        }
        super.destroy();
    }
}
exports.PopupComponent = PopupComponent;


/***/ }),

/***/ 3137:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PopupModule = void 0;
const version_1 = __webpack_require__(97205);
const popupService_1 = __webpack_require__(53906);
/**
 * @internal
 */
exports.PopupModule = {
    moduleName: 'Popup',
    version: version_1.VERSION,
    beans: [popupService_1.PopupService],
};


/***/ }),

/***/ 53906:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PopupService = void 0;
const keyCode_1 = __webpack_require__(39853);
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const aria_1 = __webpack_require__(95230);
const dom_1 = __webpack_require__(33507);
const event_1 = __webpack_require__(92979);
const generic_1 = __webpack_require__(34422);
const promise_1 = __webpack_require__(57990);
const logging_1 = __webpack_require__(47764);
var DIRECTION;
(function (DIRECTION) {
    DIRECTION[DIRECTION["vertical"] = 0] = "vertical";
    DIRECTION[DIRECTION["horizontal"] = 1] = "horizontal";
})(DIRECTION || (DIRECTION = {}));
let instanceIdSeq = 0;
const WAIT_FOR_POPUP_CONTENT_RESIZE = 200;
class PopupService extends beanStub_1.BeanStub {
    constructor() {
        super(...arguments);
        this.beanName = 'popupSvc';
        this.popupList = [];
    }
    postConstruct() {
        this.beans.ctrlsSvc.whenReady(this, (p) => {
            this.gridCtrl = p.gridCtrl;
        });
        this.addManagedEventListeners({ gridStylesChanged: this.handleThemeChange.bind(this) });
    }
    getPopupParent() {
        const ePopupParent = this.gos.get('popupParent');
        if (ePopupParent) {
            return ePopupParent;
        }
        return this.gridCtrl.getGui();
    }
    positionPopupForMenu(params) {
        const { eventSource, ePopup, column, node, event } = params;
        const sourceRect = eventSource.getBoundingClientRect();
        const parentRect = this.getParentRect();
        this.setAlignedTo(eventSource, ePopup);
        let minWidthSet = false;
        const updatePosition = () => {
            const y = this.keepXYWithinBounds(ePopup, sourceRect.top - parentRect.top, DIRECTION.vertical);
            const minWidth = ePopup.clientWidth > 0 ? ePopup.clientWidth : 200;
            if (!minWidthSet) {
                ePopup.style.minWidth = `${minWidth}px`;
                minWidthSet = true;
            }
            const widthOfParent = parentRect.right - parentRect.left;
            const maxX = widthOfParent - minWidth;
            // the x position of the popup depends on RTL or LTR. for normal cases, LTR, we put the child popup
            // to the right, unless it doesn't fit and we then put it to the left. for RTL it's the other way around,
            // we try place it first to the left, and then if not to the right.
            let x;
            if (this.gos.get('enableRtl')) {
                // for RTL, try left first
                x = xLeftPosition();
                if (x < 0) {
                    x = xRightPosition();
                    this.setAlignedStyles(ePopup, 'left');
                }
                if (x > maxX) {
                    x = 0;
                    this.setAlignedStyles(ePopup, 'right');
                }
            }
            else {
                // for LTR, try right first
                x = xRightPosition();
                if (x > maxX) {
                    x = xLeftPosition();
                    this.setAlignedStyles(ePopup, 'right');
                }
                if (x < 0) {
                    x = 0;
                    this.setAlignedStyles(ePopup, 'left');
                }
            }
            return { x, y };
            function xRightPosition() {
                return sourceRect.right - parentRect.left - 2;
            }
            function xLeftPosition() {
                return sourceRect.left - parentRect.left - minWidth;
            }
        };
        this.positionPopup({
            ePopup,
            keepWithinBounds: true,
            updatePosition,
            postProcessCallback: () => this.callPostProcessPopup('subMenu', ePopup, eventSource, event instanceof MouseEvent ? event : undefined, column, node),
        });
    }
    positionPopupUnderMouseEvent(params) {
        const { ePopup, nudgeX, nudgeY, skipObserver } = params;
        this.positionPopup({
            ePopup: ePopup,
            nudgeX,
            nudgeY,
            keepWithinBounds: true,
            skipObserver,
            updatePosition: () => this.calculatePointerAlign(params.mouseEvent),
            postProcessCallback: () => this.callPostProcessPopup(params.type, params.ePopup, null, params.mouseEvent, params.column, params.rowNode),
        });
    }
    calculatePointerAlign(e) {
        const parentRect = this.getParentRect();
        return {
            x: e.clientX - parentRect.left,
            y: e.clientY - parentRect.top,
        };
    }
    positionPopupByComponent(params) {
        const { ePopup, nudgeX, nudgeY, keepWithinBounds, eventSource, alignSide = 'left', position = 'over', column, rowNode, type, } = params;
        const sourceRect = eventSource.getBoundingClientRect();
        const parentRect = this.getParentRect();
        this.setAlignedTo(eventSource, ePopup);
        const updatePosition = () => {
            let x = sourceRect.left - parentRect.left;
            if (alignSide === 'right') {
                x -= ePopup.offsetWidth - sourceRect.width;
            }
            let y;
            if (position === 'over') {
                y = sourceRect.top - parentRect.top;
                this.setAlignedStyles(ePopup, 'over');
            }
            else {
                this.setAlignedStyles(ePopup, 'under');
                const alignSide = this.shouldRenderUnderOrAbove(ePopup, sourceRect, parentRect, params.nudgeY || 0);
                if (alignSide === 'under') {
                    y = sourceRect.top - parentRect.top + sourceRect.height;
                }
                else {
                    y = sourceRect.top - ePopup.offsetHeight - (nudgeY || 0) * 2 - parentRect.top;
                }
            }
            return { x, y };
        };
        this.positionPopup({
            ePopup,
            nudgeX,
            nudgeY,
            keepWithinBounds,
            updatePosition,
            postProcessCallback: () => this.callPostProcessPopup(type, ePopup, eventSource, null, column, rowNode),
        });
    }
    shouldRenderUnderOrAbove(ePopup, targetCompRect, parentRect, nudgeY) {
        const spaceAvailableUnder = parentRect.bottom - targetCompRect.bottom;
        const spaceAvailableAbove = targetCompRect.top - parentRect.top;
        const spaceRequired = ePopup.offsetHeight + nudgeY;
        if (spaceAvailableUnder > spaceRequired) {
            return 'under';
        }
        if (spaceAvailableAbove > spaceRequired || spaceAvailableAbove > spaceAvailableUnder) {
            return 'above';
        }
        return 'under';
    }
    setAlignedStyles(ePopup, positioned) {
        const popupIdx = this.getPopupIndex(ePopup);
        if (popupIdx === -1) {
            return;
        }
        const popup = this.popupList[popupIdx];
        const { alignedToElement } = popup;
        if (!alignedToElement) {
            return;
        }
        const positions = ['right', 'left', 'over', 'above', 'under'];
        positions.forEach((position) => {
            alignedToElement.classList.remove(`ag-has-popup-positioned-${position}`);
            ePopup.classList.remove(`ag-popup-positioned-${position}`);
        });
        if (!positioned) {
            return;
        }
        alignedToElement.classList.add(`ag-has-popup-positioned-${positioned}`);
        ePopup.classList.add(`ag-popup-positioned-${positioned}`);
    }
    setAlignedTo(eventSource, ePopup) {
        const popupIdx = this.getPopupIndex(ePopup);
        if (popupIdx !== -1) {
            const popup = this.popupList[popupIdx];
            popup.alignedToElement = eventSource;
        }
    }
    callPostProcessPopup(type, ePopup, eventSource, mouseEvent, column, rowNode) {
        const callback = this.gos.getCallback('postProcessPopup');
        if (callback) {
            const params = {
                column,
                rowNode,
                ePopup,
                type,
                eventSource,
                mouseEvent,
            };
            callback(params);
        }
    }
    positionPopup(params) {
        const { ePopup, keepWithinBounds, nudgeX, nudgeY, skipObserver, updatePosition } = params;
        const lastSize = { width: 0, height: 0 };
        const updatePopupPosition = (fromResizeObserver = false) => {
            let { x, y } = updatePosition();
            if (fromResizeObserver &&
                ePopup.clientWidth === lastSize.width &&
                ePopup.clientHeight === lastSize.height) {
                return;
            }
            lastSize.width = ePopup.clientWidth;
            lastSize.height = ePopup.clientHeight;
            if (nudgeX) {
                x += nudgeX;
            }
            if (nudgeY) {
                y += nudgeY;
            }
            // if popup is overflowing to the bottom, move it up
            if (keepWithinBounds) {
                x = this.keepXYWithinBounds(ePopup, x, DIRECTION.horizontal);
                y = this.keepXYWithinBounds(ePopup, y, DIRECTION.vertical);
            }
            ePopup.style.left = `${x}px`;
            ePopup.style.top = `${y}px`;
            if (params.postProcessCallback) {
                params.postProcessCallback();
            }
        };
        updatePopupPosition();
        // Mouse tracking will recalculate positioning when moving, so won't need to recalculate here
        if (!skipObserver) {
            // Since rendering popup contents can be asynchronous, use a resize observer to
            // reposition the popup after initial updates to the size of the contents
            const resizeObserverDestroyFunc = (0, dom_1._observeResize)(this.beans, ePopup, () => updatePopupPosition(true));
            // Only need to reposition when first open, so can clean up after a bit of time
            setTimeout(() => resizeObserverDestroyFunc(), WAIT_FOR_POPUP_CONTENT_RESIZE);
        }
    }
    getActivePopups() {
        return this.popupList.map((popup) => popup.element);
    }
    getParentRect() {
        // subtract the popup parent borders, because popupParent.getBoundingClientRect
        // returns the rect outside the borders, but the 0,0 coordinate for absolute
        // positioning is inside the border, leading the popup to be off by the width
        // of the border
        const eDocument = (0, gridOptionsUtils_1._getDocument)(this.beans);
        let popupParent = this.getPopupParent();
        if (popupParent === eDocument.body) {
            popupParent = eDocument.documentElement;
        }
        else if (getComputedStyle(popupParent).position === 'static') {
            popupParent = popupParent.offsetParent;
        }
        return (0, dom_1._getElementRectWithOffset)(popupParent);
    }
    keepXYWithinBounds(ePopup, position, direction) {
        const isVertical = direction === DIRECTION.vertical;
        const sizeProperty = isVertical ? 'clientHeight' : 'clientWidth';
        const anchorProperty = isVertical ? 'top' : 'left';
        const offsetProperty = isVertical ? 'height' : 'width';
        const scrollPositionProperty = isVertical ? 'scrollTop' : 'scrollLeft';
        const eDocument = (0, gridOptionsUtils_1._getDocument)(this.beans);
        const docElement = eDocument.documentElement;
        const popupParent = this.getPopupParent();
        const popupRect = ePopup.getBoundingClientRect();
        const parentRect = popupParent.getBoundingClientRect();
        const documentRect = eDocument.documentElement.getBoundingClientRect();
        const isBody = popupParent === eDocument.body;
        const offsetSize = Math.ceil(popupRect[offsetProperty]);
        const getSize = isVertical ? dom_1._getAbsoluteHeight : dom_1._getAbsoluteWidth;
        let sizeOfParent = isBody
            ? getSize(docElement) + docElement[scrollPositionProperty]
            : popupParent[sizeProperty];
        if (isBody) {
            sizeOfParent -= Math.abs(documentRect[anchorProperty] - parentRect[anchorProperty]);
        }
        const max = sizeOfParent - offsetSize;
        return Math.min(Math.max(position, 0), Math.abs(max));
    }
    addPopup(params) {
        const eDocument = (0, gridOptionsUtils_1._getDocument)(this.beans);
        const { eChild, ariaLabel, alwaysOnTop, positionCallback, anchorToElement } = params;
        if (!eDocument) {
            (0, logging_1._warn)(122);
            return { hideFunc: () => { } };
        }
        const pos = this.getPopupIndex(eChild);
        if (pos !== -1) {
            const popup = this.popupList[pos];
            return { hideFunc: popup.hideFunc };
        }
        this.initialisePopupPosition(eChild);
        const wrapperEl = this.createPopupWrapper(eChild, ariaLabel, !!alwaysOnTop);
        const removeListeners = this.addEventListenersToPopup({ ...params, wrapperEl });
        if (positionCallback) {
            positionCallback();
        }
        this.addPopupToPopupList(eChild, wrapperEl, removeListeners, anchorToElement);
        return {
            hideFunc: removeListeners,
        };
    }
    initialisePopupPosition(element) {
        const ePopupParent = this.getPopupParent();
        const ePopupParentRect = ePopupParent.getBoundingClientRect();
        if (!(0, generic_1._exists)(element.style.top)) {
            element.style.top = `${ePopupParentRect.top * -1}px`;
        }
        if (!(0, generic_1._exists)(element.style.left)) {
            element.style.left = `${ePopupParentRect.left * -1}px`;
        }
    }
    createPopupWrapper(element, ariaLabel, alwaysOnTop) {
        const ePopupParent = this.getPopupParent();
        // add env CSS class to child, in case user provided a popup parent, which means
        // theme class may be missing
        const { environment, gos } = this.beans;
        const eWrapper = (0, dom_1._createElement)({ tag: 'div' });
        environment.applyThemeClasses(eWrapper);
        eWrapper.classList.add('ag-popup');
        element.classList.add(gos.get('enableRtl') ? 'ag-rtl' : 'ag-ltr', 'ag-popup-child');
        if (!element.hasAttribute('role')) {
            (0, aria_1._setAriaRole)(element, 'dialog');
        }
        (0, aria_1._setAriaLabel)(element, ariaLabel);
        eWrapper.appendChild(element);
        ePopupParent.appendChild(eWrapper);
        if (alwaysOnTop) {
            this.setAlwaysOnTop(element, true);
        }
        else {
            this.bringPopupToFront(element);
        }
        return eWrapper;
    }
    handleThemeChange(e) {
        if (e.themeChanged) {
            const environment = this.beans.environment;
            for (const popup of this.popupList) {
                environment.applyThemeClasses(popup.wrapper);
            }
        }
    }
    addEventListenersToPopup(params) {
        const beans = this.beans;
        const eDocument = (0, gridOptionsUtils_1._getDocument)(beans);
        const ePopupParent = this.getPopupParent();
        const { wrapperEl, eChild: popupEl, closedCallback, afterGuiAttached, closeOnEsc, modal } = params;
        let popupHidden = false;
        const hidePopupOnKeyboardEvent = (event) => {
            if (!wrapperEl.contains((0, gridOptionsUtils_1._getActiveDomElement)(beans))) {
                return;
            }
            const key = event.key;
            if (key === keyCode_1.KeyCode.ESCAPE && !(0, event_1._isStopPropagationForAgGrid)(event)) {
                removeListeners({ keyboardEvent: event });
            }
        };
        const hidePopupOnMouseEvent = (event) => removeListeners({ mouseEvent: event });
        const hidePopupOnTouchEvent = (event) => removeListeners({ touchEvent: event });
        const removeListeners = (popupParams = {}) => {
            const { mouseEvent, touchEvent, keyboardEvent, forceHide } = popupParams;
            if (!forceHide &&
                // we don't hide popup if the event was on the child, or any
                // children of this child
                (this.isEventFromCurrentPopup({ mouseEvent, touchEvent }, popupEl) ||
                    // this method should only be called once. the client can have different
                    // paths, each one wanting to close, so this method may be called multiple times.
                    popupHidden)) {
                return;
            }
            popupHidden = true;
            ePopupParent.removeChild(wrapperEl);
            eDocument.removeEventListener('keydown', hidePopupOnKeyboardEvent);
            eDocument.removeEventListener('mousedown', hidePopupOnMouseEvent);
            eDocument.removeEventListener('touchstart', hidePopupOnTouchEvent);
            eDocument.removeEventListener('contextmenu', hidePopupOnMouseEvent);
            this.eventSvc.removeEventListener('dragStarted', hidePopupOnMouseEvent);
            if (closedCallback) {
                closedCallback(mouseEvent || touchEvent || keyboardEvent);
            }
            this.removePopupFromPopupList(popupEl);
        };
        if (afterGuiAttached) {
            afterGuiAttached({ hidePopup: removeListeners });
        }
        // if we add these listeners now, then the current mouse
        // click will be included, which we don't want
        window.setTimeout(() => {
            if (closeOnEsc) {
                eDocument.addEventListener('keydown', hidePopupOnKeyboardEvent);
            }
            if (modal) {
                eDocument.addEventListener('mousedown', hidePopupOnMouseEvent);
                this.eventSvc.addEventListener('dragStarted', hidePopupOnMouseEvent);
                eDocument.addEventListener('touchstart', hidePopupOnTouchEvent);
                eDocument.addEventListener('contextmenu', hidePopupOnMouseEvent);
            }
        }, 0);
        return removeListeners;
    }
    addPopupToPopupList(element, wrapperEl, removeListeners, anchorToElement) {
        this.popupList.push({
            element: element,
            wrapper: wrapperEl,
            hideFunc: removeListeners,
            instanceId: instanceIdSeq++,
            isAnchored: !!anchorToElement,
        });
        if (anchorToElement) {
            this.setPopupPositionRelatedToElement(element, anchorToElement);
        }
    }
    getPopupIndex(el) {
        return this.popupList.findIndex((p) => p.element === el);
    }
    setPopupPositionRelatedToElement(popupEl, relativeElement) {
        const popupIndex = this.getPopupIndex(popupEl);
        if (popupIndex === -1) {
            return;
        }
        const popup = this.popupList[popupIndex];
        if (popup.stopAnchoringPromise) {
            popup.stopAnchoringPromise.then((destroyFunc) => destroyFunc && destroyFunc());
        }
        popup.stopAnchoringPromise = undefined;
        popup.isAnchored = false;
        if (!relativeElement) {
            return;
        }
        // keeps popup positioned under created, eg if context menu, if user scrolls
        // using touchpad and the cell moves, it moves the popup to keep it with the cell.
        const destroyPositionTracker = this.keepPopupPositionedRelativeTo({
            element: relativeElement,
            ePopup: popupEl,
            hidePopup: popup.hideFunc,
        });
        popup.stopAnchoringPromise = destroyPositionTracker;
        popup.isAnchored = true;
        return destroyPositionTracker;
    }
    removePopupFromPopupList(element) {
        this.setAlignedStyles(element, null);
        this.setPopupPositionRelatedToElement(element, null);
        this.popupList = this.popupList.filter((p) => p.element !== element);
    }
    keepPopupPositionedRelativeTo(params) {
        const eParent = this.getPopupParent();
        const parentRect = eParent.getBoundingClientRect();
        const { element, ePopup } = params;
        const sourceRect = element.getBoundingClientRect();
        const extractFromPixelValue = (pxSize) => parseInt(pxSize.substring(0, pxSize.length - 1), 10);
        const createPosition = (prop, direction) => {
            const initialDiff = parentRect[prop] - sourceRect[prop];
            const initial = extractFromPixelValue(ePopup.style[prop]);
            return {
                initialDiff,
                lastDiff: initialDiff,
                initial,
                last: initial,
                direction,
            };
        };
        const topPosition = createPosition('top', DIRECTION.vertical);
        const leftPosition = createPosition('left', DIRECTION.horizontal);
        const fwOverrides = this.beans.frameworkOverrides;
        return new promise_1.AgPromise((resolve) => {
            fwOverrides.wrapIncoming(() => {
                fwOverrides
                    .setInterval(() => {
                    const pRect = eParent.getBoundingClientRect();
                    const sRect = element.getBoundingClientRect();
                    const elementNotInDom = sRect.top == 0 && sRect.left == 0 && sRect.height == 0 && sRect.width == 0;
                    if (elementNotInDom) {
                        params.hidePopup();
                        return;
                    }
                    const calculateNewPosition = (position, prop) => {
                        const current = extractFromPixelValue(ePopup.style[prop]);
                        if (position.last !== current) {
                            // some other process has moved the popup
                            position.initial = current;
                            position.last = current;
                        }
                        const currentDiff = pRect[prop] - sRect[prop];
                        if (currentDiff != position.lastDiff) {
                            const newValue = this.keepXYWithinBounds(ePopup, position.initial + position.initialDiff - currentDiff, position.direction);
                            ePopup.style[prop] = `${newValue}px`;
                            position.last = newValue;
                        }
                        position.lastDiff = currentDiff;
                    };
                    calculateNewPosition(topPosition, 'top');
                    calculateNewPosition(leftPosition, 'left');
                }, 200)
                    .then((intervalId) => {
                    const result = () => {
                        if (intervalId != null) {
                            window.clearInterval(intervalId);
                        }
                    };
                    resolve(result);
                });
            }, 'popupPositioning');
        });
    }
    hasAnchoredPopup() {
        return this.popupList.some((popup) => popup.isAnchored);
    }
    isEventFromCurrentPopup(params, target) {
        const { mouseEvent, touchEvent } = params;
        const event = mouseEvent ? mouseEvent : touchEvent;
        if (!event) {
            return false;
        }
        const indexOfThisChild = this.getPopupIndex(target);
        if (indexOfThisChild === -1) {
            return false;
        }
        for (let i = indexOfThisChild; i < this.popupList.length; i++) {
            const popup = this.popupList[i];
            if ((0, event_1._isElementInEventPath)(popup.element, event)) {
                return true;
            }
        }
        // if the user did not write their own Custom Element to be rendered as popup
        // and this component has an additional popup element, they should have the
        // `ag-custom-component-popup` class to be detected as part of the Custom Component
        return this.isElementWithinCustomPopup(event.target);
    }
    isElementWithinCustomPopup(el) {
        const eDocument = (0, gridOptionsUtils_1._getDocument)(this.beans);
        while (el && el !== eDocument.body) {
            if (el.classList.contains('ag-custom-component-popup') || el.parentElement === null) {
                return true;
            }
            el = el.parentElement;
        }
        return false;
    }
    getWrapper(ePopup) {
        while (!ePopup.classList.contains('ag-popup') && ePopup.parentElement) {
            ePopup = ePopup.parentElement;
        }
        return ePopup.classList.contains('ag-popup') ? ePopup : null;
    }
    setAlwaysOnTop(ePopup, alwaysOnTop) {
        const eWrapper = this.getWrapper(ePopup);
        if (!eWrapper) {
            return;
        }
        eWrapper.classList.toggle('ag-always-on-top', !!alwaysOnTop);
        if (alwaysOnTop) {
            this.bringPopupToFront(eWrapper);
        }
    }
    /** @returns true if moved */
    bringPopupToFront(ePopup) {
        const parent = this.getPopupParent();
        const popupList = Array.prototype.slice.call(parent.querySelectorAll('.ag-popup'));
        const popupLen = popupList.length;
        const eWrapper = this.getWrapper(ePopup);
        if (!eWrapper || popupLen <= 1 || !parent.contains(ePopup)) {
            return;
        }
        const standardPopupList = [];
        const alwaysOnTopList = [];
        for (const popup of popupList) {
            if (popup === eWrapper) {
                continue;
            }
            if (popup.classList.contains('ag-always-on-top')) {
                alwaysOnTopList.push(popup);
            }
            else {
                standardPopupList.push(popup);
            }
        }
        const innerElsScrollMap = [];
        const onTopLength = alwaysOnTopList.length;
        const isPopupAlwaysOnTop = eWrapper.classList.contains('ag-always-on-top');
        const shouldBeLast = isPopupAlwaysOnTop || !onTopLength;
        const targetList = shouldBeLast
            ? [...standardPopupList, ...alwaysOnTopList, eWrapper]
            : [...standardPopupList, eWrapper, ...alwaysOnTopList];
        for (let i = 0; i <= popupLen; i++) {
            const currentPopup = targetList[i];
            if (popupList[i] === targetList[i] || currentPopup === eWrapper) {
                continue;
            }
            const innerEls = currentPopup.querySelectorAll('div');
            innerEls.forEach((el) => {
                if (el.scrollTop !== 0) {
                    innerElsScrollMap.push([el, el.scrollTop]);
                }
            });
            if (i === 0) {
                parent.insertAdjacentElement('afterbegin', currentPopup);
            }
            else {
                targetList[i - 1].insertAdjacentElement('afterend', currentPopup);
            }
        }
        while (innerElsScrollMap.length) {
            const currentEl = innerElsScrollMap.pop();
            currentEl[0].scrollTop = currentEl[1];
        }
    }
}
exports.PopupService = PopupService;


/***/ }),

/***/ 68332:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TabGuardComp = void 0;
const component_1 = __webpack_require__(78020);
const tabGuardFeature_1 = __webpack_require__(71017);
class TabGuardComp extends component_1.Component {
    initialiseTabGuard(params) {
        this.tabGuardFeature = this.createManagedBean(new tabGuardFeature_1.TabGuardFeature(this));
        this.tabGuardFeature.initialiseTabGuard(params);
    }
    forceFocusOutOfContainer(up = false) {
        this.tabGuardFeature.forceFocusOutOfContainer(up);
    }
    appendChild(newChild, container) {
        this.tabGuardFeature.appendChild(super.appendChild.bind(this), newChild, container);
    }
}
exports.TabGuardComp = TabGuardComp;


/***/ }),

/***/ 90006:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TabGuardCtrl = exports.TabGuardClassNames = void 0;
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const focus_1 = __webpack_require__(82331);
const managedFocusFeature_1 = __webpack_require__(31772);
exports.TabGuardClassNames = {
    TAB_GUARD: 'ag-tab-guard',
    TAB_GUARD_TOP: 'ag-tab-guard-top',
    TAB_GUARD_BOTTOM: 'ag-tab-guard-bottom',
};
class TabGuardCtrl extends beanStub_1.BeanStub {
    constructor(params) {
        super();
        this.skipTabGuardFocus = false;
        this.forcingFocusOut = false;
        // Used when `isFocusableContainer` enabled
        this.allowFocus = false;
        const { comp, eTopGuard, eBottomGuard, focusTrapActive, forceFocusOutWhenTabGuardsAreEmpty, isFocusableContainer, focusInnerElement, onFocusIn, onFocusOut, shouldStopEventPropagation, onTabKeyDown, handleKeyDown, isEmpty, eFocusableElement, } = params;
        this.comp = comp;
        this.eTopGuard = eTopGuard;
        this.eBottomGuard = eBottomGuard;
        this.providedFocusInnerElement = focusInnerElement;
        this.eFocusableElement = eFocusableElement;
        this.focusTrapActive = !!focusTrapActive;
        this.forceFocusOutWhenTabGuardsAreEmpty = !!forceFocusOutWhenTabGuardsAreEmpty;
        this.isFocusableContainer = !!isFocusableContainer;
        this.providedFocusIn = onFocusIn;
        this.providedFocusOut = onFocusOut;
        this.providedShouldStopEventPropagation = shouldStopEventPropagation;
        this.providedOnTabKeyDown = onTabKeyDown;
        this.providedHandleKeyDown = handleKeyDown;
        this.providedIsEmpty = isEmpty;
    }
    postConstruct() {
        this.createManagedBean(new managedFocusFeature_1.ManagedFocusFeature(this.eFocusableElement, {
            shouldStopEventPropagation: () => this.shouldStopEventPropagation(),
            onTabKeyDown: (e) => this.onTabKeyDown(e),
            handleKeyDown: (e) => this.handleKeyDown(e),
            onFocusIn: (e) => this.onFocusIn(e),
            onFocusOut: (e) => this.onFocusOut(e),
        }));
        this.activateTabGuards();
        [this.eTopGuard, this.eBottomGuard].forEach((guard) => this.addManagedElementListeners(guard, { focus: this.onFocus.bind(this) }));
    }
    handleKeyDown(e) {
        if (this.providedHandleKeyDown) {
            this.providedHandleKeyDown(e);
        }
    }
    tabGuardsAreActive() {
        return !!this.eTopGuard && this.eTopGuard.hasAttribute('tabIndex');
    }
    shouldStopEventPropagation() {
        if (this.providedShouldStopEventPropagation) {
            return this.providedShouldStopEventPropagation();
        }
        return false;
    }
    activateTabGuards() {
        // Do not activate tabs while focus is being forced out
        if (this.forcingFocusOut) {
            return;
        }
        const tabIndex = this.gos.get('tabIndex');
        this.comp.setTabIndex(tabIndex.toString());
    }
    deactivateTabGuards() {
        this.comp.setTabIndex();
    }
    onFocus(e) {
        if (this.isFocusableContainer && !this.eFocusableElement.contains(e.relatedTarget)) {
            if (!this.allowFocus) {
                this.findNextElementOutsideAndFocus(e.target === this.eBottomGuard);
                return;
            }
        }
        if (this.skipTabGuardFocus) {
            this.skipTabGuardFocus = false;
            return;
        }
        // when there are no focusable items within the TabGuard, focus gets stuck
        // in the TabGuard itself and has nowhere to go, so we need to manually find
        // the closest element to focus by calling `forceFocusOutWhenTabGuardAreEmpty`.
        if (this.forceFocusOutWhenTabGuardsAreEmpty) {
            const isEmpty = this.providedIsEmpty
                ? this.providedIsEmpty()
                : (0, focus_1._findFocusableElements)(this.eFocusableElement, '.ag-tab-guard').length === 0;
            if (isEmpty) {
                this.findNextElementOutsideAndFocus(e.target === this.eBottomGuard);
                return;
            }
        }
        if (this.isFocusableContainer && this.eFocusableElement.contains(e.relatedTarget)) {
            return;
        }
        const fromBottom = e.target === this.eBottomGuard;
        const hasFocusedInnerElement = this.providedFocusInnerElement
            ? this.providedFocusInnerElement(fromBottom)
            : this.focusInnerElement(fromBottom);
        if (!hasFocusedInnerElement && this.forceFocusOutWhenTabGuardsAreEmpty) {
            // nothing actually got focused, so force out
            this.findNextElementOutsideAndFocus(e.target === this.eBottomGuard);
        }
    }
    findNextElementOutsideAndFocus(up) {
        const eDocument = (0, gridOptionsUtils_1._getDocument)(this.beans);
        const focusableEls = (0, focus_1._findFocusableElements)(eDocument.body, null, true);
        const index = focusableEls.indexOf(up ? this.eTopGuard : this.eBottomGuard);
        if (index === -1) {
            return;
        }
        let start;
        let end;
        if (up) {
            start = 0;
            end = index;
        }
        else {
            start = index + 1;
            end = focusableEls.length;
        }
        const focusableRange = focusableEls.slice(start, end);
        const targetTabIndex = this.gos.get('tabIndex');
        focusableRange.sort((a, b) => {
            const indexA = parseInt(a.getAttribute('tabindex') || '0');
            const indexB = parseInt(b.getAttribute('tabindex') || '0');
            if (indexB === targetTabIndex) {
                return 1;
            }
            if (indexA === targetTabIndex) {
                return -1;
            }
            if (indexA === 0) {
                return 1;
            }
            if (indexB === 0) {
                return -1;
            }
            return indexA - indexB;
        });
        focusableRange[up ? focusableRange.length - 1 : 0]?.focus();
    }
    onFocusIn(e) {
        if (this.focusTrapActive || this.forcingFocusOut) {
            return;
        }
        if (this.providedFocusIn) {
            this.providedFocusIn(e);
        }
        if (!this.isFocusableContainer) {
            this.deactivateTabGuards();
        }
    }
    onFocusOut(e) {
        if (this.focusTrapActive) {
            return;
        }
        if (this.providedFocusOut) {
            this.providedFocusOut(e);
        }
        if (!this.eFocusableElement.contains(e.relatedTarget)) {
            this.activateTabGuards();
        }
    }
    onTabKeyDown(e) {
        if (this.providedOnTabKeyDown) {
            this.providedOnTabKeyDown(e);
            return;
        }
        if (this.focusTrapActive) {
            return;
        }
        if (e.defaultPrevented) {
            return;
        }
        const tabGuardsAreActive = this.tabGuardsAreActive();
        if (tabGuardsAreActive) {
            this.deactivateTabGuards();
        }
        const nextRoot = this.getNextFocusableElement(e.shiftKey);
        if (tabGuardsAreActive) {
            // ensure the tab guards are only re-instated once the event has finished processing, to avoid the browser
            // tabbing to the tab guard from inside the component
            setTimeout(() => this.activateTabGuards(), 0);
        }
        if (!nextRoot) {
            return;
        }
        nextRoot.focus();
        e.preventDefault();
    }
    focusInnerElement(fromBottom = false) {
        const focusable = (0, focus_1._findFocusableElements)(this.eFocusableElement);
        if (this.tabGuardsAreActive()) {
            // remove tab guards from this component from list of focusable elements
            focusable.splice(0, 1);
            focusable.splice(focusable.length - 1, 1);
        }
        if (!focusable.length) {
            return false;
        }
        focusable[fromBottom ? focusable.length - 1 : 0].focus({ preventScroll: true });
        return true;
    }
    getNextFocusableElement(backwards) {
        return (0, focus_1._findNextFocusableElement)(this.beans, this.eFocusableElement, false, backwards);
    }
    forceFocusOutOfContainer(up = false) {
        // avoid multiple calls to `forceFocusOutOfContainer`
        if (this.forcingFocusOut) {
            return;
        }
        const tabGuardToFocus = up ? this.eTopGuard : this.eBottomGuard;
        this.activateTabGuards();
        this.skipTabGuardFocus = true;
        this.forcingFocusOut = true;
        // this focus will set `this.skipTabGuardFocus` to false;
        tabGuardToFocus.focus();
        window.setTimeout(() => {
            this.forcingFocusOut = false;
            this.activateTabGuards();
        });
    }
    isTabGuard(element, bottom) {
        return (element === this.eTopGuard && !bottom) || (element === this.eBottomGuard && (bottom ?? true));
    }
    setAllowFocus(allowFocus) {
        this.allowFocus = allowFocus;
    }
}
exports.TabGuardCtrl = TabGuardCtrl;


/***/ }),

/***/ 71017:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TabGuardFeature = void 0;
const beanStub_1 = __webpack_require__(68731);
const gridOptionsUtils_1 = __webpack_require__(67274);
const aria_1 = __webpack_require__(95230);
const dom_1 = __webpack_require__(33507);
const tabGuardCtrl_1 = __webpack_require__(90006);
class TabGuardFeature extends beanStub_1.BeanStub {
    constructor(comp) {
        super();
        this.comp = comp;
    }
    initialiseTabGuard(params) {
        this.eTopGuard = this.createTabGuard('top');
        this.eBottomGuard = this.createTabGuard('bottom');
        this.eFocusableElement = this.comp.getFocusableElement();
        const { eTopGuard, eBottomGuard, eFocusableElement } = this;
        const tabGuards = [eTopGuard, eBottomGuard];
        const compProxy = {
            setTabIndex: (tabIndex) => {
                tabGuards.forEach((tabGuard) => tabIndex != null
                    ? tabGuard.setAttribute('tabindex', tabIndex)
                    : tabGuard.removeAttribute('tabindex'));
            },
        };
        this.addTabGuards(eTopGuard, eBottomGuard);
        const { focusTrapActive = false, onFocusIn, onFocusOut, focusInnerElement, handleKeyDown, onTabKeyDown, shouldStopEventPropagation, isEmpty, forceFocusOutWhenTabGuardsAreEmpty, isFocusableContainer, } = params;
        this.tabGuardCtrl = this.createManagedBean(new tabGuardCtrl_1.TabGuardCtrl({
            comp: compProxy,
            focusTrapActive,
            eTopGuard,
            eBottomGuard,
            eFocusableElement,
            onFocusIn,
            onFocusOut,
            focusInnerElement,
            handleKeyDown,
            onTabKeyDown,
            shouldStopEventPropagation,
            isEmpty,
            forceFocusOutWhenTabGuardsAreEmpty,
            isFocusableContainer,
        }));
    }
    getTabGuardCtrl() {
        return this.tabGuardCtrl;
    }
    createTabGuard(side) {
        const tabGuard = (0, gridOptionsUtils_1._getDocument)(this.beans).createElement('div');
        const cls = side === 'top' ? tabGuardCtrl_1.TabGuardClassNames.TAB_GUARD_TOP : tabGuardCtrl_1.TabGuardClassNames.TAB_GUARD_BOTTOM;
        tabGuard.classList.add(tabGuardCtrl_1.TabGuardClassNames.TAB_GUARD, cls);
        (0, aria_1._setAriaRole)(tabGuard, 'presentation');
        return tabGuard;
    }
    addTabGuards(topTabGuard, bottomTabGuard) {
        const eFocusableElement = this.eFocusableElement;
        eFocusableElement.insertAdjacentElement('afterbegin', topTabGuard);
        eFocusableElement.insertAdjacentElement('beforeend', bottomTabGuard);
    }
    removeAllChildrenExceptTabGuards() {
        const tabGuards = [this.eTopGuard, this.eBottomGuard];
        (0, dom_1._clearElement)(this.comp.getFocusableElement());
        this.addTabGuards(...tabGuards);
    }
    forceFocusOutOfContainer(up = false) {
        this.tabGuardCtrl.forceFocusOutOfContainer(up);
    }
    appendChild(appendChild, newChild, container) {
        if (!(0, dom_1._isNodeOrElement)(newChild)) {
            newChild = newChild.getGui();
        }
        const { eBottomGuard: bottomTabGuard } = this;
        if (bottomTabGuard) {
            bottomTabGuard.insertAdjacentElement('beforebegin', newChild);
        }
        else {
            appendChild(newChild, container);
        }
    }
    destroy() {
        // in some places (`AgMenuPanel`) the lifecycle on the tab guard feature doesn't match
        // the lifecycle of the component gui, so remove the tab guards on destroy
        const { eTopGuard, eBottomGuard } = this;
        (0, dom_1._removeFromParent)(eTopGuard);
        (0, dom_1._removeFromParent)(eBottomGuard);
        super.destroy();
    }
}
exports.TabGuardFeature = TabGuardFeature;


/***/ }),

/***/ 99644:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TouchListener = void 0;
const localEventService_1 = __webpack_require__(85889);
const mouse_1 = __webpack_require__(3276);
class TouchListener {
    constructor(eElement, preventMouseClick = false) {
        this.DOUBLE_TAP_MILLIS = 500;
        this.destroyFuncs = [];
        this.touching = false;
        this.localEventService = new localEventService_1.LocalEventService();
        this.preventMouseClick = preventMouseClick;
        const startListener = this.onTouchStart.bind(this);
        const moveListener = this.onTouchMove.bind(this);
        const endListener = this.onTouchEnd.bind(this);
        eElement.addEventListener('touchstart', startListener, { passive: true });
        eElement.addEventListener('touchmove', moveListener, { passive: true });
        // we set passive=false, as we want to prevent default on this event
        eElement.addEventListener('touchend', endListener, { passive: false });
        this.destroyFuncs.push(() => {
            eElement.removeEventListener('touchstart', startListener, { passive: true });
            eElement.removeEventListener('touchmove', moveListener, { passive: true });
            eElement.removeEventListener('touchend', endListener, { passive: false });
        });
    }
    getActiveTouch(touchList) {
        for (let i = 0; i < touchList.length; i++) {
            const matches = touchList[i].identifier === this.touchStart.identifier;
            if (matches) {
                return touchList[i];
            }
        }
        return null;
    }
    addEventListener(eventType, listener) {
        this.localEventService.addEventListener(eventType, listener);
    }
    removeEventListener(eventType, listener) {
        this.localEventService.removeEventListener(eventType, listener);
    }
    onTouchStart(touchEvent) {
        // only looking at one touch point at any time
        if (this.touching) {
            return;
        }
        this.touchStart = touchEvent.touches[0];
        this.touching = true;
        this.moved = false;
        const touchStartCopy = this.touchStart;
        window.setTimeout(() => {
            const touchesMatch = this.touchStart === touchStartCopy;
            if (this.touching && touchesMatch && !this.moved) {
                this.moved = true;
                const event = {
                    type: 'longTap',
                    touchStart: this.touchStart,
                    touchEvent: touchEvent,
                };
                this.localEventService.dispatchEvent(event);
            }
        }, 500);
    }
    onTouchMove(touchEvent) {
        if (!this.touching) {
            return;
        }
        const touch = this.getActiveTouch(touchEvent.touches);
        if (!touch) {
            return;
        }
        const eventIsFarAway = !(0, mouse_1._areEventsNear)(touch, this.touchStart, 4);
        if (eventIsFarAway) {
            this.moved = true;
        }
    }
    onTouchEnd(touchEvent) {
        if (!this.touching) {
            return;
        }
        if (!this.moved) {
            const event = {
                type: 'tap',
                touchStart: this.touchStart,
            };
            this.localEventService.dispatchEvent(event);
            this.checkForDoubleTap();
        }
        // stops the tap from also been processed as a mouse click
        if (this.preventMouseClick && touchEvent.cancelable) {
            touchEvent.preventDefault();
        }
        this.touching = false;
    }
    checkForDoubleTap() {
        const now = Date.now();
        if (this.lastTapTime && this.lastTapTime > 0) {
            // if previous tap, see if duration is short enough to be considered double tap
            const interval = now - this.lastTapTime;
            if (interval > this.DOUBLE_TAP_MILLIS) {
                // dispatch double tap event
                const event = {
                    type: 'doubleTap',
                    touchStart: this.touchStart,
                };
                this.localEventService.dispatchEvent(event);
                // this stops a tripple tap ending up as two double taps
                this.lastTapTime = null;
            }
            else {
                this.lastTapTime = now;
            }
        }
        else {
            this.lastTapTime = now;
        }
    }
    destroy() {
        this.destroyFuncs.forEach((func) => func());
    }
}
exports.TouchListener = TouchListener;


/***/ }),

/***/ 80902:
/***/ (function(module) {

module.exports = "data:font/woff2;charset=utf-8;base64,d09GMgABAAAAABS0AAsAAAAALNgAABRhAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHItKBmAAjRIKrjimKwE2AiQDgmALgTIABCAFhF4HhjMbUSdlhhhsHADxzJlBFDVabspEVG0K2f9/WOBk7MdsnLSiQdkjaCNosdtURg76wzo9eYHT6CwM6iB9oSyMecRhsyAP+taoW6gUymzjBSbq3zEiCy42G0qYBNVY2XPE6o0CkggQIKEjVIyKeqND5SPs/vy26sH/MK47oga+wDicuId0IWu6eOlCuiSawgbABW3a5i7SJg4hWAPNXVSIGXijX46YU4tAKu5QI5nnIjVzIhWjRn4eXq66qWqGW8l/nzUsUsqY2+PpW9ueIiGKCQXwQFAuVm172RdEPMJ0POe7d+4r0y7ONO0BawKhFoT9kMkscY94oQeNTe0BkTDoiD48f8Ly8PO+t/pWv5UuCSFdBBvErW71yz4pAq72+2WXKL5I05JpnZt773OzmC94OkQtQfsWCqKhMS8hZqXrdIYWyFZKwoefS+0yAjwhxP9J6b+8Qq5AmHaU3gBBAXuCu3JKPEWKjAMSetZMSoKAMUedNpb/2nizIkMiIyVDo/FjubGJjiOU1KjLCKCiZYGceFrY4HwwH55EYbFhgF3LeAjXp8yjDFjhHsx3nK+ZOGWc8szv4BCziUOkAN3Bzvb+ePq8mwoGxCylgWDDJnvj8FgMgUgiI9G4XkTJIQUihSqp9AqjpNo6QwjGERnGtCo0eW6MnYnOW2s6gRDJLcmJxNwCl/IuZUUUEWtJQLFL6VhQ+Fgcw9tSaBhK7+JeZhsGhmyHt+NB2VDxNAu4ikqBHyqH2LlScU4D4vCmksSosYDH2YvIDIUtUTUaqzQSpYLiJotsa4mBJ6vDRKqVYz0q0p0lgi2GVtLqUNsG420IUnBzj8ajORXM6K55ocpmXwK3zuWu0C+zynBnzFBWmT9XwztBUGPuNdYZeswNRKFxq7EUJRjjeO9sHjm6V969/XIU9nY8QkAMgzIYBeO9R2spsRaKgpb4aO5rko3bjJt5NS30FFWyct4Oza0xgNJrxoHHPW687IpKCzvJqdWcLcP11TxOX0q6vX4K48tiwgCmVBdOPJWqbiQbay6SgMNQrYy3M2bVzdMZ0VhTpZUKjPZN7o+CApeWFAocL1GgQmEX0pCOcb5olce5oNdCC7OKKumIG+WvjZSxYrCMuwgj3UgK4XPBbUbStegWhRKwjDfTgqKElg92PmDG2BC7Tp7ESw71RXLOomvBJ+meTILOK8oCUiSMsx0hZkuXbjGTabaJAUlyB11EhpAMJm41vGMuueeFIYcCZW3cegP/MEzfG7HKmQSNlx8599uLpE6RgbuAeDn78LgBasMdUq3IQtU3NkuomRtN0vwXt86lnYBjVQkGjSBnsprgxHwwUejexirNzr7rD3MCzpwnVkMeZL5NTwHf07eP/9AOBCCDykJ8hJWryQvf1JOEmgHs5YSf834crg3IA1mgHciBTK+6PNoBZSxFqwzxgBrMfnCRutseeZP6k/T7tw6X3fUkRfrFPnFecCadE0pGvnAIramvOZ548SpFK5p/F0oMp+xFd9yhjWNOIpAQzFo0EzMLKxs7x3BvLm4eXj5+AUEhYZFIxIIviAcSkmxS0jKycrzyCopKyiqqaupsGppaELe2jq6evoGhkbGJqZm5BYgCxHG87D9/eFFdGdsamZ+wmludmlzHzYyvbU4vbWzrxaoBcieT6gOgYwnLwCkMA2ewCJzDLHABK8AljAFXsAVcwwhwA/PALUwA97AAPMAc8AirwBNMAc8wCbzAOvAORoH3MAN8gHHgI6wBn2AT+AzTwBdYAr7CBvDtC8u3QSIgJZkNgAiAGIAUAGkAmgBoBqAFgFYA2gBoB6ADgE4AugDoBqAHgF4A+gDoB2AAgEEAhgAYBmAEgFEAxgAYB+ABABMATAIwhYcqSGnIMwPALABzAMwDsIDRVBYBFUsALAOwAsAqAGsArAOwAcAmAFt4qILUBj12ANgFYA8PWZD6HlogDaA8hwAcAXAMwAkApwBcAJABIAtADoA8AAU8DIAkehgESfIxBLCzbuEnPxTeQLkP4tT4B5tY+AeCSSYKzbcmIAQapdDFoEjRIz0MWgfJ9JFpKWUSwU5JUImgHzYm3oVIby6GxGMgvpntFD6Scp2v0mQM/Gsnhp9Idz8H5YS1ObtKh36zICiQS2WSBqA1nAJ5bc8pKIKgcj7lXwq2MANNESjTCR0ZB9DQKcbET2BMxYkVhOdXCDavDgaoNH6ngA+/15qEWaTG/ysNkVi9m4CsIYNgGGi/VahI2a1CFhwsS0AhV2cyP1vD5JzrkwtpTna20eRwyZqK2CpL2YxSgOuXbUEhhdkify2qdB7roYuX3UxAu4v3r2eEU5Y+4WoMSda2yGn0kmczJZ6aHhDm05T7rMdA98kfiBu4GDpKgMOBZjTQuFAUwViq+tGCFneX2JQli/wHALVq3mTmn6guX1ur+1qNWnVWMVbDyVWbnZ1vrBgbalpL3vsIwly75vPUCy40PJFrvV7o3X693ow4R6SAFrkQoPWEmnaxG/oooG0+MsA+t4lUzeXBLPSys5EUmtbpVGgRQJzeTbvbHcYjgUh2+XRnde+snvAC2qCirrvDONOlW2A5R4fSdhUGcnNaqS5U0+yKFZewdHc1zIIpr75cg5hy1pfxClnCisub3ixcQlz9zX+s5m9eqZCzuQv3AhRfGuBYwgQ3ek9CDGxpemyJrZdzjgctfEyWlbcjrbUBCjZ8ps6FTsJNs3Y5ndD7EXdVMU57O7NX63/ouwrbpGKuXufnPzP2lRjPK3qQT0P/xsIrtd8audTQzzcatil8nkE9Tkh8Ze5+qFJqpt4XUI1hVJ+fN+Oa/0X9N6/9DPhsEAvlyEIED+fXCHBGJXBAQ3TYypVfZoYCzGKV7EkgPqzzaBdiqiKQohf7Zg77RXUgiy7xjI62stdq7cCRVKamq1YPusY7FVfxPz95/TdLfKuz4cRJVJYV1fLXLxh07//fNf5mhQ0pZGMVgrFyUXdhoD4SsGhU9krFYgNgubpKQLSKkiAKrZX53b8+3im3bZaK36mpl38b/m86ffEL6KTEDK92ZSwHPXZ48lIwKnyYl/DjgZ24lZQGSk2PDE5v3GzK9jjKsjmLfT9+mmwsknug4BC3U1SURoGeKJW7rHTXtQZFk12VUo/wzFYuNTGzltDrF/JVj+TAO+ftNPoobDdqx90OC7ozx86eFzArcaS0KadZEPtj8K0lhmNiv/8qh7SbZdZwKlZi5MuZmFZG7yxmn9QYmW0Xh6JHg+UPTRg+zCDTIX5bU91nA5d4l/NA8SKreiz7aqU+0Ac+DV/bUKjwvXE6UgWfPIJJ/4X/IL9hX+c3iXd48wQlqL26cUaamMaORh/TgWxvo9CLk0f0gqK7wgfQYbJNogLrkpFsQQvuO+jSYNISj7bo1nHby6Yn9V7A6C3SQwScf++c2Z+kzJ3W6lQql0dDFy1zrw/bs3oE7j03bq3pU/n5sVfSFTB/FG9ni0FrqJSTKinphfiAZKIkZ9emrioz8mf5J8UiaGcHwg0aD+micugCNasq5FzKd3dGbfp1Kx87upwjqa87tQMzqP3GoTmd9q+cVSQZvcS7QBHlgo0WWgIZKk/NI0HX8U35TBTDZ7A7bZ3CtN9Ml4JqRwgkEejvGCFtYY6JVdLKlIHZ+qF8fb+UI7s3l7f/zP5Vjf9zteqvE2u/3nWsZS5gmElqNOfjOE3iJkkjHb6W+3FkQn5QQFr1ZvN34vsHc3duLvBFG1prkqoSEqqSal5LOKoqoQ79eiKQoNuwnkq3jNiQvSLcHTVDN+OjbLx8vJma8G0CJK4zO/MiHvCceQ8ieL0vxw93ZjDy8q5eMRrz8tWFy8PCteHyqCnOfblog0bpHz6dNxj0dXUIkp52lZ2+euXq3vRdu1Z8UrExkADGJj6vAFJPppfSrTRjBLGxKApzR6btUIagAqz7qj99hl3XUxSEoWdsOGAyQmabPvwmBrgMAyx1w2Q4+Olvym5CzNy+bnO886pLkPDgw0j1BM0c8X67oJFBMUEjghKW/03J4oP3uG8mTl5i92hQcJanyU5jeOK60veBt+fImG87xAzs0gSUzkwNpA3e7jYlbXycB/Ng7NAT6qHFxeyZ7tv2ubNZDB9f9xs2mssK96mjtJ9dvYpo7gbmPwntEOn92oc23X4SY4fb6JT8Vzya2+CyTqGPz59XaFtTV4SeCDnJCgXGFJeJuc4OLMFDVssmj2OVrNjbkYOcd9BaIdzqdvKExWTiJwU76lyTZec+csRxcayJmXux8zGuH3uNaM1g0eDVGGepIk5exsH2f0q0mo1xjikUJlMVHwReNi/aJ/fivT24WjJ52JgVTcN8Mj28sP9SSzNLt98nLg3yiHL1ys1rUk4+s562guXNii+eWTQlfpHDII+hHjRYcaCdRMsW+4iwzrOhV4QF+XWqc3NLYkcWyngS3uhmrrSJqNXm5Yrnikba6fJFYu1gv4SZIvVtMRbk/0sqEbLlWtqYAQRUF2aWlc+Nm7/oZvDQ+BVgfX8BQTElEp6MZziYMUQ6ZLOC9eGKsDBFiYQjSzLfMIRzfatg63XBunNgoEgliRuUFqUWtxE2+Fdw9gzRbbXLDSthI0BAa9Ur9TpylQXSXJ/Hu1oHI0/royX7vLzIpmkJ08RFWk1fi0aRDn8dOJ+T+jbed7O5KzdUXY5vEtqtOOcAThaQydWJiVVjJayShVrwA5wux3wif6Kxnx4qDT1hbHWrXwib0qDOz1c3rNau3uKKkuw6V6qeX5GVtQgATg8bLUoLTKfWhTMshOVeE21A3bUpbXkZqDbR+oof3ScflIGeNpSH54bl5ITlhpcnj8TbHjzg4CNz6dvI5CI3iJnXuPfSz8Kfj/ZggG1ZhstTm7/XInwRRlOCr/ItxAzDDALK4pcuHaFB9b8IC+vrG5h8UkUMDBCqk5MH+kDgmaTnh1/g7/QL4fwsgeZNdg3W+acWnPLdbRkY0at5pN3jx2QH+TlyxO+B8cD6vFxtZxj7yf4+Yyhvz795REVgScDSpQElgRW3JBy1dOl7+YrAWxL/jvXzmysSSgWC0oQKU4m6e6mgIsGU2xysX8VjhcKxi1Nk5OLstxNR1WTzRdldT6/hS1tDzBybv9xf6X9n7f653MZG/d04TH+K1hGAl++Sofzit3HL8HH4si41D9+1q+uD2WrVwV1fOSGHAyvOvFutLipOgYsXH7+a8PAEsf5WSkZtWvLwR2uNFUrlIFnjnNmbZKOykh/aweB+T4VWlYpPjK2qlMtJMu7YcXB9yNVnbia1ePz4zZmk8E5CmTmBePgw2Es9n28EWEkMxMlp/KhsUJDSbpljVEm1hPTwsYxjRwiJViUh57AzgiWFGKJKnTxxdlHG8czjhy3glBpns9KDVYVEuLkKGPMa3bzc9i2Ts5Z/cIqj+oXXQHPrAzc/N6hjLbHpe1uPtHqZJkw42d7W3n4SrEn0k/T7C4HrQZ4IU+1Vv5OcCaI3FsdgOz7hNEo29+ht725vRUCLB97QfIPLpr9mBRacvh8QFNACCv/1bc6c8hPaH7Nfx2UgPP9Hc0ZXLqBdrOVQDzFP4nECnn3oCzpBt9FPBD0VXKLfpqi+wD6KUrfSa2770JlFXV3ElcOIe3/2Fuoh2gramc9Ut4PUk3uDeivedugO7Hn6rMV3JUT/ve7ohMLe6DXPTaFv6tFbqHO4/SyFUe8R6KtQsvoCQfpptcjp71WH5q5aqW5QNixeq1rpcvSx8jGcPx935w7t7h3xpPVSyWIdd0mXXdcSjm6zRKILX0KD6bN+/6Yi9pfYD2JBhQAA6H4aabhQDNuQBmEsGFw0GW1QzUNWIZYLZqNnddb5/SPbgn4Ji6gddHeQhZa5uBQxp2wMYpH/VCQvIdJqpAp1RrXNCbmc6Bykoo3sb8LAAvdFXVOSmmw1nYVmNFkx4Y1cRioTK6vQpYqsHK1HXSEWwqPQgqyqYnxjVUqYhchNW3dnodvxEqImL19UX8BH3cUpSBu+iAHloW9YeBFVNiWp8T/1H8M4xTenVnuk/TPIBTUD2JUNfnNmdhjvfitz4aAY5N/NMiGLuh7gP0LK396Y4s+1/P4JhoPpUzmUGaASTAL/NSts+d4lhcGpLckwCXwosllSAIucTRbybNqiILOZQUWVtnWVz3MIkRsMhLi3AMnps0DYfBUYm/9ACTpKoOESAFYnYsjnsylcEGL8UYL7ZBQlmPgdfYlmPIDwGr9RcmCq7pu7o/KIhDJ/Sle1lyqP/kG1qzrhoXpiUoyRqyT8jFabXjU93t520z00loeJ8UcJ7lPopShN/B7k+ZKZb0RryHL8HYrMe2eq3GvcaVsckUQuq+8q7WVdP4/+Ye6hXf1OeMjwyTDTFDERPMckl89oQ2r0JWR6dJtM1OlSwxrhn4DkdQBY45ZF7iAwgzksYAkrWMPmj3E5NP6d9ed+7fH6/IFgKByJxuIHiWQqncnm8oViqVyp1uqNZqvd6fb6g+FoPJnO5guGzRaKxBKpTK4YlpObl19Q+MdwJaEqKi4x/d+karwX9EYD09KI8CnPTLZLa8hiXNjeiL6eqmhfWj7Xm3R0Hw86CORQUYZARvHtsdhCWs695chSp7A3RlZvsAyUt5ZJxVhFN7ecLgsrnPPM5nFmi84dZrvA87XD1mMlYzyg2+AF6xxN7mdZ5rIL8YphC7tJ1rmXkBZeuKR5YQCdR+x0GQNV3NVVZOMC+fVgzmEIV5wPSGVtaZDQBDHhjlhrEyOfYC3S2VE4g5MWKYysr2X+abhuiypTzV336sCNFhJ8r/NsRtzmwUBp7fhEW70W3GGcwvVM2qj0XtzlrQqi68zN4fqckNaFrLfNUyx5USQGa7ulldJEIqo2KCbvXWnWbZa4LHSPLTos6yN0dcuqPGyFTOW07QxrFIvTStpv9ZqGRnoUccCIuHXxh62Nc3N0QcGABwEEhQAMBCfIYCFCDy/QwhlqBwMUSHCBETq4TgAAAAA=";

/***/ }),

/***/ 50221:
/***/ (function(module) {

module.exports = "data:font/woff2;charset=utf-8;base64,d09GMgABAAAAABYgAAsAAAAALyQAABXQAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHItKBmAAjRIKsnypPAE2AiQDgmgLgTYABCAFhEYHhkUb5ChlBGwcAPHYSUAUJXMzElFBKc7+/0OCNkaI+HHamlJAkxnRpkST9u5ev/XGo7HZ035fr+JSYjDQIxFCWGJJ+6YxMUvnue2AIcfQec/9TxyzDZTDDklCkyCaI2eTPIFCoQglYwnoVTWgkdWvqzSBuxL6oJvfK4Q2Nf1e/WIGJBCkhlRO1KbxhvmW4Tb7g7b1D1aMZi3Qw8JCGxAFdZeoOfPrYmIHRh1cVOFV4EV6tVcV/NCL1F8BMAPPRvjg6LaLSWM0WLep3KputKobOSFhZkUdODWgZfeY8cias1X5JN/kS4KsGbImgtTdy+Qruj9T33KtSeYblnPKmO33ve4YdJiEk3hCnEsE/J/Osl0dIM8RF9311HWj0ayt769Zr+yj2VkirY50rAPiMFTE1vryYh97Q6gAVUmZVMBluiv69KmpaFKWVzRtsJRDGT6AzS4lSHGaK8KIXfb4FbnoxjTweISSY6tjbNUNbLWRhCgWYOTFR74dASptuyRNzbgBMmcPfXqDacTsugHPq8fZU0/vg3aTyJIugYZcck9G08gn/6MlxsdGNphfLyrJfKEv+ktayai6TRFJ2jw3HaNRcQaTIInSqzFNFpusbE7CLZikJNMHQhMInSHMlm6VbUmOysuxfl9XgONjp880mt/YZdmlYQorFAZNG6dIqdt1SSiKG2D6bC6VXb31AqonpBI8jCdP0eNgXNfIV7hcibwdknClcOsWC394MdNnbLkix+j816h2yuqSa6zocJnsLyjbEU9d3BRihC2EwdEJtuuq5vomrk/lbtncSl9HMD1cA/m7r4yJylh0zvPIFxuS/C2wHy6P4sw1iRR62a4rrI++rYsZ4TbRasVA6BD9g8j/XJDGtopQDas3ljfP883PAzd9jCJSDX6MjvyoifbiSXcnnrBS0cbGD77L1Ivt+qnCmloQdxIPnfFE5dbYxtLul9I4LLi9RRRuXIoZ6mJdXxj9YkZ3lFQBf/24Wspwbhu5IhHu+yIZiVElJd5NxulUjofGeM4k1pWBcLxn7EtdGxEtTV6OoMD2Dynh0gfRaDZbCpgdNZA50NyhLPmwSEckTFu2azYrP2wcQTODPfKIcKoelY2fLvhPRilazL0Gu8Ee+d/UlPNXbdN0zKFUPUbdOWNMrXOmQbzTDjQmgkJW3P4hyhrKVs3Onktk9IfemxLcnwbHhKihbIJMEorJWadV69/zyhcn0ktQrI39YuAnhvv6TiXSLOGGFtGDEIenklUDthYlAsUs/DwcZlB7SI0sts2Tv35FqmrdVVbhli/2w1WecrCRBFayoJ5zcUSGesJEXr8rOlwev+5fzgjJ/sQjNMjWs6PAvfsfPp7rCyqQUXLMXtHacf4Iv3Ulnpuxu5BSTu1bUA2QOHsOOkEBWf/yqugkP7J7TKSQtFUtWgZvZcNz7/xIf+L//+ty30sfEkzY6y1mMmTm61ctO/YLAlFdzmGOowPPNXS45V1iCkPJJTBk6RkYi5DIiGxRMVRcQlJKupNbVk5eQVFJWcWESVNjmGn8CXFOVU1dQ1PLvAWLlixbsWrNug2bttRt27FLlrNn34FDR46dOHXm3IVLV64hSjGbyZv8nz++6nhspLUNdJZ8YYbQF3gwtHqDMarpqoHioMV7Qdc12QQOkXFwmKyCI2QRHCWbwTEyBY6TneAEmQAnyTI4RWbAGbICzpIlcI5sAefJHLhAZsFFsg1cJpPgClkAV8k0uEa2gutkB7hB5sFNsgZuke1gPXi7IAG5BwqQAAuIgAqYgAuEQAqUQAuMwAqcwAuCIAqSIAuKoAqaoAuGYAqWYAuO4Aqe4AuBEAqREAuJkAqZkAuFUAqVUAuN0Aqd0PufbpD3RmESZiOHtIx6SGvWswm7cAincAkP4Sm8hLcxBOkzhiF9s72f8OceoAq7b8+zAZ5CWRdUtpmVxGsP8ygXBJTmrozg42KFpY/8FV+C1U1GlK/Nt2INUfnMt9tqzvELDn+OJFk73rWP8mrGiMtVNQRFhZVsKQcCWZmMJBVx4npYwQ5xoUL/zWazUzZZKr9dtBojspEykZTSNhnXrjbdJD03A6kmVSRnlM3qYLAtAzDWlXsyqUb7fFZbhqeddiXVH5NuQwDpESLHXvH4lrUAoAQEYYCzYDehixhflaAkzvsoYYspjxHWHee8DJkkd2E3TSuSZpI6u+i00cXirS4Ga/4Bdn7BSIqzNOVJomEPYhggFbuQ9op57xjw6cfv41ethyeh3zjxYIvCqUrvT7MjBMOa7xX/PoQNyhdUkr/klOYi5bZDQH9uvYTGlNIELeQN9yAXzlhe7EYuTZaMSKMFzGfAg71B6lfoz3FQNsBrvECdAW9whVpNMFEkpipcc1hT7LmAL4MW/ty7ENziD9KCUMS4s08vlMvIPFAtlXZAY+/Ri9g6fxjoOdMRS1VkHgP69opVG5jPWzbVD51D5hjnqBOZi0UbWzVolA6IB6pHjKO1pfZXirma5pTMMtBtWxi9X7ArRU55PgoLe20dREgul+44IhPFMvzFFYqzs3ZaWKbygo2GXq+bzSY03makchwQTTRaLWzN7jXPHdIPn7cuHjWOXFhpPuuZDMYLlWbyO6qnIlqKuNddYV/IakNtzgzzGwexVWmnPNoiXWMP0McRahvt7DMPiEy3c+9DZhUaaxQ1SeiKVIK29LpiKkSO1RfFFqXqqN5sMjF6skXP1ac1ugJbPNUnzOTKBEtebEL9JNrizao2N1gtX9brRKqwr0VeDtabJZnYK0Rjk6dfXY0A4mYwvJKCNOQbGE8RqmAX4ghiah3ManJKDQRgPwjBJRoEBrCOBYIg6FV0U5JcCWzmBgd4SpLTLJgxbj7FGbkWRlDx5AakS6axfgSw9fh649ojBIauDSiM3Hgt+Fd9wdL9ARhcaQGPYBULPckU0o3B9PNgLehC8GgjbdYLaMUznGgW+EKfH17NMhLjlBKWoHwBJiQj1Eei8Zh0pSmbzbh6uQH0TBtpaMcT89EgtAxahHMLWBW9bFaN2rKQF4MgxCqL5p/fhKPvn32X75haW3gwKo87NO7cHCLY7bsnHZo3ipH4in2RgtBO7sy6NU6O1oZuHTGACza2owcHMu10ozH4q8Xb6vVZ3/SdaTaHfJ3Z2WrN/b435Gnwsy+Htlbqwvbns0dDNfJxEhNnr5yFhI+bDzkWuT337sTa0NX6cAxZfRiG3DSfDSIY4n6Ah+x4MadvH5oFML+DAM6OB2s93/It3+rbxBazH4xNzOobo/HWilHjY3PoWD6942UABI9JZcPFvzYMQiuwB3WvpGyS3K8qGVVWVbpR4d2JiSxZYlZ2RqwDttdnJR+24O6JCaJ4Pb1XB5NnqHHy6VgK9FWZ3qw9049t2XadplmXAQJodlLtDwiKAlBd4GyhF3C/1RKpoT0ZYJjRsDtH+pG4x3xhvLSe68/WYkqftoYwgfo5TNCgWRXgmQv6tCisSdZniD41bLSaaiQT9oS6PUFvL/taaOimCVabHucb4AzMj43GEmxUeVy5rTAhPr9JhbYcWCJwOvbi1KMjSqLITy+sTZ3I0nFpEYllaWFUTjRFkbTvbts2LsI2KAnqxi4eWzvt+2TlRaxJbhLfEALhjGNEed4SqL2tbH7kOKZm6xHXFtmHoTwrUAGuIZjM+qcr2yOE2romzcA5U90R5YJM2YAuVJKN8ZcHg8/h1om6CrVEAox7Ni4HAOGtEY5YTTUnXIEwiHFXZ+FYTUkEZvMHrf1C8p0vsBDZuGJCcsr3k//A/31Uxv/AHE86fvuYpmx78UYyNtH1XXScHZwv5rAg4Rd0mhgLBgd+L73/5X/y+525+glkAEPfttf1zOuaM6drXs93prn/rjk9875j6F5YtHOCIhTYwesAA/uDvmbgGshhw4ihs9PQZYC4RWZb74jb3qfsdoQ3/Hj82LZubqmpF85v2pSalu7MDgtvCU8u7LHtG4pe25yaGv44tXbtyrIyKjUp8YLe2IXzF3Ylbd8+5w8N0x8U4M8k/pwD/TdHdDzdgN6MBNlp53XVg0dbRHx3jXs2fCUwETn+jQ3+KkL1TZ95xR/Yqt3W/8pCFRuUcuUV1RX4HJubJ5Xmlb7VgUUUZi5yAsHtD9WVHc0T5HsowdXBMcFVwQLr2qqYvu+m15vO7hmUu9YhYufHlOa19+3nsm67OlfHjKyRu/mf7UBcPBKCUJvVDj2J7Twnj31c3yOVvjk5zLGOq3Y7Mhlu7izHy99QuzmOvTUtf9rTs1HHtR7fBeuh2/W1O6q36HJb41ArSnvljTrY5G+VurtvPI/2JcwJPcIhGaHg1mPXmWJLY/DvMJqWOR0qZHCvRVrbrkF1sMM+duxxwYOs63ckYg5PE8PVVLmLhlv14jEaHiYu7S5sCy7w5bFmFd6AJoYXxFqb7HmpL9Z4KfawMbbvMEIJ7krvSsMeWnXC6BF+ZQ+h/DgM0r/NoV3SMZ/d7Qu53aPr5jSMdsed6P4/E/LwvNW3iLPWTlH29JTUhqzu44vROQxXRmzO2Oye2Gk0aydfJxRayLhOxg8N31cnuuEqqVJpQoqzjbK23lHpnFCBTHv6Glmp5dZng1He1uOVLhImp1aUWF+VZcYwxSVl4wXq39Rs0+rYMDWHowyLtbUq7uJlRYEqgqdSpYrY+QxxqUT9HMgZqtCP3nxvznN1SRlTXHxj0Vuv9LZeo2yHyiM4o+IreKULpxpDK6OmiWsCCYK9Opf3HSFzpx7f9Rv2uNce7Hv0GL7xTxxXrL81nstfiW8ErOlNDRipxw34EX1wPC7GziBJryGDDovH4kici+sHDLihKzDDsN737uzE43H9cBwGhGXwaa/CWNdmeT7q/bfZbBo9MA1lRtjzle25l705fbOwOC6uqNU0ICTOxt7ryTZx0oi0zk1vZaAIzdK+WJcCPFP4KdMDf/yoqlioPUVVXiI/hb8vOaFtI5N/CAQ272amVDCAdXXlPqNQJJK9wTOrOy5dXXlPiaCn0H9LqMN0Bh0O98Z0gA0IzhTsvp/LA41ZEf3/PsY0xcfBW9antuTZBWFTwl3y4fZaj60tCE8JS04OSwkvEFaz192+7cmuTnGBuFCUDWIm1e+8+2/Gv2d3+YO/0bLUnkdJn8ae5g9ffv6g2kgY1hoIyDAsWGDtKUqbdWGlua6sZP7WRMz7IYuVPPBaqayuoFkwAkTp5+uWLHnzhnw7N2reXsN3o7GwFbVlMjvK3a3a6IuXtC2ye3nf4/OdO9DnYmqRczhyK2SUTCvSH1r8/SBsiD1/C+OGaIPWfjzUevDnVboTyvP7NOaw43KSILIIcnpLCEepCNW1TyfjIRHkik9894X3bAQspZV+bO8xmLcwjMN+8ZM7LKCrF8ePjtH3Ugqfm0XdLZyvH3dc36IaOw52fO7/QJWmf//t3NTmKm1QbuDMmYG5QdqrpimcOfO+YW3Q1YTUluWTG7WCPD4/T6B9XLTuP4+vFTxm1oavg/JWqbR1Oinj04P/nGxYTZWPTGJ6L8tfCGXw1jx5Mo3K3Y3vjh/EuBi8XemYqgrg7EPc/o7wydvkDykJTav1/PlTKhUJvb0lEiAluiIdfN4xL+2Vcb1UAmfOLKI0dgL5yqsirDRRuGZ+S8gmbVaWtap+wvhlqhqxcLm9Dr8H0q8ajQ/RWlSoVm/ezDt0GKrveK3El2/2kPb25fhmmq2IJWYBcecO2km59UYI+LokuCrtuSBoOGj19XWBaP3QhE0aZQuhHDiEHTpAKFo0is0TmFiIIgN5mpLuzvGi8sP44YFQ+JWbxjOSQjQZBF5bA26T6h3oDrs3ejq2HYPQnn/NUYdnUOPnAG3cIW7SLt0BHf1xRwe5ft369SQ8c6qsvJySakudWGg0fjfsnRflfPVKRkZSKTrz4GBPWUmdeeWFk4pQa3otbNu2eHHd+XRRAMOCVl2hVL4eSO7pppOnTmr27CETRJmZnz3uv7Rb1LZ4Cb3Nyr28o70dbPhOTkO6cAI24axLxlxwwV3AZhFdfmY8Nh5FJLoVUjzUXAu+Njz8NPgplr1G6w968uBh0+e2EP1lEbdjxtOKBY+eBX13EXt2Gu9pxgratYfFbuVOiNlRoE9oUD/YSu/uyZAkzp5nMfF5ll3k8P/9Z1tLMkt6uu3byFmwFXRM2+puYeCceQGK3ae0uLYGr3Gow4FTp3jXr6M3rsu7FisV01d4zTBRTDM8VyxXKFaEz0BBP+7///+subcfy1CHkIj/f6sNHhwNACBSwzOXID8NHUnVjVSAGVFGkrXb64+MR06Y87ke+P8PbkL+QmesQZ5UtQVEi4hZVUY8UQ/df2ZDIgK2mRQ1zaaew+7//ANiBrNfWxcxb8IAsbPodd4hzm2ahzSYrPTIGDB3aivZqAqVgtRDN4RqpHMUgniRpBpkE+KiWsiQ2Klq73qV+aiGmomkmMzTxGoUMcXywlE0B4u6biB1LeKNrKSSGcjMNon6/5x4dQBtzeYWOyV+t7ZDzICSb/Pm+Hi85XiXWIPr95gC9KNlTtnWX+jyfxfK0tmOe/+yrL/+Eyk9ba3+C5cxNmCLjwDw18wSZziPkCLBI0kF/54DIIF4HTSLlkMJDTBMJJYQgDlgmyCkcHE7eB0aAQFoYQMQ2mD8G3FBCArgvrbcDB5oeZx4QYT74IOWfxEEjGLxu2EYQ8nvMf6XBPclpkD4G32JRuit0Hf5j5IDU/Xa3ct7fb+QUIyiq063Knf+TbWpGuG2+sm0XlGMXCXhD7R6PKum9+ee4/gNHy23PeN/SXBfYgqEv3H/yJVoRGKHkPyPO8jwY2OqXo8vktov5jEVoOB11enm+HPn3/Qpm8pyhNsAf1bKJCE+gS+Ykp0PtFgdzwWc9P783Fcjq462Er7m7wSVj/NH75YijyJKojTKojwqfv+gqqPml4HX9npBlGRF1XTDtGzH9fwgjOIkzfKirOqm7fphnOZl3fbjvG73x/Olajrjhiks23HbnW6v7/lBOBiOxjdubtGrMt4LeqOBaWxE+JIHJtuxNWQxjuzZiG5nRbSfJ77Wfhm6J+oygRwqShvIKO558wpJ+ZeWI0udQqytTEIsLeW5ZVIxVtENLafbyArnPLC5G9iiQ4fZjvBatzkdO5nKA90Mb1jnaPJ5EFSMmxBrNEfJJlmHXkIaeeGShsIAHUZsdBwDKc51Etm4QH7ammtowx2HLVKZGsqJXAmvOiQmXBBrbWLkC7pRqiBHHKRAoxQ61mkS7AKXvJWSvh+uT0WVqeam2VDZaCTBn3WYTYfz3F4X144vFDKdrAUYWazpWTcYtGPuZ6+C2JM4o1fmhDQt1BbPMMWSRyI6sWkrdH31KiSqtm9uXvYs1gMox4U63KaV9UKErj6xKrdzokI5zcfG7sTg0pKWIdM0emXXghUYV2ve419sbZwbogsKBjwIICgEYCC4QAYLEc7wCSe4Qu2ghQIJbtBBA/ce";

/***/ }),

/***/ 61142:
/***/ (function(module) {

module.exports = "data:font/woff2;charset=utf-8;base64,d09GMgABAAAAABacAAsAAAAAMWgAABZLAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHItKBmAAjRIKt0itYAE2AiQDgmQLgTQABCAFhFIHhjkbBCtlBGwcABHswiCK8sSJERWc5Oz/vyTIEdfGX00opLuGFgaJQdp05bHxuRRN/J7LDXnfQhgaBMENM/ds+iyKxqDopr6rX+GGYyJxz9rf90lr9sIUhx2ShCZB/dhv72OaCNm0qcoPkSERCqEzxECmvc7Pu0k+4JMQc8ckgkXuvCK6TJ3F1y5D5/7Ab7MHfy7sz6eMYgqLQhS3VhyhAgZlFAZYCyOXxt2QzUtRh7uJ9dWvq9Jl2cu4qDXbTq8CgMhyLJt7EFFHLAubunPMMX+/O3jWHaC97W5uSRjZP4QVVmuKHpfvH6aXPIivDuewdJtqNi4MLIF6S6Ce73JPUHjkmNamdoTsgLs/NT9cb7OHxU4Zs9Y9v+wYZI4ESzwhfCUCfpp7tf+3IyBjyIq75MNdX5K/lO9zxilnyKQoaUYpZ0Bs51iNlZnQoFXh/2tvS49whFSeR8pG4zTVE/u+Q1RQXaNQnxBlTApJIVxIu0IlRaE2qXFypV+j/BKkOM0VcUQue/yKPEAoXcst5s/0QhQP8WzXdHsoFVIHqp+6GQEUG9rDB8WjDf7LN77+FNKQ2YoBLoeOyw/eewOobgK0pkag7nFeKviVPXzt/0jbij+iPUO57im+ayMiOqqLQCnqw3gwc3ssDoPGE4gkOAe26lgkUxABhZpID0sik+YWWwLCEtjZzNpUDUE0I8eoujMLjx+rOtF9vrpNgbX3UtJCEjCOeCSvorE9WYTLFUen0NCU6sbDKBc2msTAMYSQLlQczQF6iHReFLEfoHCZ7PkxhF9wJkcn7Dkoj8MyrwPdifR4thhUpREpDxDpcKUKF9k4kgFEoDoFW7OtPKqIp6Npe8bK5kUI54JXgl5ufhwHv7ot09u+fUjR3AP0cF1RLN/hToGRbUVJd/S+Gs4dr4+qBrXYZqgXCPyLM2Io2hDarbq2kCrT934+OuIvEMlTgHAsHsvCiorH7B0/YZq4I2685elnoktsd1PCW+asaTXx+RyDQ3CLY9Y27vj8VnBXpSiWXbzEUFdZOjv6VQ5rnkwWc/tpupTjxjG5ShFev02WYkwe7ltDeCya6vM4hjX3tgsWe3zZ+aDLCsRRmoVyjCQ/PpEqz/cu6qJQeEWxk67877TlmwDiffE9xC2taSybtfC+ySSMjHBeiMhT9ZgU/OdF4Sk7Hq0Hr0elEc4LLzNHfpw3xDrLodAuhLrLHjiFzm2BdCs3zXGTViEn3uQ9GhpJkc8eLhOBeqJvj1Ak2lOLC5NSDdUiIeBsTkFdLNtrH/vWkm+NS1u7XgyFT4b7phV3OiSWbXXUu7DtRhCeRrWCjCBxak/PbxnSGKqRVUUV8fDbKXld+6yTWvm6Hm4yxIItJTyexdmcqxg/+hPT+frdrtIYzLr/nTuUuRg/gQ3IZPGTAD5O/378agkyQAaZA7M/mj0W3ob/NCQhv2I9VwDuz/ZDfq8KyANygHogF2Ra1y9GfRHn4dTdKUftVI4qg1p6PvC5H9MmCTMavOEjXyYs7a8fmi0E/3xnXtPSvxBIOlPf535/5y0LTrTyrorsUH7EciO7uHrA4AjIew5OFBc3Dy9f58cCgkLCIqJi4hKSUuOYafyDmJNXUFRSVlFVU9fQ1NLW0dXTN9Az1DFCCBqbmJqZW1haWdvY2tk7gMiH2TjP+p/fO60a3J05CnCaMCXRBnaMt27y5fqAakwpIHcXVjeBhqXNAnvWC+zbNHBg48ChzQFHNgAc2wpwYn3AqU0CZzYEXNgUcGkTwJXNA9c2AtzYMHBri8C99QMPNgY82iDwZAvAsy0DLzYKvNoM8GZLQLZ9FSRMTsEJCAJEQBI4CJwEFIGLwE3gIfAS+Aj8BAGCIEGIIEwQIYgSxAjiBAmCJEGKIE2QIcgS5AjyBAWCIkGJoExQIagS1AjqBA2CJkGLoE3QIegS9Aj6BAOCofx6RuQ2Y/l8TMg6pvrIAWnWRyVIc9mHBcGSYEWwJtgQ7AkOBDQBQ8DqoxMkro8ukHjJhSCyiLXjD77BFxS2F5R01Kwa/3BWnDv5byLiS3ecR+x0GcGgayGZ4bzIhmOXIeVor5COWKfwvRKOL2PzScIyQkJ7lZLh2vkWwV1JGqSJfTKRkScTPscwkb941wjCTIDV9TeblULm8e7vWuY6zhy7yQj21tnE5PPlQg5c3Bc5c4XvCWFjx3/zrEjIrHQS42GczLNviMwyGVvHuMFOOreNxdCpwZhGUXeBNeVsCpj5ubQaWk8IIkHHjZQsGjFR1UHK/lDfBZFE51ZEqvsIn5XsX2oeOk/qSBeG7XrL4Dmo4tmbFaLdKe25pr3NBsRXO0HrDDSXSLUB09kyzeyQVoYMuUv8BIdt8UN71OfX+EN3Fx33MSFWGd3MPoij249JaYF5Tjoo7A9mNpdMscCcjh0QEOLgc1yzUEhSOyX0HKbCuL+tzQ54jvA9kjXizshL4wF0xlHOpzFOWiK86dLuxdxpx4trQV1fn57xgYaGFi21jy7ycmKYxXpVY5kJPe9n8Yd+Gec1NkbVuHVoTs/sBhpMKPX11dwMnWTusXBiJBwdVKCzv57p/BrMqo9FU7Xp100z9dSTimptEre2OmBDtr6qX62x1HS6iBHrP+hqWgenzWydBd6+vfXklvHsDimFqqF/nBHnWRnftSuBWuPcUDA8Hy2OhiMLH40Hy/f9VR7p8Ulty8CUobfhKjhnmjIJw0as7OWlJ0elsUeE7dWwOEupqjZa7VI9ltqyI96lZ0JLq89tU47x8zf4/5VrWGtJESoZ3jEKIlEOuHhOxO2077BO4LRHP9w78Wd+b2rDx8H1kXOJOcRSy63Fkkk+sciLaExwLSmnYQi3AHZZbxo0pBZ/MoaLN4/d3JCRQfaIsMlnFiRPPd0HJA4UzMlWka8m5BqjBoUEBDqTVFKhgzJ3CVgi55reMUk+CeIBgu/Ug1zS4HrUnbai4MBy0rb7GeJpqo26zVauqcmY1Xfr9ujtu3OpN74zp4bQ8HXuqtous3O2fsyfWY4LaqlOJ/sL7B677FWDnpV00hOduEOLb67z1qziqibzgI+pM7I14yH2Z9eEwIGcFYyeJ5iOfPqCNV7ggJ4sPA3o/VTSLboHPsE9skiyPgymnNNAAxeUMeQDXVlo8OfB/YwECfe7Xigj3GYW4dZqQl4OlujujXb156475eLmGmNSH7yi3vNnlNc8L4iq26OSV6aDkR2thaHQ1yQcWa8HuQWTNCtUotGR8jr5b01lnr25oRgN3rWAhnU13TPslg304hMPf79IkMogiMZBAUgQtBGay7u8i5i8UYAzGLu8AN5F+GYfo/jRW1ipINcRlIo1YSSJR6AsV5Ycz5ZlIi/3bmz7SbVN54nvyp8z9pF8fJEG5vgxMHZRvKmqe64xKcebdoJ7bzCoD/o810J7P+F6LuWrGiutigZlLC8tZ4rkE+RgUAOD288ZYeMBkpabIm14QgHls43FbR+uS0/Qpyt6v2U7NV9+X1Jn/DyFmyxZyZkIB3mt9LMqdquBTZJ7nQr08tEjsDffW5nlSnes+osq5QW9sY9B7NkqvC3w4YnLtKy+rr66uru31tY4tFmf54uGBg3/blxoz42FeG7JU5MlA7VM38eXhtqGl+cLIHAm6KSWcXiK3HbKuXC5WL2ymJWwsbb3kaiokNRr2KAiPE/3S1M/ELTB9ZX2Agfrg7rnPSAbP7S0DzMDTxp6/E196hkxrKRJqto6OGuqOuALwdGo0/3NhnKtJLlhmJu12JoO+UenSUK+kbBeuFTTbXMSgTviQGVSLmkiBLMPdAclQwzmLfkCa2vDGi26NarKiFKFIy/tYmbJMC0yu2pulxjVgPtM7xlyuUh4BY8mFEbKESQykqgoEhFyJApFoMjlZDKVCwyF8kgy/FPQ15eRrsWorHp76a3wKlgoOnTo4CGRKESqIDxY4aDQziHgW8ivfL5lst6xmN/6vGJ9Oz2znP4tGWt461yCvkFLnd+i+kRHp5EqZiqknQqcsVqUFiXw238bOD2LeWZKlh9I1gn046dLk+Dubc93h3HcvfLsvRyXI334/ZzFYk5LI5NXLL/CtVy5fGXfir6+ut9VLiwQAstF+UcdWCa65F2CoKNOKS7HBUmdshoD/iEVjMl6LRhYo4fXylKVb1HRVwES1SWZuoCILtxDUwtmM2614kFqzIRMqbhFkR9TMQkfslG0uBhFj7aAP/aLPrN4XeXqAySOnsPl6Dh8VLoKDYdG3F6WlNWSbk2fFez8gLTOcsf+K48xqrOeO9mymsa6WIxgjGVsyozdDuXLi3hOjEP+3v2Z3hqNy2bHH/Y7ujBpdA/H61aKXZ1jRdb6P+xRNcXRwvjIb4MF1Bd0ysYppbQWh+yl8ueeFIcZ8d0COr3jMmXXsro5/bMHmHOAVm5XIrW1YQaMM9c2Oh1PYvoPLphu20LJhz32gZtP8+8qhsZDgmfzVFx/lc5rqPx1Z+eqeCuDtWVJhZwEb16d6HQNKi6P7WGJcL22K7D5WuCJ5sBdJxASpzSyVI40Nvpl4ZMB0s6Rfho6yhwt9r29GRnaVFBNnWX5MzJ2JbYsPKcuL5y+ygllfV4Wtypu96jy4nSnhfaoVJanKDtdT6ljUpmBms3q8sBtNtOdvJ0oO+idqpPiVhwomGNQynPBl0hF9PpwTdWOPP3tgNBg/88Pepvvh5NSFbYrO4oHN7v+xFIlBC3T1IdyeeJFodvTZLQYRpStV6Jb3IzU6Srerbrn3LC4L4oi7uoiFwmTxujqJzPalir6wesC7UtyRYzY66xcqo4WKEKTfdJnam2ybZKCbu94zg2PrS4I36pc13P+Nq3SJPG1QXqbdTYpfBU3LH2Mrno6/ZgwXs8rzQoUJe0MI9u7z7GVg0ZkG+cbXqhRHwAbXq5AJm3txCdBiSth5Surwuo0cP4ccukEbgD4MJ480RkuhQ8tZWpxRwRXLBdXyCflQv1duCxLU8gmZcok1SJW1ggtr3AF3oorA0WBf4gJDwB/TyisCt2azJbu7oyMFSfastHTs7QLNm0yYDIsnNNUWl1tSLVYBCbF8vNDGlF65DKDWNzk4uVAJTG4qloCE6MSoQSTUIiq6n5UTBEThvXOgG4zlEabUlAKxcAxMGaori7lNOV5G1A5qSG6tKkUdb4KeC1BgeGrqgkJRYIJ0chHTNSquAwS1cHLpUkstoNTnxNEJ5uaiottNe/h99LMRrFRq/WnzjNoiSjnnohEj53MzaXNzY82ip4+FcGuD5kCS6Imn4lyBPjIcAFeVI6mjryaNTaP9f9vbtabm3nfiZ48Eb0VKfHlIJ677A3M+7OyKRsjoT1DxcU5wSv0d10CJ86vttYvjpN401GPWGuM80tg30hktziMDnYM21Fb0kTOHqtEEhdMD6GL81MXJ/P5SYu1+eJzlHUmiSQsmC64qpHEDypJar6EEUIPNoFvIXOy2dw8qcAnCodc12qFV6+SF+/PmoyZgEyuzVmcrLCOtum3b/AtBlvEXYoAUIjEnpNWPy+7QazHGcTAmTMD2XufzBsWeeKizagOdkwbT61qZqJnEk4jUtkEz4SdtWFOpnJK0dQXi7WNXnQKL8YzIEj7Iih10KTaVF2wUIYyn9+RWkYrvVi64IvFqTqGM7SsFhQUCAyO2mfIsqBKRPQ8amp0dwcZciutvhJfhS8LWJJA6yt1y801D2NiXiX4Xgm42SyVgfSDTGoG6njIjWCAS6NzyWBp2uiCBQEBxUWnTx8/fn1FwEVm3AzRQzpMp1Y/AGW1ulmRSdXULya4Rw+TqCQRJd4KK9RMnz0h2pRoYRQV5YwRGvWgRJlUkogdkbyPSx4MfKrtBh6zHwe+TI7Qrsx5NDT4C9gZ//3n8+VRUjPA9IGjk3sSNy13d1Bwbl/O0ckg4XnSS9EF8EIyIv+cimP9nH4Mn/oqQx7y0hX6OpRNs5+H8//JkAe/npWEF5wh/3cTleD0UoFWneuAOuwPcI3wVzoMdXhC3AWKw2Nw8HGApP9r/xX78o/mow+KiwfaWtvaBuDDYmwAGx1xbHSV/XNV+zJ/Ep7mYLkaLqvl95mUCXHVsUEqQQ3zW+uke1RjsWt8u4UdeWrUj+O3FsJ861ttXRP61/+z9QVvJdnT91ZldtIXFGFGc5xWewqd+uHeL49HAdaxoNIEXMQGJyZmDKVpZj6WOkjHGOqeHqVionyOzkdRZlj0AaiVe6pBTn+NR41HOQdJgv3w7r15wEccWPT++8aqUY8Svr0vK+7xZReP9J02g/eCtHQnhwu9YPSYDRFBzhW+FWifPSYDmO1fn3K/cjTXOPlM27zkW76FZPQ1krbkYL2cXnJOkWEmReXU/l+7BEtCtnHcLIyIaduN9LjY4uKXtrwI+wieRMI7bH+Yd7GsDFL+x2V7h4/kJrXUyI6e/ZpjCDD//Ir8Bp1VpQzJICbxIP7WRgTGA9mkUQDml7XInxBqQR7qmM4A48sKXUGCEpEhMyYvvv+xhQfxTFvXZwZYEPX/n1gvH/IejY8mRiZ1HY/WDRkHmGkTf5c9Xa7tE6X10IwPtVsQtZTLk0BuBqF56p7E09Y3OCImZ5TYSnxxJZXI7N4dgxCImI13fLttggcgerQFvRBHcgFyq9O0LYgneDiBe8gdCDER+r9rLg++p/9uSnFa/nG6HfIrgPgZL09vhfHtEo9vmv0AaLgI9zg+TuxXXPf35Vz/PxBg6/4nMv9+DBZZ2P0LKL8t9PTmg/q1O3TBZScEfNRqVYOTcJ1oMjEKzlW21HYDD/Tb7uCDVdsTOiAq/AERyAcEsCkzAIM01Bza4uCH3ynRVraPIih7uS0JcXhGHVD2U1s33EjOv98DdX802n2xt29Bp+TNN7gcNNcnLH3of+DkCYvn6sl5FV+AwFrAFvWtSJ17EWmKhqktPgkFQqAiMv2AkeosEl8fH5uDrcpQ+6DdF3v7Fu5o8sy8+QaX67PLNJPZyv7DiSs+V8LCs8oTrfMLkJ5pcagFVt8ilrob9kI81hSBytRm8CmXo6TBo3QNsV39AYMClTOHGl89ejNraAMVI8XzS1OPUP72OFwsm93N4f4NW4Onl9L97QqFI9FYPJFMpTPZXL5QLJUr1Vq90Wy1O91efzAcjSfT2XyxXK03293+QGOwODyBSCJTqDRHJ2cXOoPJYru6uXt44mnxDNo5BqfFE440M11SXyczMhoNhKE5a5ZNDQrmt6ZrmUbAnirFeLQgwK1HLbBrSspINeLCUCAuoy9V5PE9zC2mmSEU1kbADgzF29AwpdQ3qeubLAMLyQzhqppMSo5auqGdwg3KFHQ69zNl1PigkAzbipMMHPs4dEw5DjoNZBCgkVHwqNnuOJC2Ht2k1Vff+jsMWsA8sdRF2EW4ygAJYY4kpQ6BLmCHUYJN6EePw+g7kklk6DzltGFBH4fKOosQltQ064oVDtm7swyS7mCW2pvM0tIFc84kYQ78EGFyhS2mMjM72QkDLGRwknECmkEMOQ0b/DlNbMdGYk4GIpNKTIvlhHLd2CjjPMu4DE6HYMuaRKidEYpQnG2I3LGd4RwXOWee94a7kZbA3wizZX6+pbZ2ANaL0sopVqBEeUUK1UUlZVRQZ/WranVVpVWtyiqqm+pUo+4PAA==";

/***/ }),

/***/ 38906:
/***/ (function(module) {

module.exports = "data:font/woff2;charset=utf-8;base64,d09GMgABAAAAABksAAsAAAAANJgAABjZAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHItKBmAAjRIKvkyzNQE2AiQDglQLgSwABCAFhEYHhgwbkC1FJOtcAoio4oREVGw62f+XBG0Nha7Hcq0QDKQ6cupKZEan+lr89GkfpfcfztcjAIb9wgh4imVYpWgMXFzquTdfm/fH5WaXoYTJA7Uf6+3HJJKZLtrUfTopaaREfPrla/uTm18vYYi5MgL8gZituFblFvXWW199w9M2/8GJgUPkLMBhYHJOyQUIh4Vgo4K6NhoLI8GqzVWoi8pzbu0CV+1+lLl0fx+3fQ2ys2A1Byt4uijK96X99OWgcPkgTI2sUsiSaYvN6am5St+h39S/2/xoM0OqQkunytRzMpPInio/5Bd+E68JSWYiBzwTgjb3F81zy/6QpFA+GEGQuSHXPmMlCOkQ2sE29f1mO7XMHhacMmZL/6Wm7RgEdgISJ4RfiQD//9daXjxaqDzMSyaGmY/MfRdPez54mpWESpKQNBTxUCchYqlZ7JTUmf+51DLJMQs9YciZ/39yd/8nl/ZyxRxsTTu4lH85NwBSAKyAkhLedQiqoCo3B+jI7k3pvqlaWTcIkDnzguOHA7qQaoRII4YhpJBGnh8LUqdx0K1L7EBQ35cIQLYOwthybC7g2smv7yEGCZcHcBgadsaLR2BZtUE56YHlk9MehkvOTV/9HyJ6oNNGYD9SJVRwN/tB7w2BRUaLgR2OLkdQmISRKVRGJmSWX3GFEyynKaI+EaIyeO8gDCFkB2NBNStFHpKtifEbK3sM2/gbinO01hJ37meqykQybIEROWT0EAt+VkfUBqeT8NnzfSzWDiSqLWrLS7SmoXRzqIooEyAUU2Rdf+GuBpagphrkTX+GInaySkvPHtVq9NfoFLyCriqr6nTFAaWqQ2SapWUzarLjFcyGRC+YeBVsh1BrTAZq73GUiUuJ5OSp71U27AroxrrGFkurbCrdGluu8q2/qqPOmBrLrP/eQZelhcpa1x/jKlB1j6W8Ck5++uPdl/+BGFJURV0WyFbqPEGdtAYZQhZo+7a+oljbbWULn2Zo36QpDk5tmXg05sjNmnLqyeEWqraIWjkoVo0TGwfbxymip7R7O/0myZW9MXOYqrXh4hNlrR2tnS1VhiEkmoNRWyM23fDeYTPfXGmUQ0yuadzRE9FFQzoYpxfl4TgHT1naI5enRU/cBL8IQmxiKnoSRo3f+CosjpMYG2m0Hy3HxgvTZDXaVj2yx4WTmHaGxONTOhQ7SRaSNbnv/AsqvVwqU1OhTog27B3ZMm0fdYTlUsadgxVYGrp3k4VKb5rXp0HtoeeoBEYHZh4NiouH3vpuwJmjqrZunMGMDOt3hmxqR6EH71di/zSZv8flMDawVKF5ejJgW1CPxLk8ofr+FikNM6MNuvvqxrp2K2jZWoWGjCgxGTdwkUZMZf3bX6Pb2vX9Tc5Q8o9WIQ0kV1sfeIwd/374pzwkAAkxBcJbDKzxp/Cf4sihYUylBo3ns7hZAZAGpABFQCpIKvL7QhGExInVplK0sPksbvCcplc++h2rI5+eRrFH3vgcQ0TlGWE4cEXjUyom/mIRu6L5uZ49Lypb0t27Q3GwymX2Tq6sHV0YGAkQh5mYWVjZ2Dk4l5dz8/Dy8QsICgmLiG68uPiDmJSSZpeRlZNX4FNUUlZR5WNXU2fXUNUk8Ghp6+jq6RsYGhmbmJqZg5AOYTX3+M+v6dK2NIg3yrBs36nKAUgr25+u1scLzKrkAlIXIj4DFD9KD7AoNcCSdAHL0gasSC+wKvXAmgwD61ILbEgHsCmNwLZ0AjvSDuxKH7AnzcC+NAEHMgAcSR1wLK3AiTQAp9IPnMkQcC4twIV0A5cyCFxlj4C4h5gHAB4BSABIAcgAyAEoAAgASgCUAagAUAWgBkAdgAYATQBaALQB6ADQBaAHQB+AAQBDAEYAjAGYADAFYAbAHIAFReSAWEKaFQBrADYAbAHY4baVPZDHAYAjACcAzgBccE1wpYgcEDcowhMAz7j5vADFecU1xxvAFG8pIgXEO7ffeA9UwQcAPgLwCYDPAHwB4DsAPwD4CcAvAH4D8AeAvwD8Yx5BFkafm3jCG1mtAXmFCJPDX8xMS7zhFwkUsRMDku0GpgStiQgxRrxjskKgmBcS3kSiTRYMkdHYnhBReWKNBOHUURBtBVxXIemOw4yepaNBBHg1YKiKeZTmx3RQVYHl9yys8V0gsVUz8hgRyUFEGUaAeVUkcf7kOeC7ilBQwGniACKkFJzR0BW8VroGFjJxg6gOwLCoCCMSVe1Krio0QSBW2MGjEkFWweOS61b/uqeT83n/HLvseTW/7e/x/YX/H7HeVmEOfknXu/n/Hr/yofb3fd3vF3hI+VFEAf9tvP68lC/PcDWuXhUdIECGIscqe7SUrxSVXKH9dnuhBpb2yTLKluNS21jBXoeNSls6EUtMBiRl9GLnCg8Lc8WYxI2xmR8To54V2zJnKjkPzofsvQy+Ha4LUf2wYEI+rgttAdKUgOV50IvvC3l0XeBMzn8O6NOziXjuWVp8cSHnNjn/HIdokEQ18/cEKH/s1kMXbGql95zfRHaSUHgfIyQuOmUngfnO/gBlRrb9OPI8fPQ9Wg+hmlu/QIb8LMfGfY18COnbPXmXIh+y7e9DqCIphbJdf9FqxUhST+4hERTe6Jt3+gjRdXzaTEsZgYfHzLTjIB0uZLPdUAbO3BDitVPAjFtJOVtAehaYXXm7WJlK2QlinryKtCWpA6X6M5mEEItQssPycOF07Eyx2YfymYval8xaDjATCal5SErkM4ywlAIL0wkTiDgez1eSMpXla1SS+SSSzBWHpPDITcElusnF5IJGcf4cOEYt+q7YjK2rJ81T1+wbZ2Knr5eul9y3an8qWxgUvxkkW8I3KzLaOBKrSsmXE6a0CtaaAqaKSaLhyqA1LNP60YNIC1B+6MDCkegnPhO+IZOyk2pUZNGuZZRz91JodkZlDr0HO3br5CqfJbpkVoSNtLa/RNuK4mvhG/5cxYscjpcX/fftIX+5euwkMF1XiEv1M1A8D+ki49o7cnxdl++zej4EDDxGhhJxN0G7cKR4psU5uGIF2/fhI606egXLXqpxADDzG5JyYbfXfhtSvjSl/C637VY12MN/rZUo6h+0FLzBqx8ZFWwbETcft2Qtr+X7gc/BK+JpCaWzmB3ib9tHyPJlZymUXTgS3UOCtJSS9u4f4qJ0za3qVLHDF1x+X9PtaxrsroHqzbKTvLpv+S13yxWN3fHnnF6y3+Iqvslnn1qspRT5ujczp7GiP/+SW2WeVVWpqxpqdyrP+DX93pLLaFMt8g7l6DKqHz+Q5SNpQz5LE0xDfUIoo/g4pQQTZni2QI+GU8PZhKjLwbqz45NsuMR9QDvUk9b3HiA4IgNzJAel0qnnIZJzO++2cvp485Jo6JGv32m8MIe6mxaH7hfovB1vWP3DrS9nnZ3Nho1YRbalYKmDZWmArJd3gTHvvRLS+OYBtHL/NWrYedOxCrHiRyV6e62+IzBUyPHWm5SbUaqkIt0zG66sY90zi0tHlPBA07u6AEuJ8r6Ok4uaOuFP9MmgmJbK8eN5D9WwUqzNNVQwKSH8KSOV9F1Wjgbcl/Ut8Z0K9nNmM4yKN8/JXmubh6S7eXvERwufaMXaz816AbZ4nQDblmPQAvEczJohUdmxQVQFdvYYQR7V2QW7YBcrWfhZfrG1qLmx8LTA5BPj7g4dr+Uaw6QEKt7FqDEqs8GMGUXthO3CNHg/KRKK6IQZoymJXvC6dRI9PAmaYYnL4qbkhknCVvRUTPYiNLnX4e70U67r68EVO2/yJcO3K5wVPHpRi6s7lweLN1qv5LEU970Z5z00HhAG32a/lsIcf2C+A8EFkwFPkiD/fsgiQa2tArCelUTtO/23H97su8X2vlbAXnXvLQN9PIvX3XzTfa7tNwpHrPexD/Y78+2Xwgn8ADJnreh4BjqTbdh5MGaguaCXYsiwo6DbiWh9smh/ksvGY1I/nbizDxOdFt1NpyJZmWpVluu06b6UVJZ2sDffkS6Lg70SI603Zp5pyMoyu7S0OFOjwRWhZXj5DyTdFJctWcblfWWdqki/ifiXbNrLv/Q/6yX8Q0C7bGPFNwHo+5MxhaVsiSQ6HWvkViwjYYovKpkme4pXJHKG/0JCOoteyneJmCRMQxuhXC50K+zMzn8oGRuPrIPK2zE0NWX7Y5b8sK/dmirVHVgUQ04Tjn8ThSW4KVF2IxQXceIpZVYTXEaCKSi3Z0/Lf7m2rW3teFsRNb5t7dq2L/ebGJ32oMzsgR5lJmA/fltMC5QD810ZxC658uFnwpA6OR6fEzCFTxil0iko4Hro67Pf43Z8t1hVNv5t0VCm9ZRUqq8gsgVpwW8C2G+Clijf/PPF5gE+uAIMPJXLsTXh+WJyOYm0pgHvaWm59wh8b9d7GwXOwZrMBJ6Ky1XxEgy+cq5KxU3gGVKaGRK1ApGxWDJEcRBQlIylQA6APXPqBAdYi0KqGbv3GPZk6G6DIfEcvMnWb9aPyEsVpcPGsqkyIKjnxrHZcdwCc/c4NleqG//l08SYeYXRzLgykxF8qb0+7thx757rpk0FhQVvZsAjsUIM+MHDF82O2yDTBqNXt2/vTk3F4yXiAVU6cGvgmOTw4a5RNY35u8KGaaqxLnDmtZQnvchFeSjGTfx4NFj9hTwJ+yN8CAwc1k36KBBE4cP3YSkUyCzJF6E9uD881Z7iR0P8O33/EgD7sOQKxGe9dLNHiAf44tyZ3ix4/E9WRllhQ8gJnFeWF9cr02uO6F9l7aceOv5RXtmBe2ruHWD9Gle4/fmMFYzHttZZ3KltIXbMG2WQjYO/J2yxlVQlLuWTHU7xXC5muCQm0mqtthy3olHt7BlWdydhyy6r6uyisRmUBNhqu8PXOTuBn+3v9rDOpMJuGylHFP2bE0yyWLA/yN5+9y24178LucjCqAiwq7IsjyQSqIIn1IKN5POLqbxBP3PiNlgL7pLNQ6q8OY0dGz9PuyNyFkuutixnqUOTOn0YfNv0mgydrYyBZGAVoKr0cXsf6E2/0yvovSOYS72OF0i6MPvo/Q222l9tOrw5a6oAHDGc14pluu3xQFJleG5XXri9lExhfvOfL52/9ZHqhjmZPYMSGZUXX9m/Du6i2lJnJ9YmVM1uI5iTXcgwWP2iTwk5fKdBw8clnGw8vBC/P6q+zS3xHo5xoOdjkgFTKMLdD1CUNvG2wRylkKOe8m3at/vnZN9oHybZ8H9EYjrOI0kpiRYn26TbLmSohVh3mDhNJErz97APjGj1mw7fk45jyEvy14m34sNdXU8F2nv4p4uEaWJ3u6AI7quNbASxTRF2DraB7dNhGLkPB85P3GrRYnhUnlsOs4CktUqSxgi5CTX4HlR1OU0DWUXglovzNU4hX0vPVNLqS5nR5VaQO4mS5wmTSx2TLCzF8y4A+NmfPca9R6Eq+fYI/vCaAO/xMNHPYro6V1hVOaMEWwZUQEsjZlUqA8VdK91lWh5Kqaxa/IDlK00a36mIfsZp3tnkqkoK+K87H2Cb3SQ6CYxGVI9iOqleelGX7IqHpqcj6TtgNK41B+tRfblEiArLUeH3pfwXyVn0LEB8XHPIAp1EgefKiY6+jhQ7PEI8qMKDOJ3ud/T32eNwQAlpt0wn0mM3re/T5BriYJ1YnBFnJ+ugQCfdASV48qxV6i8f3Q7W0Fu3ftDkDjq03s3fmmaORDobcnPf2zddLDw2VElMj6amRe6laDQX6+mPzokmMdL5FPzOmacuj0/ZLOrdHhT9eCkC4MXoFFroNDCAmbsqpsGo3Cl0iiuxhi+Wkxb7nBGN+9+kDcYG8K9e4mUyrVapzB3ubpF0AO8RTSvV6rUoS0q14P4n6JeXUE5O0ap+/Eu92CJlrIYwZlnj69eGV4bXu9ilwNPcwEsyEB7l/wqcd5Uvwqn5Sk7eXovFlumsBR4xkXMVgnPuibaL7ILQAekWXDwuwT3MOSA/tXN2ABqDk/sEsxYsN48xV7lHekTH+kYhfSZRLNUslpqpMFOZKZNWypCwWRtu/yBsJMiidVcD3cJMBRYZVdXW2WwNvXn9HxZI371AXFdZVRVKXO0QQAtK6o016Xo8zyFiMf3//0dAqw0DPvWi67eE37penIL1zAYq8yyT2sCcTGijNaXNpY35qENcOkkX0M7S+fRp+PXrUXow/SwtBCj1q1eb00XRywa6h3NTk1ftF6NOLxmMiDO/h4ZmpRNMqO6imFu569c7x1/TnyvYK0/qv/b0LC6GiTRaWZq9WQll3fqStZa/Pnf49OTDoFVVfRfOfU+YMB+olPnEN8MU8srLjzUXrDZhKlW8Cmsv8maFyhBtaTt2/BgqbPNHgf2aZxZzGKFmutrqSyDMRF+H/ieIGPjuh6ql0r4aXTVu9Uj448JVurp+XZG8tg44Bw9nLvJM8ujs9EjyXGQwKHCfPcljkadBoZkhqcjwTxUKU/0z3g8wXKnCDNF7UMpHFCDqg/4G9/nYGfX3IwkHv2tZAsylTHp4dHR8PFM5HX5JBkN9MLth0l3hHu/OBEzFI+0e6ajRdD+gpm6NZq0KcIIyyeQPeh6YFdiI3a9gpv76/PwTJ/paWgMDAQb7SIOAWKLBU/gUAqW7Z+7ckeG9jW9teqQzZ2SEQm4bcorFtdGzWEmKdaoTf8gwxMy27K4jaUpsw7pPansYK8rZoNACjxr/VHMdzayT3jeP3r13VhMWJm5PFc0Doz/kcloKdYnAkleuTKHtMRVwrSJNOZZgsbbRERjOigrbV3CsIp1vbBhFRx963dW1yQ0wCoMvZ+jBkICTKj7tFT0E4gskK+10GsQjQsFAtPN9wx51aJEq9Mx59PxZlaxILdvbQEO9ZUr5qJ2V5fXnMi5IL5wpgDp0Tz1V4q1WqoKKamDXpCFRSMeTpz+LllTJ910PhklDoNSVBMp473mSY9qzWsrrsjJs546dOzHQT87IuBsZRcQ3Lu7p+ao/uZJtbbinVEpS4M5zE1WpybnD3QNXZIg5JQccOrRuXe6tGJE71YSQlR4a+vuZiInrcbGrV9QnTmD+ori4Tw7Pf7VcW7JuPaXEzD6trLQUWAiGi+vGjQa0Ybpj3AEbqQ2wWHuacb0erceGwfvReKke9Bo0Gt+2vqXw4NiDnm9evAzwORxwPq/NjFS+dVv9ashzyGgcmk/0dudmwuBLh10aGfRkAnwOBZqJ4mk3LN7y7OeKk+OSJ2nV8auLpIuypdnPwB0PfIMjqScojlS/32QhMHP+fKBuY11roSTNQpYXHk5Okcuduj+GeDnnFrgGBstCY2Iach3I4E+lEvfAlgrAnQ5sJOUjsPiomBhvApGlW5CtjDWdEZiKOD3NDMPQCADCD+fZK6F04nwhqyythQiyOaqoRbe0BAD/h/0cGje5XkcVy6lMRZz7IFEsuJn09w2c2s0X/77JJlV8MeQoaMHLxOThnxiK+D8QmCbNB5s6wI1QhT0PqkHQxUabGIXRFnsi4NcGwjXT/rbOfCjPJhtUihTxqzIfFCneKozC7NhGk5iJgd8xSNshJ55BfAfUiSNl+J+xBwPPcNpyKVn81VyAhgFggcUf/fUBfL/Ij4V9HIC/waDQCQD9Zx7u1ZX9b4Lhr0AofxWPqPeNrFbwj6X3RzxWNW/9Oz7TD2QEC0D6IHQecEvwaLAHSWD8ioU4EabhG4G1ozIQgDaqgBKwgAyFEETLE0wD+QAC0MQCQFAG6mejRoEASJPRm8C9ZAyB/aPGAhk8J+MIHB+FAMWZ/DQBtOAW/Jv+mUd7p8Og4wv4EjSfriDe5wM4j4TtVXeZ9WjPgMBawLb9os2TvxZxrWOK7RNhu68QqE1Mn2CkG0TSzcWFC7zuDMUVzXvGRtYdLRi2AOkFrKQiiM1jjdUKpA+wJJlPjaDWlc6lpu8zj9rjagJYqbd4lrJpI12TSHLaR4WRmPBPRpEmCRGhNZ/UyidgAntnKKAkNy6ijTlde8cYYf2bh1OtMmy6GdYwQaZQafQ/tNkX+8/v/fHx+vyBYCgcicbiiWQqncnm8oViqVyp1uqNZqvd6fb6g+FoPJnO5hImlLl1596DR0+effPdDz/98tsff/3z34tXb959xE5ensFrGQkbvZhmeV2/pjGJBkJtumY5XMXBfPU0V/u5YM9P2hjRggDHEbXAcVZKQS31rqlArNJ4FMobr7FEzNumUFgbAVuZSovaLMp53bzTuvmksi2bGv6y8eYSkzZO7C85KlA56DysJ3LjRigR19UQZ6n8GlPtF5VUndWRKjQnTRhYsbcbobQd0W/GnI9xXEIVG5bNhrJSPVgIO1iidAg0Q6zTxRZYx4J1KhPJIV/6YUj1RYRQkXMHJw1hzcMPUuWcYDs/BkooSzPcfIW1IdLmMxwLA3SSY7PM2lFVukuuM8DiNusFa0HJZm4iNU7Ou13Fqx6RmjItKOLeI4VgVU+Vp8RtSS2Utk2HiWs0p6TdV9QM0wZ1ScIeTJ3N213YtUpbW8E5yqrmMSBGBM1kRjD40ptTT0VFsjBxlrECAAAA";

/***/ }),

/***/ 43545:
/***/ (function(module) {

module.exports = "data:font/woff2;charset=utf-8;base64,d09GMgABAAAAABzUAAsAAAAAPOAAAByEAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHItKBmAAjRIKzji/FAE2AiQDgmgLgTYABCAFhEYHhkYbvTNlQcDGAWDa/P0RReWoMyLZ4CzM/v9DcmNM9ACsi0AQwTQhDWHL4NqMdePeGClltMJGrLTuMvf8hbUCjZYozi+/kt8hj73YmUgga6cpdoxOuYO8dP+JaQTbuXjYIUloijx8vx/t3LdmbeMm1WYimFqntB1CpTGESKb9v9x638HCmehXAXZhkTPkJKLWVCkzKeo0RepMAmB4nLN/JYiH8oK0DK0ECl4meIXiOjFsG3ixicJS2AlT5sDuM2hnmsLNrLkDtn/0tuRkRicGfIEzqNhGN7sHIogaoiV8KfFjv01VM1x7MmtY5JQxt8fzlz7RJCQzoQA+CMplEG9Ju+zm+60UbqsDRJGVXMT8cnVBYr4Rb52fmdZnWkcWTl+zgpyIVAWW/0bA/+ksW8MR64IwB13o9VhT12lGYxh9yfZY9r6V53T7vCzDe9FqWUfkrQLMtX0OWMc6dgAroKLkPimaFG26qwN1dV2Kog08/O83K1QqoXA6IQTx+y5i6ScgyszSvHZRa2VxBDXYYv2oxMa+YTDdVKU9HmFKusZ9G8ZmDb1rXbWbhZIiAgLGf38QARSbuMSMvhs2hC6ZT28gB7m/Z4Cv0XHJP70PnjMD6rEoeD7lvMNOSM3GJ/8ix7M4Tt3+k+vLrc5HfXVefbA8KkZc/MSHYBJMJCBkCorBk9LKCpWGFRo9U47J4LLNbY40RCJzijXr0TRFCMwS3qU5G0Fu7CXF5uH+toR7fppUG0cmmiI4ARW7LlFxXivYksYg0NL7j/FYcAgoE2aK4izoMMM1NI0ykcCOBihcm7plTEhwKV2+cROYxPoJwmnXiH8At86g0KbQNeHN7V3hwKghRKabBbu4p+pVEEsCY8So2twPwRaICrS8R4bxQlrOmR75os/PGgGW4dIo7t7ly4FZ7J5U7/qHGrANYsCT3DbHIc8SAlm6RiJNByJYp/aiGkzf/P711/9AUUU301AE5dDQPM0+xA8FUqbwzfOfUyxiu3eP2IBhO61nXj1m4kUG2ERP6VIQ1g1XS6MoewUooVYlS070VUxylBU2a/C00Mrs3CZKxSOc+iIbj1H4+f5cgpAIdK8OM53xDWranJsd3VMtaxC+NWk7Mg5M58QighvRChpNAFNOxUpoQyuvhbGbRTPEJ6djV6Eo3WxsSpRHPmhEkK2j0JDdBZ1nYKKFyE+mdcgHXc4wt/uSCdFMkYdgQa6dvYWVT+8uo3/CB2Gs240siP1NlHSEplScfAmWZ05ffocHZcwbO6bTCvlRuxgOt4gBMXnveeWLE8EeQAeGZTPQHcMzLad8eZIBZ+MHKf5ZMtumqaERCKwxf7AuIPagipQ1dWwRL8ujZOCqqG60LyzDFaZksPEMpIqAVLLqEiLsMIHU160zmKzaH84GSr/jpzyQHnSH8Ont549/OiKBhMtxfwSLZ8gj+KslIzZgO1e2O9/IW1cCeUAO0Hw4yKXO3j3RHOwHeQNfDtCJKOdpg/cz9Nw7P7KejFRpcd9LH7LIpp8b3Jsh9OAt6Tj2RyBiTt/MYbPhlWUzRntbCieUILY11cLKlguDhfjx3Dy8fPxqLvs02OOFwuAIJAqNwd4wvnMCokgi+/qoNDoDxmSxOVweXyAUiSVSGUSuUKrUGq1ObzCazJCuQeS7v46X/J8/tKCbeCNOZZjNWlRxQJom9lpdrLaQrlAKyD3sVHeBlie0BByhIeAEWgBOohngFFoGTqNR4AzaBM6iYeAcmgPOo3HgIpoHLqFZ4DJaAa6gSeAqmgCuoTXgBhoBbqJp4BYaA26jVeAO2gDuoingHloE7qN14MHFWyAjijcFNDCBDdiBB3AAT+AELmDnHxAAISAMRIAoEAPiQAJIAikgDWSALJAD8kABKAIloAxU5JdbFf6qAXWgATSBlvyyakMvHaAL9IA+MACGwAgYAxNgCsyAObAAlvJ1s4LBrIENsAV2wB44AWfgAlyl6XXKtjR9TtmO0T2Af1WG2B7wcMGxn6WvK76su6n01BObpCnecokRuvzppfATTK4o9xQUhTGGBB0Km9wtsNskCAY5EKVWd11xLrG761Tjau4De0upxEsM/+MFkHouzsR0hBDQqy+dpXf9HeCuK2LCoAPQeSsLG/3wd9gyf3d74JyigsAPQGDX4pmnX2J5lLwnqR3xrgUiRKRoyo0h1C5iUwsWpBYu4Ph0NrtIyNQKrv5AepDfSm8Gt4JJc7WsLlh/lmVrwb1zdLvCcMSnQA8HNM0eMSF/mKNR+PwuwOKy2yAdO2q5uoV52WjyiVRfw9bbzcH9naCgmKVK2OCKh7iaQ1a56BWcr4hIWu4eB1PcQaPg+KVKdCQSVavPg0Idm6qrkMMXP39cv6TVFHwS0ikls4C8r1rY+6zLCEp581Sd+FQuv/17UXjmLpGcWGrNaRRgjwJR/Sat9+39OVpqRO/FQhwrq8JrkkTLcdlqVbWq4P//JQrkDe+gHP3t25VFa711SJwQA9GiaRSuYWzB5J+pE8Z9SUtsWyBmMNv0BdOExmdG/+Az0QpEN2eHkk0YrtLTmx/iZeYHfGv0mPGF+GN1ufWhdDd50v5SF3wvL4rXKf4wGd2QlyAXO+EUap05GLaI6+svHAxRO2RRxOJNV2SWJpxZy3tnjXD6D/LXLNrsrm+KR0YNOUlwHAUH0MNRZi75Y5pKOPU7mIP/nJFf252K4VEYmqE2jQKgsDUcCenTKVBj+Ixuk5hBVTcbCJolTbWQjkKdUSTs2zzz52627/epRTVN038wJKzbhwNay4dkQI6APoV/n7rDhYzjCivJnvkT6Pan4M9fFNG8cN5AVZTyF8zqPuJF3VKr4mn8N9XhP7wex3/0SUC/fT+nFASHYU6chXzjyuLqcke2Odq62znKkFVmxslAwxAt0Q14XOQba2HG8XkJnLNtYiqwjS+uLq63shaNbNN0HDPdpJELi5XeqAN1ShVSEkwHyjFp0eECy6OeqZ4JKb6+oymaLdG2zRDBhJQU5DxwbFmimk0hmzg6HoPjZBJNyChJ4qi7Ucnb/X4Tf749juL06r/VZIV4n6YOVVNH4Ng5S2CNMiUqBF1jtdQ7cON/JVLebnCDcpGX2wB3hC1aqCKwZGcULZfmzmn71LO1ssL2JGgUcVlcr3I6BBiBhPQOnKCYTsErlsV3bJEOotNEiTcTheMDTjp6yOjr3mCdW2Ye+feZKsAri0FzuKYim41eYx81B8NBgfhY1AT/pN7uV+2WYICPIrmQObCXOJ9+GImboSlI8mJ620MRoLH65yszjyRHbSK8Y0IPi+9a6FhL/eSLf2kJ1XrP/1E3XusMD3Zmv/uTUatchOWonYf+Xlpo7x89hybJOBzDExqOIhjHJEmQ9Hb6V/3kkobR/vZ060tTkCqu0/Yj/y53OweHM01148//ocRES06hkJlb8aEH5uBAuYtyYbaMPegzerpqJbgqd0WPVc1n1Q44NfUqbcJDWjkTxREFTn36acY5IuUhPEOGx9u1X/FKjxIAILQ7XGMhwpngvMvodHJz6vmdetMnxvnTrmjMjrJHJT0oNMAMPFhvKoMhElV0Puxr5LfJXtQzMQIADhadDIlzFoxiyYkX8dBYF+weH84khDjAnZpBScaTOyrM3ZzVneqONTe44hkKjV5fk/TbGk3lBu8SpGhvFtxscQNc8yQRbNkkP5DQ5mh6mYRwMS9O2i71OsUYBh0oCnfyzFW1lMIVEJlrgDmGn2BFpwc4TPz2vF0k17ESjHh4dDIVk1hp7fkBLt5Dy3Wf5TfPGa0Ke1In0RKqyCCzt9BVsS41zlOrKUNoHf++CPjCadkzOtlJixXzk+q9Mss660Ts2RDmmHGYsqN2dORkd30AZEAzh825qlot4aBrNovlYKTOaayDD3OOeOr3nRRk1eifHsthTqP57B62R9H0wJ/VpB8Q9Hxqb/NVyvvbrqiOzHzpoZR3OD49sFGoY49ppU0xl7gj7xXN/jWaqG+Vjsk5caKVgTU7jQtCq/Ad16N2KckFmIm9ULZEhsbkfzIbUFZSMthAy42LFaeJepaO8ny5D++uOlS3GbXkSr2gypo1dlybHRlej8BpTXdFuLrdRbmGTmnyycFznW3n7RAFYypxvIbCakKWk2cX5aTZxDfSBqJquQ1hpSQo3zdnLumUdepC3qUSxxaPEqOlhANUOJa/UAbOo+EtYR7LFxvnrK8NlFeLHZZ6CsVIza6UfKfAQQ7pLEZBP0OkC9MhbKCFQanTOVpVABTq+mW8G3bdsC21zXmmYqv5JeGRiR7Uq1sB9mZfW6TL9BW/roJy5Hjxa01e1VTFMX/zMBqFp3pAGvpq4yquChANEJSAwA6HHc47rmTz8B/yH/oX/506z7gnqYteyYBbZEi8DF7x7QXQGnmx9O0i9e4LcXo4TVuueyYN212eYnW92RRzUHhlemqXcdEoWEuuDlgaYx2k3UZtLCoJ4TTZVDn+WkoxNceYic3NQH6uaaLgakubffzbRsXMVuyxJY3L4jO7tachTVd+m72bPUzB6X0jsIPCngJFzKyVD7GK0vwbbbGcZs2clLf0a8ZXQA32BIXE1DB5v69RpBgCWLilefhDOLAw7uvqwENmbR3HrAK1UUsxug7dxKpoH87puGnoL5m6EHPezLyPv1ZiSVvJJJy7UdK0+2mOAq6c7ZU9uK5Mg2MUk1cV20YWleOzsMG/pHBfFCSzuNJmGpLYZqgVamFWxS3rTvfO+twrsiApJLFNGAmnbSovcVpfRbyKbOECz+xLjJBZt44yOSCkdSzwnzJRC+l161J8VO3t7IKy7iEA/oSy7aoTqQrkOzwCLF13fgG7rTFaic4YFFJDmgocKPBYEcDgjLMzZTIooR/cv4GQuBq7caAFaZkAwZPDtMaPj+v1z4Rq4bCL4+Pd5fjMdkK/5s3tOHZXTujHgYe8BqqxA5gaP3CbmQT0oEr2wHPmCdTiGjhb0GoW2Ox6vUcWpigmuSDnW9XhoinlFSkoEoLUiZNlZWhKUEgQmlpRloZuXgiusoGzxSkPxBybf8SotqmhVVG/Z9PybZ70R7FOw1ogsGY5nshgXZfWPdoHePIQ9q4D33ZPdPWY1xL4Q+murWcvgBwnZ0Hl5uffTn77fHNlW75f7u3M9GELNK2F0o7MzIFA58Du7CxyDBsjzboTgQcyMzvGXADKu0TjalxXU0PThJ3MTirDhqzp0GlWaQmDMykp++9XXNw2RpehNtExuZaWoY6Lr9y8qZ6jtlvvsdtrt8ecryucQHLXZ4XofPx5kQJsSWI7FXyd02t1+XnnweeXrdBcNwUwl69kT3Hj+X2+vFhR1MeP550TBeTGVPJ/i0WbDx1efHhvM5qL8mf27qs9rTDF33eoztYLkitQRsjMzAAHnbHfhNKvHYwQWNzCYVjPrhXU4FqIiPqCeoL6REjPy4/x1cpJmP6yMwO2YtuusIGnHW8nh9fF43btZ/dyg3H6vMDcsT9pXIMzjo5OjhSuxenTSo4MTuIUflXV6YHAvLGJshJl9ebYsyy8DA/GS/F5u5Okgjg/4vKisVnFemLuLbF7yqru+QmNunj001uHs+W7hF7n26G9k+sf320ytvzquiLeJ7NsxDJqzRfnOYXZjbbsCgVng+3hM7YczkxE0GbJw7qNmNWR6ztit7yzZudCm3NbLp53mL2H+GEGjnBtZznhcNQmdJ536nO76zwbi2L5zy8cv7trfyr8GxHpo3UWAaftJlapDpYmzqGPnaoHbAeqnYLvi80tj9prXnvniz11UkrKSOlHqfOiClbyy7iKTMtVR7Zs9fWj1doO8/lzLCublyQLybRJd9Y6pVtnhsiSeNlG8i3rQ1EWgzR/v3TNJU9KqpPSUubrpgqF8XHmGAx4iv2hGiex52OP6aVqIcXzYvA9J8p65ZOjVD0ek9yXOXavoDlp1Y7KJKf0ETbxqTeiMKbw1gn5v81HgqzZKWlrcpoPVibAI+aYeZyzoiSvZe7AE4sRmY098OEZCTGMkd1l5ez2RpXGnCQYIXCXx4OaZSEp3pLYCIl3WlVfb90WV8m9H7LH4354VWwzlfgp1bvQqc5rIm6915jzz5TpsysDTEfn8NKrjpRRIafIUSZzLOIUetBLt4TMlizJm5X5V7R6JW6p6+2t2nhBNCKJTfFeFlITGAjkGwUrZ5Xp+TPDJa5zQWEq/lvilE1ETVeGJLpDeTKdjeFTKxoHqw1bfZJL9kocYx03SfYB7i1J9tkqQwqCpXrLOzI/eUAyJ3tOD2TIV55N71jqpcEFSLSrByPZjEt9FJjm75+2WLLTiy93eESCYQoZ1Ukg9S9Iwo8e9lL6CMn+Vz5yXpCmoLmEXVg/cGmC+kH+B5cJ0/a29qkZvZ4y2Z9BS7moamz39Psu4P2NByPVkY4Zj8tsTVWYvg9qm+Z5QXmqHxDdEtM447WEOxUaw+ml0UgDe9EcdIkXUZ6v0EsQWdk0TmVneYKyoEaogfwBy5XpbaSFble5M5oJbXDXC5iHGLdKWFkmpyWDHuRmRJOJtAQ8uQslHMygfX0nEz0TJ411+5AF1IRBB0mchDow3sg1jpOHyeOmXRJcy/iEgCxejMwzZ5Eq0dJsfkDGTjc4c6fzxGHivGlugrzqYAn+2fxoqWfuwoXL5Hj+oYgPX1gW0jCX0wCP1zYKQf9h9jQ04HF26yonKJxRKnUm6gydexhc+MADcqVS0rPY5f3BtaawDj7k70vrEZw8cFgoh1JJC9Umxx4Kf9k+AheVyu3NQruaCCBC1F1rqSYnrdSc/EKgWZPEZiEJZ5GlQ6MKB0kCUyS+TDJMNGEmJ0HlX1DrcUpjQqf4a3iM31kBl+CFrJqAiPOHGJyZmCCEpogIyrVVBoMOD2JPBd0R6p3t25uPrgJOrccs8Mzewb/x448kk6ey4WlaqDFhjqaq2tvszQynkoLYfOLAT50C6Iq5wMlZKg1bIClclB6Q6u+fGpBOSnYm1X9OTX7WZec3hZeELV8eVhLxcctbvvK0wIeIx+4PoCT81SeipAk4Ig+8rD24/HO+A5fX9xx/mjMlj+Ea2CAai07bPaH4+nbcQEWT8K2gKTcwFv1Adt4nkM2NiZ3ixAbkEnyzg8+in515gpFQkJdHGasz6H/10zhTnyzR3sguKyfycgVQC2xvbbWf4qbyz4pYCpfdHvuserYlCtAqQSKmxuIhiY0vrgpNEmzrsdq37L1LPJrc6IIq3GJREdTCu4IqkMTf1mvJfcu17N2dyAdVgrtQg/nYxbop7HqQmjDCkHMEI4E1TBkgWXzfojs7F73P5w+dPfG886IGAm+wdns+wDTw0SPl5x8dOsEj9RmP7upa9u7h4FPXeNzVQTUEruKJNWbXSiX5ycvhtvkF89HSZf0ZUcuTtsH6gvpim+6MMIl35BartPQ/OeC2pOWRGadLVlhPBctybXYXlqqw7Mp4gR/PpnDRvp2l+fbdS7sz7IjCxVth+ob4lPgNrvXHj9e7tgdv3ZTFopK1j5gK3XSuOMtnuaJZv6mPSqZa0fiB6MDA+XfdZQWejdsJDzBrUChN6DwOxGAAbnI1poHjg4O0UC2kZmZ9ELrZWSK/wK6xkRgcHIck9HovnbowAZK4FoKXB2xTOQF41xsTXOLFWt7D2FxiZobYPx04QmMimWKXEOBlSqV15olRSkg9fGABs4T0WgMDDE6BXP1Yt5H/xRHpYAMm9ERM3wL6rjIxZ7FBbKG3FjUNdtnfMY3Y9tdUqxrbPAvKu5VffjAhl1KfnZYWIIqW4AHX23WBMb2KM7+7PuzTiE4cQQJ3Ol+8QAw8eV6Buz13B1pbz+GzOqMxI6mD2dyu5IARMqzfsaooNF8szg8tehJa7Ey+eOaeFH+GiiNFMlqkti0XFPLz2try+IWCO5L92tva+HmCwjsZ7hf+mAZWVrkeo6pKL3GokYmKBixCVuHcgEqcbqh4etEDaktdHm0YG39foKSGScbjEQb2TOGlaZtU8HnGuBvYHYvES1PBbn5fJA7JzQ0RS1emvzftZ28v/aYfVqZJxbnBIbnfyIUwrmf+f65Mk6RAaemkZBp/rfeiBwWGOP5eY5ww5zGvKLOC/+ko4wMZP4IxfP8Vl5pBR90yWFOq+++Qc5TXY+cwzmMvf+d1bpXPdgxZ28dZe9lod4CnD0/b2Nvk72ha1PhVvo2XTSWYOoZaOOoc5D500jf3dMkrxfc4XJ0f7HX0Lc9+Jn7LZQpTO59oos/njcL04VEBLqgCifzdLse/mKz5c9NzcbSRG//J5opFbfbIuAh1PA6UBPoJRkSYFlTuvtDbkNLEpiW1cCnlCJ3yBgdzCLMc23pTZhwAQVMAuqjPpfDiRTROk58R2bOXV9bTOAia3JU6P4POdf3cF8hX4mcLDLbshw5P8ny7Vn4r+0Rf8Fj+n90iaGGvZo5f62uXyS0bWR38DtbGVSO3MFrVwFiThhaMNByXhUm31/hg4Gm6UllYoGz4kSOPsI6QJySEnrc+H0o0NICN/6znbeqxK7JGOiVvUwGnBCFRURvJH6lNGrB5EK+zRI10nqUexFV6gKibrUZSAKg/XYW8X0g1yM17hCELs/I6BvT7uHSahyUHEP+8vhRJrka/Sp2ITLcNpXhktaQ1+nTPx8jFQGvFEU/26b/IAZ5pkdSOPNRlQO883diAvInT0OeHSxCjg49QF2IbxLNyruUtIRMp3kgsPIyOAX0IlxWIxIMawymvLJA8wJv/U6JYMuSp6qgIujvNe7ga9Z4wqHWjbemRn2Sm2/5H8NHBT3V74xI08j/mVogBAIosXny/6YT1RPxpg3r08bfx1QBQv8LNVIb/PIv9jZ8U/wvZ3eF/CuavvwEkLU4A88AWgJhBF0QB6wV3VWMBAtB2hIA7Qd+YL3ochHN6GTXgB33UQQAcspmhy8DeF4iDSoAAl7EFcIEM2LRADAiBX4yNp/czBKZ/jziQAj8xHkx/j3xgxTL+3fygxSoKuF8fxbsv2Yjev2Kdg5HHjYIf8xMleabi5fCcdnxHJBSj6IrTrUht/apaFZVwU7wzxRGFwEUU/kCrh7NqfHt6qsKAB8tNx9RH8e5LNoFT718xFjk8bRHEFmWZP/GNJfBLYypeDs+Q4SMQ9MpG0Zmn28FMbWy+6sasip1XuCnesRJIFkLGEcRs+wNtKA7nGnZ8e9pMVcGKg8US/5+YazP/y2RsM5ik0TkYnEwWF5ubhxfFcIKkaIbleEGUZEXVdMO0bMf1/CCM4iTN8qKs6qbt+mGc5kUQJUxkhaqabkxn88XStGxntd5sb4z/r1Nyv64Fa6OeaWhE+JJ6JtmhNWQxDOzZiK7bjfbzxNfy3IXu8WE/nhwqSuPJKG7T8pmgJs4tB5Yy+rvZMvoUc0NpaplUjFV0fcvxNrDCKfVsans2a99hsgO8kk6Om0eDvaGb4A3LFEw69y7FYeUDweTAfpK0X4uPg1o4x35uUsuJlQ6DJ8pBR4GN81SPG3P1jb9jv0HKY05pogUx4YxYSxMCX8AHsXIGe5hIg+hb1rVEPw2Xp6zKVHJVrR78aCC+Pms/mRanqcFQLR1f6EqY0GZAKaONvzGPTNuizkwFsbSBE2AbbixHmDwO54g0ziQI69ayY8hpUCi3Om4GZhqjNFG1gbk0b1soFWgOM0mc02L3doSuPLEqN9NEUTlOO4e30oDVOc6vhO9ETOLUAiixNm3zL7c0zvXReQUDNQggKHhgILhAAgsBzvAJJ7hC+QgayBDhBi1UcO8A";

/***/ }),

/***/ 18791:
/***/ (function(module) {

module.exports = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgc3R5bGU9ImZpbGwtcnVsZTpldmVub2RkO2NsaXAtcnVsZTpldmVub2RkO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxLjU7Ij4KICAgIDxnIHRyYW5zZm9ybT0ibWF0cml4KDEuNTc4NCwwLDAsMS44NjQyOSwtNC40MTM0OSwtNy4yMTIxMikiPgogICAgICAgIDxwYXRoIGQ9Ik01Ljk3OSw4LjkxMUw1Ljk3OSwxMC4zMDZMMy40NDUsOC4xNkw1Ljk3OSw2LjAxNEw1Ljk3OSw3LjQwOUwxMi4yODUsNy40MDlMMTIuMjg1LDguOTExTDUuOTc5LDguOTExWiIgc3R5bGU9InN0cm9rZTp3aGl0ZTtzdHJva2Utd2lkdGg6MC40MXB4OyIvPgogICAgPC9nPgo8L3N2Zz4K";

/***/ }),

/***/ 50542:
/***/ (function(module) {

module.exports = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgc3R5bGU9ImZpbGwtcnVsZTpldmVub2RkO2NsaXAtcnVsZTpldmVub2RkO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxLjU7Ij4KICAgIDxnIHRyYW5zZm9ybT0ibWF0cml4KDEuNTc4NCwwLDAsMS44NjQyOSwtNC40MTM0OSwtNy4yMTIxMikiPgogICAgICAgIDxwYXRoIGQ9Ik0zLjQ0NSw4LjkxMUwzLjQ0NSw3LjQwOUw5Ljc1LDcuNDA5TDkuNzUsNi4wMTRMMTIuMjg1LDguMTZMOS43NSwxMC4zMDZMOS43NSw4LjkxMUwzLjQ0NSw4LjkxMVoiIHN0eWxlPSJzdHJva2U6d2hpdGU7c3Ryb2tlLXdpZHRoOjAuNDFweDsiLz4KICAgIDwvZz4KPC9zdmc+Cg==";

/***/ }),

/***/ 82487:
/***/ (function(module) {

module.exports = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjA5IiBoZWlnaHQ9IjM2IiB2aWV3Qm94PSIwIDAgMjA5IDM2IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cGF0aCBkPSJNMTkyLjk5MyAyMy42NTgyVjE1LjcxMTdIMTc5LjQ1MkwxNzEuNTA1IDIzLjY1ODJIMTkyLjk5M1oiIGZpbGw9IiM5QjlCOUIiLz4KPHBhdGggZD0iTTIwOC4yNSAzLjk1MDgxSDE5MS4yNzZMMTgzLjI2NiAxMS44OTczSDIwOC4yNVYzLjk1MDgxWiIgZmlsbD0iIzlCOUI5QiIvPgo8cGF0aCBkPSJNMTYzLjYyMiAzMS42MDQ4TDE2Ny42OTEgMjcuNTM2MUgxODEuNDIzVjM1LjQ4MjdIMTYzLjYyMlYzMS42MDQ4WiIgZmlsbD0iIzlCOUI5QiIvPgo8cGF0aCBkPSJNMTY2LjYxIDE5Ljc4MDNIMTc1LjM4M0wxODMuMzkzIDExLjgzMzdIMTY2LjYxVjE5Ljc4MDNaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0xNTcuMDExIDMxLjYwNDdIMTYzLjYyMkwxNzEuNTA1IDIzLjY1ODJIMTU3LjAxMVYzMS42MDQ3WiIgZmlsbD0iIzlCOUI5QiIvPgo8cGF0aCBkPSJNMTkxLjI3NiAzLjk1MDgxTDE4Ny4yMDggOC4wMTk0MUgxNjEuMjdWMC4wNzI4NzZIMTkxLjI3NlYzLjk1MDgxWiIgZmlsbD0iIzlCOUI5QiIvPgo8cGF0aCBkPSJNMjAuODM5MSAzMC4yMDYxSDguMzc4OTJMNi4yMTc0NSAzNS41NDYySDAuNzUwMjQ0TDEyLjI1NjggOC41OTE1NUgxNy4wMjQ3TDI4LjUzMTMgMzUuNTQ2MkgyMy4wMDA1TDIwLjgzOTEgMzAuMjA2MVpNMTkuMTIyNyAyNS45NDY4TDE0LjYwOSAxNC45NDg4TDEwLjA5NTQgMjUuOTQ2OEgxOS4xMjI3WiIgZmlsbD0iIzlCOUI5QiIvPgo8cGF0aCBkPSJNMTA0LjQzNyAxOC41MDg5QzEwNi4wMjYgMTYuMTU2NyAxMTAuMDMxIDE1LjkwMjQgMTExLjY4NCAxNS45MDI0VjIwLjQ3OTZDMTA5LjY1IDIwLjQ3OTYgMTA3LjYxNSAyMC41NDMyIDEwNi40MDcgMjEuNDMzMkMxMDUuMiAyMi4zMjMyIDEwNC41NjQgMjMuNTMxMSAxMDQuNTY0IDI0Ljk5MzJWMzUuNTQ2Mkg5OS42MDUxVjE1LjkwMjRIMTA0LjM3M0wxMDQuNDM3IDE4LjUwODlaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0xMTkuMzc2IDE1LjkwMjRIMTE0LjQxOFYzNS41NDYySDExOS4zNzZWMTUuOTAyNFoiIGZpbGw9IiM5QjlCOUIiLz4KPHBhdGggZD0iTTExOS4zNzYgNy4xMjkzOUgxMTQuNDE4VjEyLjk3OEgxMTkuMzc2VjcuMTI5MzlaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0xNDMuOTc5IDcuMTI5MzlWMzUuNTQ2MkgxMzkuMjExTDEzOS4wODQgMzIuNTU4M0MxMzguMzg0IDMzLjU3NTUgMTM3LjQ5NCAzNC40MDE5IDEzNi40MTQgMzUuMDM3NkMxMzUuMzMzIDM1LjYwOTggMTMzLjk5OCAzNS45Mjc2IDEzMi40NzIgMzUuOTI3NkMxMzEuMTM3IDM1LjkyNzYgMTI5Ljg2NiAzNS42NzMzIDEyOC43ODUgMzUuMjI4M0MxMjcuNjQxIDM0LjcxOTcgMTI2LjYyMyAzNC4wODQgMTI1Ljc5NyAzMy4xOTRDMTI0Ljk3MSAzMi4zMDQgMTI0LjI3MSAzMS4yMjMzIDEyMy44MjYgMzAuMDE1NEMxMjMuMzE4IDI4LjgwNzUgMTIzLjEyNyAyNy40MDkgMTIzLjEyNyAyNS44ODMyQzEyMy4xMjcgMjQuMzU3NSAxMjMuMzgxIDIyLjk1ODkgMTIzLjgyNiAyMS42ODc0QzEyNC4zMzUgMjAuNDE2IDEyNC45NzEgMTkuMzM1MyAxMjUuNzk3IDE4LjQ0NTNDMTI2LjYyMyAxNy41NTUyIDEyNy42NDEgMTYuODU2IDEyOC43ODUgMTYuMzQ3NEMxMjkuOTI5IDE1LjgzODggMTMxLjEzNyAxNS41ODQ1IDEzMi40NzIgMTUuNTg0NUMxMzMuOTk4IDE1LjU4NDUgMTM1LjI2OSAxNS44Mzg4IDEzNi4zNSAxNi40MTA5QzEzNy40MzEgMTYuOTgzMSAxMzguMzIxIDE3Ljc0NTkgMTM5LjAyIDE4LjgyNjdWNy4xOTI5NUgxNDMuOTc5VjcuMTI5MzlaTTEzMy41NTMgMzEuNjY4M0MxMzUuMjA2IDMxLjY2ODMgMTM2LjQ3NyAzMS4wOTYyIDEzNy40OTQgMzAuMDE1NEMxMzguNTExIDI4LjkzNDcgMTM5LjAyIDI3LjQ3MjUgMTM5LjAyIDI1LjY5MjVDMTM5LjAyIDIzLjkxMjUgMTM4LjUxMSAyMi41MTM5IDEzNy40OTQgMjEuMzY5NkMxMzYuNDc3IDIwLjI4ODggMTM1LjIwNiAxOS43MTY3IDEzMy41NTMgMTkuNzE2N0MxMzEuOTYzIDE5LjcxNjcgMTMwLjYyOCAyMC4yODg4IDEyOS42NzUgMjEuMzY5NkMxMjguNjU4IDIyLjQ1MDMgMTI4LjE0OSAyMy45MTI1IDEyOC4xNDkgMjUuNjkyNUMxMjguMTQ5IDI3LjQ3MjUgMTI4LjY1OCAyOC44NzExIDEyOS42NzUgMjkuOTUxOEMxMzAuNjkyIDMxLjA5NjEgMTMxLjk2MyAzMS42NjgzIDEzMy41NTMgMzEuNjY4M1oiIGZpbGw9IiM5QjlCOUIiLz4KPHBhdGggZD0iTTU3LjIwMjQgMjAuMzUyNUg0NC45MzNWMjQuNjExOEg1MS45MjU5QzUxLjczNTIgMjYuNzczMyA1MC45MDg4IDI4LjQyNjEgNDkuNTEwMiAyOS43NjExQzQ4LjExMTYgMzEuMDMyNiA0Ni4zMzE1IDMxLjY2ODMgNDQuMDQyOSAzMS42NjgzQzQyLjc3MTUgMzEuNjY4MyA0MS41NjM2IDMxLjQxNCA0MC41NDY1IDMwLjk2OUMzOS40NjU3IDMwLjUyNCAzOC41NzU3IDI5Ljg4ODMgMzcuODEyOSAyOC45OTgzQzM3LjA1IDI4LjE3MTggMzYuNDc3OCAyNy4xNTQ3IDM2LjAzMjggMjUuOTQ2OEMzNS41ODc4IDI0LjczODkgMzUuMzk3MSAyMy40Njc1IDM1LjM5NzEgMjIuMDA1M0MzNS4zOTcxIDIwLjU0MzIgMzUuNTg3OCAxOS4yNzE3IDM2LjAzMjggMTguMDYzOEMzNi40MTQzIDE2Ljg1NiAzNy4wNSAxNS45MDI0IDM3LjgxMjkgMTUuMDEyNEMzOC41NzU3IDE0LjE4NTkgMzkuNDY1NyAxMy41NTAyIDQwLjU0NjUgMTMuMDQxNkM0MS42MjcyIDEyLjU5NjYgNDIuNzcxNSAxMi4zNDIzIDQ0LjEwNjUgMTIuMzQyM0M0Ni43NzY2IDEyLjM0MjMgNDguODEwOSAxMi45NzggNTAuMjA5NSAxNC4yNDk1TDUzLjUxNTIgMTAuOTQzOEM1MS4wMzU5IDkuMDM2NTkgNDcuODU3MyA4LjAxOTQxIDQ0LjEwNjUgOC4wMTk0MUM0Mi4wMDg2IDguMDE5NDEgNDAuMTAxNSA4LjMzNzI5IDM4LjM4NSA5LjAzNjU5QzM2LjY2ODYgOS43MzU4OCAzNS4yMDY0IDEwLjYyNTkgMzMuOTk4NSAxMS44MzM3QzMyLjc5MDYgMTMuMDQxNiAzMS44MzcxIDE0LjUwMzggMzEuMjAxNCAxNi4yMjAzQzMwLjU2NTYgMTcuOTM2NyAzMC4yNDc4IDE5Ljg0MzggMzAuMjQ3OCAyMS44NzgyQzMwLjI0NzggMjMuOTEyNSAzMC41NjU2IDI1LjgxOTcgMzEuMjY0OSAyNy41MzYxQzMxLjk2NDIgMjkuMjUyNiAzMi44NTQyIDMwLjcxNDcgMzQuMDYyMSAzMS45MjI2QzM1LjI3IDMzLjEzMDUgMzYuNzMyMSAzNC4wODQxIDM4LjQ0ODYgMzQuNzE5OEM0MC4xNjUgMzUuNDE5MSA0Mi4wNzIyIDM1LjczNyA0NC4xMDY1IDM1LjczN0M0Ni4xNDA4IDM1LjczNyA0Ny45ODQ0IDM1LjQxOTEgNDkuNjM3MyAzNC43MTk4QzUxLjI5MDIgMzQuMDIwNSA1Mi42ODg4IDMzLjEzMDUgNTMuODMzMSAzMS45MjI2QzU0Ljk3NzQgMzAuNzE0NyA1NS44Njc0IDI5LjI1MjYgNTYuNTAzMSAyNy41MzYxQzU3LjEzODggMjUuODE5NyA1Ny40NTY3IDIzLjkxMjUgNTcuNDU2NyAyMS44NzgyVjIxLjA1MTdDNTcuMjY2IDIwLjkyNDYgNTcuMjAyNCAyMC42MDY3IDU3LjIwMjQgMjAuMzUyNVoiIGZpbGw9IiM5QjlCOUIiLz4KPHBhdGggZD0iTTk1Ljk4MTUgMjAuMzUyNUg4My43MTIxVjI0LjYxMThIOTAuNzA1QzkwLjUxNDMgMjYuNzczMyA4OS42ODc5IDI4LjQyNjEgODguMjg5MyAyOS43NjExQzg2Ljg5MDcgMzEuMDMyNiA4NS4xMTA2IDMxLjY2ODMgODIuODIyIDMxLjY2ODNDODEuNTUwNiAzMS42NjgzIDgwLjM0MjcgMzEuNDE0IDc5LjMyNTYgMzAuOTY5Qzc4LjI0NDggMzAuNTI0IDc3LjM1NDggMjkuODg4MyA3Ni41OTIgMjguOTk4M0M3NS44MjkxIDI4LjE3MTggNzUuMjU3IDI3LjE1NDcgNzQuODExOSAyNS45NDY4Qzc0LjM2NjkgMjQuNzM4OSA3NC4xNzYyIDIzLjQ2NzUgNzQuMTc2MiAyMi4wMDUzQzc0LjE3NjIgMjAuNTQzMiA3NC4zNjY5IDE5LjI3MTcgNzQuODExOSAxOC4wNjM4Qzc1LjE5MzQgMTYuODU2IDc1LjgyOTEgMTUuOTAyNCA3Ni41OTIgMTUuMDEyNEM3Ny4zNTQ4IDE0LjE4NTkgNzguMjQ0OCAxMy41NTAyIDc5LjMyNTYgMTMuMDQxNkM4MC40MDYzIDEyLjU5NjYgODEuNTUwNiAxMi4zNDIzIDgyLjg4NTYgMTIuMzQyM0M4NS41NTU3IDEyLjM0MjMgODcuNTkgMTIuOTc4IDg4Ljk4ODYgMTQuMjQ5NUw5Mi4yOTQzIDEwLjk0MzhDODkuODE1IDkuMDM2NTkgODYuNjM2NCA4LjAxOTQxIDgyLjg4NTYgOC4wMTk0MUM4MC43ODc4IDguMDE5NDEgNzguODgwNiA4LjMzNzI5IDc3LjE2NDEgOS4wMzY1OUM3NS40NDc3IDkuNzM1ODggNzMuOTg1NSAxMC42MjU5IDcyLjc3NzYgMTEuODMzN0M3MS41Njk4IDEzLjA0MTYgNzAuNjE2MiAxNC41MDM4IDY5Ljk4MDUgMTYuMjIwM0M2OS4zNDQ3IDE3LjkzNjcgNjkuMDI2OSAxOS44NDM4IDY5LjAyNjkgMjEuODc4MkM2OS4wMjY5IDIzLjkxMjUgNjkuMzQ0NyAyNS44MTk3IDcwLjA0NCAyNy41MzYxQzcwLjc0MzMgMjkuMjUyNiA3MS42MzM0IDMwLjcxNDcgNzIuODQxMiAzMS45MjI2Qzc0LjA0OTEgMzMuMTMwNSA3NS41MTEyIDM0LjA4NDEgNzcuMjI3NyAzNC43MTk4Qzc4Ljk0NDEgMzUuNDE5MSA4MC44NTEzIDM1LjczNyA4Mi44ODU2IDM1LjczN0M4NC45MiAzNS43MzcgODYuNzYzNiAzNS40MTkxIDg4LjQxNjQgMzQuNzE5OEM5MC4wNjkzIDM0LjAyMDUgOTEuNDY3OSAzMy4xMzA1IDkyLjYxMjIgMzEuOTIyNkM5My43NTY1IDMwLjcxNDcgOTQuNjQ2NSAyOS4yNTI2IDk1LjI4MjIgMjcuNTM2MUM5NS45MTggMjUuODE5NyA5Ni4yMzU4IDIzLjkxMjUgOTYuMjM1OCAyMS44NzgyVjIxLjA1MTdDOTYuMDQ1MSAyMC45MjQ2IDk1Ljk4MTUgMjAuNjA2NyA5NS45ODE1IDIwLjM1MjVaIiBmaWxsPSIjOUI5QjlCIi8+Cjwvc3ZnPgo=";

/***/ }),

/***/ 47249:
/***/ (function(module) {

module.exports = "data:image/svg+xml;charset=utf-8;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMiIgaGVpZ2h0PSIxMiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMS41Ij48cGF0aCBkPSJNNS4zIDlhMy43IDMuNyAwIDEgMCAwLTcuNSAzLjcgMy43IDAgMCAwIDAgNy41Wk0xMC41IDEwLjUgOC4zIDguMiIvPjwvc3ZnPg==";

/***/ }),

/***/ 31244:
/***/ (function(module) {

module.exports = "data:image/svg+xml;utf8,<svg xmlns=%22http://www.w3.org/2000/svg%22 width=%224%22 height=%224%22><rect x=%220%22 y=%220%22 width=%224%22 height=%224%22 fill=%22%23fff%22/><path d=%22M0 0H2V4H4V2H0Z%22 fill=%22%23b2b2b2%22/></svg>";

/***/ }),

/***/ 85608:
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   __addDisposableResource: function() { return /* binding */ __addDisposableResource; },
/* harmony export */   __assign: function() { return /* binding */ __assign; },
/* harmony export */   __asyncDelegator: function() { return /* binding */ __asyncDelegator; },
/* harmony export */   __asyncGenerator: function() { return /* binding */ __asyncGenerator; },
/* harmony export */   __asyncValues: function() { return /* binding */ __asyncValues; },
/* harmony export */   __await: function() { return /* binding */ __await; },
/* harmony export */   __awaiter: function() { return /* binding */ __awaiter; },
/* harmony export */   __classPrivateFieldGet: function() { return /* binding */ __classPrivateFieldGet; },
/* harmony export */   __classPrivateFieldIn: function() { return /* binding */ __classPrivateFieldIn; },
/* harmony export */   __classPrivateFieldSet: function() { return /* binding */ __classPrivateFieldSet; },
/* harmony export */   __createBinding: function() { return /* binding */ __createBinding; },
/* harmony export */   __decorate: function() { return /* binding */ __decorate; },
/* harmony export */   __disposeResources: function() { return /* binding */ __disposeResources; },
/* harmony export */   __esDecorate: function() { return /* binding */ __esDecorate; },
/* harmony export */   __exportStar: function() { return /* binding */ __exportStar; },
/* harmony export */   __extends: function() { return /* binding */ __extends; },
/* harmony export */   __generator: function() { return /* binding */ __generator; },
/* harmony export */   __importDefault: function() { return /* binding */ __importDefault; },
/* harmony export */   __importStar: function() { return /* binding */ __importStar; },
/* harmony export */   __makeTemplateObject: function() { return /* binding */ __makeTemplateObject; },
/* harmony export */   __metadata: function() { return /* binding */ __metadata; },
/* harmony export */   __param: function() { return /* binding */ __param; },
/* harmony export */   __propKey: function() { return /* binding */ __propKey; },
/* harmony export */   __read: function() { return /* binding */ __read; },
/* harmony export */   __rest: function() { return /* binding */ __rest; },
/* harmony export */   __rewriteRelativeImportExtension: function() { return /* binding */ __rewriteRelativeImportExtension; },
/* harmony export */   __runInitializers: function() { return /* binding */ __runInitializers; },
/* harmony export */   __setFunctionName: function() { return /* binding */ __setFunctionName; },
/* harmony export */   __spread: function() { return /* binding */ __spread; },
/* harmony export */   __spreadArray: function() { return /* binding */ __spreadArray; },
/* harmony export */   __spreadArrays: function() { return /* binding */ __spreadArrays; },
/* harmony export */   __values: function() { return /* binding */ __values; }
/* harmony export */ });
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */

var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() { this.constructor = d; }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
  __assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
  }
  return __assign.apply(this, arguments);
}

function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
      }
  return t;
}

function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
  return function (target, key) { decorator(target, key, paramIndex); }
}

function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
      var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind === "accessor") {
          if (result === void 0) continue;
          if (result === null || typeof result !== "object") throw new TypeError("Object expected");
          if (_ = accept(result.get)) descriptor.get = _;
          if (_ = accept(result.set)) descriptor.set = _;
          if (_ = accept(result.init)) initializers.unshift(_);
      }
      else if (_ = accept(result)) {
          if (kind === "field") initializers.unshift(_);
          else descriptor[key] = _;
      }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};

function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};

function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
};

function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};

function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
  return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
      function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
  function verb(n) { return function (v) { return step([n, v]); }; }
  function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
              case 0: case 1: t = op; break;
              case 4: _.label++; return { value: op[1], done: false };
              case 5: _.label++; y = op[1]; op = [0]; continue;
              case 7: op = _.ops.pop(); _.trys.pop(); continue;
              default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                  if (t[2]) _.ops.pop();
                  _.trys.pop(); continue;
          }
          op = body.call(thisArg, _);
      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
  }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
  }
  Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
      next: function () {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
      }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  }
  catch (error) { e = { error: error }; }
  finally {
      try {
          if (r && !r.done && (m = i["return"])) m.call(i);
      }
      finally { if (e) throw e.error; }
  }
  return ar;
}

/** @deprecated */
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
  return ar;
}

/** @deprecated */
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
  return r;
}

function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
      }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;
  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }
  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }
  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
  function fulfill(value) { resume("next", value); }
  function reject(value) { resume("throw", value); }
  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
  return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
  o["default"] = v;
};

var ownKeys = function(o) {
  ownKeys = Object.getOwnPropertyNames || function (o) {
    var ar = [];
    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
    return ar;
  };
  return ownKeys(o);
};

function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
  __setModuleDefault(result, mod);
  return result;
}

function __importDefault(mod) {
  return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}

function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
    env.stack.push({ value: value, dispose: dispose, async: async });
  }
  else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}

var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  var r, s = 0;
  function next() {
    while (r = env.stack.pop()) {
      try {
        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
        if (r.dispose) {
          var result = r.dispose.call(r.value);
          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
        }
        else s |= 1;
      }
      catch (e) {
        fail(e);
      }
    }
    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next();
}

function __rewriteRelativeImportExtension(path, preserveJsx) {
  if (typeof path === "string" && /^\.\.?\//.test(path)) {
      return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {
          return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : (d + ext + "." + cm.toLowerCase() + "js");
      });
  }
  return path;
}

/* harmony default export */ __webpack_exports__["default"] = ({
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __esDecorate,
  __runInitializers,
  __propKey,
  __setFunctionName,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
  __rewriteRelativeImportExtension,
});


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	!function() {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			792: 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(89058);
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});